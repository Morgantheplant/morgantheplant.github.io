(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = {
    components: require('famous-components'),
    core: require('famous-core'),
    engine: require('famous-engine'),
    domRenderables: require('famous-dom-renderables'),
    math: require('famous-math'),
    physics: require('famous-physics'),
    renderers: require('famous-renderers'),
    stylesheets: require('famous-stylesheets'),
    router: require('famous-router'),
    transitions: require('famous-transitions'),
    utilities: require('famous-utilities'),
    webglRenderables: require('famous-webgl-renderables'),
    webglGeometries: require('famous-webgl-geometries'),
    webglMaterials: require('famous-webgl-materials'),
    webglShaders: require('famous-webgl-shaders'),
    polyfills: require('famous-polyfills')
};

},{"famous-components":49,"famous-core":58,"famous-dom-renderables":77,"famous-engine":80,"famous-math":85,"famous-physics":134,"famous-polyfills":136,"famous-renderers":287,"famous-router":290,"famous-stylesheets":293,"famous-transitions":296,"famous-utilities":307,"famous-webgl-geometries":336,"famous-webgl-materials":350,"famous-webgl-renderables":389,"famous-webgl-shaders":395}],2:[function(require,module,exports){
'use strict';

/**
 * Equivalent of an Engine in the Worker Thread. Used to synchronize and manage
 * time across different Threads.
 *
 * @class  Clock
 * @constructor
 * @private
 */
function Clock () {
    this._time = 0;
    this._frame = 0;
    this._timerQueue = [];
    this._updatingIndex = 0;
}

/**
 * Updates the internal clock time.
 *
 * @method  step
 * @chainable
 * 
 * @param  {Number} time high resolution timstamp used for invoking the
 *                       `update` method on all registered objects
 * @return {Clock}       this
 */
Clock.prototype.step = function step (time) {
    this._frame++;
    this._time = time;
    for (var i = 0; i < this._timerQueue.length; i++) {
        if (this._timerQueue[i](this._time)) {
            this._timerQueue.splice(i, 1);
        }
    }
    return this;
};

/**
 * Returns the internal clock time.
 *
 * @method  getTime
 * @deprecated Use #now instead
 * 
 * @param  {Number} time high resolution timstamp used for invoking the
 *                       `update` method on all registered objects
 */
Clock.prototype.getTime = function getTime() {
    return this._time;
};

/**
 * Returns the internal clock time.
 *
 * @method  now
 * 
 * @param  {Number} time high resolution timstamp used for invoking the
 *                       `update` method on all registered objects
 */
Clock.prototype.now = function now () {
    return this._time;
};

/**
 * Returns the number of frames elapsed so far.
 *
 * @method getFrame
 * 
 * @return {Number} frames
 */
Clock.prototype.getFrame = function getFrame () {
    return this._frame;
};

/**
 * Wraps a function to be invoked after a certain amount of time.
 * After a set duration has passed, it executes the function and
 * removes it as a listener to 'prerender'.
 *
 * @method setTimeout
 *
 * @param {Function} callback function to be run after a specified duration
 * @param {Number} delay milliseconds from now to execute the function
 *
 * @return {Function} timer function used for Clock#clearTimer
 */
Clock.prototype.setTimeout = function (callback, delay) {
    var params = Array.prototype.slice.call(arguments, 2);
    var startedAt = this._time;
    var timer = function(time) {
        if (time - startedAt >= delay) {
            callback.apply(null, params);
            return true;
        }
        return false;
    };
    this._timerQueue.push(timer);
    return timer;
};


/**
 * Wraps a function to be invoked after a certain amount of time.
 *  After a set duration has passed, it executes the function and
 *  resets the execution time.
 *
 * @method setInterval
 *
 * @param {Function} callback function to be run after a specified duration
 * @param {Number} duration interval to execute function in milliseconds
 *
 * @return {Function} timer function used for Clock#clearTimer
 */
Clock.prototype.setInterval = function setInterval(callback, delay) {
    var params = Array.prototype.slice.call(arguments, 2);
    var startedAt = this._time;
    var timer = function(time) {
        if (time - startedAt >= delay) {
            callback.apply(null, params);
            startedAt = time;
        }
        return false;
    };
    this._timerQueue.push(timer);
    return timer;
};

/**
 * Removes previously via `Clock#setTimeout` or `Clock#setInterval`
 * registered callback function
 *
 * @method clearTimer
 * @chainable
 * 
 * @param  {Function} callback  previously by `Clock#setTimeout` or
 *                              `Clock#setInterval` returned callback function
 * @return {Clock}              this
 */
Clock.prototype.clearTimer = function (timer) {
    var index = this._timerQueue.indexOf(timer);
    if (index !== -1) {
        this._timerQueue.splice(index, 1);
    }
    return this;
};

module.exports = Clock;


},{}],3:[function(require,module,exports){
'use strict';

var Dispatch = require('./Dispatch');
var Node = require('./Node');
var Size = require('./Size');

/**
 * Context is the bottom of the scene graph. It is it's own
 * parent and provides the global updater to the scene graph.
 *
 * @class Context
 * @constructor
 *
 * @param {String} selector a string which is a dom selector
 *                 signifying which dom element the context
 *                 should be set upon
 * @param {Famous} a class which conforms to Famous' interface
 *                 it needs to be able to send methods to
 *                 the renderers and update nodes in the scene graph
 */
function Context (selector, updater) {
    if (!selector) throw new Error('Context needs to be created with a DOM selector');
    if (!updater) throw new Error('Context needs to be created with a class like Famous');

    Node.call(this);         // Context inherits from node

    this._updater = updater; // The updater that will both
                             // send messages to the renderers
                             // and update dirty nodes 

    this._dispatch = new Dispatch(this); // instantiates a dispatcher
                                         // to send events to the scene
                                         // graph below this context
    
    this._selector = selector; // reference to the DOM selector
                               // that represents the elemnent
                               // in the dom that this context
                               // inhabits

    this.onMount(this, selector); // Mount the context to itself
                                  // (it is its own parent)
    
    this._updater                  // message a request for the dom
        .message('NEED_SIZE_FOR')  // size of the context so that
        .message(selector);        // the scene graph has a total size

    this.show(); // the context begins shown (it's already present in the dom)

}

// Context inherits from node
Context.prototype = Object.create(Node.prototype);
Context.prototype.constructor = Context;

/**
 * Context getUpdater function returns the passed in updater
 *
 * @return {Famous} the updater for this Context
 */
Context.prototype.getUpdater = function getUpdater () {
    return this._updater;
};

/**
 * Returns the selector that the context was instantiated with
 *
 * @return {String} dom selector
 */
Context.prototype.getSelector = function getSelector () {
    return this._selector;
};

/**
 * Returns the dispatcher of the context. Used to send events
 * to the nodes in the scene graph.
 *
 * @return {Dispatch} the Context's Dispatch
 */
Context.prototype.getDispatch = function getDispatch () {
    return this._dispatch;
};

/**
 * Receives an event. If the event is 'CONTEXT_RESIZE' it sets the size of the scene
 * graph to the payload, which must be an array of numbers of at least
 * length three representing the pixel size in 3 dimensions.
 *
 * @param {String} event
 * @param {*} payload
 */
Context.prototype.onReceive = function onReceive (event, payload) {
    // TODO: In the future the dom element that the context is attached to
    // should have a representation as a component. It would be render sized
    // and the context would receive its size the same way that any render size
    // component receives its size.
    if (event === 'CONTEXT_RESIZE') {
        
        if (payload.length < 2) 
            throw new Error(
                    'CONTEXT_RESIZE\'s payload needs to be at least a pair' +
                    ' of pixel sizes'
            );

        this.setSizeMode(Size.ABSOLUTE, Size.ABSOLUTE, Size.ABSOLUTE);
        this.setAbsoluteSize(payload[0],
                             payload[1],
                             payload[2] ? payload[2] : 0);

    }
};

module.exports = Context;


},{"./Dispatch":4,"./Node":7,"./Size":8}],4:[function(require,module,exports){
'use strict';

// TODO: Dispatch should be generalized so that it can work on any Node
// not just Contexts.


/**
 * The Dispatch class is used to propogate events down the
 * scene graph.
 *
 * @param {Context} Context on which it operates
 */
function Dispatch (context) {

    if (!context) throw new Error('Dispatch needs to be instantiated on a node');
    
    this._context = context; // A reference to the context
                             // on which the dispatcher
                             // operates

    this._queue = []; // The queue is used for two purposes
                      // 1. It is used to list indicies in the
                      //    Nodes path which are then used to lookup
                      //    a node in the scene graph.
                      // 2. It is used to assist dispatching
                      //    such that it is possible to do a breadth first
                      //    traversal of the scene graph.
}

/**
 * lookupNode takes a path and returns the node at the location specified
 * by the path, if one exists. If not, it returns undefined.
 *
 * @param {String} The location of the node specified by its path
 * 
 * @return {Node | undefined} The node at the requested path
 */
Dispatch.prototype.lookupNode = function lookupNode (location) {
    if (!location) throw new Error('lookupNode must be called with a path');

    var path = this._queue;

    _splitTo(location, path);
    
    if (path[0] !== this._context.getSelector()) return void 0;

    var children = this._context.getChildren();
    var child;
    var i = 1;
    path[0] = this._context;

    while (i < path.length) {
        child = children[path[i]];
        path[i] = child;
        if (child) children = child.getChildren();
        else return void 0;
        i++;
    }

    return child;
};

/**
 * dispatch takes an event name and a payload and dispatches it to the
 * entire scene graph below the node that the dispatcher is on. The nodes
 * receive the events in a breadth first traversal, meaning that parents
 * have the opportunity to react to the event before children.
 *
 * @param {String} event name
 * @param {Any} payload
 */
Dispatch.prototype.dispatch = function dispatch (event, payload) {
    if (!event) throw new Error('dispatch requires an event name as it\'s first argument');

    var queue = this._queue;
    var item;
    var i;
    var len;
    var children;

    queue.length = 0;
    queue.push(this._context);

    while (queue.length) {
        item = queue.shift();
        if (item.onReceive) item.onReceive(event, payload);
        children = item.getChildren();
        for (i = 0, len = children.length ; i < len ; i++) queue.push(children[i]);
    }
};

/**
 * dispatchUIevent takes a path, an event name, and a payload and dispatches them in
 * a manner anologous to DOM bubbling. It first traverses down to the node specified at
 * the path. That node receives the event first, and then every ancestor receives the event
 * until the context.
 *
 * @param {String} the path of the node
 * @param {String} the event name
 * @param {Any} the payload
 */
Dispatch.prototype.dispatchUIEvent = function dispatchUIEvent (path, event, payload) {
    if (!path) throw new Error('dispatchUIEvent needs a valid path to dispatch to');
    if (!event) throw new Error('dispatchUIEvent needs an event name as its second argument');

    var queue = this._queue;
    var node;

    payload.node = this.lookupNode(path); // After this call, the path is loaded into the queue
                                          // (lookUp node doesn't clear the queue after the lookup)

    while (queue.length) {
        node = queue.pop(); // pop nodes off of the queue to move up the ancestor chain.
        if (node.onReceive) node.onReceive(event, payload);
    }
};

/**
 * _splitTo is a private method which takes a path and splits it at every '/'
 * pushing the result into the supplied array. This is a destructive change.
 *
 * @private
 * @param {String} the specified path
 * @param {Array} the array to which the result should be written
 */
function _splitTo (string, target) {
    target.length = 0; // clears the array first.
    var last = 0;

    for (var i = 0, len = string.length ; i < len ; i++) {
        if (string[i] === '/') {
            target.push(string.substring(last, i));
            last = i + 1;
        }
    }

    if (i - last > 0) target.push(string.substring(last, i));

    return target;
}

module.exports = Dispatch;


},{}],5:[function(require,module,exports){
// TODO: This will wrap UI events as the bubble in the scene graph to allow .stopPropogation() to be called

},{}],6:[function(require,module,exports){
'use strict';

// Check to see if we're in a worker
var isWorker = typeof self !== 'undefined' && self.window !== self;

var Clock = require('./Clock');
var Context = require('./Context');

/**
 * Famous has two responsibilities, one to act as the highest level
 * updater and another to send messages over to the renderers. It is
 * a singleton.
 */
function Famous () {
    this._updateQueue = []; // The updateQueue is a place where nodes
                            // can place themselves in order to be
                            // updated on the frame.
    
    this._nextUpdateQueue = []; // the nextUpdateQueue is used to queue
                                // updates for the next tick.
                                // this prevents infinite loops where during
                                // an update a node continuously puts itself
                                // back in the update queue.

    this._contexts = {}; // a hash of all of the context's that this famous
                         // is responsible for.

    this._messages = []; // a queue of all of the draw commands to send to the
                         // the renderers this frame.

    this._inUpdate = false; // when the famous is updating this is true.
                            // all requests for updates will get put in the
                            // nextUpdateQueue

    this._clock = new Clock(); // a clock to keep track of time for the scene
                               // graph.

    // if famous is in a worker we wire the event listener here.
    // otherwise the thread manager will postMessage directly to
    // famous
    var _this = this;
    if (isWorker)
        self.addEventListener('message', function (ev) {
            _this.postMessage(ev.data);
        });
}

/**
 * _update is the body of the update loop. The frame consists of
 * pulling in appending the nextUpdateQueue to the currentUpdate queue
 * then moving through the updateQueue and calling onUpdate with the current
 * time on all nodes. While _update is called _inUpdate is set to true and 
 * all requests to be placed in the update queue will be forwarded to the 
 * nextUpdateQueue.
 *
 * @param {Number} The current time
 */
Famous.prototype._update = function _update (time) {
    this._inUpdate = true;
    var nextQueue = this._nextUpdateQueue;
    var queue = this._updateQueue;
    var item;

    while (nextQueue.length) queue.unshift(nextQueue.pop());

    while (queue.length) {
        item = queue.shift();
        if (item && item.onUpdate) item.onUpdate(time);
    }

    this._inUpdate = false;
};

/**
 * requestUpdates takes a class that has an onUpdate method and puts it
 * into the updateQueue to be updated at the next frame.
 * If Famous is currently in an update, requestUpdate
 * passes its argument to requestUpdateOnNextTick.
 *
 * @param {Object} an object with an onUpdate method
 */
Famous.prototype.requestUpdate = function requestUpdate (requester) {
    if (!requester)
        throw new Error(
            'requestUpdate must be called with a class to be updated'
        );

    if (this._inUpdate) this.requestUpdateOnNextTick(requester);
    else this._updateQueue.push(requester);
};

/**
 * requestUpdateOnNextTick is requests an update on the next frame.
 * If Famous is not currently in an update than it is functionally equivalent
 * to requestUpdate. This method should be used to prevent infinite loops where
 * a class is updated on the frame but needs to be updated again next frame.
 *
 * @param {Object} an object with an onUpdate method
 */
Famous.prototype.requestUpdateOnNextTick = function requestUpdateOnNextTick (requester) {
    this._nextUpdateQueue.push(requester);
};

/**
 * postMessage sends a message queue into Famous to be processed.
 * These messages will be interpreted and sent into the scene graph
 * as events if necessary.
 *
 * @param {Array} an array of commands.
 * @chainable
 * 
 * @return {Famous} this
 */
Famous.prototype.postMessage = function postMessage (messages) {
    if (!messages)
        throw new Error(
            'postMessage must be called with an array of messages'
        );

    var command;

    while (messages.length > 0) {
        command = messages.shift();
        switch (command) {
            case 'WITH':
                this.handleWith(messages);
                break;
            case 'FRAME':
                this.handleFrame(messages);
                break;
            case 'INVOKE':
                this.handleInvoke(message);
                break;
            default:
                throw new Error('received unknown command: ' + command);
                break;
        }
    }
    return this;
};

/**
 * handleWith is a method that takes an array of messages following the
 * WITH command. It'll then issue the next commands to the path specified
 * by the WITH command.
 *
 * @param {Array} array of messages.
 * @chainable
 *
 * @return {Famous} this
 */
Famous.prototype.handleWith = function handleWith (messages) {
    var path = messages.shift();
    var command = messages.shift();
    var i;
    var len;

    switch (command) {
        case 'TRIGGER': // the TRIGGER command sends a UIEvent to the specified path
            var type = messages.shift();
            var ev = messages.shift();
            
            this.getContext(path).getDispatch().dispatchUIEvent(path, type, ev);
            break;
        default:
            throw new Error('received unknown command: ' + command);
            break;
    }
    return this;
};

/**
 * handleFrame is called when the renderers issue a FRAME command to 
 * Famous. Famous will then step updating the scene graph to the current time.
 *
 * @param {Array} array of messages.
 * @chainable
 *
 * @return {Famous} this
 */
Famous.prototype.handleFrame = function handleFrame (messages) {
    if (!messages) throw new Error('handleFrame must be called with an array of messages');
    if (!messages.length) throw new Error('FRAME must be sent with a time');

    this.step(messages.shift());
    return this;
};

/**
 * step updates the clock and the scene graph and then sends the draw commands
 * that accumulated in the update to the renderers.
 *
 * @param {Number} current engine time
 * @chainable
 *
 * @return {Famous} this
 */
Famous.prototype.step = function step (time) {
    if (time == null) throw new Error('step must be called with a time');

    this._clock.step(time);

    this._update(time);

    if (this._messages.length) {
        if (isWorker) self.postMessage(this._messages);
        else this.onmessage(this._messages);
    }
    
    this._messages.length = 0;

    return this;
};

/**
 * returns the context of a particular path. The context is looked up by the selector
 * portion of the path and is listed from the start of the string to the first
 * '/'.
 *
 * @param {String} the path to look up the context for.
 *
 * @return {Context | Undefined} the context if found, else undefined.
 */
Famous.prototype.getContext = function getContext (selector) {
    if (!selector) throw new Error('getContext must be called with a selector');
    
    var index = selector.indexOf('/');
    selector = index === -1 ? selector : selector.substring(0, index);

    return this._contexts[selector];
};

/**
 * returns the instance of clock within famous.
 *
 * @return {Clock} Famous's clock
 */
Famous.prototype.getClock = function getClock () {
    return this._clock;
};

/**
 * queues a message to be transfered to the renderers.
 *
 * @param {Any} Draw Command
 * @chainable
 *
 * @return {Famous} this
 */
Famous.prototype.message = function message (command) {
    this._messages.push(command);
    return this;
};

/**
 * Creates a context under which a scene graph could be built.
 *
 * @param {String} a dom selector for where the context should be placed
 *
 * @return {Context} a new instance of Context.
 */
Famous.prototype.createContext = function createContext (selector) {
    selector = selector || 'body';

    if (this._contexts[selector]) this._contexts[selector].dismount();
    this._contexts[selector] = new Context(selector, this);
    return this._contexts[selector];
};

module.exports = new Famous();


},{"./Clock":2,"./Context":3}],7:[function(require,module,exports){
'use strict';

var Transform = require('./Transform');
var Size = require('./Size');

var TRANSFORM_PROCESSOR = new Transform();
var SIZE_PROCESSOR = new Size();

var IDENT = [
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1
];

var ONES = [1, 1, 1];
var QUAT = [0, 0, 0, 1];

/**
 * Nodes define hierarchy and geometrical transformations. They can be moved
 * (translated), scaled and rotated.
 * 
 * A Node is either mounted or unmounted. Unmounted nodes are detached from the
 * scene graph. Unmounted nodes have no parent node, while each mounted node has
 * exactly one parent. Nodes have an arbitary number of children, which can be
 * dynamically added using @{@link addChild}.
 *
 * Each Nodes have an arbitrary number of `components`. Those components can
 * send `draw` commands to the renderer or mutate the node itself, in which case
 * they define behavior in the most explicit way. Components that send `draw`
 * commands aare considered `renderables`. From the node's perspective, there is
 * no distinction between nodes that send draw commands and nodes that define
 * behavior.
 *
 * Because of the fact that Nodes themself are very unopinioted (they don't
 * "render" to anything), they are often being subclassed in order to add e.g.
 * components at initialization to them. Because of this flexibility, they might
 * as well have been called `Entities`.
 *
 * @example
 * // create three detached (unmounted) nodes
 * var parent = new Node();
 * var child1 = new Node();
 * var child2 = new Node();
 *
 * // build an unmounted subtree (parent is still detached)
 * parent.addChild(child1);
 * parent.addChild(child2);
 *
 * // mount parent by adding it to the context
 * var context = Famous.createContext("body");
 * context.addChild(parent);
 *
 * @class Node
 * @constructor
 */
function Node () {
    this._calculatedValues = {
        transform: new Float32Array(IDENT),
        size: new Float32Array(3)
    };

    this._requestingUpdate = false;
    this._inUpdate = false;

    this._updateQueue = [];
    this._nextUpdateQueue = [];

    this._freedComponentIndicies = [];
    this._components = [];

    this._freedChildIndicies = [];
    this._children = [];

    this._parent = null;
    this._globalUpdater = null;

    this.value = new Node.Spec();
}

Node.RELATIVE_SIZE = Size.RELATIVE;
Node.ABSOLUTE_SIZE = Size.ABSOLUTE;
Node.RENDER_SIZE = Size.RENDER;
Node.DEFAULT_SIZE = Size.DEFAULT;

/**
 * A Node spec holds the "data" associated with a Node.
 *
 * @property {String} location path to the node (e.g. "body/0/1")
 * @property {Object} showState
 * @property {Boolean} showState.mounted
 * @property {Boolean} showState.shown
 * @property {Number} showState.opacity
 * @property {Object} offsets
 * @property {Float32Array.<Number>} offsets.mountPoint
 * @property {Float32Array.<Number>} offsets.align
 * @property {Float32Array.<Number>} offsets.origin
 * @property {Object} vectors
 * @property {Float32Array.<Number>} vectors.position
 * @property {Float32Array.<Number>} vectors.rotation
 * @property {Float32Array.<Number>} vectors.scale
 * @property {Object} size
 * @property {Float32Array.<Number>} size.sizeMode
 * @property {Float32Array.<Number>} size.proportional
 * @property {Float32Array.<Number>} size.differential
 * @property {Float32Array.<Number>} size.absolute
 * @property {Float32Array.<Number>} size.render
 */
Node.Spec = function Spec () {
    this.location = null;
    this.showState = {
        mounted: false,
        shown: false,
        opacity: 1
    };
    this.offsets = {
        mountPoint: new Float32Array(3),
        align: new Float32Array(3),
        origin: new Float32Array(3)
    };
    this.vectors = {
        position: new Float32Array(3),
        rotation: new Float32Array(QUAT),
        scale: new Float32Array(ONES)
    };
    this.size = {
        sizeMode: new Float32Array([Size.RELATIVE, Size.RELATIVE, Size.RELATIVE]),
        proportional: new Float32Array(ONES),
        differential: new Float32Array(3),
        absolute: new Float32Array(3),
        render: new Float32Array(3)
    };
    this.UIEvents = [];
};

/**
 * @method getContext
 * @chainable
 *
 * @deprecated Node can be used directly instead!
 * @return {Node} this
 */
Node.prototype.getContext = function getContext () {
    console.warn(
        'Node#getContext is deprecated!\n' +
        'Nodes can be used directly!'
    );
    return this;
};

/**
 * @method getDispatch
 * @chainable
 *
 * @deprecated Node can be used directly instead!
 * @return {Node} this
 */
Node.prototype.getDispatch = function getDispatch () {
    console.warn(
        'Node#getDispatch is deprecated!\n' +
        'Component constructors accept a Node instead!' +
        'Use new Component(node) instead of new Component(node.getDispatch())!'
    );
    return this;
};

/**
 * @method getRenderProxy
 * @chainable
 *
 * @deprecated Node can be used directly instead!
 * @return {Node} this
 */
Node.prototype.getRenderProxy = function getRenderProxy () {
    console.warn(
        'Node#getRenderProxy is deprecated!\n' +
        'RenderProxy functionality has been merged into Node!'
    );
    return this;
};

/**
 * @method getRenderPath
 * @chainable
 *
 * @deprecated Use #getLocation()
 * @return {string} render path
 */
Node.prototype.getRenderPath = function getRenderPath () {
    console.warn(
        'Node#getRenderPath is deprecated!\n' +
        'Use Node#getLocation instead!'
    );
    return this.getLocation();
};

/**
 * @method addRenderable
 * @chainable
 *
 * @deprecated Use addComponent
 * @param {*} component component to be added
 * @return this
 */
Node.prototype.addRenderable = function addRenderable (component) {
    console.warn(
        'Node#addRenderable is deprecated!\n' +
        'use node.addComponent instead'
    );
    this.addComponent(component);
    return this;
};

/**
 * Determine the node's location in the scene graph hierarchy.
 * A location of `body/0/1` can be interpreted as the following scene graph
 * hierarchy (ignoring siblings of ancestors and additional child nodes):
 *
 * `Context:body` -> `Node:0` -> `Node:1`, where `Node:1` is the node the
 * `getLocation` method has been invoked on.
 *
 * @method getLocation
 * 
 * @return {String} location (path), e.g. `body/0/1`
 */
Node.prototype.getLocation = function getLocation () {
    return this.value.location;
};

/**
 * @alias getId
 */
Node.prototype.getId = Node.prototype.getLocation;

/**
 * Dispatches the event on the node by recursively traversing the scene graph
 * upwards.
 *
 * @method emit
 * 
 * @param  {String} event   Event type.
 * @param  {Object} payload Event object to be dispatched.
 */
Node.prototype.emit = function emit (event, payload) {
    var p = this.getParent();
    // the context is its own ancestor
    while (p !== (p = p.getParent()));
    p.getDispatch().dispatch(event, payload);
    return this;
};

// THIS WILL BE DEPRICATED
Node.prototype.sendDrawCommand = function sendDrawCommand (message) {
    this._globalUpdater.message(message);
    return this;
};

/**
 * Recursively serializes the Node, including all previously added components.
 *
 * @method getValue
 * 
 * @return {Object}     Serialized representation of the node, including
 *                      components.
 */
Node.prototype.getValue = function getValue () {
    var numberOfChildren = this._children.length;
    var numberOfComponents = this._components.length;
    var i = 0;

    var value = {
        location: this.value.location,
        spec: this.value,
        components: new Array(numberOfComponents),
        children: new Array(numberOfChildren)
    };

    for (; i < numberOfChildren ; i++)
        value.children[i] = this._children[i].getValue();

    for (i = 0 ; i < numberOfComponents ; i++)
        if (this._components[i].getValue)
            value.components[i] = this._components[i].getValue();

    return value;
};

/**
 * Similar to @{@link getValue}, but returns the actual "computed" value. E.g.
 * a proportional size of 0.5 might resolve into a "computed" size of 200px
 * (assuming the parent has a width of 400px).
 *
 * @method getComputedValue
 * 
 * @return {Object}     Serialized representation of the node, including
 *                      children, excluding components.
 */
Node.prototype.getComputedValue = function getComputedValue () {
    var numberOfChildren = this._children.length;

    var value = {
        location: this.value.location,
        computedValues: this._calculatedValues,
        children: new Array(numberOfChildren)
    };

    for (var i = 0 ; i < numberOfChildren ; i++)
        value.children[i] = this._children[i].getComputedValue();

    return value;
};

/**
 * Retrieves all children of the current node.
 *
 * @method getChildren
 * 
 * @return {Array.<Node>}   An array of children.
 */
Node.prototype.getChildren = function getChildren () {
    return this._children;
};

/**
 * Retrieves the parent of the current node. Unmounted nodes do not have a
 * parent node.
 *
 * @method getParent
 * 
 * @return {Node}       Parent node.
 */
Node.prototype.getParent = function getParent () {
    return this._parent;
};

/**
 * Schedules the @{@link update} function of the node to be invoked on the next
 * frame (if no update during this frame has been scheduled already).
 * If the node is currently being updated (which means one of the requesters
 * invoked requestsUpdate while being updated itself), an update will be
 * scheduled on the next frame.
 *
 * @method requestUpdate
 * 
 * @param  {Object} requester   If the requester has an `onUpdate` method, it
 *                              will be invoked during the next update phase of
 *                              the node.
 */
Node.prototype.requestUpdate = function requestUpdate (requester) {
    if (this._inUpdate) return this.requestUpdateOnNextTick(requester);
    this._updateQueue.push(requester);
    if (!this._requestingUpdate) this._requestUpdate();
    return this;
};

/**
 * Schedules an update on the next tick. Similarily to @{@link requestUpdate},
 * `requestUpdateOnNextTick` schedules the node's `onUpdate` function to be
 * invoked on the frame after the next invocation on the node's onUpdate function.
 *
 * @method requestUpdateOnNextTick
 * 
 * @param  {Object} requester   If the requester has an `onUpdate` method, it
 *                              will be invoked during the next update phase of
 *                              the node.
 */
Node.prototype.requestUpdateOnNextTick = function requestUpdateOnNextTick (requester) {
    this._nextUpdateQueue.push(requester);
    return this;
};

/**
 * If the context has been created using @{@link Famous.createContext}, the
 * @{@link Famous} singleton will be the global updater.
 *
 * @method getUpdater
 * 
 * @return {Object} The global updater.
 */
Node.prototype.getUpdater = function getUpdater () {
    return this._globalUpdater;
};

/**
 * Checks if the node is mounted. Unmounted nodes are detached from the scene
 * graph.
 *
 * @method isMounted
 * 
 * @return {Boolean}    Boolean indicating weather the node is mounted or not.
 */
Node.prototype.isMounted = function isMounted () {
    return this.value.showState.mounted;
};

/**
 * Checks if the node is visible ("shown").
 *
 * @method isShown
 * 
 * @return {Boolean}    Boolean indicating weather the node is visible
 *                      ("shown") or not.
 */
Node.prototype.isShown = function isShown () {
    return this.value.showState.shown;
};

/**
 * Determines the node's relative opacity.
 * The opacity needs to be within [0, 1], where 0 indicates a completely
 * transparent, therefore invisible node, whereas an opacity of 1 means the
 * node is completely solid.
 *
 * @method getOpacity
 * 
 * @return {Number}         Relative opacity of the node.
 */
Node.prototype.getOpacity = function getOpacity () {
    return this.value.showState.opacity;
};

/**
 * Determines the node's previously set mount point.
 * 
 * @method getMountPoint
 * 
 * @return {Float32Array}   An array representing the mount point.
 */
Node.prototype.getMountPoint = function getMountPoint () {
    return this.value.offsets.mountPoint;
};

/**
 * Determines the node's previously set align.
 * 
 * @method getAlign
 * 
 * @return {Float32Array}   An array representing the align.
 */
Node.prototype.getAlign = function getAlign () {
    return this.value.offsets.align;
};

/**
 * Determines the node's previously set origin.
 * 
 * @method getOrigin
 * 
 * @return {Float32Array}   An array representing the origin.
 */
Node.prototype.getOrigin = function getOrigin () {
    return this.value.offsets.origin;
};

/**
 * Determines the node's previously set position.
 *
 * @method getPosition
 * 
 * @return {Float32Array}   An array representing the position.
 */
Node.prototype.getPosition = function getPosition () {
    return this.value.vectors.position;
};

Node.prototype.getRotation = function getRotation () {
    return this.value.vectors.rotation;
};

Node.prototype.getScale = function getScale () {
    return this.value.vectors.scale;
};

Node.prototype.getSizeMode = function getSizeMode () {
    return this.value.size.sizeMode;
};

Node.prototype.getProportionalSize = function getProportionalSize () {
    return this.value.size.proportional;
};

Node.prototype.getDifferentialSize = function getDifferentialSize () {
    return this.value.size.differential;
};

Node.prototype.getAbsoluteSize = function getAbsoluteSize () {
    return this.value.size.absolute;
};

Node.prototype.getRenderSize = function getRenderSize () {
    return this.value.size.render;
};

Node.prototype.getSize = function getSize () {
    return this._calculatedValues.size;
};

Node.prototype.getTransform = function getTransform () {
    return this._calculatedValues.transform;
};

Node.prototype.getUIEvents = function getUIEvents () {
    return this.value.UIEvents;
};

Node.prototype.addChild = function addChild (child) {
    var index = child ? this._children.indexOf(child) : -1;
    child = child ? child : new Node();

    if (index === -1) {
        index = this._freedChildIndicies.length ? this._freedChildIndicies.pop() : this._children.length;
        this._children[index] = child;

        if (this.isMounted() && child.onMount) {
            var myId = this.getId();
            var childId = myId + '/' + index;
            child.onMount(this, childId);
        }

    }

    return child;
};

Node.prototype.removeChild = function removeChild (child) {
    var index = this._children.indexOf(child);
    var added = index !== -1;
    if (added) {
        this._freedChildIndicies.push(index);

        if (this.isMounted() && child.onDismount)
            child.onDismount();

        this._children[index] = null;
    }
    return added;
};

/**
 * Each component can only be added once per node.
 *
 * @method addComponent
 * 
 * @param {Object} component    An component to be added.
 */
Node.prototype.addComponent = function addComponent (component) {
    var index = this._components.indexOf(component);
    if (index === -1) {
        index = this._freedComponentIndicies.length ? this._freedComponentIndicies.pop() : this._components.length;
        this._components[index] = component;

        if (this.isMounted() && component.onMount)
            component.onMount(this, index);

        if (this.isShown() && component.onShow)
            component.onShow();
    }

    return index;
};

/**
 * Removes a previously via @{@link addComponent} added component.
 *
 * @method removeComponent
 * 
 * @param  {Object} component   An component that has previously been added
 *                              using @{@link addComponent}.
 */
Node.prototype.removeComponent = function removeComponent (component) {
    var index = this._components.indexOf(component);
    if (index !== -1) {
        this._freedComponentIndicies.push(index);
        if (this.isShown() && component.onHide)
            component.onHide();

        if (this.isMounted() && component.onDismount)
            component.onDismount();

        this._components[index] = null;
    }
    return component;
};

Node.prototype.addUIEvent = function addUIEvent (eventName) {
    var UIEvents = this.getUIEvents();
    var components = this._components;
    var component;

    var added = UIEvents.indexOf(eventName) !== -1;
    if (!added) {
        UIEvents.push(eventName);
        for (var i = 0, len = components.length ; i < len ; i++) {
            component = components[i];
            if (component.onAddUIEvent) component.onAddUIEvent(eventName);
        }
    }
    return added;
};

Node.prototype._requestUpdate = function _requestUpdate (force) {
    if (force || (!this._requestingUpdate && this._globalUpdater)) {
        this._globalUpdater.requestUpdate(this);
        this._requestingUpdate = true;
    }
};

Node.prototype._vecOptionalSet = function _vecOptionalSet (vec, index, val) {
    if (val != null && vec[index] !== val) {
        vec[index] = val;
        if (!this._requestingUpdate) this._requestUpdate();
        return true;
    }
    return false;
};

Node.prototype.show = function show () {
    var i = 0;
    var items = this._components;
    var len = items.length;
    var item;

    this.value.showState.shown = true;

    for (; i < len ; i++) {
        item = items[i];
        if (item && item.onShow) item.onShow();
    }

    i = 0;
    items = this._children;
    len = items.length;

    for (; i < len ; i++) {
        item = items[i];
        if (item && item.onParentShow) item.onParentShow();
    }
    return this;
};

Node.prototype.hide = function hide () {
    var i = 0;
    var items = this._components;
    var len = items.length;
    var item;

    this.value.showState.shown = false;

    for (; i < len ; i++) {
        item = items[i];
        if (item && item.onHide) item.onHide();
    }

    i = 0;
    items = this._children;
    len = items.length;

    for (; i < len ; i++) {
        item = items[i];
        if (item && item.onParentHide) item.onParentHide();
    }
    return this;
};

Node.prototype.setAlign = function setAlign (x, y, z) {
    var vec3 = this.value.offsets.align;
    var propogate = false;

    propogate = this._vecOptionalSet(vec3, 0, x) || propogate;
    propogate = this._vecOptionalSet(vec3, 1, y) || propogate;
    if (z != null) propogate = this._vecOptionalSet(vec3, 2, (z - 0.5)) || propogate;

    if (propogate) {
        var i = 0;
        var list = this._components;
        var len = list.length;
        var item;
        x = vec3[0];
        y = vec3[1];
        z = vec3[2];
        for (; i < len ; i++) {
            item = list[i];
            if (item && item.onAlignChange) item.onAlignChange(x, y, z);
        }
    }
    return this;
};

Node.prototype.setMountPoint = function setMountPoint (x, y, z) {
    var vec3 = this.value.offsets.mountPoint;
    var propogate = false;

    propogate = this._vecOptionalSet(vec3, 0, x) || propogate;
    propogate = this._vecOptionalSet(vec3, 1, y) || propogate;
    if (z != null) propogate = this._vecOptionalSet(vec3, 2, (z - 0.5)) || propogate;

    if (propogate) {
        var i = 0;
        var list = this._components;
        var len = list.length;
        var item;
        x = vec3[0];
        y = vec3[1];
        z = vec3[2];
        for (; i < len ; i++) {
            item = list[i];
            if (item && item.onMountPointChange) item.onMountPointChange(x, y, z);
        }
    }
    return this;
};

Node.prototype.setOrigin = function setOrigin (x, y, z) {
    var vec3 = this.value.offsets.origin;
    var propogate = false;

    propogate = this._vecOptionalSet(vec3, 0, x) || propogate;
    propogate = this._vecOptionalSet(vec3, 1, y) || propogate;
    if (z != null) propogate = this._vecOptionalSet(vec3, 2, (z - 0.5)) || propogate;

    if (propogate) {
        var i = 0;
        var list = this._components;
        var len = list.length;
        var item;
        x = vec3[0];
        y = vec3[1];
        z = vec3[2];
        for (; i < len ; i++) {
            item = list[i];
            if (item && item.onOriginChange) item.onOriginChange(x, y, z);
        }
    }
    return this;
};


Node.prototype.setPosition = function setPosition (x, y, z) {
    var vec3 = this.value.vectors.position;
    var propogate = false;

    propogate = this._vecOptionalSet(vec3, 0, x) || propogate;
    propogate = this._vecOptionalSet(vec3, 1, y) || propogate;
    propogate = this._vecOptionalSet(vec3, 2, z) || propogate;

    if (propogate) {
        var i = 0;
        var list = this._components;
        var len = list.length;
        var item;
        x = vec3[0];
        y = vec3[1];
        z = vec3[2];
        for (; i < len ; i++) {
            item = list[i];
            if (item && item.onPositionChange) item.onPositionChange(x, y, z);
        }
    }

    return this;
};

Node.prototype.setRotation = function setRotation (x, y, z, w) {
    var quat = this.value.vectors.rotation;
    var propogate = false;
    var qx, qy, qz, qw;

    if (w != null) {
        qx = x;
        qy = y;
        qz = z;
        qw = w;
    }
    else {
        var hx = x * 0.5;
        var hy = y * 0.5;
        var hz = z * 0.5;

        var sx = Math.sin(hx);
        var sy = Math.sin(hy);
        var sz = Math.sin(hz);
        var cx = Math.cos(hx);
        var cy = Math.cos(hy);
        var cz = Math.cos(hz);

        var sysz = sy * sz;
        var cysz = cy * sz;
        var sycz = sy * cz;
        var cycz = cy * cz;

        qx = sx * cycz + cx * sysz;
        qy = cx * sycz - sx * cysz;
        qz = cx * cysz + sx * sycz;
        qw = cx * cycz - sx * sysz;
    }

    propogate = this._vecOptionalSet(quat, 0, qx) || propogate;
    propogate = this._vecOptionalSet(quat, 1, qy) || propogate;
    propogate = this._vecOptionalSet(quat, 2, qz) || propogate;
    propogate = this._vecOptionalSet(quat, 3, qw) || propogate;

    if (propogate) {
        var i = 0;
        var list = this._components;
        var len = list.length;
        var item;
        x = quat[0];
        y = quat[1];
        z = quat[2];
        w = quat[3];
        for (; i < len ; i++) {
            item = list[i];
            if (item && item.onRotationChange) item.onRotationChange(x, y, z, w);
        }
    }
    return this;
};

Node.prototype.setScale = function setScale (x, y, z) {
    var vec3 = this.value.vectors.scale;
    var propogate = false;

    propogate = this._vecOptionalSet(vec3, 0, x) || propogate;
    propogate = this._vecOptionalSet(vec3, 1, y) || propogate;
    propogate = this._vecOptionalSet(vec3, 2, z) || propogate;

    if (propogate) {
        var i = 0;
        var list = this._components;
        var len = list.length;
        var item;
        x = vec3[0];
        y = vec3[1];
        z = vec3[2];
        for (; i < len ; i++) {
            item = list[i];
            if (item && item.onScaleChange) item.onScaleChange(x, y, z);
        }
    }
    return this;
};

Node.prototype.setOpacity = function setOpacity (val) {
    if (val != this.value.showState.opacity) {
        this.value.showState.opacity = val;
        if (!this._requestingUpdate) this._requestUpdate();

        var i = 0;
        var list = this._components;
        var len = list.length;
        var item;
        for (; i < len ; i++) {
            item = list[i];
            if (item && item.onOpacityChange) item.onOpacityChange(val);
        }
    }
    return this;
};

/**
 * Sets the size mode being used for determining the nodes final width, height
 * and depth.
 * Size modes are a way to define the way the node's size is being calculated.
 * Size modes are enums set on the @{@link Size} constructor (and aliased on
 * the Node).
 *
 * @example
 * node.setSizeMode(Node.RELATIVE_SIZE, Node.ABSOLUTE_SIZE, Node.ABSOLUTE_SIZE);
 * // Instead of null, any proporional height or depth can be passed in, since
 * // it would be ignored in any case.
 * node.setProportionalSize(0.5, null, null);
 * node.setAbsoluteSize(null, 100, 200);
 *
 * @method setSizeMode
 * 
 * @param {SizeMode} x    The size mode being used for determining the size in
 *                        x direction ("width").
 * @param {SizeMode} y    The size mode being used for determining the size in
 *                        y direction ("height").
 * @param {SizeMode} z    The size mode being used for determining the size in
 *                        z direction ("depth").
 */
Node.prototype.setSizeMode = function setSizeMode (x, y, z) {
    var vec3 = this.value.size.sizeMode;
    var propogate = false;

    propogate = this._vecOptionalSet(vec3, 0, x) || propogate;
    propogate = this._vecOptionalSet(vec3, 1, y) || propogate;
    propogate = this._vecOptionalSet(vec3, 2, z) || propogate;

    if (propogate) {
        var i = 0;
        var list = this._components;
        var len = list.length;
        var item;
        x = vec3[0];
        y = vec3[1];
        z = vec3[2];
        for (; i < len ; i++) {
            item = list[i];
            if (item && item.onSizeModeChange) item.onSizeModeChange(x, y, z);
        }
    }
    return this;
};

/**
 * A proportional size defines the node's dimensions relative to its parents
 * final size.
 * Proportional sizes need to be within the range of [0, 1].
 *
 * @method setProportionalSize
 * 
 * @param {Number} x    x-Size in pixels ("width").
 * @param {Number} y    y-Size in pixels ("height").
 * @param {Number} z    z-Size in pixels ("depth").
 */
Node.prototype.setProportionalSize = function setProportionalSize (x, y, z) {
    var vec3 = this.value.size.proportional;
    var propogate = false;

    propogate = this._vecOptionalSet(vec3, 0, x) || propogate;
    propogate = this._vecOptionalSet(vec3, 1, y) || propogate;
    propogate = this._vecOptionalSet(vec3, 2, z) || propogate;

    if (propogate) {
        var i = 0;
        var list = this._components;
        var len = list.length;
        var item;
        x = vec3[0];
        y = vec3[1];
        z = vec3[2];
        for (; i < len ; i++) {
            item = list[i];
            if (item && item.onProportionalSizeChange) item.onProportionalSizeChange(x, y, z);
        }
    }
    return this;
};

/**
 * Differential sizing can be used to add or subtract an absolute size from a
 * otherwise proportionally sized node.
 * E.g. a differential width of `-10` and a proportional width of `0.5` is
 * being interpreted as setting the node's size to 50% of its parent's width
 * *minus* 10 pixels.
 *
 * @method setDifferentialSize
 * 
 * @param {Number} x    x-Size to be added to the relatively sized node in
 *                      pixels ("width").
 * @param {Number} y    y-Size to be added to the relatively sized node in
 *                      pixels ("height").
 * @param {Number} z    z-Size to be added to the relatively sized node in
 *                      pixels ("depth").
 */
Node.prototype.setDifferentialSize = function setDifferentialSize (x, y, z) {
    var vec3 = this.value.size.differential;
    var propogate = false;

    propogate = this._vecOptionalSet(vec3, 0, x) || propogate;
    propogate = this._vecOptionalSet(vec3, 1, y) || propogate;
    propogate = this._vecOptionalSet(vec3, 2, z) || propogate;

    if (propogate) {
        var i = 0;
        var list = this._components;
        var len = list.length;
        var item;
        x = vec3[0];
        y = vec3[1];
        z = vec3[2];
        for (; i < len ; i++) {
            item = list[i];
            if (item && item.onDifferentialSizeChange) item.onDifferentialSizeChange(x, y, z);
        }
    }
    return this;
};

/**
 * Sets the nodes size in pixels, independent of its parent.
 *
 * @method setAbsoluteSize
 * 
 * @param {Number} x    x-Size in pixels ("width").
 * @param {Number} y    y-Size in pixels ("height").
 * @param {Number} z    z-Size in pixels ("depth").
 */
Node.prototype.setAbsoluteSize = function setAbsoluteSize (x, y, z) {
    var vec3 = this.value.size.absolute;
    var propogate = false;

    propogate = this._vecOptionalSet(vec3, 0, x) || propogate;
    propogate = this._vecOptionalSet(vec3, 1, y) || propogate;
    propogate = this._vecOptionalSet(vec3, 2, z) || propogate;

    if (propogate) {
        var i = 0;
        var list = this._components;
        var len = list.length;
        var item;
        x = vec3[0];
        y = vec3[1];
        z = vec3[2];
        for (; i < len ; i++) {
            item = list[i];
            if (item && item.onAbsoluteSizeChange) item.onAbsoluteSizeChange(x, y, z);
        }
    }
    return this;
};

Node.prototype._transformChanged = function _transformChanged (transform) {
    var i = 0;
    var items = this._components;
    var len = items.length;
    var item;

    for (; i < len ; i++) {
        item = items[i];
        if (item && item.onTransformChange) item.onTransformChange(transform);
    }

    i = 0;
    items = this._children;
    len = items.length;

    for (; i < len ; i++) {
        item = items[i];
        if (item && item.onParentTransformChange) item.onParentTransformChange(transform);
    }
};

Node.prototype._sizeChanged = function _sizeChanged (size) {
    var i = 0;
    var items = this._components;
    var len = items.length;
    var item;

    for (; i < len ; i++) {
        item = items[i];
        if (item && item.onSizeChange) item.onSizeChange(size);
    }

    i = 0;
    items = this._children;
    len = items.length;

    for (; i < len ; i++) {
        item = items[i];
        if (item && item.onParentSizeChange) item.onParentSizeChange(size);
    }
};

// DEPRICATE
Node.prototype.getFrame = function getFrame () {
    return this._globalUpdater.getFrame();
};

/**
 * Enters the node's update phase while updating its own spec and updating its components.
 *
 * @method update
 * 
 * @param  {Number} time    high-resolution timstamp, usually retrieved using
 *                          requestAnimationFrame
 */
Node.prototype.update = function update (time){
    this._inUpdate = true;
    var nextQueue = this._nextUpdateQueue;
    var queue = this._updateQueue;
    var item;

    while (nextQueue.length) queue.unshift(nextQueue.pop());

    while (queue.length) {
        item = this._components[queue.shift()];
        if (item && item.onUpdate) item.onUpdate(time);
    }

    var mySize = this.getSize();
    var myTransform = this.getTransform();
    var parent = this.getParent();
    var parentSize = parent.getSize();
    var parentTransform = parent.getTransform();
    var sizeChanged = SIZE_PROCESSOR.fromSpecWithParent(parentSize, this.value, mySize);

    var transformChanged = TRANSFORM_PROCESSOR.fromSpecWithParent(parentTransform, this.value, mySize, parentSize, myTransform);
    if (transformChanged) this._transformChanged(myTransform);
    if (sizeChanged) this._sizeChanged(mySize);

    this._inUpdate = false;
    this._requestingUpdate = false;

    if (this._nextUpdateQueue.length) {
        this._globalUpdater.requestUpdateOnNextTick(this);
        this._requestingUpdate = true;
    }
    if (!this.isMounted()) {
        // last update
        this._parent = null;
        this.value.location = null;
        this._globalUpdater = null;
    }
    return this;
};

/**
 * Mounts the node and therefore its subtree by setting it as a child of the
 * passed in parent.
 *
 * @method mount
 * 
 * @param  {Node} parent    parent node
 * @param  {String} myId    path to node (e.g. `body/0/1`)
 */
Node.prototype.mount = function mount (parent, myId) {
    if (this.isMounted()) return;
    var i = 0;
    var list = this._components;
    var len = list.length;
    var item;

    this._parent = parent;
    this._globalUpdater = parent.getUpdater();
    this.value.location = myId;
    this.value.showState.mounted = true;

    for (; i < len ; i++) {
        item = list[i];
        if (item.onMount) item.onMount(this, i);
    }

    i = 0;
    list = this._children;
    len = list.length;
    for (; i < len ; i++) {
        item = list[i];
        if (item.onParentMount) item.onParentMount(this, myId, i);
    }

    if (this._requestingUpdate) this._requestUpdate(true);
    return this;
};

/**
 * Dismounts (detaches) the node from the scene graph by removing it as a
 * child of its parent.
 *
 * @method dismount
 */
Node.prototype.dismount = function dismount () {
    if (!this.isMounted()) return;
    var i = 0;
    var list = this._components;
    var len = list.length;
    var item;

    this.value.showState.mounted = false;

    this._parent.removeChild(this);

    for (; i < len ; i++) {
        item = list[i];
        if (item.onDismount) item.onDismount();
    }

    i = 0;
    list = this._children;
    len = list.length;
    for (; i < len ; i++) {
        item = list[i];
        if (item.onParentDismount) item.onParentDismount();
    }

    if (!this._requestingUpdate) this._requestUpdate();
    this._globalUpdater = null;
    return this;
};

/**
 * Function to be invoked by the parent as soon as the parent is
 * being mounted.
 *
 * @method onParentMount
 * 
 * @param  {Node} parent        The parent node.
 * @param  {String} parentId    The parent id (path to parent).
 * @param  {Number} index       Id the node should be mounted to.
 */
Node.prototype.onParentMount = function onParentMount (parent, parentId, index) {
    return this.mount(parent, parentId + '/' + index);
};

/**
 * Function to be invoked by the parent as soon as the parent is being
 * unmounted.
 *
 * @method onParentDismount
 */
Node.prototype.onParentDismount = function onParentDismount () {
    return this.dismount();
};

/**
 * Method to be called in order to dispatch an event to the node and all its
 * components. Note that this doesn't recurse the subtree.
 *
 * @method receive
 * 
 * @param  {String} type   The event type (e.g. "click").
 * @param  {Object} ev     The event payload object to be dispatched.
 */
Node.prototype.receive = function receive (type, ev) {
    var i = 0;
    var list = this._components;
    var len = list.length;
    var item;
    for (; i < len ; i++) {
        item = list[i];
        if (item && item.onReceive) item.onReceive(type, ev);
    }
    return this;
};


Node.prototype._requestUpdateWithoutArgs = function _requestUpdateWithoutArgs () {
    if (!this._requestingUpdate) this._requestUpdate();
};

Node.prototype.onUpdate = Node.prototype.update;

Node.prototype.onParentShow = Node.prototype.show;

Node.prototype.onParentHide = Node.prototype.hide;

Node.prototype.onParentTransformChange = Node.prototype._requestUpdateWithoutArgs;

Node.prototype.onParentSizeChange = Node.prototype._requestUpdateWithoutArgs;

Node.prototype.onShow = Node.prototype.show;

Node.prototype.onHide = Node.prototype.hide;

Node.prototype.onMount = Node.prototype.mount;

Node.prototype.onDismount = Node.prototype.dismount;

Node.prototype.onReceive = Node.prototype.receive;

module.exports = Node;

},{"./Size":8,"./Transform":9}],8:[function(require,module,exports){
'use strict';

/**
 * The Size class is responsible for processing Size from a node
 * @constructor {Size}
 */
function Size () {
    this._size = new Float32Array(3);
}

// an enumeration of the different types of size modes
Size.RELATIVE = 0;
Size.ABSOLUTE = 1;
Size.RENDER = 2;
Size.DEFAULT = Size.RELATIVE;

/**
 * fromSpecWithParent takes the parent node's size, the target nodes spec,
 * and a target array to write to. Using the node's size mode it calculates 
 * a final size for the node from the node's spec. Returns whether or not
 * the final size has changed from its last value.
 *
 * @param {Array} parent node's calculated size
 * @param {Node.Spec} the target node's spec
 * @param {Array} an array to write the result to
 *
 * @return {Boolean} true if the size of the node has changed.
 */
Size.prototype.fromSpecWithParent = function fromSpecWithParent (parentSize, spec, target) {
    var mode = spec.size.sizeMode;
    var prev;
    var changed = false;
    for (var i = 0 ; i < 3 ; i++) {
        switch (mode[i]) {
            case Size.RELATIVE:
                prev = target[i];
                target[i] = parentSize[i] * spec.size.proportional[i] + spec.size.differential[i];
                changed = changed || prev !== target[i];
                break;
            case Size.ABSOLUTE:
                prev = target[i];
                target[i] = spec.size.absolute[i];
                changed = changed || prev !== target[i];
                break;
            case Size.RENDER:
                break;
        }
    }
    return changed;
};

module.exports = Size;

},{}],9:[function(require,module,exports){
'use strict';

/**
 * The transform class is responsible for calculating the transform of a particular
 * node from the data on the node and its parent
 *
 * @constructor {Transform}
 */
function Transform () {
    this._matrix = new Float32Array(16);
}

/**
 * Returns the last calculated transform
 *
 * @return {Array} a transform
 */
Transform.prototype.get = function get () {
    return this._matrix;
};

/**
 * Uses the parent transform, the node's spec, the node's size, and the parent's size
 * to calculate a final transform for the node. Returns true if the transform has changed.
 *
 * @param {Array} the parent matrix
 * @param {Node.Spec} the target node's spec
 * @param {Array} the size of the node
 * @param {Array} the size of the parent
 * @param {Array} the target array to write the resulting transform to
 *
 * @return {Boolean} whether or not the transform changed
 */
Transform.prototype.fromSpecWithParent = function fromSpecWithParent (parentMatrix, spec, mySize, parentSize, target) {
    target = target ? target : this._matrix;

    // local cache of everything
    var t00         = target[0];
    var t01         = target[1];
    var t02         = target[2];
    var t10         = target[4];
    var t11         = target[5];
    var t12         = target[6];
    var t20         = target[8];
    var t21         = target[9];
    var t22         = target[10];
    var t30         = target[12];
    var t31         = target[13];
    var t32         = target[14];
    var p00         = parentMatrix[0];
    var p01         = parentMatrix[1];
    var p02         = parentMatrix[2];
    var p10         = parentMatrix[4];
    var p11         = parentMatrix[5];
    var p12         = parentMatrix[6];
    var p20         = parentMatrix[8];
    var p21         = parentMatrix[9];
    var p22         = parentMatrix[10];
    var p30         = parentMatrix[12];
    var p31         = parentMatrix[13];
    var p32         = parentMatrix[14];
    var posX        = spec.vectors.position[0];
    var posY        = spec.vectors.position[1];
    var posZ        = spec.vectors.position[2];
    var rotX        = spec.vectors.rotation[0];
    var rotY        = spec.vectors.rotation[1];
    var rotZ        = spec.vectors.rotation[2];
    var rotW        = spec.vectors.rotation[3];
    var scaleX      = spec.vectors.scale[0];
    var scaleY      = spec.vectors.scale[1];
    var scaleZ      = spec.vectors.scale[2];
    var alignX      = spec.offsets.align[0] * parentSize[0];
    var alignY      = spec.offsets.align[1] * parentSize[1];
    var alignZ      = spec.offsets.align[2] * parentSize[2];
    var mountPointX = spec.offsets.mountPoint[0] * mySize[0];
    var mountPointY = spec.offsets.mountPoint[1] * mySize[1];
    var mountPointZ = spec.offsets.mountPoint[2] * mySize[2];
    var originX     = spec.offsets.origin[0] * mySize[0];
    var originY     = spec.offsets.origin[1] * mySize[1];
    var originZ     = spec.offsets.origin[2] * mySize[2];

    var wx = rotW * rotX;
    var wy = rotW * rotY;
    var wz = rotW * rotZ;
    var xx = rotX * rotX;
    var yy = rotY * rotY;
    var zz = rotZ * rotZ;
    var xy = rotX * rotY;
    var xz = rotX * rotZ;
    var yz = rotY * rotZ;

    var rs0 = (1 - 2 * (yy + zz)) * scaleX;
    var rs1 = (2 * (xy + wz)) * scaleX;
    var rs2 = (2 * (xz - wy)) * scaleX;
    var rs3 = (2 * (xy - wz)) * scaleY;
    var rs4 = (1 - 2 * (xx + zz)) * scaleY;
    var rs5 = (2 * (yz + wx)) * scaleY;
    var rs6 = (2 * (xz + wy)) * scaleZ;
    var rs7 = (2 * (yz - wx)) * scaleZ;
    var rs8 = (1 - 2 * (xx + yy)) * scaleZ;

    var tx = alignX + posX - mountPointX + originX - (rs0 * originX + rs3 * originY + rs6 * originZ);
    var ty = alignY + posY - mountPointY + originY - (rs1 * originX + rs4 * originY + rs7 * originZ);
    var tz = alignZ + posZ - mountPointZ + originZ - (rs2 * originX + rs5 * originY + rs8 * originZ);

    target[0] = p00 * rs0 + p10 * rs1 + p20 * rs2;
    target[1] = p01 * rs0 + p11 * rs1 + p21 * rs2;
    target[2] = p02 * rs0 + p12 * rs1 + p22 * rs2;
    target[3] = 0;
    target[4] = p00 * rs3 + p10 * rs4 + p20 * rs5;
    target[5] = p01 * rs3 + p11 * rs4 + p21 * rs5;
    target[6] = p02 * rs3 + p12 * rs4 + p22 * rs5;
    target[7] = 0;
    target[8] = p00 * rs6 + p10 * rs7 + p20 * rs8;
    target[9] = p01 * rs6 + p11 * rs7 + p21 * rs8;
    target[10] = p02 * rs6 + p12 * rs7 + p22 * rs8;
    target[11] = 0;
    target[12] = p00 * tx + p10 * ty + p20 * tz + p30;
    target[13] = p01 * tx + p11 * ty + p21 * tz + p31;
    target[14] = p02 * tx + p12 * ty + p22 * tz + p32;
    target[15] = 1;

    return t00 !== target[0] ||
        t01 !== target[1] ||
        t02 !== target[2] ||
        t10 !== target[4] ||
        t11 !== target[5] ||
        t12 !== target[6] ||
        t20 !== target[8] ||
        t21 !== target[9] ||
        t22 !== target[10] ||
        t30 !== target[12] ||
        t31 !== target[13] ||
        t32 !== target[14];

};

module.exports = Transform;

},{}],10:[function(require,module,exports){
'use strict';

module.exports = {
    Clock: require('./Clock'),
    Event: require('./Event'),
    Context: require('./Context'),
    Famous: require('./Famous'),
    Dispatch: require('./Dispatch'),
    Dispatcher: require('./Dispatch'),
    Node: require('./Node'),
    Size: require('./Size'),
    Transform: require('./Transform')
};

},{"./Clock":2,"./Context":3,"./Dispatch":4,"./Event":5,"./Famous":6,"./Node":7,"./Size":8,"./Transform":9}],11:[function(require,module,exports){
'use strict';

/**
 * A 3x3 numerical matrix, represented as an array.
 *
 * @class Mat33
 * @constructor
 *
 * @param {Number[]} values
 */
function Mat33(values) {
    this.values = values || [1,0,0,0,1,0,0,0,1];

    return this;
}

/**
 * Return the values in the Mat33 as an array.
 *
 * @method get
 * @return {Number[]} matrix values as array of rows.
 */
Mat33.prototype.get = function get() {
    return this.values;
};

/**
 * Set the values of the current Mat33.
 *
 * @method set
 * @param {Number[]} values Array of nine numbers to set in the Mat33.
 * @chainable
 */
Mat33.prototype.set = function set(values) {
    this.values = values;
    return this;
};

/**
 * Copy the values of the input Mat33.
 *
 * @method copy
 * @param {Mat33} matrix The Mat33 to copy.
 * @chainable
 */
Mat33.prototype.copy = function copy(matrix) {
    var A = this.values;
    var B = matrix.values;

    A[0] = B[0];
    A[1] = B[1];
    A[2] = B[2];
    A[3] = B[3];
    A[4] = B[4];
    A[5] = B[5];
    A[6] = B[6];
    A[7] = B[7];
    A[8] = B[8];

    return this;
};

/**
 * Take this Mat33 as A, input vector V as a column vector, and return Mat33 product (A)(V).
 *
 * @method vectorMultiply
 * @param {Vec3} v Vector to rotate.
 * @param {Vec3} output Vec3 in which to place the result.
 * @return {Vec3} The input vector after multiplication.
 */
Mat33.prototype.vectorMultiply = function vectorMultiply(v, output) {
    var M = this.values;
    var v0 = v.x;
    var v1 = v.y;
    var v2 = v.z;

    output.x = M[0]*v0 + M[1]*v1 + M[2]*v2;
    output.y = M[3]*v0 + M[4]*v1 + M[5]*v2;
    output.z = M[6]*v0 + M[7]*v1 + M[8]*v2;

    return output;
};

/**
 * Multiply the provided Mat33 with the current Mat33.  Result is (this) * (matrix).
 *
 * @method multiply
 * @param {Mat33} matrix Input Mat33 to multiply on the right.
 * @chainable
 */
Mat33.prototype.multiply = function multiply(matrix) {
    var A = this.values;
    var B = matrix.values;

    var A0 = A[0];
    var A1 = A[1];
    var A2 = A[2];
    var A3 = A[3];
    var A4 = A[4];
    var A5 = A[5];
    var A6 = A[6];
    var A7 = A[7];
    var A8 = A[8];

    var B0 = B[0];
    var B1 = B[1];
    var B2 = B[2];
    var B3 = B[3];
    var B4 = B[4];
    var B5 = B[5];
    var B6 = B[6];
    var B7 = B[7];
    var B8 = B[8];

    A[0] = A0*B0 + A1*B3 + A2*B6;
    A[1] = A0*B1 + A1*B4 + A2*B7;
    A[2] = A0*B2 + A1*B5 + A2*B8;
    A[3] = A3*B0 + A4*B3 + A5*B6;
    A[4] = A3*B1 + A4*B4 + A5*B7;
    A[5] = A3*B2 + A4*B5 + A5*B8;
    A[6] = A6*B0 + A7*B3 + A8*B6;
    A[7] = A6*B1 + A7*B4 + A8*B7;
    A[8] = A6*B2 + A7*B5 + A8*B8;

    return this;
};

/**
 * Transposes the Mat33.
 *
 * @method transpose
 * @chainable
 */
Mat33.prototype.transpose = function transpose() {
    var M = this.values;

    var M1 = M[1];
    var M2 = M[2];
    var M3 = M[3];
    var M5 = M[5];
    var M6 = M[6];
    var M7 = M[7];

    M[1] = M3;
    M[2] = M6;
    M[3] = M1;
    M[5] = M7;
    M[6] = M2;
    M[7] = M5;

    return this;
};

/**
 * The determinant of the Mat33.
 *
 * @method getDeterminant
 * @return {Number} The determinant.
 */
Mat33.prototype.getDeterminant = function getDeterminant() {
    var M = this.values;

    var M3 = M[3];
    var M4 = M[4];
    var M5 = M[5];
    var M6 = M[6];
    var M7 = M[7];
    var M8 = M[8];

    var det = M[0]*(M4*M8 - M5*M7)
            - M[1]*(M3*M8 - M5*M6)
            + M[2]*(M3*M7 - M4*M6);

    return det;
};

/**
 * The inverse of the Mat33.
 *
 * @method inverse
 * @chainable
 */
Mat33.prototype.inverse = function inverse() {
    var M = this.values;

    var M0 = M[0];
    var M1 = M[1];
    var M2 = M[2];
    var M3 = M[3];
    var M4 = M[4];
    var M5 = M[5];
    var M6 = M[6];
    var M7 = M[7];
    var M8 = M[8];

    var det = M0*(M4*M8 - M5*M7)
            - M1*(M3*M8 - M5*M6)
            + M2*(M3*M7 - M4*M6);

    if (Math.abs(det) < 1e-40) return null;

    det = 1 / det;

    M[0] = (M4*M8 - M5*M7) * det;
    M[3] = (-M3*M8 + M5*M6) * det;
    M[6] = (M3*M7 - M4*M6) * det;
    M[1] = (-M1*M8 + M2*M7) * det;
    M[4] = (M0*M8 - M2*M6) * det;
    M[7] = (-M0*M7 + M1*M6) * det;
    M[2] = (M1*M5 - M2*M4) * det;
    M[5] = (-M0*M5 + M2*M3) * det;
    M[8] = (M0*M4 - M1*M3) * det;

    return this;
};

/**
 * Clones the input Mat33.
 *
 * @method clone
 * @param {Mat33} m Mat33 to clone.
 * @return {Mat33} New copy of the original Mat33.
 */
Mat33.clone = function clone(m) {
    return new Mat33(m.values.slice());
};

/**
 * The inverse of the Mat33.
 *
 * @method inverse
 * @param {Mat33} matrix Mat33 to invert.
 * @param {Mat33} output Mat33 in which to place the result.
 * @return {Mat33} The Mat33 after the invert.
 */
Mat33.inverse = function inverse(matrix, output) {
    var M = matrix.values;
    var result = output.values;

    var M0 = M[0];
    var M1 = M[1];
    var M2 = M[2];
    var M3 = M[3];
    var M4 = M[4];
    var M5 = M[5];
    var M6 = M[6];
    var M7 = M[7];
    var M8 = M[8];

    var det = M0*(M4*M8 - M5*M7)
            - M1*(M3*M8 - M5*M6)
            + M2*(M3*M7 - M4*M6);

    if (Math.abs(det) < 1e-40) return null;

    det = 1 / det;

    result[0] = (M4*M8 - M5*M7) * det;
    result[3] = (-M3*M8 + M5*M6) * det;
    result[6] = (M3*M7 - M4*M6) * det;
    result[1] = (-M1*M8 + M2*M7) * det;
    result[4] = (M0*M8 - M2*M6) * det;
    result[7] = (-M0*M7 + M1*M6) * det;
    result[2] = (M1*M5 - M2*M4) * det;
    result[5] = (-M0*M5 + M2*M3) * det;
    result[8] = (M0*M4 - M1*M3) * det;

    return output;
};

/**
 * Transposes the Mat33.
 *
 * @method transpose
 * @param {Mat33} matrix Mat33 to transpose.
 * @param {Mat33} output Mat33 in which to place the result.
 * @return {Mat33} The Mat33 after the transpose.
 */
Mat33.transpose = function transpose(matrix, output) {
    var M = matrix.values;
    var result = output.values;

    var M0 = M[0];
    var M1 = M[1];
    var M2 = M[2];
    var M3 = M[3];
    var M4 = M[4];
    var M5 = M[5];
    var M6 = M[6];
    var M7 = M[7];
    var M8 = M[8];

    result[0] = M0;
    result[1] = M3;
    result[2] = M6;
    result[3] = M1;
    result[4] = M4;
    result[5] = M7;
    result[6] = M2;
    result[7] = M5;
    result[8] = M8;

    return output;
};

/**
 * Add the provided Mat33's.
 *
 * @method add
 * @param {Mat33} matrix1 The left Mat33.
 * @param {Mat33} matrix2 The right Mat33.
 * @param {Mat33} output Mat33 in which to place the result.
 * @return {Mat33} The result of the addition.
 */
Mat33.add = function add(matrix1, matrix2, output) {
    var A = matrix1.values;
    var B = matrix2.values;
    var result = output.values;

    var A0 = A[0];
    var A1 = A[1];
    var A2 = A[2];
    var A3 = A[3];
    var A4 = A[4];
    var A5 = A[5];
    var A6 = A[6];
    var A7 = A[7];
    var A8 = A[8];

    var B0 = B[0];
    var B1 = B[1];
    var B2 = B[2];
    var B3 = B[3];
    var B4 = B[4];
    var B5 = B[5];
    var B6 = B[6];
    var B7 = B[7];
    var B8 = B[8];

    result[0] = A0 + B0;
    result[1] = A1 + B1;
    result[2] = A2 + B2;
    result[3] = A3 + B3;
    result[4] = A4 + B4;
    result[5] = A5 + B5;
    result[6] = A6 + B6;
    result[7] = A7 + B7;
    result[8] = A8 + B8;

    return output;
};

/**
 * Subtract the provided Mat33's.
 *
 * @method subtract
 * @param {Mat33} matrix1 The left Mat33.
 * @param {Mat33} matrix2 The right Mat33.
 * @param {Mat33} output Mat33 in which to place the result.
 * @return {Mat33} The result of the subtraction.
 */
Mat33.subtract = function subtract(matrix1, matrix2, output) {
    var A = matrix1.values;
    var B = matrix2.values;
    var result = output.values;

    var A0 = A[0];
    var A1 = A[1];
    var A2 = A[2];
    var A3 = A[3];
    var A4 = A[4];
    var A5 = A[5];
    var A6 = A[6];
    var A7 = A[7];
    var A8 = A[8];

    var B0 = B[0];
    var B1 = B[1];
    var B2 = B[2];
    var B3 = B[3];
    var B4 = B[4];
    var B5 = B[5];
    var B6 = B[6];
    var B7 = B[7];
    var B8 = B[8];

    result[0] = A0 - B0;
    result[1] = A1 - B1;
    result[2] = A2 - B2;
    result[3] = A3 - B3;
    result[4] = A4 - B4;
    result[5] = A5 - B5;
    result[6] = A6 - B6;
    result[7] = A7 - B7;
    result[8] = A8 - B8;

    return output;
};
/**
 * Multiply the provided Mat33 M2 with this Mat33.  Result is (this) * (M2).
 *
 * @method multiply
 * @param {Mat33} matrix1 The left Mat33.
 * @param {Mat33} matrix2 The right Mat33.
 * @param {Mat33} output Mat33 in which to place the result.
 * @return {Mat33} the result of the multiplication.
 */
Mat33.multiply = function multiply(matrix1, matrix2, output) {
    var A = matrix1.values;
    var B = matrix2.values;
    var result = output.values;

    var A0 = A[0];
    var A1 = A[1];
    var A2 = A[2];
    var A3 = A[3];
    var A4 = A[4];
    var A5 = A[5];
    var A6 = A[6];
    var A7 = A[7];
    var A8 = A[8];

    var B0 = B[0];
    var B1 = B[1];
    var B2 = B[2];
    var B3 = B[3];
    var B4 = B[4];
    var B5 = B[5];
    var B6 = B[6];
    var B7 = B[7];
    var B8 = B[8];

    result[0] = A0*B0 + A1*B3 + A2*B6;
    result[1] = A0*B1 + A1*B4 + A2*B7;
    result[2] = A0*B2 + A1*B5 + A2*B8;
    result[3] = A3*B0 + A4*B3 + A5*B6;
    result[4] = A3*B1 + A4*B4 + A5*B7;
    result[5] = A3*B2 + A4*B5 + A5*B8;
    result[6] = A6*B0 + A7*B3 + A8*B6;
    result[7] = A6*B1 + A7*B4 + A8*B7;
    result[8] = A6*B2 + A7*B5 + A8*B8;

    return output;
};

module.exports = Mat33;

},{}],12:[function(require,module,exports){
'use strict';

var Matrix = require('./Mat33');

var sin = Math.sin;
var cos = Math.cos;
var asin = Math.asin;
var acos = Math.acos;
var atan2 = Math.atan2;
var sqrt = Math.sqrt;

/**
 * A vector-like object used to represent rotations. If theta is the angle of
 * rotation, and (x', y', z') is a normalized vector representing the axis of
 * rotation, then w = cos(theta/2), x = sin(theta/2)*x', y = sin(theta/2)*y',
 * and z = sin(theta/2)*z'.
 *
 * @class Quaternion
 * @param {Number} w The w component.
 * @param {Number} x The x component.
 * @param {Number} y The y component.
 * @param {Number} z The z component.
 */
function Quaternion(w, x, y, z) {
    this.w = w || 1;
    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
}

/**
 * Multiply the current Quaternion by input Quaternion q.
 * Left-handed multiplication.
 *
 * @method multiply
 * @param {Quaternion} q The Quaternion to multiply by on the right.
 */
Quaternion.prototype.multiply = function multiply(q) {
    var x1 = this.x;
    var y1 = this.y;
    var z1 = this.z;
    var w1 = this.w;
    var x2 = q.x;
    var y2 = q.y;
    var z2 = q.z;
    var w2 = q.w || 0;

    this.w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;
    this.x = x1 * w2 + x2 * w1 + y2 * z1 - y1 * z2;
    this.y = y1 * w2 + y2 * w1 + x1 * z2 - x2 * z1;
    this.z = z1 * w2 + z2 * w1 + x2 * y1 - x1 * y2;
    return this;
};

/**
 * Multiply the current Quaternion by input Quaternion q on the left, i.e. q * this.
 * Left-handed multiplication.
 *
 * @method leftMultiply
 * @param {Quaternion} q The Quaternion to multiply by on the left.
 */
Quaternion.prototype.leftMultiply = function leftMultiply(q) {
    var x1 = q.x;
    var y1 = q.y;
    var z1 = q.z;
    var w1 = q.w || 0;
    var x2 = this.x;
    var y2 = this.y;
    var z2 = this.z;
    var w2 = this.w;

    this.w = w1*w2 - x1*x2 - y1*y2 - z1*z2;
    this.x = x1*w2 + x2*w1 + y2*z1 - y1*z2;
    this.y = y1*w2 + y2*w1 + x1*z2 - x2*z1;
    this.z = z1*w2 + z2*w1 + x2*y1 - x1*y2;
    return this;
};

/**
 * Apply the current Quaternion to input Vec3 v, according to
 * v' = ~q * v * q.
 *
 * @method rotateVector
 * @param {Vec3} v The reference Vec3.
 * @param {Vec3} output Vec3 in which to place the result.
 * @return {Vec3} The rotated version of the Vec3.
 */
Quaternion.prototype.rotateVector = function rotateVector(v, output) {
    var cw = this.w;
    var cx = -this.x;
    var cy = -this.y;
    var cz = -this.z;

    var vx = v.x;
    var vy = v.y;
    var vz = v.z;

    var tw = -cx * vx - cy * vy - cz * vz;
    var tx = vx * cw + vy * cz - cy * vz;
    var ty = vy * cw + cx * vz - vx * cz;
    var tz = vz * cw + vx * cy - cx * vy;

    var w = cw;
    var x = -cx;
    var y = -cy;
    var z = -cz;

    output.x = tx * w + x * tw + y * tz - ty * z;
    output.y = ty * w + y * tw + tx * z - x * tz;
    output.z = tz * w + z * tw + x * ty - tx * y;
    return output;
};

/**
 * Invert the current Quaternion.
 *
 * @method invert
 * @chainable
 */
Quaternion.prototype.invert = function invert() {
    this.w = -this.w;
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
};

/**
 * Conjugate the current Quaternion.
 *
 * @method conjugate
 * @chainable
 */
Quaternion.prototype.conjugate = function conjugate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
};

/**
 * Compute the length (norm) of the current Quaternion.
 *
 * @method length
 * @return {Number}
 */
Quaternion.prototype.length = function length() {
    var w = this.w;
    var x = this.x;
    var y = this.y;
    var z = this.z;
    return sqrt(w * w + x * x + y * y + z * z);
};

/**
 * Alter the current Quaternion to be of unit length;
 *
 * @method normalize
 * @chainable
 */
Quaternion.prototype.normalize = function normalize() {
    var w = this.w;
    var x = this.x;
    var y = this.y;
    var z = this.z;
    var length = sqrt(w * w + x * x + y * y + z * z);
    if (length === 0) return;
    length = 1 / length;
    this.w *= length;
    this.x *= length;
    this.y *= length;
    this.z *= length;
    return this;
};

/**
 * Set the w, x, y, z components of the current Quaternion.
 *
 * @method set
 * @param {Number} w The w component.
 * @param {Number} x The x component.
 * @param {Number} y The y component.
 * @param {Number} z The z component.
 * @chainable
 */
Quaternion.prototype.set = function set(w, x ,y, z) {
    if (w != null) this.w = w;
    if (x != null) this.x = x;
    if (y != null) this.y = y;
    if (z != null) this.z = z;
    return this;
};

/**
 * Copy input Quaternion q onto the current Quaternion.
 *
 * @method copy
 * @param {Quaternion} q The reference Quaternion.
 * @chainable
 */
Quaternion.prototype.copy = function copy(q) {
    this.w = q.w;
    this.x = q.x;
    this.y = q.y;
    this.z = q.z;
    return this;
};

/**
 * Reset the current Quaternion.
 *
 * @method clear
 * @chainable
 */
Quaternion.prototype.clear = function clear() {
    this.w = 1;
    this.x = 0;
    this.y = 0;
    this.z = 0;
    return this;
};

/**
 * The dot product. Can be used to determine the cosine of the angle between
 * the two rotations, assuming both Quaternions are of unit length.
 *
 * @method dot
 * @param {Quaternion} q The other Quaternion.
 * @return {Number}
 */
Quaternion.prototype.dot = function dot(q) {
    return this.w * q.w + this.x * q.x + this.y * q.y + this.z * q.z;
};

/**
 * Spherical linear interpolation.
 *
 * @method slerp
 * @param {Quaternion} q The final orientation.
 * @param {Number} t The tween parameter.
 * @param {Vec3} output Vec3 in which to put the result.
 * @return {Quaternion}
 */
Quaternion.prototype.slerp = function slerp(q, t, output) {
    var w = this.w;
    var x = this.x;
    var y = this.y;
    var z = this.z;

    var qw = q.w;
    var qx = q.x;
    var qy = q.y;
    var qz = q.z;

    var omega;
    var cosomega;
    var sinomega;
    var scaleFrom;
    var scaleTo;

    cosomega = w * qw + x * qx + y * qy + z * qz;
    if ((1.0 - cosomega) > 1e-5) {
        omega = acos(cosomega);
        sinomega = sin(omega);
        scaleFrom = sin((1.0 - t) * omega) / sinomega;
        scaleTo = sin(t * omega) / sinomega;
    }
    else {
        scaleFrom = 1.0 - t;
        scaleTo = t;
    }

    output.w = w * scaleFrom + qw * scaleTo;
    output.x = x * scaleFrom + qx * scaleTo;
    output.y = y * scaleFrom + qy * scaleTo;
    output.z = z * scaleFrom + qz * scaleTo;

    return output;
};

/**
 * Get the Mat33 matrix corresponding to the current Quaternion.
 *
 * @method toMatrix
 * @return {Transform}
 */
Quaternion.prototype.toMatrix = function toMatrix(output) {
    var w = this.w;
    var x = this.x;
    var y = this.y;
    var z = this.z;

    var xx = x*x;
    var yy = y*y;
    var zz = z*z;
    var xy = x*y;
    var xz = x*z;
    var yz = y*z;

    return output.set([
        1 - 2 * (yy + zz), 2 * (xy - w*z), 2 * (xz + w*y),
        2 * (xy + w*z), 1 - 2 * (xx + zz), 2 * (yz - w*x),
        2 * (xz - w*y), 2 * (yz + w*x), 1 - 2 * (xx + yy)
    ]);
};

/**
 * The rotation angles about the x, y, and z axes corresponding to the
 * current Quaternion, when applied in the ZYX order.
 *
 * @method toEuler
 * @param {Vec3} output Vec3 in which to put the result.
 * @return {Vec3}
 */

Quaternion.prototype.toEuler = function toEuler(output) {
    var w = this.w;
    var x = this.x;
    var y = this.y;
    var z = this.z;

    var xx = x * x;
    var yy = y * y;
    var zz = z * z;
    var ww = w * w;

    var ty = 2 * (x * z + y * w);
    ty = ty < -1 ? -1 : ty > 1 ? 1 : ty;

    output.x = atan2(2 * (x * w - y * z), 1 - 2 * (xx + yy));
    output.y = asin(ty);
    output.z = atan2(2 * (z * w - x * y), 1 - 2 * (yy + zz));

    return output;
};

/**
 * The Quaternion corresponding to the Euler angles x, y, and z,
 * applied in the ZYX order.
 *
 * @method fromEuler
 * @param {Number} x The angle of rotation about the x axis.
 * @param {Number} y The angle of rotation about the y axis.
 * @param {Number} z The angle of rotation about the z axis.
 * @param {Quaternion} output Quaternion in which to put the result.
 * @return {Quaternion} The equivalent Quaternion.
 */
Quaternion.prototype.fromEuler = function fromEuler(x, y, z) {
    var hx = x * 0.5;
    var hy = y * 0.5;
    var hz = z * 0.5;

    var sx = sin(hx);
    var sy = sin(hy);
    var sz = sin(hz);
    var cx = cos(hx);
    var cy = cos(hy);
    var cz = cos(hz);

    this.w = cx * cy * cz - sx * sy * sz;
    this.x = sx * cy * cz + cx * sy * sz;
    this.y = cx * sy * cz - sx * cy * sz;
    this.z = cx * cy * sz + sx * sy * cz;

    return this;
};

/**
 * Alter the current Quaternion to reflect a rotation of input angle about
 * input axis v.
 *
 * @method makeFromAngleAndAxis
 * @param {Number} angle The angle of rotation.
 * @param {Vec3} v The axis of rotation.
 * @chainable
 */
Quaternion.prototype.fromAngleAxis = function fromAngleAxis(angle, x, y, z) {
    var len = sqrt(x * x + y * y + z * z);
    if (len === 0) {
        this.w = 1;
        this.x = this.y = this.z = 0;
    }
    else {
        len = 1 / len;
        var halfTheta = angle * 0.5;
        var s = sin(halfTheta);
        this.w = cos(halfTheta);
        this.x = s * x * len;
        this.y = s * y * len;
        this.z = s * z * len;
    }
    return this;
};

/**
 * Multiply the input Quaternions.
 * Left-handed coordinate system multiplication.
 *
 * @method multiply
 * @param {Quaternion} q1 The left Quaternion.
 * @param {Quaternion} q2 The right Quaternion.
 * @param {Quaternion} output Quaternion in which to place the result.
 * @return {Quaternion} The product of multiplication.
 */
Quaternion.multiply = function multiply(q1, q2, output) {
    var w1 = q1.w || 0;
    var x1 = q1.x;
    var y1 = q1.y;
    var z1 = q1.z;

    var w2 = q2.w || 0;
    var x2 = q2.x;
    var y2 = q2.y;
    var z2 = q2.z;

    output.w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;
    output.x = x1 * w2 + x2 * w1 + y2 * z1 - y1 * z2;
    output.y = y1 * w2 + y2 * w1 + x1 * z2 - x2 * z1;
    output.z = z1 * w2 + z2 * w1 + x2 * y1 - x1 * y2;
    return output;
};

/**
 * Normalize the input quaternion.
 *
 * @method normalize
 * @return {Quaternion} The normalized quaternion.
 */
Quaternion.normalize = function normalize(q, output) {
    var w = q.w;
    var x = q.x;
    var y = q.y;
    var z = q.z;
    var length = sqrt(w * w + x * x + y * y + z * z);
    if (length === 0) return;
    length = 1 / length;
    output.w *= length;
    output.x *= length;
    output.y *= length;
    output.z *= length;
    return output;
};

/**
 * The conjugate of the input Quaternion.
 *
 * @method conjugate
 * @param {Quaternion} q The reference Quaternion.
 * @param {Quaternion} output Quaternion in which to place the result.
 * @return {Quaternion} The conjugate Quaternion.
 */
Quaternion.conjugate = function conjugate(q, output) {
    output.w = q.w;
    output.x = -q.x;
    output.y = -q.y;
    output.z = -q.z;
    return output;
};

/**
 * Clone the input Quaternion.
 *
 * @method clone
 * @param {Quaternion} q the reference Quaternion.
 * @return {Quaternion} The cloned Quaternion.
 */
Quaternion.clone = function clone(q) {
    return new Quaternion(q.w, q.x, q.y, q.z);
};

/**
 * The dot product of the two input Quaternions.
 *
 * @method dotProduct
 * @param {Quaternion} q1 The left Quaternion.
 * @param {Quaternion} q2 The right Quaternion.
 * @return {Number} The dot product of the two Quaternions.
 */
Quaternion.dot = function dot(q1, q2) {
    return q1.w * q2.w + q1.x * q2.x + q1.y * q2.y + q1.z * q2.z;
};

module.exports = Quaternion;

},{"./Mat33":11}],13:[function(require,module,exports){
'use strict';

var sin = Math.sin;
var cos = Math.cos;
var sqrt = Math.sqrt;

/**
 * A two-dimensional vector.
 *
 * @class Vec2
 * @param {Number} x The x component.
 * @param {Number} y The y component.
 */
var Vec2 = function(x, y){
    if (x instanceof Array || x instanceof Float32Array) {
        this.x = x[0] || 0;
        this.y = x[1] || 0;
    }
    else {
        this.x = x || 0;
        this.y = y || 0;
    }
};

/**
 * Set the components of the current Vec2.
 *
 * @method set
 * @param {Number} x The x component.
 * @param {Number} y The y component.
 * @chainable
 */
Vec2.prototype.set = function set(x, y) {
    if (x != null) this.x = x;
    if (y != null) this.y = y;
    return this;
};

/**
 * Add the input v to the current Vec2.
 *
 * @method add
 * @param {Vec2} v The Vec2 to add.
 * @chainable
 */
Vec2.prototype.add = function add(v) {
    this.x += v.x;
    this.y += v.y;
    return this;
};

/**
 * Subtract the input v from the current Vec2.
 *
 * @method subtract
 * @param {Vec2} v The Vec2 to subtract.
 * @chainable
 */
Vec2.prototype.subtract = function subtract(v) {
    this.x -= v.x;
    this.y -= v.y;
    return this;
};

/**
 * Scale the current Vec2 by a scalar or Vec2.
 *
 * @method scale
 * @param {Number|Vec2} s The Number or vec2 by which to scale.
 * @chainable
 */
Vec2.prototype.scale = function scale(s) {
    if (s instanceof Vec2) {
        this.x *= s.x;
        this.y *= s.y;
    } else {
        this.x *= s;
        this.y *= s;
    }
    return this;
};

/**
 * Rotate the Vec2 counter-clockwise by theta about the z-axis.
 *
 * @method rotate
 * @param {Number} theta Angle by which to rotate.
 * @chainable
 */
Vec2.prototype.rotate = function(theta) {
    var x = this.x;
    var y = this.y;

    var cosTheta = cos(theta);
    var sinTheta = sin(theta);

    this.x = x * cosTheta - y * sinTheta;
    this.y = x * sinTheta + y * cosTheta;

    return this;
};

/**
 * The dot product of of the current Vec2 with the input Vec2.
 *
 * @method dot
 * @param {Number} v The other Vec2.
 * @chainable
 */
Vec2.prototype.dot = function(v) {
    return this.x * v.x + this.y * v.y;
};

/**
 * The cross product of of the current Vec2 with the input Vec2.
 *
 * @method cross
 * @param {Number} v The other Vec2.
 * @chainable
 */
Vec2.prototype.cross = function(v) {
    return this.x * v.y - this.y * v.x;
};

/**
 * Preserve the magnitude but invert the orientation of the current Vec2.
 *
 * @method invert
 * @chainable
 */
Vec2.prototype.invert = function invert() {
    this.x *= -1;
    this.y *= -1;
    return this;
};

/**
 * Apply a function component-wise to the current Vec2.
 *
 * @method map
 * @param {Function} fn Function to apply.
 * @chainable
 */
Vec2.prototype.map = function map(fn) {
    this.x = fn(this.x);
    this.y = fn(this.y);
    return this;
};

/**
 * The magnitude of the current Vec2.
 *
 * @method length
 * @return {Number}
 */
Vec2.prototype.length = function length() {
    var x = this.x;
    var y = this.y;

    return sqrt(x * x + y * y);
};

/**
 * Copy the input onto the current Vec2.
 *
 * @method copy
 * @param {Vec2} v Vec2 to copy.
 * @chainable
 */
Vec2.prototype.copy = function copy(v) {
    this.x = v.x;
    this.y = v.y;
    return this;
};

/**
 * Reset the current Vec2.
 *
 * @method clear
 * @chainable
 */
Vec2.prototype.clear = function clear() {
    this.x = 0;
    this.y = 0;
    return this;
};

/**
 * Check whether the magnitude of the current Vec2 is exactly 0.
 *
 * @method isZero
 * @return {Boolean}
 */
Vec2.prototype.isZero = function isZero() {
    if (this.x !== 0 || this.y !== 0) return false;
    else return true;
};

/**
 * The array form of the current Vec2.
 *
 * @method toArray
 * @return {Number[]}
 */
Vec2.prototype.toArray = function toArray() {
    return [this.x, this.y];
};

/**
 * Normalize the input Vec2.
 *
 * @method normalize
 * @param {Vec2} v The reference Vec2.
 * @param {Vec2} output Vec2 in which to place the result.
 * @return {Vec2} The normalize Vec2.
 */
Vec2.normalize = function normalize(v, output) {
    var x = v.x;
    var y = v.y;

    var length = sqrt(x * x + y * y) || 1;
    length = 1 / length;
    output.x = v.x * length;
    output.y = v.y * length;

    return output;
};

/**
 * Clone the input Vec2.
 *
 * @method clone
 * @param {Vec2} v The Vec2 to clone.
 * @return {Vec2} The cloned Vec2.
 */
Vec2.clone = function clone(v) {
    return new Vec2(v.x, v.y);
};

/**
 * Add the input Vec2's.
 *
 * @method add
 * @param {Vec2} v1 The left Vec2.
 * @param {Vec2} v2 The right Vec2.
 * @param {Vec2} output Vec2 in which to place the result.
 * @return {Vec2} The result of the addition.
 */
Vec2.add = function add(v1, v2, output) {
    output.x = v1.x + v2.x;
    output.y = v1.y + v2.y;

    return output;
};

/**
 * Subtract the second Vec2 from the first.
 *
 * @method subtract
 * @param {Vec2} v1 The left Vec2.
 * @param {Vec2} v2 The right Vec2.
 * @param {Vec2} output Vec2 in which to place the result.
 * @return {Vec2} The result of the subtraction.
 */
Vec2.subtract = function subtract(v1, v2, output) {
    output.x = v1.x - v2.x;
    output.y = v1.y - v2.y;
    return output;
};

/**
 * Scale the input Vec2.
 *
 * @method scale
 * @param {Vec2} v The reference Vec2.
 * @param {Number} s Number to scale by.
 * @param {Vec2} output Vec2 in which to place the result.
 * @return {Vec2} The result of the scaling.
 */
Vec2.scale = function scale(v, s, output) {
    output.x = v.x * s;
    output.y = v.y * s;
    return output;
};

/**
 * The dot product of the input Vec2's.
 *
 * @method dot
 * @param {Vec2} v1 The left Vec2.
 * @param {Vec2} v2 The right Vec2.
 * @return {Number} The dot product.
 */
Vec2.dot = function dot(v1, v2) {
    return v1.x * v2.x + v1.y * v2.y;
};

/**
 * The cross product of the input Vec2's.
 *
 * @method cross
 * @param {Number} v The left Vec2.
 * @param {Number} v The right Vec2.
 * @return {Number} The z-component of the cross product.
 */
Vec2.cross = function(v1,v2) {
    return v1.x * v2.y - v1.y * v2.x;
};

module.exports = Vec2;

},{}],14:[function(require,module,exports){
'use strict';

var sin = Math.sin;
var cos = Math.cos;
var sqrt = Math.sqrt;

/**
 * A three-dimensional vector.
 *
 * @class Vec3
 * @param {Number} x The x component.
 * @param {Number} y The y component.
 * @param {Number} z The z component.
 */
var Vec3 = function(x ,y, z){
    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
};

/**
 * Set the components of the current Vec3.
 *
 * @method set
 * @param {Number} x The x component.
 * @param {Number} y The y component.
 * @param {Number} z The z component.
 * @chainable
 */
Vec3.prototype.set = function set(x, y, z) {
    if (x != null) this.x = x;
    if (y != null) this.y = y;
    if (z != null) this.z = z;

    return this;
};

/**
 * Add the input v to the current Vec3.
 *
 * @method add
 * @param {Vec3} v The Vec3 to add.
 * @chainable
 */
Vec3.prototype.add = function add(v) {
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;

    return this;
};

/**
 * Subtract the input v from the current Vec3.
 *
 * @method subtract
 * @param {Vec3} v The Vec3 to subtract.
 * @chainable
 */
Vec3.prototype.subtract = function subtract(v) {
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;

    return this;
};

/**
 * Rotate the current Vec3 by theta clockwise about the x axis.
 *
 * @method rotateX
 * @param {Number} theta Angle by which to rotate.
 * @chainable
 */
Vec3.prototype.rotateX = function rotateX(theta) {
    var x = this.x;
    var y = this.y;
    var z = this.z;

    var cosTheta = cos(theta);
    var sinTheta = sin(theta);

    this.y = y * cosTheta - z * sinTheta;
    this.z = y * sinTheta + z * cosTheta;

    return this;
};

/**
 * Rotate the current Vec3 by theta clockwise about the y axis.
 *
 * @method rotateY
 * @param {Number} theta Angle by which to rotate.
 * @chainable
 */
Vec3.prototype.rotateY = function rotateY(theta) {
    var x = this.x;
    var y = this.y;
    var z = this.z;

    var cosTheta = cos(theta);
    var sinTheta = sin(theta);

    this.x = z * sinTheta + x * cosTheta;
    this.z = z * cosTheta - x * sinTheta;

    return this;
};

/**
 * Rotate the current Vec3 by theta clockwise about the z axis.
 *
 * @method rotateZ
 * @param {Number} theta Angle by which to rotate.
 * @chainable
 */
Vec3.prototype.rotateZ = function rotateZ(theta) {
    var x = this.x;
    var y = this.y;
    var z = this.z;

    var cosTheta = cos(theta);
    var sinTheta = sin(theta);

    this.x = x * cosTheta - y * sinTheta;
    this.y = x * sinTheta + y * cosTheta;

    return this;
};

/**
 * The dot product of the current Vec3 with input Vec3 v.
 *
 * @method dot
 * @param {Vec3} v The other Vec3.
 * @return {Number}
 */
Vec3.prototype.dot = function dot(v) {
    return this.x*v.x + this.y*v.y + this.z*v.z;
};

/**
 * The dot product of the current Vec3 with input Vec3 v.
 * Stores the result in the current Vec3.
 *
 * @method cross
 * @param {Vec3} v The other Vec3.
 * @chainable
 */
Vec3.prototype.cross = function cross(v) {
    var x = this.x;
    var y = this.y;
    var z = this.z;

    var vx = v.x;
    var vy = v.y;
    var vz = v.z;

    this.x = y * vz - z * vy;
    this.y = z * vx - x * vz;
    this.z = x * vy - y * vx;
    return this;
};

/**
 * Scale the current Vec3 by a scalar.
 *
 * @method scale
 * @param {Number} s The Number by which to scale.
 * @chainable
 */
Vec3.prototype.scale = function scale(s) {
    this.x *= s;
    this.y *= s;
    this.z *= s;

    return this;
};

/**
 * Preserve the magnitude but invert the orientation of the current Vec3.
 *
 * @method invert
 * @chainable
 */
Vec3.prototype.invert = function invert() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;

    return this;
};

/**
 * Apply a function component-wise to the current Vec3.
 *
 * @method map
 * @param {Function} fn Function to apply.
 * @chainable
 */
Vec3.prototype.map = function map(fn) {
    this.x = fn(this.x);
    this.y = fn(this.y);
    this.z = fn(this.z);

    return this;
};

/**
 * The magnitude of the current Vec3.
 *
 * @method length
 * @return {Number}
 */
Vec3.prototype.length = function length() {
    var x = this.x;
    var y = this.y;
    var z = this.z;

    return sqrt(x * x + y * y + z * z);
};

/**
 * The magnitude squared of the current Vec3.
 *
 * @method length
 * @return {Number}
 */
Vec3.prototype.lengthSq = function lengthSq() {
    var x = this.x;
    var y = this.y;
    var z = this.z;

    return x * x + y * y + z * z;
};

/**
 * Copy the input onto the current Vec3.
 *
 * @method copy
 * @param {Vec3} v Vec3 to copy.
 * @chainable
 */
Vec3.prototype.copy = function copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    return this;
};

/**
 * Reset the current Vec3.
 *
 * @method clear
 * @chainable
 */
Vec3.prototype.clear = function clear() {
    this.x = 0;
    this.y = 0;
    this.z = 0;
    return this;
};

/**
 * Check whether the magnitude of the current Vec3 is exactly 0.
 *
 * @method isZero
 * @return {Boolean}
 */
Vec3.prototype.isZero = function isZero() {
    return this.x === 0 && this.y === 0 && this.z === 0;
};

/**
 * The array form of the current Vec3.
 *
 * @method toArray
 * @return {Number[]}
 */
Vec3.prototype.toArray = function toArray() {
    return [this.x, this.y, this.z];
};

/**
 * Preserve the orientation but change the length of the current Vec3 to 1.
 *
 * @method normalize
 * @chainable
 */
Vec3.prototype.normalize = function normalize() {
    var x = this.x;
    var y = this.y;
    var z = this.z;

    var len = sqrt(x * x + y * y + z * z) || 1;
    len = 1 / len;

    this.x *= len;
    this.y *= len;
    this.z *= len;
    return this;
};

/**
 * Apply the rotation corresponding to the input (unit) Quaternion
 * to the current Vec3.
 *
 * @method applyRotation
 * @param {Quaternion} q Unit Quaternion representing the rotation to apply.
 * @chainable
 */
Vec3.prototype.applyRotation = function applyRotation(q) {
    var cw = q.w;
    var cx = -q.x;
    var cy = -q.y;
    var cz = -q.z;

    var vx = this.x;
    var vy = this.y;
    var vz = this.z;

    var tw = -cx * vx - cy * vy - cz * vz;
    var tx = vx * cw + vy * cz - cy * vz;
    var ty = vy * cw + cx * vz - vx * cz;
    var tz = vz * cw + vx * cy - cx * vy;

    var w = cw;
    var x = -cx;
    var y = -cy;
    var z = -cz;

    this.x = tx * w + x * tw + y * tz - ty * z;
    this.y = ty * w + y * tw + tx * z - x * tz;
    this.z = tz * w + z * tw + x * ty - tx * y;
    return this;
};

/**
 * Apply the input Mat33 the the current Vec3.
 *
 * @method applyMatrix
 * @param {Mat33} matrix Mat33 to apply.
 * @chainable
 */
Vec3.prototype.applyMatrix = function applyMatrix(matrix) {
    var M = matrix.get();

    var x = this.x;
    var y = this.y;
    var z = this.z;

    this.x = M[0]*x + M[1]*y + M[2]*z;
    this.y = M[3]*x + M[4]*y + M[5]*z;
    this.z = M[6]*x + M[7]*y + M[8]*z;
    return this;
};

/**
 * Normalize the input Vec3.
 *
 * @method normalize
 * @param {Vec3} v The reference Vec3.
 * @param {Vec3} output Vec3 in which to place the result.
 * @return {Vec3} The normalize Vec3.
 */
Vec3.normalize = function normalize(v, output) {
    var x = v.x;
    var y = v.y;
    var z = v.z;

    var length = sqrt(x * x + y * y + z * z) || 1;
    length = 1 / length;

    output.x = x * length;
    output.y = y * length;
    output.z = z * length;
    return output;
};

/**
 * Apply a rotation to the input Vec3.
 *
 * @method applyRotation
 * @param {Vec3} v The reference Vec3.
 * @param {Quaternion} q Unit Quaternion representing the rotation to apply.
 * @param {Vec3} output Vec3 in which to place the result.
 * @return {Vec3} The rotated version of the input Vec3.
 */
Vec3.applyRotation = function applyRotation(v, q, output) {
    var cw = q.w;
    var cx = -q.x;
    var cy = -q.y;
    var cz = -q.z;

    var vx = v.x;
    var vy = v.y;
    var vz = v.z;

    var tw = -cx * vx - cy * vy - cz * vz;
    var tx = vx * cw + vy * cz - cy * vz;
    var ty = vy * cw + cx * vz - vx * cz;
    var tz = vz * cw + vx * cy - cx * vy;

    var w = cw;
    var x = -cx;
    var y = -cy;
    var z = -cz;

    output.x = tx * w + x * tw + y * tz - ty * z;
    output.y = ty * w + y * tw + tx * z - x * tz;
    output.z = tz * w + z * tw + x * ty - tx * y;
    return output;
};

/**
 * Clone the input Vec3.
 *
 * @method clone
 * @param {Vec3} v The Vec3 to clone.
 * @return {Vec3} The cloned Vec3.
 */
Vec3.clone = function clone(v) {
    return new Vec3(v.x, v.y, v.z);
};

/**
 * Add the input Vec3's.
 *
 * @method add
 * @param {Vec3} v1 The left Vec3.
 * @param {Vec3} v2 The right Vec3.
 * @param {Vec3} output Vec3 in which to place the result.
 * @return {Vec3} The result of the addition.
 */
Vec3.add = function add(v1, v2, output) {
    output.x = v1.x + v2.x;
    output.y = v1.y + v2.y;
    output.z = v1.z + v2.z;
    return output;
};

/**
 * Subtract the second Vec3 from the first.
 *
 * @method subtract
 * @param {Vec3} v1 The left Vec3.
 * @param {Vec3} v2 The right Vec3.
 * @param {Vec3} output Vec3 in which to place the result.
 * @return {Vec3} The result of the subtraction.
 */
Vec3.subtract = function subtract(v1, v2, output) {
    output.x = v1.x - v2.x;
    output.y = v1.y - v2.y;
    output.z = v1.z - v2.z;
    return output;
};

/**
 * Scale the input Vec3.
 *
 * @method scale
 * @param {Vec3} v The reference Vec3.
 * @param {Number} s Number to scale by.
 * @param {Vec3} output Vec3 in which to place the result.
 * @return {Vec3} The result of the scaling.
 */
Vec3.scale = function scale(v, s, output) {
    output.x = v.x * s;
    output.y = v.y * s;
    output.z = v.z * s;
    return output;
};

/**
 * The dot product of the input Vec3's.
 *
 * @method dotProduct
 * @param {Vec3} v1 The left Vec3.
 * @param {Vec3} v2 The right Vec3.
 * @return {Number} The dot product.
 */
Vec3.dot = function dot(v1, v2) {
    return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
};

/**
 * The (right-handed) cross product of the input Vec3's.
 * v1 x v2.
 *
 * @method crossProduct
 * @param {Vec3} v1 The left Vec3.
 * @param {Vec3} v2 The right Vec3.
 * @param {Vec3} output Vec3 in which to place the result.
 * @return {Vec3}
 */
Vec3.cross = function cross(v1, v2, output) {
    var x1 = v1.x;
    var y1 = v1.y;
    var z1 = v1.z;
    var x2 = v2.x;
    var y2 = v2.y;
    var z2 = v2.z;

    output.x = y1 * z2 - z1 * y2;
    output.y = z1 * x2 - x1 * z2;
    output.z = x1 * y2 - y1 * x2;
    return output;
};

/**
 * The projection of v1 onto v2.
 *
 * @method project
 * @param {Vec3} v1 The left Vec3.
 * @param {Vec3} v2 The right Vec3.
 * @param {Vec3} output Vec3 in which to place the result.
 * @return {Vec3}
 */
Vec3.project = function project(v1, v2, output) {
    var x1 = v1.x;
    var y1 = v1.y;
    var z1 = v1.z;
    var x2 = v2.x;
    var y2 = v2.y;
    var z2 = v2.z;

    var scale = x1 * x2 + y1 * y2 + z1 * z2;
    scale /= x2 * x2 + y2 * y2 + z2 * z2;

    output.x = x2 * scale;
    output.y = y2 * scale;
    output.z = z2 * scale;

    return output;
};

module.exports = Vec3;

},{}],15:[function(require,module,exports){
module.exports = {
    Mat33: require('./Mat33'),
    Quaternion: require('./Quaternion'),
    Vec2: require('./Vec2'),
    Vec3: require('./Vec3')
};


},{"./Mat33":11,"./Quaternion":12,"./Vec2":13,"./Vec3":14}],16:[function(require,module,exports){
/*jshint -W008 */

'use strict';

var Curves = {
    /**
     * @property linear
     * @static
     * @type {Function}
     */
    linear: function(t) {
        return t;
    },

    /**
     * @property easeIn
     * @static
     * @type {Function}
     */
    easeIn: function(t) {
        return t*t;
    },

    /**
     * @property easeOut
     * @static
     * @type {Function}
     */
    easeOut: function(t) {
        return t*(2-t);
    },

    /**
     * @property easeInOut
     * @static
     * @type {Function}
     */
    easeInOut: function(t) {
        if (t <= 0.5) return 2*t*t;
        else return -2*t*t + 4*t - 1;
    },

    /**
     * @property easeOutBounce
     * @static
     * @type {Function}
     */
    easeOutBounce: function(t) {
        return t*(3 - 2*t);
    },

    /**
     * @property spring
     * @static
     * @type {Function}
     */
    spring: function(t) {
        return (1 - t) * Math.sin(6 * Math.PI * t) + t;
    },

    /**
     * @property inQuad
     * @static
     * @type {Function}
     */
    inQuad: function(t) {
        return t*t;
    },

    /**
     * @property outQuad
     * @static
     * @type {Function}
     */
    outQuad: function(t) {
        return -(t-=1)*t+1;
    },

    /**
     * @property inOutQuad
     * @static
     * @type {Function}
     */
    inOutQuad: function(t) {
        if ((t/=.5) < 1) return .5*t*t;
        return -.5*((--t)*(t-2) - 1);
    },

    /**
     * @property inCubic
     * @static
     * @type {Function}
     */
    inCubic: function(t) {
        return t*t*t;
    },

    /**
     * @property outCubic
     * @static
     * @type {Function}
     */
    outCubic: function(t) {
        return ((--t)*t*t + 1);
    },

    /**
     * @property inOutCubic
     * @static
     * @type {Function}
     */
    inOutCubic: function(t) {
        if ((t/=.5) < 1) return .5*t*t*t;
        return .5*((t-=2)*t*t + 2);
    },

    /**
     * @property inQuart
     * @static
     * @type {Function}
     */
    inQuart: function(t) {
        return t*t*t*t;
    },

    /**
     * @property outQuart
     * @static
     * @type {Function}
     */
    outQuart: function(t) {
        return -((--t)*t*t*t - 1);
    },

    /**
     * @property inOutQuart
     * @static
     * @type {Function}
     */
    inOutQuart: function(t) {
        if ((t/=.5) < 1) return .5*t*t*t*t;
        return -.5 * ((t-=2)*t*t*t - 2);
    },

    /**
     * @property inQuint
     * @static
     * @type {Function}
     */
    inQuint: function(t) {
        return t*t*t*t*t;
    },

    /**
     * @property outQuint
     * @static
     * @type {Function}
     */
    outQuint: function(t) {
        return ((--t)*t*t*t*t + 1);
    },

    /**
     * @property inOutQuint
     * @static
     * @type {Function}
     */
    inOutQuint: function(t) {
        if ((t/=.5) < 1) return .5*t*t*t*t*t;
        return .5*((t-=2)*t*t*t*t + 2);
    },

    /**
     * @property inSine
     * @static
     * @type {Function}
     */
    inSine: function(t) {
        return -1.0*Math.cos(t * (Math.PI/2)) + 1.0;
    },

    /**
     * @property outSine
     * @static
     * @type {Function}
     */
    outSine: function(t) {
        return Math.sin(t * (Math.PI/2));
    },

    /**
     * @property inOutSine
     * @static
     * @type {Function}
     */
    inOutSine: function(t) {
        return -.5*(Math.cos(Math.PI*t) - 1);
    },

    /**
     * @property inExpo
     * @static
     * @type {Function}
     */
    inExpo: function(t) {
        return (t===0) ? 0.0 : Math.pow(2, 10 * (t - 1));
    },

    /**
     * @property outExpo
     * @static
     * @type {Function}
     */
    outExpo: function(t) {
        return (t===1.0) ? 1.0 : (-Math.pow(2, -10 * t) + 1);
    },

    /**
     * @property inOutExpo
     * @static
     * @type {Function}
     */
    inOutExpo: function(t) {
        if (t===0) return 0.0;
        if (t===1.0) return 1.0;
        if ((t/=.5) < 1) return .5 * Math.pow(2, 10 * (t - 1));
        return .5 * (-Math.pow(2, -10 * --t) + 2);
    },

    /**
     * @property inCirc
     * @static
     * @type {Function}
     */
    inCirc: function(t) {
        return -(Math.sqrt(1 - t*t) - 1);
    },

    /**
     * @property outCirc
     * @static
     * @type {Function}
     */
    outCirc: function(t) {
        return Math.sqrt(1 - (--t)*t);
    },

    /**
     * @property inOutCirc
     * @static
     * @type {Function}
     */
    inOutCirc: function(t) {
        if ((t/=.5) < 1) return -.5 * (Math.sqrt(1 - t*t) - 1);
        return .5 * (Math.sqrt(1 - (t-=2)*t) + 1);
    },

    /**
     * @property inElastic
     * @static
     * @type {Function}
     */
    inElastic: function(t) {
        var s=1.70158;var p=0;var a=1.0;
        if (t===0) return 0.0;  if (t===1) return 1.0;  if (!p) p=.3;
        s = p/(2*Math.PI) * Math.asin(1.0/a);
        return -(a*Math.pow(2,10*(t-=1)) * Math.sin((t-s)*(2*Math.PI)/ p));
    },

    /**
     * @property outElastic
     * @static
     * @type {Function}
     */
    outElastic: function(t) {
        var s=1.70158;var p=0;var a=1.0;
        if (t===0) return 0.0;  if (t===1) return 1.0;  if (!p) p=.3;
        s = p/(2*Math.PI) * Math.asin(1.0/a);
        return a*Math.pow(2,-10*t) * Math.sin((t-s)*(2*Math.PI)/p) + 1.0;
    },

    /**
     * @property inOutElastic
     * @static
     * @type {Function}
     */
    inOutElastic: function(t) {
        var s=1.70158;var p=0;var a=1.0;
        if (t===0) return 0.0;  if ((t/=.5)===2) return 1.0;  if (!p) p=(.3*1.5);
        s = p/(2*Math.PI) * Math.asin(1.0/a);
        if (t < 1) return -.5*(a*Math.pow(2,10*(t-=1)) * Math.sin((t-s)*(2*Math.PI)/p));
        return a*Math.pow(2,-10*(t-=1)) * Math.sin((t-s)*(2*Math.PI)/p)*.5 + 1.0;
    },

    /**
     * @property inBack
     * @static
     * @type {Function}
     */
    inBack: function(t, s) {
        if (s === undefined) s = 1.70158;
        return t*t*((s+1)*t - s);
    },

    /**
     * @property outBack
     * @static
     * @type {Function}
     */
    outBack: function(t, s) {
        if (s === undefined) s = 1.70158;
        return ((--t)*t*((s+1)*t + s) + 1);
    },

    /**
     * @property inOutBack
     * @static
     * @type {Function}
     */
    inOutBack: function(t, s) {
        if (s === undefined) s = 1.70158;
        if ((t/=.5) < 1) return .5*(t*t*(((s*=(1.525))+1)*t - s));
        return .5*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2);
    },

    /**
     * @property inBounce
     * @static
     * @type {Function}
     */
    inBounce: function(t) {
        return 1.0 - Curves.outBounce(1.0-t);
    },

    /**
     * @property outBounce
     * @static
     * @type {Function}
     */
    outBounce: function(t) {
        if (t < (1/2.75)) {
            return (7.5625*t*t);
        } else if (t < (2/2.75)) {
            return (7.5625*(t-=(1.5/2.75))*t + .75);
        } else if (t < (2.5/2.75)) {
            return (7.5625*(t-=(2.25/2.75))*t + .9375);
        } else {
            return (7.5625*(t-=(2.625/2.75))*t + .984375);
        }
    },

    /**
     * @property inOutBounce
     * @static
     * @type {Function}
     */
    inOutBounce: function(t) {
        if (t < .5) return Curves.inBounce(t*2) * .5;
        return Curves.outBounce(t*2-1.0) * .5 + .5;
    },

    /**
     * @property flat
     *
     * Useful for delaying the execution of a subsequent transition.
     * 
     * @static
     * @type {Function}
     */
    flat: function() {
        return 0;
    }
};

module.exports = Curves;

},{}],17:[function(require,module,exports){
'use strict';

var Curves = require('./Curves');

/**
 * A state maintainer for a smooth transition between
 *    numerically-specified states. Example numeric states include floats and
 *    arrays of floats objects.
 *
 * An initial state is set with the constructor or using
 *     {@link Transitionable#from}. Subsequent transitions consist of an
 *     intermediate state, easing curve, duration and callback. The final state
 *     of each transition is the initial state of the subsequent one. Calls to
 *     {@link Transitionable#get} provide the interpolated state along the way.
 *
 * Note that there is no event loop here - calls to {@link Transitionable#get}
 *    are the only way to find state projected to the current (or provided)
 *    time and are the only way to trigger callbacks and mutate the internal
 *    transition queue.
 *
 * @example
 * var t = new Transitionable([0, 0]);
 * t
 *     .to([100, 0], 'linear', 1000)
 *     .delay(1000)
 *     .to([200, 0], 'outBounce', 1000);
 *
 * var div = document.createElement('div');
 * div.style.background = 'blue';
 * div.style.width = '100px';
 * div.style.height = '100px';
 * document.body.appendChild(div);
 *
 * div.addEventListener('click', function() {
 *     t.isPaused() ? t.resume() : t.pause();
 * });
 *
 * requestAnimationFrame(function loop() {
 *     div.style.transform = 'translateX(' + t.get()[0] + 'px)' + ' translateY(' + t.get()[1] + 'px)';
 *     requestAnimationFrame(loop);
 * });
 *
 * @class Transitionable
 * @constructor
 * @param {Number|Array.Number} initialState    initial state to transition
 *                                              from - equivalent to a pursuant
 *                                              invocation of
 *                                              {@link Transitionable#from}
 */
function Transitionable(initialState) {
    this._queue = [];
    this._multi = null;
    this._method = null;
    this._end = null;
    this._startedAt = null;
    this._pausedAt = null;
    if (initialState != null) this.from(initialState);
}

/**
 * Internal Clock used for determining the current time for the ongoing
 * transitions.
 *
 * @type {Performance|Date|Object}
 */
Transitionable.Clock = typeof performance !== 'undefined' ? performance : Date;

/**
 * Registers a transition to be pushed onto the internal queue.
 *
 * @method to
 * @chainable
 *
 * @param  {Number|Array.Number}    finalState              final state to
 *                                                          transiton to
 * @param  {String|Function}        [curve=Curves.linear]   easing function
 *                                                          used for
 *                                                          interpolating
 *                                                          [0, 1]
 * @param  {Number}                 [duration=100]          duration of
 *                                                          transition
 * @param  {Function}               [callback]              callback function
 *                                                          to be called after
 *                                                          the transition is
 *                                                          complete
 * @return {Transitionable}         this
 */
Transitionable.prototype.to = function to(finalState, curve, duration, callback, method) {
    curve = curve != null && curve.constructor === String ? Curves[curve] : curve;
    this._method = method;
    if (this._queue.length === 0) {
        this._startedAt = this.constructor.Clock.now();
        this._pausedAt = null;
    }
    this._queue.push(
        finalState,
        curve != null ? curve : Curves.linear,
        duration != null ? duration : 100,
        callback
    );
    return this;
};

/**
 * Resets the transition queue to a stable initial state.
 *
 * @method from
 * @chainable
 *
 * @param  {Number|Array.Number}    initialState    initial state to
 *                                                  transition from
 * @return {Transitionable}         this
 */
Transitionable.prototype.from = function from(initialState) {
    this._end = initialState;
    if (initialState.constructor === Array && this._multi != null && this._multi.constructor === Array) {
        this._multi.length = initialState.length;
    } else {
        this._multi = initialState.constructor === Array ? [] : false;
    }
    this._queue.length = 0;
    this._startedAt = this.constructor.Clock.now();
    this._pausedAt = null;
    return this;
};

/**
 * Delays the execution of the subsequent transition for a certain period of
 * time.
 *
 * @method delay
 * @chainable
 *
 * @param {Number}      duration    delay time in ms
 * @param {Function}    [callback]  Zero-argument function to call on observed
 *                                  completion (t=1)
 * @return {Transitionable}         this
 */
Transitionable.prototype.delay = function delay(duration, callback) {
    var endState = this._queue.length > 0 ? this._queue[this._queue.length - 4] : this._end;
    return this.to(endState, Curves.flat, duration, callback);
};

/**
 * Overrides current transition.
 *
 * @method override
 * @chainable
 *
 * @param  {Number|Array.Number}    [finalState]    final state to transiton to
 * @param  {String|Function}        [curve]         easing function used for
 *                                                  interpolating [0, 1]
 * @param  {Number}                 [duration]      duration of transition
 * @param  {Function}               [callback]      callback function to be
 *                                                  called after the transition
 *                                                  is complete
 * @return {Transitionable}         this
 */
Transitionable.prototype.override = function override(finalState, curve, duration, callback) {
    if (this._queue.length > 0) {
        if (finalState != null) this._queue[0] = finalState;
        if (curve != null)      this._queue[1] = curve.constructor === String ? Curves[curve] : curve;
        if (duration != null)   this._queue[2] = duration;
        if (callback != null)   this._queue[3] = callback;
    }
    return this;
};

Transitionable.prototype._interpolate = function _interpolate(from, to, progress) {
    if (this._multi) {
        if (this._method === 'slerp') {
            var x, y, z, w;
            var qx, qy, qz, qw;
            var omega, cosomega, sinomega, scaleFrom, scaleTo;
            var resx, resy, resz, resw;

            x = from[0];
            y = from[1];
            z = from[2];
            w = from[3];

            qx = to[0];
            qy = to[1];
            qz = to[2];
            qw = to[3];

            cosomega = w * qw + x * qx + y * qy + z * qz;
            if ((1.0 - cosomega) > 1e-5) {
                omega = Math.acos(cosomega);
                sinomega = Math.sin(omega);
                scaleFrom = Math.sin((1.0 - progress) * omega) / sinomega;
                scaleTo = Math.sin(progress * omega) / sinomega;
            }
            else {
                scaleFrom = 1.0 - progress;
                scaleTo = progress;
            }

            this._multi[0] = x * scaleFrom + qx * scaleTo;
            this._multi[1] = y * scaleFrom + qy * scaleTo;
            this._multi[2] = z * scaleFrom + qz * scaleTo;
            this._multi[3] = w * scaleFrom + qw * scaleTo;
        }
        else {
            for (var i = 0; i < to.length; i++) {
                this._multi[i] = from[i] + progress * (to[i] - from[i]);
            }
        }
        return this._multi;
    } else {
        return from + progress * (to - from);
    }
};

/**
 * Get interpolated state of current action at provided time. If the last
 *    action has completed, invoke its callback.
 *
 * @method get
 *
 * @param {Number=} timestamp Evaluate the curve at a normalized version of this
 *    time. If omitted, use current time. (Unix epoch time)
 * @return {Number|Array.Number} beginning state
 *    interpolated to this point in time.
 */
Transitionable.prototype.get = function get(t) {
    t = this._pausedAt ? this._pausedAt : t;
    t = t ? t : this.constructor.Clock.now();
    if (this._queue.length === 0) return this._end;

    var progress = (t - this._startedAt) / this._queue[2];
    var state = this._interpolate(this._end, this._queue[0], this._queue[1](progress > 1 ? 1 : progress), this._method);
    if (progress >= 1) {
        this._startedAt = this._startedAt + this._queue[2];
        this._end = this._queue.shift();
        this._queue.shift();
        this._queue.shift();
        var callback = this._queue.shift();
        if (callback) callback();
    }
    return progress > 1 ? this.get() : state;
};

/**
 * Is there at least one transition pending completion?
 *
 * @method isActive
 *
 * @return {boolean}
 */
Transitionable.prototype.isActive = function isActive() {
    return this._queue.length > 0;
};

/**
 * Halt transition at current state and erase all pending actions.
 *
 * @method halt
 * @chainable
 *
 * @return {Transitionable} this
 */
Transitionable.prototype.halt = function halt() {
    return this.from(this.get());
};

/**
 * Pause transition. This will not erase any actions.
 *
 * @method pause
 * @chainable
 *
 * @return {Transitionable} this
 */
Transitionable.prototype.pause = function pause() {
    this._pausedAt = this.constructor.Clock.now();
    return this;
};

/**
 * Has the current action been paused?
 *
 * @method isPaused
 * @chainable
 *
 * @return {Boolean} if the current action has been paused
 */
Transitionable.prototype.isPaused = function isPaused() {
    return !!this._pausedAt;
};

/**
 * Resume transition.
 *
 * @method resume
 * @chainable
 *
 * @return {Transitionable} this
 */
Transitionable.prototype.resume = function resume() {
    var diff = this._pausedAt - this._startedAt;
    this._startedAt = this.constructor.Clock.now() - diff;
    this._pausedAt = null;
    return this;
};

/**
 * Cancel all transitions and reset to a stable state
 *
 * @method reset
 * @chainable
 * @deprecated Use `.from` instead!
 *
 * @param {Number|Array.Number|Object.<number, number>} startState
 *    stable state to set to
 */
Transitionable.prototype.reset = function(start) {
    return this.from(start);
};

/**
 * Add transition to end state to the queue of pending transitions. Special
 *    Use: calling without a transition resets the object to that state with
 *    no pending actions
 *
 * @method set
 * @chainable
 * @deprecated Use `.to` instead!
 *
 * @param {Number|FamousMatrix|Array.Number|Object.<number, number>} endState
 *    end state to which we interpolate
 * @param {transition=} transition object of type {duration: number, curve:
 *    f[0,1] -> [0,1] or name}. If transition is omitted, change will be
 *    instantaneous.
 * @param {function()=} callback Zero-argument function to call on observed
 *    completion (t=1)
 */
Transitionable.prototype.set = function(state, transition, callback) {
    if (transition == null) {
        this.from(state);
        if (callback) callback();
    } else {
        this.to(state, transition.curve, transition.duration, callback, transition.method);
    }
    return this;
};

module.exports = Transitionable;

},{"./Curves":16}],18:[function(require,module,exports){
'use strict';

module.exports = {
    Curves: require('./Curves'),
    Transitionable: require('./Transitionable')
};

},{"./Curves":16,"./Transitionable":17}],19:[function(require,module,exports){
/*jshint -W008 */

'use strict';

var Curves = {
    /**
     * @property linear
     * @static
     * @type {Function}
     */
    linear: function(t) {
        return t;
    },

    /**
     * @property easeIn
     * @static
     * @type {Function}
     */
    easeIn: function(t) {
        return t*t;
    },

    /**
     * @property easeOut
     * @static
     * @type {Function}
     */
    easeOut: function(t) {
        return t*(2-t);
    },

    /**
     * @property easeInOut
     * @static
     * @type {Function}
     */
    easeInOut: function(t) {
        if (t <= 0.5) return 2*t*t;
        else return -2*t*t + 4*t - 1;
    },

    /**
     * @property easeOutBounce
     * @static
     * @type {Function}
     */
    easeOutBounce: function(t) {
        return t*(3 - 2*t);
    },

    /**
     * @property spring
     * @static
     * @type {Function}
     */
    spring: function(t) {
        return (1 - t) * Math.sin(6 * Math.PI * t) + t;
    },

    /**
     * @property inQuad
     * @static
     * @type {Function}
     */
    inQuad: function(t) {
        return t*t;
    },

    /**
     * @property outQuad
     * @static
     * @type {Function}
     */
    outQuad: function(t) {
        return -(t-=1)*t+1;
    },

    /**
     * @property inOutQuad
     * @static
     * @type {Function}
     */
    inOutQuad: function(t) {
        if ((t/=.5) < 1) return .5*t*t;
        return -.5*((--t)*(t-2) - 1);
    },

    /**
     * @property inCubic
     * @static
     * @type {Function}
     */
    inCubic: function(t) {
        return t*t*t;
    },

    /**
     * @property outCubic
     * @static
     * @type {Function}
     */
    outCubic: function(t) {
        return ((--t)*t*t + 1);
    },

    /**
     * @property inOutCubic
     * @static
     * @type {Function}
     */
    inOutCubic: function(t) {
        if ((t/=.5) < 1) return .5*t*t*t;
        return .5*((t-=2)*t*t + 2);
    },

    /**
     * @property inQuart
     * @static
     * @type {Function}
     */
    inQuart: function(t) {
        return t*t*t*t;
    },

    /**
     * @property outQuart
     * @static
     * @type {Function}
     */
    outQuart: function(t) {
        return -((--t)*t*t*t - 1);
    },

    /**
     * @property inOutQuart
     * @static
     * @type {Function}
     */
    inOutQuart: function(t) {
        if ((t/=.5) < 1) return .5*t*t*t*t;
        return -.5 * ((t-=2)*t*t*t - 2);
    },

    /**
     * @property inQuint
     * @static
     * @type {Function}
     */
    inQuint: function(t) {
        return t*t*t*t*t;
    },

    /**
     * @property outQuint
     * @static
     * @type {Function}
     */
    outQuint: function(t) {
        return ((--t)*t*t*t*t + 1);
    },

    /**
     * @property inOutQuint
     * @static
     * @type {Function}
     */
    inOutQuint: function(t) {
        if ((t/=.5) < 1) return .5*t*t*t*t*t;
        return .5*((t-=2)*t*t*t*t + 2);
    },

    /**
     * @property inSine
     * @static
     * @type {Function}
     */
    inSine: function(t) {
        return -1.0*Math.cos(t * (Math.PI/2)) + 1.0;
    },

    /**
     * @property outSine
     * @static
     * @type {Function}
     */
    outSine: function(t) {
        return Math.sin(t * (Math.PI/2));
    },

    /**
     * @property inOutSine
     * @static
     * @type {Function}
     */
    inOutSine: function(t) {
        return -.5*(Math.cos(Math.PI*t) - 1);
    },

    /**
     * @property inExpo
     * @static
     * @type {Function}
     */
    inExpo: function(t) {
        return (t===0) ? 0.0 : Math.pow(2, 10 * (t - 1));
    },

    /**
     * @property outExpo
     * @static
     * @type {Function}
     */
    outExpo: function(t) {
        return (t===1.0) ? 1.0 : (-Math.pow(2, -10 * t) + 1);
    },

    /**
     * @property inOutExpo
     * @static
     * @type {Function}
     */
    inOutExpo: function(t) {
        if (t===0) return 0.0;
        if (t===1.0) return 1.0;
        if ((t/=.5) < 1) return .5 * Math.pow(2, 10 * (t - 1));
        return .5 * (-Math.pow(2, -10 * --t) + 2);
    },

    /**
     * @property inCirc
     * @static
     * @type {Function}
     */
    inCirc: function(t) {
        return -(Math.sqrt(1 - t*t) - 1);
    },

    /**
     * @property outCirc
     * @static
     * @type {Function}
     */
    outCirc: function(t) {
        return Math.sqrt(1 - (--t)*t);
    },

    /**
     * @property inOutCirc
     * @static
     * @type {Function}
     */
    inOutCirc: function(t) {
        if ((t/=.5) < 1) return -.5 * (Math.sqrt(1 - t*t) - 1);
        return .5 * (Math.sqrt(1 - (t-=2)*t) + 1);
    },

    /**
     * @property inElastic
     * @static
     * @type {Function}
     */
    inElastic: function(t) {
        var s=1.70158;var p=0;var a=1.0;
        if (t===0) return 0.0;  if (t===1) return 1.0;  if (!p) p=.3;
        s = p/(2*Math.PI) * Math.asin(1.0/a);
        return -(a*Math.pow(2,10*(t-=1)) * Math.sin((t-s)*(2*Math.PI)/ p));
    },

    /**
     * @property outElastic
     * @static
     * @type {Function}
     */
    outElastic: function(t) {
        var s=1.70158;var p=0;var a=1.0;
        if (t===0) return 0.0;  if (t===1) return 1.0;  if (!p) p=.3;
        s = p/(2*Math.PI) * Math.asin(1.0/a);
        return a*Math.pow(2,-10*t) * Math.sin((t-s)*(2*Math.PI)/p) + 1.0;
    },

    /**
     * @property inOutElastic
     * @static
     * @type {Function}
     */
    inOutElastic: function(t) {
        var s=1.70158;var p=0;var a=1.0;
        if (t===0) return 0.0;  if ((t/=.5)===2) return 1.0;  if (!p) p=(.3*1.5);
        s = p/(2*Math.PI) * Math.asin(1.0/a);
        if (t < 1) return -.5*(a*Math.pow(2,10*(t-=1)) * Math.sin((t-s)*(2*Math.PI)/p));
        return a*Math.pow(2,-10*(t-=1)) * Math.sin((t-s)*(2*Math.PI)/p)*.5 + 1.0;
    },

    /**
     * @property inBack
     * @static
     * @type {Function}
     */
    inBack: function(t, s) {
        if (s === undefined) s = 1.70158;
        return t*t*((s+1)*t - s);
    },

    /**
     * @property outBack
     * @static
     * @type {Function}
     */
    outBack: function(t, s) {
        if (s === undefined) s = 1.70158;
        return ((--t)*t*((s+1)*t + s) + 1);
    },

    /**
     * @property inOutBack
     * @static
     * @type {Function}
     */
    inOutBack: function(t, s) {
        if (s === undefined) s = 1.70158;
        if ((t/=.5) < 1) return .5*(t*t*(((s*=(1.525))+1)*t - s));
        return .5*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2);
    },

    /**
     * @property inBounce
     * @static
     * @type {Function}
     */
    inBounce: function(t) {
        return 1.0 - Curves.outBounce(1.0-t);
    },

    /**
     * @property outBounce
     * @static
     * @type {Function}
     */
    outBounce: function(t) {
        if (t < (1/2.75)) {
            return (7.5625*t*t);
        } else if (t < (2/2.75)) {
            return (7.5625*(t-=(1.5/2.75))*t + .75);
        } else if (t < (2.5/2.75)) {
            return (7.5625*(t-=(2.25/2.75))*t + .9375);
        } else {
            return (7.5625*(t-=(2.625/2.75))*t + .984375);
        }
    },

    /**
     * @property inOutBounce
     * @static
     * @type {Function}
     */
    inOutBounce: function(t) {
        if (t < .5) return Curves.inBounce(t*2) * .5;
        return Curves.outBounce(t*2-1.0) * .5 + .5;
    },

    flat: function() {
        return 0;
    }
};

module.exports = Curves;

},{}],20:[function(require,module,exports){
/*jshint -W008 */

'use strict';

var _defaultCurves = {
    /**
     * @property linear
     * @static
     * @type {Function}
     */
    linear: function(t) {
        return t;
    },

    /**
     * @property easeIn
     * @static
     * @type {Function}
     */
    easeIn: function(t) {
        return t*t;
    },

    /**
     * @property easeOut
     * @static
     * @type {Function}
     */
    easeOut: function(t) {
        return t*(2-t);
    },

    /**
     * @property easeInOut
     * @static
     * @type {Function}
     */
    easeInOut: function(t) {
        if (t <= 0.5) return 2*t*t;
        else return -2*t*t + 4*t - 1;
    },

    /**
     * @property easeOutBounce
     * @static
     * @type {Function}
     */
    easeOutBounce: function(t) {
        return t*(3 - 2*t);
    },

    /**
     * @property spring
     * @static
     * @type {Function}
     */
    spring: function(t) {
        return (1 - t) * Math.sin(6 * Math.PI * t) + t;
    },

    /**
     * @property inQuad
     * @static
     * @type {Function}
     */
    inQuad: function(t) {
        return t*t;
    },

    /**
     * @property outQuad
     * @static
     * @type {Function}
     */
    outQuad: function(t) {
        return -(t-=1)*t+1;
    },

    /**
     * @property inOutQuad
     * @static
     * @type {Function}
     */
    inOutQuad: function(t) {
        if ((t/=.5) < 1) return .5*t*t;
        return -.5*((--t)*(t-2) - 1);
    },

    /**
     * @property inCubic
     * @static
     * @type {Function}
     */
    inCubic: function(t) {
        return t*t*t;
    },

    /**
     * @property outCubic
     * @static
     * @type {Function}
     */
    outCubic: function(t) {
        return ((--t)*t*t + 1);
    },

    /**
     * @property inOutCubic
     * @static
     * @type {Function}
     */
    inOutCubic: function(t) {
        if ((t/=.5) < 1) return .5*t*t*t;
        return .5*((t-=2)*t*t + 2);
    },

    /**
     * @property inQuart
     * @static
     * @type {Function}
     */
    inQuart: function(t) {
        return t*t*t*t;
    },

    /**
     * @property outQuart
     * @static
     * @type {Function}
     */
    outQuart: function(t) {
        return -((--t)*t*t*t - 1);
    },

    /**
     * @property inOutQuart
     * @static
     * @type {Function}
     */
    inOutQuart: function(t) {
        if ((t/=.5) < 1) return .5*t*t*t*t;
        return -.5 * ((t-=2)*t*t*t - 2);
    },

    /**
     * @property inQuint
     * @static
     * @type {Function}
     */
    inQuint: function(t) {
        return t*t*t*t*t;
    },

    /**
     * @property outQuint
     * @static
     * @type {Function}
     */
    outQuint: function(t) {
        return ((--t)*t*t*t*t + 1);
    },

    /**
     * @property inOutQuint
     * @static
     * @type {Function}
     */
    inOutQuint: function(t) {
        if ((t/=.5) < 1) return .5*t*t*t*t*t;
        return .5*((t-=2)*t*t*t*t + 2);
    },

    /**
     * @property inSine
     * @static
     * @type {Function}
     */
    inSine: function(t) {
        return -1.0*Math.cos(t * (Math.PI/2)) + 1.0;
    },

    /**
     * @property outSine
     * @static
     * @type {Function}
     */
    outSine: function(t) {
        return Math.sin(t * (Math.PI/2));
    },

    /**
     * @property inOutSine
     * @static
     * @type {Function}
     */
    inOutSine: function(t) {
        return -.5*(Math.cos(Math.PI*t) - 1);
    },

    /**
     * @property inExpo
     * @static
     * @type {Function}
     */
    inExpo: function(t) {
        return (t===0) ? 0.0 : Math.pow(2, 10 * (t - 1));
    },

    /**
     * @property outExpo
     * @static
     * @type {Function}
     */
    outExpo: function(t) {
        return (t===1.0) ? 1.0 : (-Math.pow(2, -10 * t) + 1);
    },

    /**
     * @property inOutExpo
     * @static
     * @type {Function}
     */
    inOutExpo: function(t) {
        if (t===0) return 0.0;
        if (t===1.0) return 1.0;
        if ((t/=.5) < 1) return .5 * Math.pow(2, 10 * (t - 1));
        return .5 * (-Math.pow(2, -10 * --t) + 2);
    },

    /**
     * @property inCirc
     * @static
     * @type {Function}
     */
    inCirc: function(t) {
        return -(Math.sqrt(1 - t*t) - 1);
    },

    /**
     * @property outCirc
     * @static
     * @type {Function}
     */
    outCirc: function(t) {
        return Math.sqrt(1 - (--t)*t);
    },

    /**
     * @property inOutCirc
     * @static
     * @type {Function}
     */
    inOutCirc: function(t) {
        if ((t/=.5) < 1) return -.5 * (Math.sqrt(1 - t*t) - 1);
        return .5 * (Math.sqrt(1 - (t-=2)*t) + 1);
    },

    /**
     * @property inElastic
     * @static
     * @type {Function}
     */
    inElastic: function(t) {
        var s=1.70158;var p=0;var a=1.0;
        if (t===0) return 0.0;  if (t===1) return 1.0;  if (!p) p=.3;
        s = p/(2*Math.PI) * Math.asin(1.0/a);
        return -(a*Math.pow(2,10*(t-=1)) * Math.sin((t-s)*(2*Math.PI)/ p));
    },

    /**
     * @property outElastic
     * @static
     * @type {Function}
     */
    outElastic: function(t) {
        var s=1.70158;var p=0;var a=1.0;
        if (t===0) return 0.0;  if (t===1) return 1.0;  if (!p) p=.3;
        s = p/(2*Math.PI) * Math.asin(1.0/a);
        return a*Math.pow(2,-10*t) * Math.sin((t-s)*(2*Math.PI)/p) + 1.0;
    },

    /**
     * @property inOutElastic
     * @static
     * @type {Function}
     */
    inOutElastic: function(t) {
        var s=1.70158;var p=0;var a=1.0;
        if (t===0) return 0.0;  if ((t/=.5)===2) return 1.0;  if (!p) p=(.3*1.5);
        s = p/(2*Math.PI) * Math.asin(1.0/a);
        if (t < 1) return -.5*(a*Math.pow(2,10*(t-=1)) * Math.sin((t-s)*(2*Math.PI)/p));
        return a*Math.pow(2,-10*(t-=1)) * Math.sin((t-s)*(2*Math.PI)/p)*.5 + 1.0;
    },

    /**
     * @property inBack
     * @static
     * @type {Function}
     */
    inBack: function(t, s) {
        if (s === undefined) s = 1.70158;
        return t*t*((s+1)*t - s);
    },

    /**
     * @property outBack
     * @static
     * @type {Function}
     */
    outBack: function(t, s) {
        if (s === undefined) s = 1.70158;
        return ((--t)*t*((s+1)*t + s) + 1);
    },

    /**
     * @property inOutBack
     * @static
     * @type {Function}
     */
    inOutBack: function(t, s) {
        if (s === undefined) s = 1.70158;
        if ((t/=.5) < 1) return .5*(t*t*(((s*=(1.525))+1)*t - s));
        return .5*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2);
    },

    /**
     * @property inBounce
     * @static
     * @type {Function}
     */
    inBounce: function(t) {
        return 1.0 - _defaultCurves.outBounce(1.0-t);
    },

    /**
     * @property outBounce
     * @static
     * @type {Function}
     */
    outBounce: function(t) {
        if (t < (1/2.75)) {
            return (7.5625*t*t);
        } else if (t < (2/2.75)) {
            return (7.5625*(t-=(1.5/2.75))*t + .75);
        } else if (t < (2.5/2.75)) {
            return (7.5625*(t-=(2.25/2.75))*t + .9375);
        } else {
            return (7.5625*(t-=(2.625/2.75))*t + .984375);
        }
    },

    /**
     * @property inOutBounce
     * @static
     * @type {Function}
     */
    inOutBounce: function(t) {
        if (t < .5) return _defaultCurves.inBounce(t*2) * .5;
        return _defaultCurves.outBounce(t*2-1.0) * .5 + .5;
    }
};

var _curves = Object.create(_defaultCurves);

/*
 * A library of curves which map an animation explicitly as a function of time.
 *    The following easing curves are available by default and can not be
 *    unregistered or overwritten:
 *
 *    linear,
 *    easeIn, easeOut, easeInOut,
 *    easeOutBounce,
 *    spring,
 *    inQuad, outQuad, inOutQuad,
 *    inCubic, outCubic, inOutCubic,
 *    inQuart, outQuart, inOutQuart,
 *    inQuint, outQuint, inOutQuint,
 *    inSine, outSine, inOutSine,
 *    inExpo, outExpo, inOutExpo,
 *    inCirc, outCirc, inOutCirc,
 *    inElastic, outElastic, inOutElastic,
 *    inBack, outBack, inOutBack,
 *    inBounce, outBounce, inOutBounce
 *
 * @class Easing
 * @deprecated Use curves instead
 */
var Easing = {
    /**
     * Registers a given curve to be available in subsequent transitions by
     *    adding it to the interal dictionary of registered curves.
     *
     * @method registerCurve
     * @chainable
     * @static
     *
     * @throws {Error} Will throw an error when attempting to overwrite default
     *    curve.
     * @throws {Error} Will throw an error if curve has already been registered.
     *
     * @param {String} name unique name for later access
     * @param {Function} curve function of one numeric variable mapping [0,1]
     *    to range inside [0,1]
     * @return {Easing} this
     */
    registerCurve: function(name, curve) {
        console.warn('Easing is deprecated! Use transitions.Curves instead!');
        if (_defaultCurves[name]) throw new Error('Default curves can not be overwritten');
        if (_curves[name]) throw new Error('Curve has already been registered');
        _curves[name] = curve;
        return this;
    },

    /**
     * Unregisters the curve registered under the given name by removing it from
     *    the internal dictionary of registered curves. This won't effect
     *    currently active transitions.
     *
     * @method unregisterCurve
     * @chainable
     * @static
     *
     * @throws {Error} Will throw an error if curve does not exist.
     * @param {String} name name of curve
     * @return {Easing} this
     */
    unregisterCurve: function(name) {
        console.warn('Easing is deprecated! Use transitions.Curves instead!');
        if (_defaultCurves[name]) throw new Error('Default curves can not be unregistered');
        if (!_curves[name]) throw new Error('Curve has not been registered');
        delete _curves[name];
        return this;
    },

    /**
     * Returns the easing curve with the given name.
     *
     * @method getCurve
     * @static
     *
     * @param {String} name name of curve
     * @return {Function} curve function of one numeric variable mapping [0,1]
     *    to range inside [0,1]
     */
    getCurve: function(name) {
        console.warn('Easing is deprecated! Use transitions.Curves instead!');
        return _curves[name];
    },

    /**
     * Retrieves the names of all previously registered easing curves.
     *
     * @method getCurves
     * @static
     *
     * @return {String[]} array of registered easing curves
     */
    getCurves: function() {
        console.warn('Easing is deprecated! Use transitions.Curves instead!');
        return Object.keys(_defaultCurves).concat(Object.keys(_curves));
    },

    createBezierCurve: function(v1, v2) {
        console.warn('Easing is deprecated! Use transitions.Curves instead!');
        v1 = v1 || 0; v2 = v2 || 0;
        return function(t) {
            return v1*t + (-2*v1 - v2 + 3)*t*t + (v1 + v2 - 2)*t*t*t;
        };
    }
};

module.exports = Easing;

},{}],21:[function(require,module,exports){
'use strict';

var Curves = require('./Curves');

/**
 * A state maintainer for a smooth transition between
 *    numerically-specified states. Example numeric states include floats and
 *    arrays of floats objects.
 *
 * An initial state is set with the constructor or using
 *     {@link Transitionable#from}. Subsequent transitions consist of an
 *     intermediate state, easing curve, duration and callback. The final state
 *     of each transition is the initial state of the subsequent one. Calls to
 *     {@link Transitionable#get} provide the interpolated state along the way.
 *
 * Note that there is no event loop here - calls to {@link Transitionable#get}
 *    are the only way to find state projected to the current (or provided)
 *    time and are the only way to trigger callbacks and mutate the internal
 *    transition queue.
 *
 * @example
 * var t = new Transitionable([0, 0]);
 * t
 *     .to([100, 0], 'linear', 1000)
 *     .delay(1000)
 *     .to([200, 0], 'outBounce', 1000);
 *
 * var div = document.createElement('div');
 * div.style.background = 'blue';
 * div.style.width = '100px';
 * div.style.height = '100px';
 * document.body.appendChild(div);
 *
 * div.addEventListener('click', function() {
 *     t.isPaused() ? t.resume() : t.pause();
 * });
 *
 * requestAnimationFrame(function loop() {
 *     div.style.transform = 'translateX(' + t.get()[0] + 'px)' + ' translateY(' + t.get()[1] + 'px)';
 *     requestAnimationFrame(loop);
 * });
 *
 * @class Transitionable
 * @constructor
 * @param {Number|Array.Number} initialState    initial state to transition
 *                                              from - equivalent to a pursuant
 *                                              invocation of
 *                                              {@link Transitionable#from}
 */
function Transitionable(initialState) {
    this._queue = [];
    this._multi = null;
    this._end = null;
    this._startedAt = null;
    this._pausedAt = null;
    if (initialState != null) this.from(initialState);
}

/**
 * Internal Clock used for determining the current time for the ongoing
 * transitions.
 *
 * @type {Performance|Date|Object}
 */
Transitionable.Clock = typeof performance !== 'undefined' ? performance : Date;

/**
 * Registers a transition to be pushed onto the internal queue.
 *
 * @method to
 * @chainable
 *
 * @param  {Number|Array.Number}    finalState              final state to
 *                                                          transiton to
 * @param  {String|Function}        [curve=Curves.linear]   easing function
 *                                                          used for
 *                                                          interpolating
 *                                                          [0, 1]
 * @param  {Number}                 [duration=100]          duration of
 *                                                          transition
 * @param  {Function}               [callback]              callback function
 *                                                          to be called after
 *                                                          the transition is
 *                                                          complete
 * @return {Transitionable}         this
 */
Transitionable.prototype.to = function to(finalState, curve, duration, callback) {
    curve = curve != null && curve.constructor === String ? Curves[curve] : curve;
    if (this._queue.length === 0) {
        this._startedAt = this.constructor.Clock.now();
        this._pausedAt = null;
    }
    this._queue.push(
        finalState,
        curve != null ? curve : Curves.linear,
        duration != null ? duration : 100,
        callback
    );
    return this;
};

/**
 * Resets the transition queue to a stable initial state.
 *
 * @method from
 * @chainable
 *
 * @param  {Number|Array.Number}    initialState    initial state to
 *                                                  transition from
 * @return {Transitionable}         this
 */
Transitionable.prototype.from = function from(initialState) {
    this._end = initialState;
    if (initialState.constructor === Array && this._multi != null && this._multi.constructor === Array) {
        this._multi.length = initialState.length;
    } else {
        this._multi = initialState.constructor === Array ? [] : false;
    }
    this._queue.length = 0;
    this._startedAt = this.constructor.Clock.now();
    this._pausedAt = null;
    return this;
};

/**
 * Delays the execution of the subsequent transition for a certain period of
 * time.
 *
 * @method delay
 * @chainable
 *
 * @param {Number}      duration    delay time in ms
 * @param {Function}    [callback]  Zero-argument function to call on observed
 *                                  completion (t=1)
 * @return {Transitionable}         this
 */
Transitionable.prototype.delay = function delay(duration, callback) {
    var endState = this._queue.length > 0 ? this._queue[this._queue.length - 4] : this._end;
    return this.to(endState, Curves.flat, duration, callback);
};

/**
 * Overrides current transition.
 *
 * @method override
 * @chainable
 *
 * @param  {Number|Array.Number}    [finalState]    final state to transiton to
 * @param  {String|Function}        [curve]         easing function used for
 *                                                  interpolating [0, 1]
 * @param  {Number}                 [duration]      duration of transition
 * @param  {Function}               [callback]      callback function to be
 *                                                  called after the transition
 *                                                  is complete
 * @return {Transitionable}         this
 */
Transitionable.prototype.override = function override(finalState, curve, duration, callback) {
    if (this._queue.length > 0) {
        if (finalState != null) this._queue[0] = finalState;
        if (curve != null)      this._queue[1] = curve.constructor === String ? Curves[curve] : curve;
        if (duration != null)   this._queue[2] = duration;
        if (callback != null)   this._queue[3] = callback;
    }
    return this;
};

Transitionable.prototype._interpolate = function _interpolate(from, to, progress) {
    if (this._multi) {
        for (var i = 0; i < to.length; i++) {
            this._multi[i] = from[i] + progress * (to[i] - from[i]);
        }
        return this._multi;
    } else {
        return from + progress * (to - from);
    }
};

/**
 * Get interpolated state of current action at provided time. If the last
 *    action has completed, invoke its callback.
 *
 * @method get
 *
 * @param {Number=} timestamp Evaluate the curve at a normalized version of this
 *    time. If omitted, use current time. (Unix epoch time)
 * @return {Number|Array.Number} beginning state
 *    interpolated to this point in time.
 */
Transitionable.prototype.get = function get(t) {
    t = this._pausedAt ? this._pausedAt : t;
    t = t ? t : this.constructor.Clock.now();
    if (this._queue.length === 0) return this._end;

    var progress = (t - this._startedAt) / this._queue[2];
    var state = this._interpolate(this._end, this._queue[0], this._queue[1](progress > 1 ? 1 : progress));
    if (progress >= 1) {
        this._startedAt = this._startedAt + this._queue[2];
        this._end = this._queue.shift();
        this._queue.shift();
        this._queue.shift();
        var callback = this._queue.shift();
        if (callback) callback();
    }
    return progress > 1 ? this.get() : state;
};

/**
 * Is there at least one transition pending completion?
 *
 * @method isActive
 *
 * @return {boolean}
 */
Transitionable.prototype.isActive = function isActive() {
    return this._queue.length > 0;
};

/**
 * Halt transition at current state and erase all pending actions.
 *
 * @method halt
 * @chainable
 *
 * @return {Transitionable} this
 */
Transitionable.prototype.halt = function halt() {
    return this.from(this.get());
};

/**
 * Pause transition. This will not erase any actions.
 *
 * @method pause
 * @chainable
 *
 * @return {Transitionable} this
 */
Transitionable.prototype.pause = function pause() {
    this._pausedAt = this.constructor.Clock.now();
    return this;
};

/**
 * Has the current action been paused?
 *
 * @method isPaused
 * @chainable
 *
 * @return {Boolean} if the current action has been paused
 */
Transitionable.prototype.isPaused = function isPaused() {
    return !!this._pausedAt;
};

/**
 * Resume transition.
 *
 * @method resume
 * @chainable
 *
 * @return {Transitionable} this
 */
Transitionable.prototype.resume = function resume() {
    var diff = this._pausedAt - this._startedAt;
    this._startedAt = this.constructor.Clock.now() - diff;
    this._pausedAt = null;
    return this;
};

/**
 * Cancel all transitions and reset to a stable state
 *
 * @method reset
 * @chainable
 * @deprecated Use `.from` instead!
 *
 * @param {Number|Array.Number|Object.<number, number>} startState
 *    stable state to set to
 */
Transitionable.prototype.reset = function(start) {
    return this.from(start);
};

/**
 * Add transition to end state to the queue of pending transitions. Special
 *    Use: calling without a transition resets the object to that state with
 *    no pending actions
 *
 * @method set
 * @chainable
 * @deprecated Use `.to` instead!
 *
 * @param {Number|FamousMatrix|Array.Number|Object.<number, number>} endState
 *    end state to which we interpolate
 * @param {transition=} transition object of type {duration: number, curve:
 *    f[0,1] -> [0,1] or name}. If transition is omitted, change will be
 *    instantaneous.
 * @param {function()=} callback Zero-argument function to call on observed
 *    completion (t=1)
 */
Transitionable.prototype.set = function(state, transition, callback) {
    if (transition == null) {
        this.from(state);
        if (callback) callback();
    } else {
        this.to(state, transition.curve, transition.duration, callback);
    }
    return this;
};

module.exports = Transitionable;

},{"./Curves":19}],22:[function(require,module,exports){
'use strict';

/**
 * Return wrapper around callback function. Once the wrapper is called N
 *   times, invoke the callback function. Arguments and scope preserved.
 *
 * @method after
 * @deprecated
 *
 * @param {number} count number of calls before callback function invoked
 * @param {Function} callback wrapped callback function
 *
 * @return {function} wrapped callback with coundown feature
 */
var after = function after(count, callback) {
    console.warn('transitions.after is deprecated!');
    var counter = count;
    return function() {
        counter--;
        if (counter === 0) callback.apply(this, arguments);
    };
};

module.exports = after;

},{}],23:[function(require,module,exports){
'use strict';

module.exports = {
    after: require('./after'),
    Easing: require('./Easing'),
    Curves: require('./Curves'),
    Transitionable: require('./Transitionable')
};

},{"./Curves":19,"./Easing":20,"./Transitionable":21,"./after":22}],24:[function(require,module,exports){
'use strict';

/**
 * A lightweight, featureless EventEmitter.
 * 
 * @class CallbackStore
 * @constructor
 */
function CallbackStore () {
    this._events = {};
}

/**
 * Adds a listener for the specified event (= key).
 *
 * @method on
 * @chainable
 * 
 * @param  {String}   key
 * @param  {Function} callback
 * @return {Function} A function to call if you want to remove the callback
 */
CallbackStore.prototype.on = function on (key, callback) {
    if (!this._events[key]) this._events[key] = [];
    var callbackList = this._events[key];
    callbackList.push(callback);
    return function () {
        callbackList.splice(callbackList.indexOf(callback), 1);
    }
};

/**
 * Removes a previously added event listener.
 *
 * @method off
 * @chainable
 * 
 * @param  {String}          key
 * @param  {Function}        callback
 * @return {CallbackStore}   this
 */
CallbackStore.prototype.off = function off (key, callback) {
    var events = this._events[key];
    if (events) events.splice(events.indexOf(callback), 1);
    return this;
};

/**
 * Invokes all the previously for this key registered callbacks.
 *
 * @method trigger
 * @chainable
 * 
 * @param  {String}        key
 * @param  {Object}        payload
 * @return {CallbackStore} this
 */
CallbackStore.prototype.trigger = function trigger (key, payload) {
    var events = this._events[key];
    if (events) {
        var i = 0;
        var len = events.length;
        for (; i < len ; i++) events[i](payload);
    }
    return this;
};

module.exports = CallbackStore;

},{}],25:[function(require,module,exports){
'use strict';

var Transitionable = require('famous-transitions').Transitionable;

/**
 * @class Color
 * @constructor
 * @component
 * @param {Color|String|Array} Optional argument for setting color using
 * Hex, a Color instance, color name or RGB
 * @param {Object} Optional transition
 * @param {Function} Callback
 */
function Color(color, transition, cb) {
    this._r = new Transitionable(0);
    this._g = new Transitionable(0);
    this._b = new Transitionable(0);
    if (color) this.set(color, transition, cb);
};

/**
* Returns the definition of the Class: 'Color'
* @method toString
* @return {String} definition
*/
Color.toString = function toString() {
    return 'Color';
};

/**
* Sets the color. It accepts an optional transition parameter and callback.
* set(Color, transition, callback)
* set('#000000', transition, callback)
* set('black', transition, callback)
* set([r, g, b], transition, callback)
* @method set
 * @param {Color|String|Array} Optional argument for setting color using
 * Hex, a Color instance, color name or RGB
 * @param {Object} Optional transition
 * @param {Function} Callback
* @chainable
*/
Color.prototype.set = function set(color, transition, cb) {
    switch (Color.determineType(color)) {
        case 'hex': return this.setHex(color, transition, cb);
        case 'colorName': return this.setColor(color, transition, cb);
        case 'instance': return this.changeTo(color, transition, cb);
        case 'rgb': return this.setRGB(color[0], color[1], color[2], transition, cb);
    }
};

/**
 * Returns whether Color is still in an animating (transitioning) state.
 *
 * @method isActive
 * @returns {Boolean} boolean
 */
Color.prototype.isActive = function isActive() {
    return this._r.isActive() || this._g.isActive() || this._b.isActive();
};

/**
 * Halt transition at current state and erase all pending actions.
 *
 * @method halt
 * @chainable
 *
 * @return {Color} this
 */
Color.prototype.halt = function halt() {
    this._r.halt();
    this._g.halt();
    this._b.halt();
    return this;
};

/**
 * Sets the color values from another Color instance.
 *
 * @method changeTo
 * @param {Color} Color instance
 * @param {Object} transition Optional transition
 * @param {Function} callback Optional
 * @chainable
 */
Color.prototype.changeTo = function changeTo(color, transition, cb) {
    if (Color.isColorInstance(color)) {
        var rgb = color.getRGB();
        this.setRGB(rgb[0], rgb[1], rgb[2], transition, cb);
    }
    return this;
};

/**
 * Sets the color based on static color names.
 *
 * @method setColor
 * @param {String} Color name
 * @param {Object} transition Optional transition parameters
 * @param {Function} callback Optional
 * @chainable
 */
Color.prototype.setColor = function setColor(name, transition, cb) {
    if (colorNames[name]) {
        this.setHex(colorNames[name], transition, cb);
    }
    return this;
};

/**
 * Returns the color in either RGB or with the requested format.
 *
 * @method getColor
 * @param {String} Optional argument for determining which type of color to get (default is RGB)
 * @returns Color in either RGB or specific option value
 */
Color.prototype.getColor = function getColor(option) {
    if (Color.isString(option)) option = option.toLowerCase();
    return (option === 'hex') ? this.getHex() : this.getRGB();
};

/**
 * Sets the R of the Color's RGB
 *
 * @method setR
 * @param {Integer} R channel of color
 * @param {Object} transition Optional transition parameters
 * @param {Function} callback Optional
 * @chainable
 */
Color.prototype.setR = function setR(r, transition, cb) {
    this._r.set(r, transition, cb);
    return this;
};

/**
 * Sets the G of the Color's RGB
 *
 * @method setG
 * @param {Integer} G channel of color
 * @param {Object} transition Optional transition parameters
 * @param {Function} callback Optional
 * @chainable
 */
Color.prototype.setG = function setG(g, transition, cb) {
    this._g.set(g, transition, cb);
    return this;
};

/**
 * Sets the B of the Color's RGB
 *
 * @method setB
 * @param {Integer} B channel of color
 * @param {Object} transition Optional transition parameters
 * @param {Function} callback Optional
 * @chainable
 */
Color.prototype.setB = function setB(b, transition, cb) {
    this._b.set(b, transition, cb);
    return this;
};

/**
 * Sets RGB
 *
 * @method setRGB
 * @param {Integer} R channel of color
 * @param {Integer} G channel of color
 * @param {Integer} B channel of color
 * @param {Object} transition Optional transition parameters
 * @param {Function} callback Optional
 * @chainable
 */
Color.prototype.setRGB = function setRGB(r, g, b, transition, cb) {
    this.setR(r, transition);
    this.setG(g, transition);
    this.setB(b, transition, cb);
    return this;
};

/**
 * Returns R of RGB
 *
 * @method getR
 * @returns R of Color
 */
Color.prototype.getR = function getR() {
    return this._r.get();
};

/**
 * Returns G of RGB
 *
 * @method getG
 * @returns G of Color
 */
Color.prototype.getG = function getG() {
    return this._g.get();
};

/**
 * Returns B of RGB
 *
 * @method getB
 * @returns B of Color
 */
Color.prototype.getB = function getB() {
    return this._b.get();
};

/**
 * Returns RGB
 *
 * @method getRGB
 * @returns RGB
 */
Color.prototype.getRGB = function getRGB() {
    return [this.getR(), this.getG(), this.getB()];
};

/**
 * Returns Normalized RGB
 *
 * @method getNormalizedRGB
 * @returns Normalized RGB
 */
Color.prototype.getNormalizedRGB = function getNormalizedRGB() {
    var r = this.getR() / 255.0;
    var g = this.getG() / 255.0;
    var b = this.getB() / 255.0;
    return [r, g, b];
};

/**
 * Returns the current color in Hex
 *
 * @method getHex
 * @returns Hex value
 */
Color.prototype.getHex = function getHex() {
    var r = Color.toHex(this.getR());
    var g = Color.toHex(this.getG());
    var b = Color.toHex(this.getB());
    return '#' + r + g + b;
};

/**
 * Sets color using Hex
 *
 * @method setHex
 * @param {String} Hex value
 * @param {Object} transition Optional transition parameters
 * @param {Function} callback Optional
 * @chainable
 */
Color.prototype.setHex = function setHex(hex, transition, cb) {
    hex = (hex.charAt(0) === '#') ? hex.substring(1, hex.length) : hex;

    if (hex.length === 3) {
        var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hex = hex.replace(shorthandRegex, function(m, r, g, b) {
            return r + r + g + g + b + b;
        });
    }

    var r = parseInt(hex.substring(0, 2), 16);
    var g = parseInt(hex.substring(2, 4), 16);
    var b = parseInt(hex.substring(4, 6), 16);
    this.setRGB(r, g, b, transition, cb);
    return this;
};

/**
 * Converts a number to a hex value
 *
 * @method toHex
 * @param {Integer} Number
 * @returns Hex value
 */
Color.toHex = function toHex(num) {
    var hex = num.toString(16);
    return hex.length === 1 ? '0' + hex : hex;
};

/**
 * Determines the given input with the appropriate configuration
 *
 * @method determineType
 * @param {Color|String|Array} Color type
 * @returns {String} Appropriate color type
 */
Color.determineType = function determineType(type) {
    if (Color.isColorInstance(type)) return 'instance';
    if (colorNames[type]) return 'colorName';
    if (Color.isHex(type)) return 'hex';
    if (Array.isArray(type)) return 'rgb';
};

/**
 * Returns a boolean checking whether input is a 'String'
 *
 * @method isString
 * @param Primitive
 * @returns {Boolean} Boolean
 */
Color.isString = function isString(val) {
    return (typeof val === 'string');
};

/**
 * Returns a boolean checking whether string input has a hash (#) symbol
 *
 * @method isHex
 * @param String
 * @returns {Boolean} Boolean
 */
Color.isHex = function isHex(val) {
    if (!Color.isString(val)) return false;
    return val[0] === '#';
};

/**
 * Returns boolean whether the input is a Color instance
 *
 * @method isColorInstance
 * @param Color instance
 * @returns {Boolean} Boolean
 */
Color.isColorInstance = function isColorInstance(val) {
    return !!val.getColor;
};

/**
 * Common color names with their associated Hex values
 */
var colorNames = { aliceblue: '#f0f8ff', antiquewhite: '#faebd7', aqua: '#00ffff', aquamarine: '#7fffd4', azure: '#f0ffff', beige: '#f5f5dc', bisque: '#ffe4c4', black: '#000000', blanchedalmond: '#ffebcd', blue: '#0000ff', blueviolet: '#8a2be2', brown: '#a52a2a', burlywood: '#deb887', cadetblue: '#5f9ea0', chartreuse: '#7fff00', chocolate: '#d2691e', coral: '#ff7f50', cornflowerblue: '#6495ed', cornsilk: '#fff8dc', crimson: '#dc143c', cyan: '#00ffff', darkblue: '#00008b', darkcyan: '#008b8b', darkgoldenrod: '#b8860b', darkgray: '#a9a9a9', darkgreen: '#006400', darkgrey: '#a9a9a9', darkkhaki: '#bdb76b', darkmagenta: '#8b008b', darkolivegreen: '#556b2f', darkorange: '#ff8c00', darkorchid: '#9932cc', darkred: '#8b0000', darksalmon: '#e9967a', darkseagreen: '#8fbc8f', darkslateblue: '#483d8b', darkslategray: '#2f4f4f', darkslategrey: '#2f4f4f', darkturquoise: '#00ced1', darkviolet: '#9400d3', deeppink: '#ff1493', deepskyblue: '#00bfff', dimgray: '#696969', dimgrey: '#696969', dodgerblue: '#1e90ff', firebrick: '#b22222', floralwhite: '#fffaf0', forestgreen: '#228b22', fuchsia: '#ff00ff', gainsboro: '#dcdcdc', ghostwhite: '#f8f8ff', gold: '#ffd700', goldenrod: '#daa520', gray: '#808080', green: '#008000', greenyellow: '#adff2f', grey: '#808080', honeydew: '#f0fff0', hotpink: '#ff69b4', indianred: '#cd5c5c', indigo: '#4b0082', ivory: '#fffff0', khaki: '#f0e68c', lavender: '#e6e6fa', lavenderblush: '#fff0f5', lawngreen: '#7cfc00', lemonchiffon: '#fffacd', lightblue: '#add8e6', lightcoral: '#f08080', lightcyan: '#e0ffff', lightgoldenrodyellow: '#fafad2', lightgray: '#d3d3d3', lightgreen: '#90ee90', lightgrey: '#d3d3d3', lightpink: '#ffb6c1', lightsalmon: '#ffa07a', lightseagreen: '#20b2aa', lightskyblue: '#87cefa', lightslategray: '#778899', lightslategrey: '#778899', lightsteelblue: '#b0c4de', lightyellow: '#ffffe0', lime: '#00ff00', limegreen: '#32cd32', linen: '#faf0e6', magenta: '#ff00ff', maroon: '#800000', mediumaquamarine: '#66cdaa', mediumblue: '#0000cd', mediumorchid: '#ba55d3', mediumpurple: '#9370db', mediumseagreen: '#3cb371', mediumslateblue: '#7b68ee', mediumspringgreen: '#00fa9a', mediumturquoise: '#48d1cc', mediumvioletred: '#c71585', midnightblue: '#191970', mintcream: '#f5fffa', mistyrose: '#ffe4e1', moccasin: '#ffe4b5', navajowhite: '#ffdead', navy: '#000080', oldlace: '#fdf5e6', olive: '#808000', olivedrab: '#6b8e23', orange: '#ffa500', orangered: '#ff4500', orchid: '#da70d6', palegoldenrod: '#eee8aa', palegreen: '#98fb98', paleturquoise: '#afeeee', palevioletred: '#db7093', papayawhip: '#ffefd5', peachpuff: '#ffdab9', peru: '#cd853f', pink: '#ffc0cb', plum: '#dda0dd', powderblue: '#b0e0e6', purple: '#800080', rebeccapurple: '#663399', red: '#ff0000', rosybrown: '#bc8f8f', royalblue: '#4169e1', saddlebrown: '#8b4513', salmon: '#fa8072', sandybrown: '#f4a460', seagreen: '#2e8b57', seashell: '#fff5ee', sienna: '#a0522d', silver: '#c0c0c0', skyblue: '#87ceeb', slateblue: '#6a5acd', slategray: '#708090', slategrey: '#708090', snow: '#fffafa', springgreen: '#00ff7f', steelblue: '#4682b4', tan: '#d2b48c', teal: '#008080', thistle: '#d8bfd8', tomato: '#ff6347', turquoise: '#40e0d0', violet: '#ee82ee', wheat: '#f5deb3', white: '#ffffff', whitesmoke: '#f5f5f5', yellow: '#ffff00', yellowgreen: '#9acd32' };

module.exports = Color;

},{"famous-transitions":23}],26:[function(require,module,exports){
'use strict';

/**
 * Collection to map keyboard codes in plain english
 *
 * @class KeyCodes
 * @static
 */
module.exports = {
    0: 48,
    1: 49,
    2: 50,
    3: 51,
    4: 52,
    5: 53,
    6: 54,
    7: 55,
    8: 56,
    9: 57,
    a: 97,
    b: 98,
    c: 99,
    d: 100,
    e: 101,
    f: 102,
    g: 103,
    h: 104,
    i: 105,
    j: 106,
    k: 107,
    l: 108,
    m: 109,
    n: 110,
    o: 111,
    p: 112,
    q: 113,
    r: 114,
    s: 115,
    t: 116,
    u: 117,
    v: 118,
    w: 119,
    x: 120,
    y: 121,
    z: 122,
    A: 65,
    B: 66,
    C: 67,
    D: 68,
    E: 69,
    F: 70,
    G: 71,
    H: 72,
    I: 73,
    J: 74,
    K: 75,
    L: 76,
    M: 77,
    N: 78,
    O: 79,
    P: 80,
    Q: 81,
    R: 82,
    S: 83,
    T: 84,
    U: 85,
    V: 86,
    W: 87,
    X: 88,
    Y: 89,
    Z: 90,
    ENTER : 13,
    LEFT_ARROW: 37,
    RIGHT_ARROW: 39,
    UP_ARROW: 38,
    DOWN_ARROW: 40,
    SPACE: 32,
    SHIFT: 16,
    TAB: 9
};


},{}],27:[function(require,module,exports){
'use strict';

function MethodStore () {
    this._events = {};
}

MethodStore.prototype.on = function on (key, cbclass, cbname) {
    var events = this._events[key];
    if (!events) events = [];
    events.push(cbclass, cbname);
    return this;
}

MethodStore.prototype.off = function off (key, cbclass) {
    var events = this._events[key];
    if (events) {
        var index = events.indexOf(cbclass);
        if (index > -1) events.splice(index, 2);
    }
    return this;
}

MethodStore.prototype.trigger = function trigger (key, payload) {
    var events = this._events[key];
    if (events) {
        var i = 0;
        var len = events.length;
        for (; i < len ; i += 2) events[i][events[i + 1]](payload);
    }
    return this;
};

module.exports = MethodStore;

},{}],28:[function(require,module,exports){
'use strict';

/**
 * Singleton object to manage recycling of objects with typically short lifespans, used to cut down on the
 * amount of garbage collection required.
 *
 * @singleton
 */
var ObjectManager = {};

ObjectManager.pools = {};

/**
 * Register request and free functions for the given type.
 *
 * @method register
 * @param {String} type
 * @param {Function} Constructor
 */
ObjectManager.register = function(type, Constructor) {
    var pool = this.pools[type] = [];

    this['request' + type] = _request(pool, Constructor);
    this['free' + type] = _free(pool);
};

function _request(pool, Constructor) {
    return function request() {
        if (pool.length !== 0) return pool.pop();
        else return new Constructor();
    }
}

function _free(pool) {
    return function free(obj) {
        pool.push(obj);
    }
}

/**
 * Untrack all object of the given type. Used to allow allocated objects to be garbage collected.
 *
 * @method disposeOf
 * @param {String}
 */
ObjectManager.disposeOf= function(type) {
    var pool = this.pools[type];
    var i = pool.length;
    while (i--) pool.pop();
};

module.exports = ObjectManager;

},{}],29:[function(require,module,exports){
'use strict';

/**
 *  Deep clone an object.
 *  @memberof Utilities
 *  @param b {Object} Object to clone
 *  @return a {Object} Cloned object.
 */
var clone = function clone(b) {
    var a;
    if (typeof b === 'object') {
        a = (b instanceof Array) ? [] : {};
        for (var key in b) {
            if (typeof b[key] === 'object' && b[key] !== null) {
                if (b[key] instanceof Array) {
                    a[key] = new Array(b[key].length);
                    for (var i = 0; i < b[key].length; i++) {
                        a[key][i] = clone(b[key][i]);
                    }
                }
                else {
                  a[key] = clone(b[key]);
                }
            }
            else {
                a[key] = b[key];
            }
        }
    }
    else {
        a = b;
    }
    return a;
};

module.exports = clone;

},{}],30:[function(require,module,exports){
'use strict';

/**
 * Flat clone an object.
 * @memberof Utilities
 * @param {Object} obj - Object to clone
 * @return {Object} Cloned object
 */
function flatClone(obj) {
    var clone = {};
    for (var key in obj) clone[key] = obj[key];
    return clone;
}

module.exports = flatClone;

},{}],31:[function(require,module,exports){
'use strict';

module.exports = {
    CallbackStore: require('./CallbackStore'),
    clone: require('./clone'),
    flatClone: require('./flatClone'),
    KeyCodes: require('./KeyCodes'),
    loadURL: require('./loadURL'),
    MethodStore: require('./MethodStore'),
    ObjectManager: require('./ObjectManager'),
    Color: require('./Color'),
    strip: require('./strip'),
    keyValueToArrays: require('./keyValueToArrays')
};


},{"./CallbackStore":24,"./Color":25,"./KeyCodes":26,"./MethodStore":27,"./ObjectManager":28,"./clone":29,"./flatClone":30,"./keyValueToArrays":32,"./loadURL":33,"./strip":34}],32:[function(require,module,exports){
/**
 * Takes an object containing keys and values and returns an object
 * comprising two "associate" arrays, one with the keys and the other
 * with the values.
 *
 * @method keyValuesToArrays
 *
 * @param {Object} Object
 * @returns {Object} Object Object containing two arrays, one with the keys and the other for values
 */
module.exports = function keyValuesToArrays(obj) {
    var keysArray = [], valuesArray = [];
    var i = 0;
    for(var key in obj) {
        if (obj.hasOwnProperty(key)) {
            keysArray[i] = key;
            valuesArray[i] = obj[key];
            i++;
        }
    }
    return {
        keys: keysArray,
        values: valuesArray
    };
};

},{}],33:[function(require,module,exports){
'use strict';

/**
 * Load a URL and return its contents in a callback
 *
 * @method loadURL
 * @memberof Utilities
 * @param {string} url URL of object
 * @param {function} callback callback to dispatch with content
 */
var loadURL = function loadURL(url, callback) {
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function onreadystatechange() {
        if (this.readyState === 4) {
            if (callback) callback(this.responseText);
        }
    };
    xhr.open('GET', url);
    xhr.send();
};

module.exports = loadURL;

},{}],34:[function(require,module,exports){
'use strict';

/**
 * Removes all values not being of a primitive type from an arbitrary object
 * literal.
 *
 * @method strip
 * @memberof Utilities
 * @param  {any}        primitive or (non-)serializable object without
 *                      circular references
 * @return {any}        primitive or (nested) object only containing primitive
 *                      types (serializable)
 */
function strip(obj) {
    switch (obj) {
        case null:
        case undefined:
            return obj;
    }
    switch (obj.constructor) {
        case Boolean:
        case Number:
        case String:
        case Symbol:
            return obj;
        case Object:
            for (var key in obj) {
                var stripped = strip(obj[key], true);
                obj[key] = stripped;
            }
            return obj;
        default:
            return null;
    }
}

module.exports = strip;

},{}],35:[function(require,module,exports){
'use strict';

var Position = require('./Position');

/**
 * @class Align
 * @constructor
 * @component
 * @param {LocalDispatch} node LocalDispatch to be retrieved from corresponding Render Node of the Align component
 */

function Align(node) {
    Position.call(this, node);

    var initial = node.getAlign();

    this._x.set(initial[0]);
    this._y.set(initial[1]);
    this._z.set(initial[2]);
}

/**
*
* stringifies Align
*
* @method
* @return {String} the name of the Component Class: 'Align'
*/
Align.toString = function toString() {
    return Align.toString;
};

Align.prototype = Object.create(Position.prototype);
Align.prototype.constructor = Align;

Align.prototype.update = function update() {
    this._node.setAlign(this._x.get(), this._y.get(), this._z.get());
    this._checkUpdate();
};

Align.prototype.onUpdate = Align.prototype.update;

module.exports = Align;

},{"./Position":43}],36:[function(require,module,exports){
'use strict';

/**
 * @class Camera
 * @constructor
 * @component
 * @param {RenderNode} RenderNode to which the instance of Camera will be a component of
 */
function Camera(node) {
    this._node = node;
    this._projectionType = Camera.ORTHOGRAPHIC_PROJECTION;
    this._focalDepth = 0;
    this._near = 0;
    this._far = 0;
    this._requestingUpdate = false;
    this._id = node.addComponent(this);
    this._viewTransform = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
    this._viewDirty = false;
    this._perspectiveDirty = false;
    this.setFlat();
}

Camera.FRUSTUM_PROJECTION = 0;
Camera.PINHOLE_PROJECTION = 1;
Camera.ORTHOGRAPHIC_PROJECTION = 2;

// Return the name of the Element Class: 'Camera'
Camera.toString = function toString() {
    return 'Camera';
};

Camera.prototype.getValue = function getValue() {
    return {
        component: this.constructor.toString(),
        projectionType: this._projectionType,
        focalDepth: this._focalDepth,
        near: this._near,
        far: this._far
    };
};

Camera.prototype.setValue = function setValue(state) {
    if (state.component === this.constructor.toString()) {
        this.set(state.projectionType, state.focalDepth, state.near, state.far);
        return true;
    }
    return false;
};

Camera.prototype.set = function set(type, depth, near, far) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }
    this._projectionType = type;
    this._focalDepth = depth;
    this._near = near;
    this._far = far;
};

Camera.prototype.setDepth = function setDepth(depth) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }
    this._perspectiveDirty = true;
    this._projectionType = Camera.PINHOLE_PROJECTION;
    this._focalDepth = depth;
    this._near = 0;
    this._far = 0;

    return this;
};

Camera.prototype.setFrustum = function setFrustum(near, far) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }
    this._perspectiveDirty = true;
    this._projectionType = Camera.FRUSTUM_PROJECTION;
    this._focalDepth = 0;
    this._near = near;
    this._far = far;

    return this;
};

Camera.prototype.setFlat = function setFlat() {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }
    this._perspectiveDirty = true;
    this._projectionType = Camera.ORTHOGRAPHIC_PROJECTION;
    this._focalDepth = 0;
    this._near = 0;
    this._far = 0;

    return this;
};

Camera.prototype.onUpdate = function onUpdate() {
    this._requestingUpdate = false;

    var path = this._node.getLocation();

    this._node
        .sendDrawCommand('WITH')
        .sendDrawCommand(path);

    if (this._perspectiveDirty) {
        this._perspectiveDirty = false;

        switch (this._projectionType) {
            case Camera.FRUSTUM_PROJECTION:
                this._node.sendDrawCommand('FRUSTUM_PROJECTION');
                this._node.sendDrawCommand(this._near);
                this._node.sendDrawCommand(this._far);
                break;
            case Camera.PINHOLE_PROJECTION:
                this._node.sendDrawCommand('PINHOLE_PROJECTION');
                this._node.sendDrawCommand(this._focalDepth);
                break;
            case Camera.ORTHOGRAPHIC_PROJECTION:
                this._node.sendDrawCommand('ORTHOGRAPHIC_PROJECTION');
                break;
        }
    }

    if (this._viewDirty) {
        this._viewDirty = false;

        this._node.sendDrawCommand('CHANGE_VIEW_TRANSFORM');
        this._node.sendDrawCommand(this._viewTransform[0]);
        this._node.sendDrawCommand(this._viewTransform[1]);
        this._node.sendDrawCommand(this._viewTransform[2]);
        this._node.sendDrawCommand(this._viewTransform[3]);

        this._node.sendDrawCommand(this._viewTransform[4]);
        this._node.sendDrawCommand(this._viewTransform[5]);
        this._node.sendDrawCommand(this._viewTransform[6]);
        this._node.sendDrawCommand(this._viewTransform[7]);

        this._node.sendDrawCommand(this._viewTransform[8]);
        this._node.sendDrawCommand(this._viewTransform[9]);
        this._node.sendDrawCommand(this._viewTransform[10]);
        this._node.sendDrawCommand(this._viewTransform[11]);

        this._node.sendDrawCommand(this._viewTransform[12]);
        this._node.sendDrawCommand(this._viewTransform[13]);
        this._node.sendDrawCommand(this._viewTransform[14]);
        this._node.sendDrawCommand(this._viewTransform[15]);
    }
};


Camera.prototype.onTransformChange = function onTransformChange(transform) {
    var a = transform;
    this._viewDirty = true;

    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }

    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
    a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
    a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
    a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

    b00 = a00 * a11 - a01 * a10,
    b01 = a00 * a12 - a02 * a10,
    b02 = a00 * a13 - a03 * a10,
    b03 = a01 * a12 - a02 * a11,
    b04 = a01 * a13 - a03 * a11,
    b05 = a02 * a13 - a03 * a12,
    b06 = a20 * a31 - a21 * a30,
    b07 = a20 * a32 - a22 * a30,
    b08 = a20 * a33 - a23 * a30,
    b09 = a21 * a32 - a22 * a31,
    b10 = a21 * a33 - a23 * a31,
    b11 = a22 * a33 - a23 * a32,

    det = 1/(b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06);

    this._viewTransform[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    this._viewTransform[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    this._viewTransform[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    this._viewTransform[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    this._viewTransform[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    this._viewTransform[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    this._viewTransform[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    this._viewTransform[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    this._viewTransform[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    this._viewTransform[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    this._viewTransform[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    this._viewTransform[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    this._viewTransform[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    this._viewTransform[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    this._viewTransform[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    this._viewTransform[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
};

module.exports = Camera;

},{}],37:[function(require,module,exports){
'use strict';

/**
 * Component to manage general event emission.
 *
 * @class EventEmitter
 * @param {Node} node The node to send events through.
 */
function EventEmitter(node) {
    this.node = node;
}

/**
 * Returns the name of EventEmitter as a string.
 *
 * @method toString
 * @static
 * @return {String} 'EventEmitter'
 */
EventEmitter.toString = function toString() {
    return 'EventEmitter';
};

/**
 * Emit an event with a payload.
 *
 * @method emit
 * @param {Object} event The event name.
 * @param {Object} payload The event payload.
 */
EventEmitter.prototype.emit = function emit(event, payload) {
    this.node.emit(event, payload);
    return this;
};

module.exports = EventEmitter;

},{}],38:[function(require,module,exports){
'use strict';

var CallbackStore = require('famous-utilities').CallbackStore;

/**
 * Component to handle general events.
 *
 * @class EventHandler
 * @param {Node} node The node on which this component is registered.
 */
function EventHandler (node) {
    this.node = node;
    this.id = node.addComponent(this);
    this._events = new CallbackStore();
}

/**
 * Returns the name of EventHandler as a string.
 *
 * @method toString
 * @static
 * @return {String} 'EventHandler'
 */
EventHandler.toString = function toString() {
    return 'EventHandler';
};

/**
 * Register a callback to be invoked on an event.
 *
 * @method on
 * @param {String} ev The event name.
 * @param {Function} cb The callback.
 */
EventHandler.prototype.on = function on (ev, cb) {
    this._events.on(ev, cb);
};

/**
 * Deregister a callback from an event.
 *
 * @method on
 * @param {String} ev The event name.
 * @param {Function} cb The callback.
 */
EventHandler.prototype.off = function off (ev, cb) {
    this._events.off(ev, cb);
};

/**
 * Trigger the callback associated with an event, passing in a payload.
 *
 * @method trigger
 * @param {String} ev The event name.
 * @param {Object} payload The event payload.
 */
EventHandler.prototype.trigger = function trigger (ev, payload) {
    this._events.trigger(ev, payload);
};

EventHandler.prototype.onReceive = EventHandler.prototype.trigger;

module.exports = EventHandler;

},{"famous-utilities":31}],39:[function(require,module,exports){
'use strict';

var CallbackStore = require('famous-utilities').CallbackStore;
var Vec2 = require('famous-math').Vec2;

var VEC_REGISTER = new Vec2();

var gestures = {drag: true, tap: true, rotate: true, pinch: true};

/**
 * Component to manage gesture events. Will track 'pinch', 'rotate', 'tap', and 'drag' events, on an
 * as-requested basis.
 *
 * @class GestureHandler
 * @param {LocalDispatch} node The node with which to register the handler.
 * @param {Object[]} events An array of event objects specifying .event and .callback properties.
 */

function GestureHandler (node, events) {
    this.node = node;
    this.id = node.addComponent(this);

    this._events = new CallbackStore();

    this.last1 = new Vec2();
    this.last2 = new Vec2();

    this.delta1 = new Vec2();
    this.delta2 = new Vec2();

    this.velocity1 = new Vec2();
    this.velocity2 = new Vec2();

    this.dist = 0;
    this.diff12 = new Vec2();

    this.center = new Vec2();
    this.centerDelta = new Vec2();
    this.centerVelocity = new Vec2();

    this.pointer1 = {
        position: this.last1,
        delta: this.delta1,
        velocity: this.velocity1,
    };

    this.pointer2 = {
        position: this.last2,
        delta: this.delta2,
        velocity: this.velocity2,
    };

    this.event = {
        status: null,
        time: 0,
        pointers: [],
        center: this.center,
        centerDelta: this.centerDelta,
        centerVelocity: this.centerVelocity,
        points: 0,
        current: 0
    };

    this.trackedPointerIDs = [-1, -1];
    this.timeOfPointer = 0;
    this.multiTap = 0;

    this.mice = [];

    this.gestures = [];
    this.options = {};
    this.trackedGestures = {};

    var i;
    var len;

    if (events) {
        for (i = 0, len = events.length; i < len; i++) {
            this.on(events[i], events[i].callback);
        }
    }

    node.addUIEvent('touchstart');
    node.addUIEvent('mousedown');
    node.addUIEvent('touchmove');
    node.addUIEvent('mousemove');
    node.addUIEvent('touchend');
    node.addUIEvent('mouseup');
    node.addUIEvent('mouseleave');
}

GestureHandler.prototype.onReceive = function onReceive (ev, payload) {
    switch(ev) {
        case 'touchstart':
        case 'mousedown':
            _processPointerStart.call(this, payload);
            break;
        case 'touchmove':
        case 'mousemove':
            _processPointerMove.call(this, payload);
            break;
        case 'touchend':
        case 'mouseup':
            _processPointerEnd.call(this, payload);
            break;
        case 'mouseleave':
            _processMouseLeave.call(this, payload);
            break;
        default:
            break;
    }
};

/**
 * Returns the name of GestureHandler as a string.
 *
 * @method toString
 * @static
 * @return {String} 'GestureHandler'
 */
GestureHandler.toString = function toString() {
    return 'GestureHandler';
};

/**
 * Register a callback to be invoked on an event.
 *
 * @method on
 * @param {Object|String} ev The event object or event name.
 * @param {Function} cb The callback.
 */
GestureHandler.prototype.on = function on(ev, cb) {
    var gesture = ev.event || ev;
    if (gestures[gesture]) {
        this.trackedGestures[gesture] = true;
        this.gestures.push(gesture);
        if (ev.event) this.options[gesture] = ev;
        this._events.on(gesture, cb);
    }
};

/**
 * Trigger gestures in the order they were requested, if they occured.
 *
 * @method triggerGestures
 */
GestureHandler.prototype.triggerGestures = function() {
    var payload = this.event;
    for (var i = 0, len = this.gestures.length; i < len; i++) {
        var gesture = this.gestures[i];
        switch (gesture) {
            case 'rotate':
            case 'pinch':
                if (payload.points === 2) this.trigger(gesture, payload);
                break;
            case 'tap':
                if (payload.status === 'start') {
                    if (this.options.tap) {
                        var pts = this.options.tap.points || 1;
                        if(this.multiTap >= pts && payload.points >= pts) this.trigger(gesture, payload);
                    }
                    else this.trigger(gesture, payload);
                }
                break;
            default:
                this.trigger(gesture, payload);
                break;
        }
    }
};

/**
 * Trigger the callback associated with an event, passing in a payload.
 *
 * @method trigger
 * @param {String} ev The event name.
 * @param {Object} payload The event payload.
 */
GestureHandler.prototype.trigger = function trigger (ev, payload) {
    this._events.trigger(ev, payload);
};

/**
 * Process up to the first two touch/mouse move events. Exit out if the first two points are already being tracked.
 *
 * @method _processPointerStart
 * @private
 * @param {Object} e The event object.
 */
function _processPointerStart(e) {
    var t;
    if (!e.targetTouches) {
        this.mice[0] = e;
        t = this.mice;
        e.identifier = 1;
    }
    else t = e.targetTouches;

    if (t[0] && t[1] && this.trackedPointerIDs[0] === t[0].identifier && this.trackedPointerIDs[1] === t[1].identifier) {
        return;
    }

    this.event.time = Date.now();

    var threshold;
    var id;

    if (this.trackedPointerIDs[0] !== t[0].identifier) {
        if (this.trackedGestures.tap) {
            threshold = (this.options.tap && this.options.tap.threshold) || 250;
            if (this.event.time - this.timeOfPointer < threshold) this.event.taps++;
            else this.event.taps = 1;
            this.timeOfPointer = this.event.time;
            this.multiTap = 1;
        }
        this.event.current = 1;
        this.event.points = 1;
        id = t[0].identifier;
        this.trackedPointerIDs[0] = id;

        this.last1.set(t[0].pageX, t[0].pageY);
        this.velocity1.clear();
        this.delta1.clear();
        this.event.pointers.push(this.pointer1);
    }
    if (t[1] && this.trackedPointerIDs[1] !== t[1].identifier) {
        if (this.trackedGestures.tap) {
            threshold = (this.options.tap && this.options.tap.threshold) || 250;
            if (this.event.time - this.timeOfPointer < threshold) this.multiTap = 2;
        }
        this.event.current = 2;
        this.event.points = 2;
        id = t[1].identifier;
        this.trackedPointerIDs[1] = id;

        this.last2.set(t[1].pageX, t[1].pageY);
        this.velocity2.clear();
        this.delta2.clear();

        Vec2.add(this.last1, this.last2, this.center).scale(0.5);
        this.centerDelta.clear();
        this.centerVelocity.clear();

        Vec2.subtract(this.last2, this.last1, this.diff12);
        this.dist = this.diff12.length();

        if (this.trackedGestures.pinch) {
            this.event.scale = this.event.scale || 1;
            this.event.scaleDelta = 0;
            this.event.scaleVelocity = 0;
        }
        if (this.trackedGestures.rotate) {
            this.event.rotation = this.event.rotation || 0;
            this.event.rotationDelta = 0;
            this.event.rotationVelocity = 0;
        }
        this.event.pointers.push(this.pointer2);
    }

    this.event.status = 'start';
    if (this.event.points === 1) {
        this.center.copy(this.last1);
        this.centerDelta.clear();
        this.centerVelocity.clear();
        if (this.trackedGestures.pinch) {
            this.event.scale = 1;
            this.event.scaleDelta = 0;
            this.event.scaleVelocity = 0;
        }
        if (this.trackedGestures.rotate) {
            this.event.rotation = 0;
            this.event.rotationDelta = 0;
            this.event.rotationVelocity = 0;
        }
    }
    this.triggerGestures();
}

/**
 * Process up to the first two touch/mouse move events.
 *
 * @method _processPointerMove
 * @private
 * @param {Object} e The event object.
 */
function _processPointerMove(e) {
    var t;
    if (!e.targetTouches) {
        if (!this.event.current) return;
        this.mice[0] = e;
        t = this.mice;
        e.identifier = 1;
    }
    else t = e.targetTouches;

    var time = Date.now();
    var dt = time - this.event.time;
    if (dt === 0) return;
    var invDt = 1000 / dt;
    this.event.time = time;

    this.event.current = 1;
    this.event.points = 1;
    if (this.trackedPointerIDs[0] === t[0].identifier) {
        VEC_REGISTER.set(t[0].pageX, t[0].pageY);
        Vec2.subtract(VEC_REGISTER, this.last1, this.delta1);
        Vec2.scale(this.delta1, invDt, this.velocity1);
        this.last1.copy(VEC_REGISTER);

    }
    if (t[1]) {
        this.event.current = 2;
        this.event.points = 2;
        VEC_REGISTER.set(t[1].pageX, t[1].pageY);
        Vec2.subtract(VEC_REGISTER, this.last2, this.delta2);
        Vec2.scale(this.delta2, invDt, this.velocity2);
        this.last2.copy(VEC_REGISTER);

        Vec2.add(this.last1, this.last2, VEC_REGISTER).scale(0.5);
        Vec2.subtract(VEC_REGISTER, this.center, this.centerDelta);
        Vec2.add(this.velocity1, this.velocity2, this.centerVelocity).scale(0.5);
        this.center.copy(VEC_REGISTER);

        Vec2.subtract(this.last2, this.last1, VEC_REGISTER);

        if (this.trackedGestures.rotate) {
            var dot = VEC_REGISTER.dot(this.diff12);
            var cross = VEC_REGISTER.cross(this.diff12);
            var theta = -Math.atan2(cross, dot);
            this.event.rotation += theta;
            this.event.rotationDelta = theta;
            this.event.rotationVelocity = theta * invDt;
        }

        var dist = VEC_REGISTER.length();
        var scale = dist / this.dist;
        this.diff12.copy(VEC_REGISTER);
        this.dist = dist;

        if (this.trackedGestures.pinch) {
            this.event.scale *= scale;
            scale -= 1.0;
            this.event.scaleDelta = scale;
            this.event.scaleVelocity = scale * invDt;
        }
    }

    this.event.status = 'move';
    if (this.event.points === 1) {
        this.center.copy(this.last1);
        this.centerDelta.copy(this.delta1);
        this.centerVelocity.copy(this.velocity1);
        if (this.trackedGestures.pinch) {
            this.event.scale = 1;
            this.event.scaleDelta = 0;
            this.event.scaleVelocity = 0;
        }
        if (this.trackedGestures.rotate) {
            this.event.rotation = 0;
            this.event.rotationDelta = 0;
            this.event.rotationVelocity = 0;
        }
    }
    this.triggerGestures();
}

/**
 * Process up to the first two touch/mouse end events. Exit out if the two points being tracked are still active.
 *
 * @method _processPointerEnd
 * @private
 * @param {Object} e The event object.
 */
function _processPointerEnd(e) {
    var t;
    if (!e.targetTouches) {
        if (!this.event.current) return;
        this.mice.pop();
        t = this.mice;
    }
    else t = e.targetTouches;

    if (t[0] && t[1] && this.trackedPointerIDs[0] === t[0].identifier && this.trackedPointerIDs[1] === t[1].identifier) {
            return;
    }

    var id;

    this.event.status = 'end';
    if (!t[0]) {
        this.event.current = 0;
        this.trackedPointerIDs[0] = -1;
        this.trackedPointerIDs[1] = -1;
        this.triggerGestures();
        this.event.pointers.pop();
        this.event.pointers.pop();
        return;
    }
    else if(this.trackedPointerIDs[0] !== t[0].identifier) {
        this.trackedPointerIDs[0] = -1;
        id = t[0].identifier;
        this.trackedPointerIDs[0] = id;

        this.last1.set(t[0].pageX, t[0].pageY);
        this.velocity1.clear();
        this.delta1.clear();
    }
    if (!t[1]) {
        this.event.current = 1;
        this.trackedPointerIDs[1] = -1;
        this.triggerGestures();
        this.event.points = 1;
        this.event.pointers.pop();
    }
    else if (this.trackedPointerIDs[1] !== t[1].identifier) {
        this.trackedPointerIDs[1] = -1;
        this.event.points = 2;
        id = t[1].identifier;
        this.trackedPointerIDs[1] = id;

        this.last2.set(t[1].pageX, t[1].pageY);
        this.velocity2.clear();
        this.delta2.clear();

        Vec2.add(this.last1, this.last2, this.center).scale(0.5);
        this.centerDelta.clear();
        this.centerVelocity.clear();

        Vec2.subtract(this.last2, this.last1, this.diff12);
        this.dist = this.diff12.length();
    }
}

/**
 * Treats a mouseleave event as a gesture end.
 *
 * @method _processMouseLeave
 * @private
 */
function _processMouseLeave() {
    if (this.event.current) {
        this.event.status = 'end';
        this.event.current = 0;
        this.trackedPointerIDs[0] = -1;
        this.triggerGestures();
        this.event.pointers.pop();
    }
}

module.exports = GestureHandler;

},{"famous-math":15,"famous-utilities":31}],40:[function(require,module,exports){
'use strict';

var Position = require('./Position');

/**
 * @class MountPoint
 * @constructor
 * @component
 * @param {LocalDispatch} dispatch LocalDispatch to be retrieved from corresponding Render Node of the MountPoint component
 */
function MountPoint(node) {
    Position.call(this, node);

    var initial = node.getMountPoint();

    this._x.set(initial[0]);
    this._y.set(initial[1]);
    this._z.set(initial[2]);
}

/**
*
* Stringifies MountPoint
*
* @method
* @return {String} the name of the Component Class: 'MountPoint'
*/
MountPoint.toString = function toString() {
    return 'MountPoint';
};

MountPoint.prototype = Object.create(Position.prototype);
MountPoint.prototype.constructor = MountPoint;

MountPoint.prototype.update = function update() {
    this._node.setMountPoint(this._x.get(), this._y.get(), this._z.get());
    this._checkUpdate();
};

MountPoint.prototype.onUpdate = MountPoint.prototype.update;

module.exports = MountPoint;

},{"./Position":43}],41:[function(require,module,exports){
'use strict';

var Transitionable = require('famous-transitions').Transitionable;


/**
 * @class Opacity
 * @constructor
 * @component
 * @param {LocalDispatch} dispatch LocalDispatch to be retrieved from corresponding Render Node of the Opacity component
 */
function Opacity(node) {
    this._node = node;
    this._id = node.addComponent(this);
    this._value = new Transitionable(1);

    this._requestingUpdate = false;
}

/**
*
* returns stringified Opacity
*
* @method
* @return {String} the name of the Component Class: 'Opacity'
*/
Opacity.toString = function toString() {
    return 'Opacity';
};

/**
*
* Retrieves state of Opacity
*
* @method
* @return {Object} contains component key which holds the stringified constructor 
* and value key which contains the numeric value
*/
Opacity.prototype.getValue = function getValue() {
    return {
        component: this.constructor.toString(),
        value: this._value.get()
    };
};

/**
*
* Setter for Opacity state
*
* @method
* @param {Object} state contains component key, which holds stringified constructor, and a value key, which contains a numeric value used to set opacity if the constructor value matches
* @return {Boolean} true if set is successful, false otherwise
*/
Opacity.prototype.setValue = function setValue(value) {
    if (this.constructor.toString() === value.component) {
        this.set(value.value);
        return true;
    }
    return false;
};

/**
*
* Setter for Opacity with callback
*
* @method
* @param {Number} value value used to set Opacity
* @param {Object} options options hash
* @param {Function} callback to be called following Opacity set
* @chainable
*/
Opacity.prototype.set = function set(value, options, callback) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }

    this._value.set(value, options, callback);
    return this;
};

/**
*
* Getter for Opacity
*
* @method
* @return {Number}
*/
Opacity.prototype.get = function get() {
    return this._value.get();
};

/**
*
* Stops Opacity transition
*
* @method
* @chainable
*/
Opacity.prototype.halt = function halt() {
    this._value.halt();
    return this;
};

Opacity.prototype.isActive = function isActive(){
    return this._value.isActive();
};

Opacity.prototype.update = function update () {
    this._node.setOpacity(this._value.get());
    if (this._value.isActive()) {
      this._node.requestUpdateOnNextTick(this._id);
    } else {
      this._requestingUpdate = false;
    }
};

Opacity.prototype.onUpdate = Opacity.prototype.update;

module.exports = Opacity;

},{"famous-transitions":18}],42:[function(require,module,exports){
'use strict';

var Position = require('./Position');

/**
 * @class Origin
 * @constructor
 * @component
 * @param {LocalDispatch} dispatch LocalDispatch to be retrieved from corresponding Render Node of the Origin component
 */
function Origin(node) {
    Position.call(this, node);

    var initial = node.getOrigin();

    this._x.set(initial[0]);
    this._y.set(initial[1]);
    this._z.set(initial[2]);
}


/**
*
* returns stringified Origin
*
* @method
* @return {String} the name of the Component Class: 'Origin'
*/
Origin.toString = function toString() {
    return 'Origin';
};

Origin.prototype = Object.create(Position.prototype);
Origin.prototype.constructor = Origin;

Origin.prototype.update = function update() {
    this._node.setOrigin(this._x.get(), this._y.get(), this._z.get());
    this._checkUpdate();
};

Origin.prototype.onUpdate = Origin.prototype.update;

module.exports = Origin;

},{"./Position":43}],43:[function(require,module,exports){
'use strict';

var Transitionable = require('famous-transitions').Transitionable;

/**
 * @class Position
 * @constructor
 * @component
 * @param {LocalDispatch} dispatch LocalDispatch to be retrieved from corresponding Render Node of the Position component
 */
function Position(node) {
    this._node = node;
    this._id = node.addComponent(this);
  
    this._requestingUpdate = false;
    
    var initialPosition = node.getPosition();

    this._x = new Transitionable(initialPosition[0]);
    this._y = new Transitionable(initialPosition[1]);
    this._z = new Transitionable(initialPosition[2]);
}

/** 
*
* stringifies Position constructor
*
* @method
* @return {String} the definition of the Component Class: 'Position'
*/
Position.toString = function toString() {
    return 'Position';
};

/**
*
* Gets object containing stringified constructor, x, y, z coordinates
*
* @method
* @return {Object}
*/
Position.prototype.getValue = function getValue() {
    return {
        component: this.constructor.toString(),
        x: this._x.get(),
        y: this._y.get(),
        z: this._z.get()
    };
};

/**
*
* Setter for position coordinates
*
* @method
* @param {Object} state Object -- component: stringified constructor, x: number, y: number, z: number
* @return {Boolean} true on success
*/
Position.prototype.setValue = function setValue(state) {
    if (state.component === this.constructor.toString()) {
        this.set(state.x, state.y, state.z);
        return true;
    }
    return false;
};

/**
*
* Getter for X position
*
* @method
* @return {Number}
*/
Position.prototype.getX = function getX() {
    return this._x.get();
};

/**
*
* Getter for Y position
*
* @method
* @return {Number}
*/
Position.prototype.getY = function getY() {
    return this._y.get();
};

/**
*
* Getter for Z position
*
* @method
* @return {Number}
*/
Position.prototype.getZ = function getZ() {
    return this._z.get();
};

/**
*
* Getter for any active coordinates
*
* @method
* @return {Boolean}
*/
Position.prototype.isActive = function isActive() {
    return this._x.isActive() || this._y.isActive() || this._z.isActive();
};

Position.prototype._checkUpdate = function _checkUpdate() {
    if (this.isActive()) this._node.requestUpdateOnNextTick(this._id);
    else this._requestingUpdate = false;
};


Position.prototype.update = function update () {
    this._node.setPosition(this._x.get(), this._y.get(), this._z.get());
    this._checkUpdate();
};

/** 
*
* If true, component is to be updated on next engine tick
*
* @method
*/
Position.prototype.onUpdate = Position.prototype.update;

/** 
*
* Setter for X position
*
* @method
* @param {Number} val used to set x coordinate
* @param {Object} options options hash
* @param {Function} callback function to execute after setting X
* @chainable
*/
Position.prototype.setX = function setX(val, options, callback) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }

    this._x.set(val, options, callback);
    return this;
};

/** 
*
* Setter for Y position
*
* @method
* @param {Number} val used to set y coordinate
* @param {Object} options options hash
* @param {Function} callback function to execute after setting Y
* @chainable
*/
Position.prototype.setY = function setY(val, options, callback) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }

    this._y.set(val, options, callback);
    return this;
};

/** 
*
* Setter for Z position
*
* @method
* @param {Number} val used to set z coordinate
* @param {Object} options options hash
* @param {Function} callback function to execute after setting Z
* @chainable
*/
Position.prototype.setZ = function setZ(val, options, callback) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }

    this._z.set(val, options, callback);
    return this;
};


/**
*
* Setter for XYZ position with callback
*
* @method
* @param {Number} x used to set x coordinate
* @param {Number} y used to set y coordinate
* @param {Number} z used to set z coordinate
* @param {Object} options options hash
* @param {Function} callback function to execute after setting each coordinate
* @chainable
*/
Position.prototype.set = function set(x, y, z, options, callback) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }

    var xCallback;
    var yCallback;
    var zCallback;

    if (z != null) {
        zCallback = callback;
    }
    else if (y != null) {
        yCallback = callback;
    }
    else if (x != null) {
        xCallback = callback;
    }

    if (x != null) this._x.set(x, options, xCallback);
    if (y != null) this._y.set(y, options, yCallback);
    if (z != null) this._z.set(z, options, zCallback);

    return this;
};

/**
*
* Stops transition of Position component
*
* @method
* @chainable
*/
Position.prototype.halt = function halt() {
    this._x.halt();
    this._y.halt();
    this._z.halt();
    return this;
};

module.exports = Position;

},{"famous-transitions":18}],44:[function(require,module,exports){
'use strict';

var Position = require('./Position');

/**
 * @class Rotation
 * @constructor
 * @component
 * @param {LocalDispatch} dispatch LocalDispatch to be retrieved from corresponding Render Node of the Rotation component
 */
function Rotation(node) {
    Position.call(this, node);

    var initial = node.getRotation();

    var x = initial[0];
    var y = initial[1];
    var z = initial[2];
    var w = initial[3];

    var xx = x * x;
    var yy = y * y;
    var zz = z * z;

    var ty = 2 * (x * z + y * w);
    ty = ty < -1 ? -1 : ty > 1 ? 1 : ty;

    var rx = Math.atan2(2 * (x * w - y * z), 1 - 2 * (xx + yy));
    var ry = Math.asin(ty);
    var rz = Math.atan2(2 * (z * w - x * y), 1 - 2 * (yy + zz));

    this._x.set(rx);
    this._y.set(ry);
    this._z.set(rz);
}

/**
*
* stringifies Rotation
*
* @method
* @return {String} the name of the Component Class: 'Rotation'
*/
Rotation.toString = function toString() {
    return 'Rotation';
};

Rotation.prototype = Object.create(Position.prototype);
Rotation.prototype.constructor = Rotation;

Rotation.prototype.update = function update() {
    this._node.setRotation(this._x.get(), this._y.get(), this._z.get());
    this._checkUpdate();
};

Rotation.prototype.onUpdate = Rotation.prototype.update;

module.exports = Rotation;

},{"./Position":43}],45:[function(require,module,exports){
'use strict';

var Position = require('./Position');

/**
 * @class Scale
 * @constructor
 * @component
 * @param {LocalDispatch} dispatch LocalDispatch to be retrieved from corresponding Render Node of the Scale component
 */
function Scale(node) {
    Position.call(this, node);
    this._x.set(1);
    this._y.set(1);
    this._z.set(1);
}

/**
*
* stringifies Scale
*
* @method 
* @return {String} the name of the Component Class: 'Scale'
*/
Scale.toString = function toString() {
    return 'Scale';
};

Scale.prototype = Object.create(Position.prototype);
Scale.prototype.constructor = Scale;

Scale.prototype.update = function update() {
    this._node.setScale(this._x.get(), this._y.get(), this._z.get());
    this._checkUpdate();
};

Scale.prototype.onUpdate = Scale.prototype.update;

module.exports = Scale;

},{"./Position":43}],46:[function(require,module,exports){
'use strict';

var Transitionable = require('famous-transitions').Transitionable;
var CoreSize = require('famous-core').Size;

/**
 * Size component used for managing the size of the underlying RenderContext.
 * Supports absolute and relative (proportional and differential) sizing.
 *
 * @class Size
 * @constructor
 * @component
 *
 * @param {LocalDispatch} node LocalDispatch to be retrieved from
 *                                 corresponding RenderNode of the Size
 *                                 component
 */
function Size(node) {
    this._node = node;
    this._id = node.addComponent(this);
    this._requestingUpdate = false;

    var initialProportionalSize = node.getProportionalSize();
    var initialDifferentialSize = node.getDifferentialSize();
    var initialAbsoluteSize = node.getAbsoluteSize();

    this._proportional = {
        x: new Transitionable(initialProportionalSize[0]),
        y: new Transitionable(initialProportionalSize[1]),
        z: new Transitionable(initialProportionalSize[2])
    };
    this._differential = {
        x: new Transitionable(initialDifferentialSize[0]),
        y: new Transitionable(initialDifferentialSize[1]),
        z: new Transitionable(initialDifferentialSize[2])
    };
    this._absolute = {
        x: new Transitionable(initialAbsoluteSize[0]),
        y: new Transitionable(initialAbsoluteSize[1]),
        z: new Transitionable(initialAbsoluteSize[2])
    };
}

Size.RELATIVE = CoreSize.RELATIVE;
Size.ABSOLUTE = CoreSize.ABSOLUTE;
Size.RENDER = CoreSize.RENDER;
Size.DEFAULT = CoreSize.DEFAULT;

Size.prototype.setMode = function setMode(x, y, z) {
    this._node.setSizeMode(x, y, z);
    return this;
};

/**
* Stringifies Size.
*
* @method toString
*
* @return {String} `Size`
*/
Size.toString = function toString() {
    return 'Size';
};

/**
 * @typedef absoluteSizeValue
 * @type {Object}
 * @property {String} type current type of sizing being applied ('absolute')
 * @property {String} component component name ('Size')
 * @property {number} x
 * @property {number} y
 * @property {number} z
 */

/**
 * @typedef relativeSizeValue
 * @type {Object}
 * @property {String} type current type of sizing being applied ('relative')
 * @property {String} component component name ('Size')
 * @property {Object} differential
 * @property {number} differential.x
 * @property {number} differential.y
 * @property {number} differential.z
 * @property {Object} proportional
 * @property {number} proportional.x
 * @property {number} proportional.y
 * @property {number} proportional.z
 */

/**
* Returns serialized state of the component.
*
* @method getValue
*
* @return {absoluteSizeValue|relativeSizeValue}
*/
Size.prototype.getValue = function getValue() {
    return {
        sizeMode: this._node.value.sizeMode,
        absolute: {
            x: this._absolute.x.get(),
            y: this._absolute.y.get(),
            z: this._absolute.z.get()
        },
        differential: {
            x: this._differential.x.get(),
            y: this._differential.y.get(),
            z: this._differential.z.get()
        },
        proportional: {
            x: this._proportional.x.get(),
            y: this._proportional.y.get(),
            z: this._proportional.z.get()
        }
    };
};

/**
* Updates state of component.
*
* @method setValue
*
* @param {absoluteSizeValue|relativeSizeValue} state state encoded in same
*                                                    format as state retrieved
*                                                    through `getValue`
* @return {Boolean}                                  boolean indicating
*                                                    whether the new state has
*                                                    been applied
*/
Size.prototype.setValue = function setValue(state) {
    if (state.component === this.constructor.toString()) {
        this.setMode.apply(this, state.sizeMode);
        if (state.absolute) {
            this.setAbsolute(state.absolute.x, state.absolute.y, state.absolute.z);
        }
        if (state.differential) {
            this.setAbsolute(state.differential.x, state.differential.y, state.differential.z);
        }
        if (state.proportional) {
            this.setAbsolute(state.proportional.x, state.proportional.y, state.proportional.z);
        }
    }
    return false;
};

Size.prototype._isActive = function _isActive(type) {
    return type.x.isActive() || type.y.isActive() || type.z.isActive();
};

Size.prototype.isActive = function isActive(){
    return (
        this._isActive(this._absolute) ||
        this._isActive(this._proportional) ||
        this._isActive(this._differential)
    );
};

Size.prototype.onUpdate = function onUpdate() {
    var abs = this._absolute;
    this._node.setAbsoluteSize(
        abs.x.get(),
        abs.y.get(),
        abs.z.get()
    );
    var prop = this._proportional;
    var diff = this._differential;
    this._node.setProportionalSize(
        prop.x.get(),
        prop.y.get(),
        prop.z.get()
    );
    this._node.setDifferentialSize(
        diff.x.get(),
        diff.y.get(),
        diff.z.get()
    );

    if (this.isActive()) this._node.requestUpdateOnNextTick(this._id);
    else this._requestingUpdate = false;
};


/**
* Applies absolute size.
*
* @method setAbsolute
* @chainable
*
* @param {Number} x used to set absolute size in x-direction (width)
* @param {Number} y used to set absolute size in y-direction (height)
* @param {Number} z used to set absolute size in z-direction (depth)
* @param {Object} options options hash
* @param {Function} callback callback function to be executed after the
*                            transitions have been completed
* @return {Size} this
*/
Size.prototype.setAbsolute = function setAbsolute(x, y, z, options, callback) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }

    var xCallback;
    var yCallback;
    var zCallback;

    if (z != null) {
        zCallback = callback;
    }
    else if (y != null) {
        yCallback = callback;
    }
    else if (x != null) {
        xCallback = callback;
    }

    var abs = this._absolute;
    if (x != null) {
        abs.x.set(x, options, xCallback);
    }
    if (y != null) {
        abs.y.set(y, options, yCallback);
    }
    if (z != null) {
        abs.z.set(z, options, zCallback);
    }
};

/**
* Applies proportional size.
*
* @method setProportional
* @chainable
*
* @param {Number} x used to set proportional size in x-direction (width)
* @param {Number} y used to set proportional size in y-direction (height)
* @param {Number} z used to set proportional size in z-direction (depth)
* @param {Object} options options hash
* @param {Function} callback callback function to be executed after the
*                            transitions have been completed
* @return {Size} this
*/
Size.prototype.setProportional = function setProportional(x, y, z, options, callback) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }

    var xCallback;
    var yCallback;
    var zCallback;

    if (z != null) {
        zCallback = callback;
    }
    else if (y != null) {
        yCallback = callback;
    }
    else if (x != null) {
        xCallback = callback;
    }

    var prop = this._proportional;
    if (x != null) {
        prop.x.set(x, options, xCallback);
    }
    if (y != null) {
        prop.y.set(y, options, yCallback);
    }
    if (z != null) {
        prop.z.set(z, options, zCallback);
    }
    return this;
};

/**
* Applies differential size to Size component.
*
* @method setDifferential
* @chainable
*
* @param {Number} x used to set differential size in x-direction (width)
* @param {Number} y used to set differential size in y-direction (height)
* @param {Number} z used to set differential size in z-direction (depth)
* @param {Object} options options hash
* @param {Function} callback callback function to be executed after the
*                            transitions have been completed
*/
Size.prototype.setDifferential = function setDifferential(x, y, z, options, callback) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }

    var xCallback;
    var yCallback;
    var zCallback;

    if (z != null) {
        zCallback = callback;
    }
    else if (y != null) {
        yCallback = callback;
    }
    else if (x != null) {
        xCallback = callback;
    }

    var diff = this._differential;
    if (x != null) {
        diff.x.set(x, options, xCallback);
    }
    if (y != null) {
        diff.y.set(y, options, yCallback);
    }
    if (z != null) {
        diff.z.set(z, options, zCallback);
    }
    return this;
};

/**
* Retrieves the computed size applied to the underlying RenderContext.
*
* @method get
*
* @return {Number[]} size three dimensional computed size
*/
Size.prototype.get = function get () {
    return this._node.getSize();
};

/**
 * Halts all currently active size transitions.
 *
 * @method halt
 * @chainable
 *
 * @return {Size} this
 */
Size.prototype.halt = function halt () {
    this._proportional.x.halt();
    this._proportional.y.halt();
    this._proportional.z.halt();
    this._differential.x.halt();
    this._differential.y.halt();
    this._differential.z.halt();
    this._absolute.x.halt();
    this._absolute.y.halt();
    this._absolute.z.halt();
    return this;
};

module.exports = Size;

},{"famous-core":10,"famous-transitions":18}],47:[function(require,module,exports){
'use strict';

var Transitionable = require('famous-transitions').Transitionable;
var Quaternion = require('famous-math').Quaternion;

var Q_REGISTER = new Quaternion();
var Q2_REGISTER = new Quaternion();

function Vec3Transitionable(x, y, z, transform) {
    this._transform = transform;
    this._dirty = false;
    this.x = new Transitionable(x);
    this.y = new Transitionable(y);
    this.z = new Transitionable(z);
    this._values = {x: x, y: y, z: z};
}

Vec3Transitionable.prototype.get = function get() {
    this._values.x = this.x.get();
    this._values.y = this.y.get();
    this._values.z = this.z.get();
    return this._values;
};

Vec3Transitionable.prototype.set = function set(x, y, z, options, callback) {
    this.dirty();

    var cbX = null;
    var cbY = null;
    var cbZ = null;

    if (z != null) cbZ = callback;
    else if (y != null) cbY = callback;
    else if (x != null) cbX = callback;

    if (x != null) this.x.set(x, options, cbX);
    if (y != null) this.y.set(y, options, cbY);
    if (z != null) this.z.set(z, options, cbZ);

    return this;
};

Vec3Transitionable.prototype.isActive = function isActive() {
    return this.x.isActive() || this.y.isActive() || this.z.isActive();
};

Vec3Transitionable.prototype.pause = function pause() {
    this.x.pause();
    this.y.pause();
    this.z.pause();
    return this;
};

Vec3Transitionable.prototype.resume = function resume() {
    this.x.resume();
    this.y.resume();
    this.z.resume();
    return this;
};

Vec3Transitionable.prototype.halt = function halt() {
    this.x.halt();
    this.y.halt();
    this.z.halt();
    return this;
};

Vec3Transitionable.prototype.dirty = function dirty() {
    if (!this._transform._dirty) {
        this._transform._node.requestUpdate(this._transform._id);
        this._transform._dirty = true;
    }
    this._dirty = true;
    return this;
};

function QuatTransitionable(x, y, z, w, transform) {
    this._transform = transform;
    this._queue = [];
    this._front = 0;
    this._end = 0;
    this._dirty = false;
    this._t = new Transitionable(0);
    this._fromQ = new Quaternion(w, x, y, z);
    this._toQ = new Quaternion();
    this._q = new Quaternion(w, x, y, z);
}

QuatTransitionable.prototype.get = function get() {
    var t = this._t.get();
    var w, x, y, z;
    var queue = this._queue;
    while (t >= this._front + 1) {
        this._front++;
        w = queue.shift();
        x = queue.shift();
        y = queue.shift();
        z = queue.shift();
        this._q.set(w, x, y, z);
        this._fromQ.set(w, x, y, z);
        if (this._queue.length !== 0) this._toQ.set(queue[0], queue[1], queue[2], queue[3]);
    }
    if (this._queue.length !== 0) this._fromQ.slerp(this._toQ, t - this._front, this._q);
    return this._q;
};

QuatTransitionable.prototype.set = function set(x, y, z, w, options, callback) {
    if (!this._transform._dirty) {
        this._transform._node.requestUpdate(this._transform._id);
        this._transform._dirty = true;
    }
    this._dirty = true;
    if (this._queue.length === 0) this._toQ.set(w, x, y, z);
    this._queue.push(w, x, y, z);
    this._end++;
    this._t.set(this._end, options, callback);
    return this;
};

QuatTransitionable.prototype.isActive = function isActive() {
    return this._t.isActive();
};

QuatTransitionable.prototype.pause = function pause() {
    this._t.pause();
    return this;
};

QuatTransitionable.prototype.resume = function resume() {
    this._t.resume();
    return this;
};

QuatTransitionable.prototype.halt = function halt() {
    this._dirty = false;
    this._t.reset(0);
    this._queue.length = 0;
    this._front = 0;
    this._end = 0;
    return this;
};

function Transform(node) {
    this._node = node;
    this._id = node.addComponent(this);
    this.origin = null;
    this.mountPoint = null;
    this.align = null;
    this.scale = null;
    this.position = null;
    this.rotation = null;

    this._dirty = false;
}

Transform.toString = function toString() {
    return 'Transform';
};

Transform.prototype.getValue = function getValue() {
    return {
        component: this.constructor.toString(),
        origin: this.origin && this.origin.get(),
        mountPoint: this.mountPoint && this.mountPoint.get(),
        align: this.align && this.align.get(),
        scale: this.scale && this.scale.get(),
        position: this.position && this.position.get(),
        rotation: this.rotation && this.rotation.get()
    };
};

Transform.prototype.setState = function setState(state) {
    if (state.component === this.constructor.toString()) {
        state.origin && this.setOrigin(state.origin.x, state.origin.y, state.origin.z);
        state.mountPoint && this.setMountPoint(state.mountPoint.x, state.mountPoint.y, state.mountPoint.z);
        state.align && this.setAlign(state.align.x, state.align.y, state.align.z);
        state.scale && this.setScale(state.scale.x, state.scale.y, state.scale.z);
        state.position && this.setPosition(state.position.x, state.position.y, state.position.z);
        state.rotation && this.setRotation(state.rotation.x, state.rotation.y, state.rotation.z, state.rotation.w);
        return true;
    }
    return false;
};

Transform.prototype.setOrigin = function setOrigin(x, y, z, options, callback) {
    if (!this.origin) {
        var v = this._node.getOrigin();
        this.origin = new Vec3Transitionable(v[0], v[1], v[2], this);
    }
    this.origin.set(x, y, z, options, callback);
    return this;
};

Transform.prototype.setMountPoint = function setMountPoint(x, y, z, options, callback) {
    if (!this.mountPoint) {
        var v = this._node.getMountPoint();
        this.mountPoint = new Vec3Transitionable(v[0], v[1], v[2], this);
    }
    this.mountPoint.set(x, y, z, options, callback);
    return this;
};

Transform.prototype.setAlign = function setAlign(x, y, z, options, callback) {
    if (!this.align) {
        var v = this._node.getAlign();
        this.align = new Vec3Transitionable(v[0], v[1], v[2], this);
    }
    this.align.set(x, y, z, options, callback);
    return this;
};

Transform.prototype.setScale = function setScale(x, y, z, options, callback) {
    if (!this.scale) {
        var v = this._node.getScale();
        this.scale = new Vec3Transitionable(v[0], v[1], v[2], this);
    }
    this.scale.set(x, y, z, options, callback);
    return this;
};

Transform.prototype.setPosition = function setPosition(x, y, z, options, callback) {
    if (!this.position) {
        var v = this._node.getPosition();
        this.position = new Vec3Transitionable(v[0], v[1], v[2], this);
    }
    this.position.set(x, y, z, options, callback);
    return this;
};

Transform.prototype.translate = function translate(x, y, z, options, callback) {
    if (!this.position) {
        var v = this._node.getPosition();
        this.position = new Vec3Transitionable(v[0], v[1], v[2], this);
    }
    var p = this.position;
    var xq = p.x._queue;
    var yq = p.y._queue;
    var zq = p.z._queue;
    var xEnd = x == null ? null : x + (xq.length > 0 ? xq[xq.length - 4] : p.x._end);
    var yEnd = y == null ? null : y + (yq.length > 0 ? yq[yq.length - 4] : p.y._end);
    var zEnd = z == null ? null : z + (zq.length > 0 ? zq[zq.length - 4] : p.z._end);
    this.position.set(xEnd, yEnd, zEnd, options, callback);
    return this;
};

Transform.prototype.setRotation = function setRotation(x, y, z, w, options, callback) {
    if (!this.rotation) {
        var v = this._node.getRotation();
        this.rotation = new QuatTransitionable(v[0], v[1], v[2], v[3], this);
    }
    var q = Q_REGISTER;
    if (typeof w === 'number') {
        q.set(w, x, y, z);
    }
    else {
        q.fromEuler(x, y, z);
        callback = options;
        options = w;
    }
    this.rotation.set(q.x, q.y, q.z, q.w, options, callback);
    return this;
};

Transform.prototype.rotate = function rotate(x, y, z, w, options, callback) {
    if (!this.rotation) {
        var v = this._node.getRotation();
        this.rotation = new QuatTransitionable(v[0], v[1], v[2], v[3], this);
    }
    var queue = this.rotation._queue;
    var len = this.rotation._queue.length;
    var referenceQ;
    if (len !== 0) {
        referenceQ = Q2_REGISTER.set(queue[len - 4], queue[len - 3], queue[len - 2], queue[len - 1]);
    }
    else referenceQ = Q2_REGISTER.copy(this.rotation._q);

    var rotQ = Q_REGISTER;
    if (typeof w === 'number') {
        rotQ.set(w, x, y, z);
    }
    else {
        rotQ.fromEuler(x, y, z);
        callback = options;
        options = w;
    }

    var q = referenceQ.multiply(rotQ);
    this.rotation.set(q.x, q.y, q.z, q.w, options, callback);
    return this;
};

Transform.prototype.clean = function clean() {
    var node = this._node;
    var c;
    var isDirty = false;
    if ((c = this.origin) && c._dirty) {
        node.setOrigin(c.x.get(), c.y.get(), c.z.get());
        c._dirty = c.isActive();
        isDirty = isDirty || c._dirty;
    }
    if ((c = this.mountPoint) && c._dirty) {
        node.setMountPoint(c.x.get(), c.y.get(), c.z.get());
        c._dirty = c.isActive();
        isDirty = isDirty || c._dirty;
    }
    if ((c = this.align) && c._dirty) {
        node.setAlign(c.x.get(), c.y.get(), c.z.get());
        c._dirty = c.isActive();
        isDirty = isDirty || c._dirty;
    }
    if ((c = this.scale) && c._dirty) {
        node.setScale(c.x.get(), c.y.get(), c.z.get());
        c._dirty = c.isActive();
        isDirty = isDirty || c._dirty;
    }
    if ((c = this.position) && c._dirty) {
        node.setPosition(c.x.get(), c.y.get(), c.z.get());
        c._dirty = c.isActive();
        isDirty = isDirty || c._dirty;
    }
    if ((c = this.rotation) && c._dirty) {
        c.get();
        node.setRotation(c._q.x, c._q.y, c._q.z, c._q.w);
        c._dirty = c.isActive();
        isDirty = isDirty || c._dirty;
    }
    if (isDirty) this._node.requestUpdateOnNextTick(this._id);
    else this._dirty = false;
};

Transform.prototype.onUpdate = Transform.prototype.clean;

module.exports = Transform;

},{"famous-math":15,"famous-transitions":18}],48:[function(require,module,exports){
'use strict';

var CallbackStore = require('famous-utilities').CallbackStore;

/**
 * Component to manage DOM events. When registering an event, the user may specify .methods and
 * .properties to preprocess the event object.
 *
 * @class UIEventHandler
 * @param {LocalDispatch} dispatch The dispatch with which to register the handler.
 * @param {Object[]} events An array of event objects specifying .event and .callback properties.
 */
function UIEventHandler (dispatch, events) {
    this.dispatch = dispatch;
    this._events = new CallbackStore();

    if (events) {
        for (var i = 0, len = events.length; i < len; i++) {
            this.on(events[i], events[i].callback);
        }
    }
}

/**
 * Returns the name of UIEventHandler as a string.
 *
 * @method toString
 * @static
 * @return {String} 'UIEventHandler'
 */
UIEventHandler.toString = function toString() {
    return 'UIEventHandler';
};

/**
 * Register a callback to be invoked on an event.
 *
 * @method on
 * @param {Object|String} ev The event object or event name.
 * @param {Function} cb The callback.
 */
UIEventHandler.prototype.on = function on(ev, cb) {
    var renderables = this.dispatch.getRenderables();
    var eventName = ev.event || ev;
    var methods = ev.methods;
    var properties = ev.properties;
    for (var i = 0, len = renderables.length; i < len; i++) {
        if (renderables[i].on) renderables[i].on(eventName, methods, properties);
    }
    this._events.on(eventName, cb);
    this.dispatch.registerTargetedEvent(eventName, this.trigger.bind(this, eventName));
};

/**
 * Deregister a callback from an event.
 *
 * @method on
 * @param {String} ev The event name.
 * @param {Function} cb The callback.
 */
UIEventHandler.prototype.off = function off(ev, cb) {
    this._events.off(ev, cb);
    this.dispatch.deregisterGlobalEvent(ev, this.trigger.bind(this, ev));
};

/**
 * Trigger the callback associated with an event, passing in a payload.
 *
 * @method trigger
 * @param {String} ev The event name.
 * @param {Object} payload The event payload.
 */
UIEventHandler.prototype.trigger = function trigger (ev, payload) {
    this._events.trigger(ev, payload);
};

module.exports = UIEventHandler;

},{"famous-utilities":31}],49:[function(require,module,exports){
'use strict';

module.exports = {
    Align: require('./Align'),
    Camera: require('./Camera'),
    EventEmitter: require('./EventEmitter'),
    EventHandler: require('./EventHandler'),
    GestureHandler: require('./GestureHandler'),
    MountPoint: require('./MountPoint'),
    Opacity: require('./Opacity'),
    Origin: require('./Origin'),
    Position: require('./Position'),
    Rotation: require('./Rotation'),
    Scale: require('./Scale'),
    Size: require('./Size'),
    Transform: require('./Transform'),
    UIEventHandler: require('./UIEventHandler')
};

},{"./Align":35,"./Camera":36,"./EventEmitter":37,"./EventHandler":38,"./GestureHandler":39,"./MountPoint":40,"./Opacity":41,"./Origin":42,"./Position":43,"./Rotation":44,"./Scale":45,"./Size":46,"./Transform":47,"./UIEventHandler":48}],50:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"dup":2}],51:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./Dispatch":52,"./Node":55,"./Size":56,"dup":3}],52:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],53:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5}],54:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"./Clock":50,"./Context":51,"dup":6}],55:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"./Size":56,"./Transform":57,"dup":7}],56:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],57:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"dup":9}],58:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"./Clock":50,"./Context":51,"./Dispatch":52,"./Event":53,"./Famous":54,"./Node":55,"./Size":56,"./Transform":57,"dup":10}],59:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],60:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],61:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"./Curves":59,"dup":21}],62:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],63:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"./Curves":59,"./Easing":60,"./Transitionable":61,"./after":62,"dup":23}],64:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24}],65:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25,"famous-transitions":63}],66:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26}],67:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27}],68:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"dup":28}],69:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"dup":29}],70:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],71:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"./CallbackStore":64,"./Color":65,"./KeyCodes":66,"./MethodStore":67,"./ObjectManager":68,"./clone":69,"./flatClone":70,"./keyValueToArrays":72,"./loadURL":73,"./strip":74,"dup":31}],72:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],73:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],74:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],75:[function(require,module,exports){
'use strict';

var CallbackStore = require('famous-utilities').CallbackStore;

var RENDER_SIZE = 2;

/**
 * A DOMElement is a renderable that can be added just like a "normal"
 * component to a node using `addComponent`.
 * Renderables send draw commands to the node they are attached to.
 * Those commands then get interpreted by the `DOMRenderer` in the Main thread
 * to build the actual DOM representation.
 *
 * @class DOMElement
 * @constructor
 * 
 * @param {Node} node                   The entity to which the `DOMElement`
 *                                      renderable should be attached to.
 * @param {Object} options              Initial options used for instantiating
 *                                      the Node.
 * @param {Object} options.properties   CSS properties that should be added to
 *                                      the actual DOMElement on the initial draw.
 */
function DOMElement (node, options) {
    if (typeof options === 'string') {
        console.warn(
            'HTMLElement constructor signature changed!\n' +
            'Pass in an options object with {tagName: ' + options + '} instead.'
        );
        options = {
            tagName: options
        };
    }

    this._node = node;

    this._requestingUpdate = false;

    this._changeQueue = [];
    
    this._UIEvents = node.getUIEvents().slice(0);
    this._classes = ['fa-surface'];
    this._requestingEventListeners = [];
    this._styles = {
        display: node.isShown() 
    };
    this._attributes = {};
    this._content = '';

    this._tagName = options && options.tagName ? options.tagName : 'div';
    this._id = node.addComponent(this);

    this._callbacks = new CallbackStore();

    if (!options) return;

    if (options.classes) {
        for (var i = 0; i < options.classes.length; i++)
            this.addClass(options.classes[i]);
    }

    if (options.attributes) {
        for (var key in options.attributes)
            this.setAttribute(key, options.attributes[key]);
    }

    if (options.properties) {
        for (var key in options.properties)
            this.setProperty(key, options.properties[key]);
    }

    if (options.id) this.setId(options.id);
    if (options.content) this.setContent(options.content);
}

/**
 * Serializes the state of the DOMElement. This method will be invoked by
 * @{@link Node#getValue} in order to serialize the node and possibly entire
 * scene graph hierarchies.
 *
 * @method getValue
 * 
 * @return {Object}     serialized component.
 */
DOMElement.prototype.getValue = function getValue () {
    return {
        classes: this._classes,
        styles: this._styles,
        attributes: this._attributes,
        content: this._content,
        id: this._attributes.id,
        tagName: this._tagName
    };
};

/**
 * Method to be invoked by the node as soon as an update occurs. This allows
 * the DOMElement renderable to dynamically react to state changes on the Node.
 *
 * This flushes the internal draw command queue by sending individual commands
 * to the node using `sendDrawCommand`.
 *
 * @method onUpdate
 */
DOMElement.prototype.onUpdate = function onUpdate () {
    var node = this._node;
    var queue = this._changeQueue;
    var len = queue.length;

    if (len && node) {
        node.sendDrawCommand('WITH');
        node.sendDrawCommand(node.getLocation());
        node.sendDrawCommand('DOM');

        while (len--) node.sendDrawCommand(queue.shift());
    }

    this._requestingUpdate = false;
};

/**
 * Method to be invoked by the Node as soon as the node (or any of its
 * ancestors) is being mounted.
 *
 * @method onMount
 * 
 * @param  {Node} node      Parent node to which the component should be added.
 * @param  {String} id      Path at which the component (or node) is being
 *                          attached. The path is being set on the actual
 *                          DOMElement as a `data-fa-path`-attribute.
 */
DOMElement.prototype.onMount = function onMount (node, id) {
    this._node = node;
    this._id = id;
    this._UIEvents = node.getUIEvents().slice(0);
    this.draw();
    this.setAttribute('data-fa-path', node.getLocation());
};

/**
 * Method to be invoked by the Node as soon as the node is being dismounted 
 * either directly or by dismounting one of its ancestors).
 *
 * @method onDismount
 */
DOMElement.prototype.onDismount = function onDismount () {
    this.setProperty('display', 'none');
    this.setAttribute('data-fa-path', '');
    this._initialized = false;
};

/**
 * Method to be invoked by the node as soon as the DOMElement is being shown.
 * This results into the DOMElement setting the `display` property to `block`
 * and therefore visually showing the corresponding DOMElement (again).
 *
 * @method onShow
 */
DOMElement.prototype.onShow = function onShow () {
    this.setProperty('display', 'block');
};

/**
 * Method to be invoked by the node as soon as the DOMElement is being hidden.
 * This results into the DOMElement setting the `display` property to `none`
 * and therefore visually hiding the corresponding DOMElement (again).
 *
 * @method onHide
 */
DOMElement.prototype.onHide = function onHide () {
    this.setProperty('display', 'none');
};

/**
 * Method to be invoked by the node as soon as the transform matrix associated
 * with the node changes.
 * The DOMElement will react to transform changes by sending `CHANGE_TRANSFORM`
 * commands to the `DOMRenderer`.
 *
 * @method onTransformChange
 * 
 * @param  {Float32Array} transform     The final transform matrix.
 */
DOMElement.prototype.onTransformChange = function onTransformChange (transform) {
    this._changeQueue.push('CHANGE_TRANSFORM');
    for (var i = 0, len = transform.length ; i < len ; i++)
        this._changeQueue.push(transform[i]);

    if (!this._requestingUpdate) this._requestUpdate();
};

/**
 * Method to be invoked by the node as soon as its computed size changes.
 * 
 * @method onSizeChange
 * @chainable
 * 
 * @param  {Float32Array} size      Absolute, pixel size.
 * @return {DOMElement} this
 */
DOMElement.prototype.onSizeChange = function onSizeChange (size) {
    var sizeMode = this._node.getSizeMode();
    var sizedX = sizeMode[0] !== RENDER_SIZE;
    var sizedY = sizeMode[1] !== RENDER_SIZE;
    if (this._initialized) 
        this._changeQueue.push('CHANGE_SIZE',
            sizedX ? size[0] : sizedX,
            sizedY ? size[1] : sizedY);

    if (!this._requestingUpdate) this._requestUpdate();
    return this;
};

/**
 * Method to be invoked by the node as soon as its opacity changes.
 * 
 * @method onOpacityChange
 * @chainable
 * 
 * @param  {Number} opacity      The new opacity, as a scalar from 0 to 1.
 * @return {DOMElement} this
 */
DOMElement.prototype.onOpacityChange = function onOpacityChange (opacity) {
    return this.setProperty('opacity', opacity);
};

/**
 * Method to be invoked by the node as soon as a new UIEvent is being added.
 * This results into an `ADD_EVENT_LISTENER` command being send.
 * 
 * @param  {String} UIEvent     UIEvent to be subscribed to (e.g. `click`).
 */
DOMElement.prototype.onAddUIEvent = function onAddUIEvent (UIEvent) {
    var index = this._UIEvents.indexOf(UIEvent);
    if (index === -1) {
        this._changeQueue.push('ADD_EVENT_LISTENER', UIEvent, void 0, true, 'EVENT_END');
        this._UIEvents.push(UIEvent);
    }
    if (!this._requestingUpdate) this._requestUpdate();
};

/**
 * Method to be invoked by the node as soon as the underlying size mode
 * changes. This results into the size being fetched from the node in
 * order to update the actual, rendered size.
 *
 * @method onSizeModeChange
 */
DOMElement.prototype.onSizeModeChange = function onSizeModeChange () {
    this.onSizeChange(this._node.getSize());
}; 

DOMElement.prototype._requestUpdate = function _requestUpdate () {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }
};

/**
 * Initializes the DOMElement by sending the `INIT_DOM` command. This creates
 * or reallocates a new Element in the actual DOM hierarchy.
 *
 * @method init
 */
DOMElement.prototype.init = function init () {
    this._changeQueue.push('INIT_DOM', this._tagName);
    this._initialized = true;
    this.onTransformChange(this._node.getTransform());
    this.onSizeChange(this._node.getSize());
    if (!this._requestingUpdate) this._requestUpdate();
};

/**
 * Sets the id attribute of the DOMElement.
 *
 * @method setId
 * @chainable
 *
 * @param {String} id   New id to be set.
 */
DOMElement.prototype.setId = function setId (id) {
    this.setAttribute('id', id);
    return this;
};

/**
 * Adds a new class to the internal class list of the underlying Element in the
 * DOM.
 *
 * @method addClass
 * @chainable
 * 
 * @param {String} value    New class name to be added.
 * @return {DOMElement} this
 */
DOMElement.prototype.addClass = function addClass (value) {
    if (this._classes.indexOf(value) < 0) {
        if (this._initialized) this._changeQueue.push('ADD_CLASS', value);
        this._classes.push(value);
        if (!this._requestingUpdate) this._requestUpdate();
        return this;
    }

    if (this._inDraw) {
        if (this._initialized) this._changeQueue.push('ADD_CLASS', value);
        if (!this._requestingUpdate) this._requestUpdate();
    }
    return this;
};

/**
 * Removes a class from the DOMElement's classList.
 *
 * @method removeClass
 * 
 * @param  {String} value       Class name to be removed.
 * @return {DOMElement} this
 */
DOMElement.prototype.removeClass = function removeClass (value) {
    var index = this._classes.indexOf(value);

    if (index < 0) return this;

    this._changeQueue.push('REMOVE_CLASS', value);

    this._classes.splice(index, 1);

    if (!this._requestingUpdate) this._requestUpdate();
    return this;
};

/**
 * Sets an attribute of the DOMElement.
 *
 * @method setAttribute
 * 
 * @param {String} name     Attribute key (e.g. `src`)
 * @param {String} value    Attribute value (e.g. `http://famo.us`)
 */
DOMElement.prototype.setAttribute = function setAttribute (name, value) {
    if (this._attributes[name] !== value || this._inDraw) {
        this._attributes[name] = value;
        if (this._initialized) this._changeQueue.push('CHANGE_ATTRIBUTE', name, value);
        if (!this._requestUpdate) this._requestUpdate();
    }
    return this;
};

/**
 * Sets a CSS property.
 *
 * @method setProperty
 * @chainable
 * 
 * @param {String} name  Name of the CSS rule (e.g. `background-color`).
 * @param {String} value Value of CSS property (e.g. `red`).
 * @return {DOMElement} this
 */
DOMElement.prototype.setProperty = function setProperty (name, value) {
    if (this._styles[name] !== value || this._inDraw) {
        this._styles[name] = value;
        if (this._initialized) this._changeQueue.push('CHANGE_PROPERTY', name, value);
        if (!this._requestingUpdate) this._requestUpdate();
    }
    return this;
};

/**
 * Sets the content of the DOMElement. This is using `innerHTML`, escaping user
 * generated content is therefore essential for security purposes.
 *
 * @method setContent
 * 
 * @param {String} content     Content to be set using `.innerHTML = ...`
 */
DOMElement.prototype.setContent = function setContent (content) {
    if (this._content !== content || this._inDraw) {
        this._content = content;
        if (this._initialized) this._changeQueue.push('CHANGE_CONTENT', content);
        if (!this._requestingUpdate) this._requestUpdate();
    }
    return this;
};

/**
 * Subscribes to a DOMElement using.
 *
 * @method on
 * 
 * @param  {String} event       The event type (e.g. `click`).
 * @param  {Function} listener  Handler function for the specified event type
 *                              in which the payload event object will be
 *                              passed into.
 */
DOMElement.prototype.on = function on (event, listener) {
    return this._callbacks.on(event, listener);
};

/**
 * Function to be invoked by the Node whenever an UIEvent is being received.
 * There are two different ways to subscribe for those events:
 *
 * 1. By overriding the onReceive method (and possibly using `switch` in order
 *     to differentiate between the different event types).
 * 2. By using @{@link DOMElement#on} and using the built-in
 *     @{@linkCallbackStore}.
 *
 * @method onReceive
 * 
 * @param  {String} event   Event type (e.g. `click`).
 * @param  {Object} payload Event object.
 */
DOMElement.prototype.onReceive = function onReceive (event, payload) {
    this._callbacks.trigger(event, payload);
};

/**
 * The draw function is being used in order to allow mutating the DOMElement
 * before actually mounting the corresponding node.
 *
 * @method draw
 * @private
 */
DOMElement.prototype.draw = function draw () {
    var key;
    var i;
    var len;

    this._inDraw = true;

    this.init();

    for (i = 0, len = this._classes.length ; i < len ; i++)
        this.addClass(this._classes[i]);

    this.setContent(this._content);

    for (key in this._styles) 
        if (this._styles[key])
            this.setProperty(key, this._styles[key]);

    for (key in this._attributes)
        if (this._attributes[key])
            this.setAttribute(key, this._attributes[key]);
    
    for (i = 0, len = this._UIEvents.length ; i < len ; i++)
        this._changeQueue.push('ADD_EVENT_LISTENER', this._UIEvents[i], void 0, true, 'EVENT_END');

    this._inDraw = false;
};

module.exports = DOMElement;


},{"famous-utilities":71}],76:[function(require,module,exports){
'use strict';

var DOMElement = require('./DOMElement');
var CallbackStore = require('famous-utilities').CallbackStore;

var WITH = 'WITH';
var CHANGE_TRANSFORM = 'CHANGE_TRANSFORM';
var CHANGE_PROPERTY = 'CHANGE_PROPERTY';
var INIT_DOM = 'INIT_DOM';
var CHANGE_ATTRIBUTE = 'CHANGE_ATTRIBUTE';
var ADD_CLASS = 'ADD_CLASS';
var REMOVE_CLASS = 'REMOVE_CLASS';
var CHANGE_ATTRIBUTE = 'CHANGE_ATTRIBUTE';
var CHANGE_CONTENT = 'CHANGE_CONTENT';
var ADD_EVENT_LISTENER = 'ADD_EVENT_LISTENER';
var EVENT_PROPERTIES = 'EVENT_PROPERTIES';
var EVENT_END = 'EVENT_END';
var RECALL = 'RECALL';

/**
 * The Element class is responsible for providing the API for how
 *   a RenderNode will interact with the DOM API's.  The element is
 *   responsible for adding a set of commands to the renderer.
 *
 * @class HTMLElement
 * @constructor
 * @component
 * @param {RenderNode} RenderNode to which the instance of Element will be a component of
 */
function HTMLElement(node, tagName) {
    console.warn("HTMLElement was depricated\n use DOMElement");
    return new DOMElement(node, tagName);
} 

module.exports = HTMLElement;

},{"./DOMElement":75,"famous-utilities":71}],77:[function(require,module,exports){
'use strict';

module.exports = {
    HTMLElement: require('./HTMLElement'),
    DOMElement: require('./DOMElement')
};

},{"./DOMElement":75,"./HTMLElement":76}],78:[function(require,module,exports){
// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
 
// requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel
 
// MIT license

'use strict';

var lastTime = 0;
var vendors = ['ms', 'moz', 'webkit', 'o'];

var rAF, cAF;

if (typeof window === 'object') {
    rAF = window.requestAnimationFrame;
    cAF = window.cancelAnimationFrame || window.cancelRequestAnimationFrame;
    for (var x = 0; x < vendors.length && !rAF; ++x) {
        rAF = window[vendors[x] + 'RequestAnimationFrame'];
        cAF = window[vendors[x] + 'CancelRequestAnimationFrame']
            || window[vendors[x] + 'CancelAnimationFrame'];
    }

    if (rAF && !cAF) {
        // cAF not supported.
        // Fall back to setInterval for now (very rare).
        rAF = null;
    }
}

var now = Date.now ? Date.now : function () {
    return new Date().getTime();
};

if (!rAF) {
    rAF = function(callback) {
        var currTime = now();
        var timeToCall = Math.max(0, 16 - (currTime - lastTime));
        var id = setTimeout(function () {
            callback(currTime + timeToCall);
        }, timeToCall);
        lastTime = currTime + timeToCall;
        return id;
    };

    cAF = function (id) {
        clearTimeout(id);
    };
}

module.exports = {
    requestAnimationFrame: rAF,
    cancelAnimationFrame: cAF
};

},{}],79:[function(require,module,exports){
'use strict';

module.exports = {
    requestAnimationFrame: require('./animationFrame').requestAnimationFrame,
    cancelAnimationFrame: require('./animationFrame').cancelAnimationFrame
};

},{"./animationFrame":78}],80:[function(require,module,exports){
'use strict';

var polyfills = require('famous-polyfills');
var rAF = polyfills.requestAnimationFrame;
var cAF = polyfills.cancelAnimationFrame;

var _now;
if (typeof performance !== 'undefined') {
    _now = function() {
        return performance.now();
    };
}
else {
    _now = Date.now;
}

if (typeof document !== 'undefined') {
    var VENDOR_HIDDEN, VENDOR_VISIBILITY_CHANGE;

    // Opera 12.10 and Firefox 18 and later support
    if (typeof document.hidden !== 'undefined') {
        VENDOR_HIDDEN = 'hidden';
        VENDOR_VISIBILITY_CHANGE = 'visibilitychange';
    }
    else if (typeof document.mozHidden !== 'undefined') {
        VENDOR_HIDDEN = 'mozHidden';
        VENDOR_VISIBILITY_CHANGE = 'mozvisibilitychange';
    }
    else if (typeof document.msHidden !== 'undefined') {
        VENDOR_HIDDEN = 'msHidden';
        VENDOR_VISIBILITY_CHANGE = 'msvisibilitychange';
    }
    else if (typeof document.webkitHidden !== 'undefined') {
        VENDOR_HIDDEN = 'webkitHidden';
        VENDOR_VISIBILITY_CHANGE = 'webkitvisibilitychange';
    }
}

/**
 * Engine class used for updating objects on a frame-by-frame. Synchronizes the
 * `update` method invocations to the refresh rate of the screen. Manages
 * the `requestAnimationFrame`-loop by normalizing the passed in timestamp
 * when switching tabs.
 * 
 * @class Engine
 * @constructor
 */
function Engine() {
    this._updates = [];
    var _this = this;
    this._looper = function(time) {
        _this.loop(time);
    };
    this._stoppedAt = _now();
    this._sleep = 0;
    this._startOnVisibilityChange = true;
    this._rAF = null;
    this.start();

    if (typeof document !== 'undefined') {
        document.addEventListener(VENDOR_VISIBILITY_CHANGE, function() {
            if (document[VENDOR_HIDDEN]) {
                cAF(this._rAF);
                var startOnVisibilityChange = _this._startOnVisibilityChange;
                _this.stop();
                _this._startOnVisibilityChange = startOnVisibilityChange;
            }
            else {
                if (_this._startOnVisibilityChange) {
                    _this.start();
                }
            }
        });
    }
}

/**
 * Starts the Engine.
 *
 * @method start
 * @chainable
 * 
 * @return {Engine} this
 */
Engine.prototype.start = function start() {
    if (!this._running) {
        this._startOnVisibilityChange = true;
        this._running = true;
        this._sleep += _now() - this._stoppedAt;
        this._rAF = rAF(this._looper);
    }
    return this;
};

/**
 * Stops the Engine.
 *
 * @method stop
 * @chainable
 * 
 * @return {Engine} this
 */
Engine.prototype.stop = function stop() {
    if (this._running) {
        this._startOnVisibilityChange = false;
        this._running = false;
        this._stoppedAt = _now();
        cAF(this._rAF);
    }
    return this;
};

/**
 * Determines whether the Engine is currently running or not.
 *
 * @method isRunning
 * 
 * @return {Boolean}    boolean value indicating whether the Engine is
 *                      currently running or not
 */
Engine.prototype.isRunning = function isRunning() {
    return this._running;
};

/**
 * Updates all registered objects.
 *
 * @method step
 * @chainable
 * 
 * @param  {Number} time high resolution timstamp used for invoking the
 *                       `update` method on all registered objects
 * @return {Engine}      this
 */
Engine.prototype.step = function step (time) {
    for (var i = 0, len = this._updates.length ; i < len ; i++) {
        this._updates[i].update(time);
    }
    return this;
};

/**
 * Method being called by `requestAnimationFrame` on every paint. Indirectly
 * recursive by scheduling a future invocation of itself on the next paint.
 *
 * @method loop
 * @chainable
 * 
 * @param  {Number} time high resolution timstamp used for invoking the
 *                       `update` method on all registered objects
 * @return {Engine}      this
 */
Engine.prototype.loop = function loop(time) {
    this.step(time - this._sleep);
    this._rAF = rAF(this._looper);
    return this;
};

/**
 * Registeres an updateable object which `update` method should be invoked on
 * every paint, starting on the next paint (assuming the Engine is running).
 *
 * @method update
 * @chainable
 * 
 * @param  {Object} updateable          object to be updated
 * @param  {Function} updateable.update update function to be called on the
 *                                      registered object
 * @return {Engine}                     this
 */
Engine.prototype.update = function update(updateable) {
    if (this._updates.indexOf(updateable) === -1) {
        this._updates.push(updateable);
    }
    return this;
};

/**
 * Deregisters an updateable object previously registered using `update` to be
 * no longer updated.
 *
 * @method noLongerUpdate
 * @chainable
 * 
 * @param  {Object} updateable          updateable object previously
 *                                      registered using `update`
 * @return {Engine}                     this
 */
Engine.prototype.noLongerUpdate = function noLongerUpdate(updateable) {
    var index = this._updates.indexOf(updateable);
    if (index > -1) {
        this._updates.splice(index, 1);
    }
    return this;
};

module.exports = Engine;

},{"famous-polyfills":79}],81:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],82:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./Mat33":81,"dup":12}],83:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"dup":13}],84:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"dup":14}],85:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./Mat33":81,"./Quaternion":82,"./Vec2":83,"./Vec3":84,"dup":15}],86:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],87:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./Mat33":86,"dup":12}],88:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"dup":13}],89:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"dup":14}],90:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./Mat33":86,"./Quaternion":87,"./Vec2":88,"./Vec3":89,"dup":15}],91:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],92:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],93:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"./Curves":91,"dup":21}],94:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],95:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"./Curves":91,"./Easing":92,"./Transitionable":93,"./after":94,"dup":23}],96:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24}],97:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25,"famous-transitions":95}],98:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26}],99:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27}],100:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"dup":28}],101:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"dup":29}],102:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],103:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"./CallbackStore":96,"./Color":97,"./KeyCodes":98,"./MethodStore":99,"./ObjectManager":100,"./clone":101,"./flatClone":102,"./keyValueToArrays":104,"./loadURL":105,"./strip":106,"dup":31}],104:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],105:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],106:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],107:[function(require,module,exports){
'use strict';

var Vec3 = require('famous-math').Vec3;
var Mat33 = require('famous-math').Mat33;

var ObjectManager = require('famous-utilities').ObjectManager;
ObjectManager.register('DynamicGeometry', DynamicGeometry);
ObjectManager.register('DynamicGeometryFeature', DynamicGeometryFeature);
var OMRequestDynamicGeometryFeature = ObjectManager.requestDynamicGeometryFeature;
var OMFreeDynamicGeometryFeature = ObjectManager.freeDynamicGeometryFeature;

var TRIPLE_REGISTER = new Vec3();

/**
 * The so called triple product. Used to find a vector perpendicular to (v2 - v1) in the direction of v3.
 * (v1 x v2) x v3.
 *
 * @method tripleProduct
 * @private
 * @param {Vec3} v1 The first Vec3.
 * @param {Vec3} v2 The second Vec3.
 * @param {Vec3} v3 The third Vec3.
 * @return {Vec3} The result of the triple product.
 */
function tripleProduct(v1, v2, v3) {
    var v = TRIPLE_REGISTER;

    Vec3.cross(v1, v2, v);
    Vec3.cross(v, v3, v);

    return v;
}

/**
 * Of a set of vertices, retrieves the vertex furthest in the given direction.
 *
 * @method _hullSupport
 * @private
 * @param {Vec3[]} vertices The reference set of Vec3's.
 * @param {Vec3} direction The direction to compare against.
 * @return {Object} The vertex and its index in the vertex array.
 */
function _hullSupport(vertices, direction) {
    var furthest;
    var max = -Infinity;
    var dot;
    var vertex;
    var index;
    for (var i = 0; i < vertices.length; i++) {
        vertex = vertices[i];
        dot = Vec3.dot(vertex, direction);
        if (dot > max) {
            furthest = vertex;
            max = dot;
            index = i;
        }
    }

    return {
        vertex: furthest,
        index: index
    };
}

var VEC_REGISTER = new Vec3();
var POINTCHECK_REGISTER = new Vec3();
var AO_REGISTER = new Vec3();
var AB_REGISTER = new Vec3();
var AC_REGISTER = new Vec3();
var AD_REGISTER = new Vec3();
var BC_REGISTER = new Vec3();
var BD_REGISTER = new Vec3();

/**
 * Used internally to represent polyhedral facet information.
 *
 * @class DynamicGeometryFeature
 * @param {Number} distance The distance of the feature from the origin.
 * @param {Vec3} normal The Vec3 orthogonal to the feature, pointing out of the geometry.
 * @param {Number[]} vertexIndices The indices of the vertices which compose the feature.
 */
function DynamicGeometryFeature(distance, normal, vertexIndices) {
    this.distance = distance;
    this.normal = normal;
    this.vertexIndices = vertexIndices;
}

/**
 * Used by ObjectManager to reset objects.
 *
 * @method reset
 * @param {Array} args Argument array analogous to that used in instantiation.
 * @chainable
 */
DynamicGeometryFeature.prototype.reset = function(distance, normal, vertexIndices) {
    this.distance = distance;
    this.normal = normal;
    this.vertexIndices = vertexIndices;

    return this;
};

/**
 * Abstract object representing a growing polyhedron. Used in ConvexHull and in GJK+EPA collision detection.
 *
 * @class DynamicGeometry
 */
function DynamicGeometry() {
    this.vertices = [];
    this.numVertices = 0;
    this.features = [];
    this.numFeatures = 0;
    this.lastVertexIndex = 0;

    this._IDPool = {
        vertices: [],
        features: []
    };
}

/**
 * Used by ObjectManager to reset objects.
 *
 * @method reset
 * @param {Array} args Argument array analogous to that used in instantiation.
 * @chainable
 */
DynamicGeometry.prototype.reset = function reset() {
    this.vertices = [];
    this.numVertices = 0;
    this.features = [];
    this.numFeatures = 0;
    this.lastVertexIndex = 0;

    this._IDPool = {
        vertices: [],
        features: []
    };

    return this;
};

/**
 * Add a vertex to the polyhedron.
 *
 * @method addVertex
 * @param {Object} vertexObj Object returned by the support function.
 */
DynamicGeometry.prototype.addVertex = function(vertexObj) {
    var index = this._IDPool.vertices.length ? this._IDPool.vertices.pop() : this.vertices.length;
    this.vertices[index] = vertexObj;
    this.lastVertexIndex = index;
    this.numVertices++;
};

/**
 * Remove a vertex and push its location in the vertex array to the IDPool for later use.
 *
 * @method removeVertex
 * @param {Number} index Index of the vertex to remove.
 */
DynamicGeometry.prototype.removeVertex = function(index) {
    var vertex = this.vertices[index];
    this.vertices[index] = null;
    this._IDPool.vertices.push(index);
    this.numVertices--;

    return vertex;
};

/**
 * Add a feature (facet) to the polyhedron. Used internally in the reshaping process.
 *
 * @method addFeature
 * @param {Number} distance The distance of the feature from the origin.
 * @param {Vec3} normal The facet normal.
 * @param {Number[]} vertexIndices The indices of the vertices which compose the feature.
 */
DynamicGeometry.prototype.addFeature = function(distance, normal, vertexIndices) {
    var index = this._IDPool.features.length ? this._IDPool.features.pop() : this.features.length;
    this.features[index] = OMRequestDynamicGeometryFeature().reset(distance, normal, vertexIndices);
    this.numFeatures++;
};

/**
 * Remove a feature and push its location in the feature array to the IDPool for later use.
 *
 * @method removeFeature
 * @param {Number} index Index of the feature to remove.
 */
DynamicGeometry.prototype.removeFeature = function(index) {
    var feature = this.features[index];
    this.features[index] = null;
    this._IDPool.features.push(index);
    this.numFeatures--;

    OMFreeDynamicGeometryFeature(feature);
};

/**
 * Retrieve the last vertex object added to the geometry.
 *
 * @method getLastVertex
 * @return {Object}
 */
DynamicGeometry.prototype.getLastVertex = function() {
    return this.vertices[this.lastVertexIndex];
};

/**
 * Of the closest face to the origin, returns the normal vector pointed away from the origin.
 *
 * @method getFeatureClosestToOrigin
 * @return {Object}
 */
DynamicGeometry.prototype.getFeatureClosestToOrigin = function() {
    var min = Infinity;
    var closest = null;
    var features = this.features;
    for (var i = 0, len = features.length; i < len; i++) {
        var feature = features[i];
        if (!feature) continue;
        if (feature.distance < min) {
            min = feature.distance;
            closest = feature;
        }
    }
    return closest;
};

/**
 * Adds edge if not already on the frontier, removes if the edge or its reverse are on the frontier.
 * Used when reshaping DynamicGeometry's.
 *
 * @method _validateEdge
 * @private
 * @param {Object[]} vertices Vec3 reference array.
 * @param {Number[][]} frontier Current edges potentially separating the features to remove from the persistant shape.
 * @param {Number} start The index of the starting Vec3 on the edge.
 * @param {Number} end The index of the culminating Vec3.
 */
function _validateEdge(vertices, frontier, start, end) {
    var e0 = vertices[start].vertex;
    var e1 = vertices[end].vertex;
    for (var i = 0, len = frontier.length; i < len; i++) {
        var edge = frontier[i];
        if (!edge) continue;
        var v0 = vertices[edge[0]].vertex;
        var v1 = vertices[edge[1]].vertex;
        if ((e0 === v0 && (e1 === v1)) || (e0 === v1 && (e1 === v0))) {
            frontier[i] = null;
            return;
        }
    }
    frontier.push([start, end]);
}

/**
 * Based on the last (exterior) point added to the polyhedron, removes features as necessary and redetermines
 * its (convex) shape to include the new point by adding triangle features. Uses referencePoint, a point on the shape's
 * interior, to ensure feature normals point outward, else takes referencePoint to be the origin.
 *
 * @method reshape
 * @param {Vec3} referencePoint Point known to be in the interior, used to orient feature normals.
 */
DynamicGeometry.prototype.reshape = function(referencePoint) {
    var vertices = this.vertices;
    var point = this.getLastVertex().vertex;
    var features = this.features;
    var vertexOnFeature;
    var featureVertices;

    var i, j, len;

    // The removal of features creates a hole in the polyhedron -- frontierEdges maintains the edges
    // of this hole, each of which will form one edge of a new feature to be created
    var frontierEdges = [];

    for (i = 0, len = features.length; i < len; i++) {
        if (!features[i]) continue;
        featureVertices = features[i].vertexIndices;
        vertexOnFeature = vertices[featureVertices[0]].vertex;
        // If point is 'above' the feature, remove that feature, and check to add its edges to the frontier.
        if (Vec3.dot(features[i].normal, Vec3.subtract(point, vertexOnFeature, POINTCHECK_REGISTER)) > -0.001) {
            _validateEdge(vertices, frontierEdges, featureVertices[0], featureVertices[1]);
            _validateEdge(vertices, frontierEdges, featureVertices[1], featureVertices[2]);
            _validateEdge(vertices, frontierEdges, featureVertices[2], featureVertices[0]);
            this.removeFeature(i);
        }
    }

    var A = point;
    var a = this.lastVertexIndex;
    for (j = 0, len = frontierEdges.length; j < len; j++) {
        if (!frontierEdges[j]) continue;
        var b = frontierEdges[j][0];
        var c = frontierEdges[j][1];
        var B = vertices[b].vertex;
        var C = vertices[c].vertex;

        var AB = Vec3.subtract(B, A, AB_REGISTER);
        var AC = Vec3.subtract(C, A, AC_REGISTER);
        var ABC = Vec3.cross(AB, AC, new Vec3());
        ABC.normalize();

        if (!referencePoint) {
            var distance = Vec3.dot(ABC, A);
            if (distance < 0) {
                ABC.invert();
                distance *= -1;
            }
            this.addFeature(distance, ABC, [a, b, c]);
        }
        else {
            var reference = Vec3.subtract(referencePoint, A, VEC_REGISTER);
            if (Vec3.dot(ABC, reference) > -0.001) ABC.invert();
            this.addFeature(null, ABC, [a, b, c]);
        }
    }
};

/**
 * Checks if the Simplex instance contains the origin, returns true or false.
 * If false, removes a point and, as a side effect, changes input direction to be both
 * orthogonal to the current working simplex and point toward the origin.
 * Calls callback on the removed point.
 *
 * @method simplexContainsOrigin
 * @param {Vec3} direction Vector used to store the new search direction.
 * @param {Function} callback Function invoked with the removed vertex, used e.g. to free the vertex object
 * in the object manager.
 * @return {Boolean} The result of the containment check.
 */
DynamicGeometry.prototype.simplexContainsOrigin = function(direction, callback) {
    var numVertices = this.vertices.length;

    var a = this.lastVertexIndex;
    var b = a - 1;
    var c = a - 2;
    var d = a - 3;

    b = b < 0 ? b + numVertices : b;
    c = c < 0 ? c + numVertices : c;
    d = d < 0 ? d + numVertices : d;

    var A = this.vertices[a].vertex;
    var B = this.vertices[b].vertex;
    var C = this.vertices[c].vertex;
    var D = this.vertices[d].vertex;

    var AO = Vec3.scale(A, -1, AO_REGISTER);
    var AB = Vec3.subtract(B, A, AB_REGISTER);
    var AC, AD, BC, BD;
    var ABC, ACD, ABD, BCD;
    var distanceABC, distanceACD, distanceABD, distanceBCD;

    var vertexToRemove;

    if (numVertices === 4) {
        // Tetrahedron
        AC = Vec3.subtract(C, A, AC_REGISTER);
        AD = Vec3.subtract(D, A, AD_REGISTER);

        ABC = Vec3.cross(AB, AC, new Vec3());
        ACD = Vec3.cross(AC, AD, new Vec3());
        ABD = Vec3.cross(AB, AD, new Vec3());
        ABC.normalize();
        ACD.normalize();
        ABD.normalize();
        if (Vec3.dot(ABC, AD) > 0) ABC.invert();
        if (Vec3.dot(ACD, AB) > 0) ACD.invert();
        if (Vec3.dot(ABD, AC) > 0) ABD.invert();
        // Don't need to check BCD because we would have just checked that in the previous iteration
        // -- we added A to the BCD triangle because A was in the direction of the origin.

        distanceABC = Vec3.dot(ABC, AO);
        distanceACD = Vec3.dot(ACD, AO);
        distanceABD = Vec3.dot(ABD, AO);

        // Norms point away from origin -> origin is inside tetrahedron
        if (distanceABC < 0.001 && distanceABD < 0.001 && distanceACD < 0.001) {
            BC = Vec3.subtract(C, B, BC_REGISTER);
            BD = Vec3.subtract(D, B, BD_REGISTER);
            BCD = Vec3.cross(BC, BD, new Vec3());
            BCD.normalize();
            if (Vec3.dot(BCD, AB) <= 0) BCD.invert();
            distanceBCD = -1 * Vec3.dot(BCD,B);
            // Prep features for EPA
            this.addFeature(-distanceABC, ABC, [a,b,c]);
            this.addFeature(-distanceACD, ACD, [a,c,d]);
            this.addFeature(-distanceABD, ABD, [a,d,b]);
            this.addFeature(-distanceBCD, BCD, [b,c,d]);
            return true;
        }
        else if (distanceABC >= 0.001) {
            vertexToRemove = this.removeVertex(d);
            direction.copy(ABC);
        }
        else if (distanceACD >= 0.001) {
            vertexToRemove = this.removeVertex(b);
            direction.copy(ACD);
        }
        else {
            vertexToRemove = this.removeVertex(c);
            direction.copy(ABD);
        }
    }
    else if (numVertices === 3) {
        // Triangle
        AC = Vec3.subtract(C, A, AC_REGISTER);
        Vec3.cross(AB, AC, direction);
        if (Vec3.dot(direction, AO) <= 0) direction.invert();
    }
    else {
        // Line
        direction.copy(tripleProduct(AB, AO, AB));
    }
    if (vertexToRemove && callback) callback(vertexToRemove);
    return false;
};

/**
 * Given an array of Vec3's, computes the convex hull. Used in constructing bodies in the physics system and to
 * create custom GL meshes.
 *
 * @class ConvexHull
 * @constructor
 * @param {Vec3[]} vertices Cloud of vertices of which the enclosing convex hull is desired.
 * @param {Number} [iterations = 1e3] Maximum number of vertices to compose the convex hull.
 */
function ConvexHull(vertices, iterations) {
    iterations = iterations || 1e3;
    var hull = _computeConvexHull(vertices, iterations);

    var i, len;

    var indices = [];
    for (i = 0, len = hull.features.length; i < len; i++) {
        var f = hull.features[i];
        if (f) indices.push(f.vertexIndices);
    }

    var polyhedralProperties = _computePolyhedralProperties(hull.vertices, indices);
    var centroid = polyhedralProperties.centroid;

    var worldVertices = [];
    for (i = 0, len = hull.vertices.length; i < len; i++) {
        worldVertices.push(Vec3.subtract(hull.vertices[i].vertex, centroid, new Vec3()));
    }

    var normals = [];
    for (i = 0, len = worldVertices.length; i < len; i++) {
        normals.push(Vec3.normalize(worldVertices[i], new Vec3()));
    }

    var graph = {};
    var _neighborMatrix = {};
    for (i = 0; i < indices.length; i++) {
        var a = indices[i][0];
        var b = indices[i][1];
        var c = indices[i][2];

        _neighborMatrix[a] = _neighborMatrix[a] || {};
        _neighborMatrix[b] = _neighborMatrix[b] || {};
        _neighborMatrix[c] = _neighborMatrix[c] || {};

        graph[a] = graph[a] || [];
        graph[b] = graph[b] || [];
        graph[c] = graph[c] || [];

        if (!_neighborMatrix[a][b]) {
            _neighborMatrix[a][b] = 1;
            graph[a].push(b);
        }
        if (!_neighborMatrix[a][c]) {
            _neighborMatrix[a][c] = 1;
            graph[a].push(c);
        }
        if (!_neighborMatrix[b][a]) {
            _neighborMatrix[b][a] = 1;
            graph[b].push(a);
        }
        if (!_neighborMatrix[b][c]) {
            _neighborMatrix[b][c] = 1;
            graph[b].push(c);
        }
        if (!_neighborMatrix[c][a]) {
            _neighborMatrix[c][a] = 1;
            graph[c].push(a);
        }
        if (!_neighborMatrix[c][b]) {
            _neighborMatrix[c][b] = 1;
            graph[c].push(b);
        }
    }

    this.indices = indices;
    this.vertices = worldVertices;
    this.normals = normals;
    this.polyhedralProperties = polyhedralProperties;
    this.graph = graph;
}

/**
 * Performs the actual computation of the convex hull.
 *
 * @method _computeConvexHull
 * @private
 * @param {Vec3[]} vertices Cloud of vertices of which the enclosing convex hull is desired.
 * @param {Number} maxIterations Maximum number of vertices to compose the convex hull.
 * @return {DynamicGeometry} The computed hull.
 */
function _computeConvexHull(vertices, maxIterations) {
    var hull = new DynamicGeometry();

    hull.addVertex(_hullSupport(vertices, new Vec3(1, 0, 0)));
    hull.addVertex(_hullSupport(vertices, new Vec3(-1, 0, 0)));
    var A = hull.vertices[0].vertex;
    var B = hull.vertices[1].vertex;
    var AB = Vec3.subtract(B, A, AB_REGISTER);

    var dot;
    var vertex;
    var furthest;
    var index;
    var i, len;

    var max = -Infinity;
    for (i = 0; i < vertices.length; i++) {
        vertex = vertices[i];
        if (vertex === A || vertex === B) continue;
        var AV = Vec3.subtract(vertex, A, VEC_REGISTER);
        dot = Vec3.dot(AV, tripleProduct(AB, AV, AB));
        dot = dot < 0 ? dot * -1 : dot;
        if (dot > max) {
            max = dot;
            furthest = vertex;
            index = i;
        }
    }
    hull.addVertex({
        vertex: furthest,
        index: index
    });

    var C = furthest;
    var AC = Vec3.subtract(C, A, AC_REGISTER);
    var ABC = Vec3.cross(AB, AC, new Vec3());
    ABC.normalize();

    max = -Infinity;
    for (i = 0; i < vertices.length; i++) {
        vertex = vertices[i];
        if (vertex === A || vertex === B || vertex === C) continue;
        dot = Vec3.dot(Vec3.subtract(vertex, A, VEC_REGISTER), ABC);
        dot = dot < 0 ? dot * -1 : dot;
        if (dot > max) {
            max = dot;
            furthest = vertex;
            index = i;
        }
    }
    hull.addVertex({
        vertex: furthest,
        index: index
    });

    var D = furthest;
    var AD = Vec3.subtract(D, A, AD_REGISTER);
    var BC = Vec3.subtract(C, B, BC_REGISTER);
    var BD = Vec3.subtract(D, B, BD_REGISTER);

    var ACD = Vec3.cross(AC, AD, new Vec3());
    var ABD = Vec3.cross(AB, AD, new Vec3());
    var BCD = Vec3.cross(BC, BD, new Vec3());
    ACD.normalize();
    ABD.normalize();
    BCD.normalize();
    if (Vec3.dot(ABC, AD) > 0) ABC.invert();
    if (Vec3.dot(ACD, AB) > 0) ACD.invert();
    if (Vec3.dot(ABD, AC) > 0) ABD.invert();
    if (Vec3.dot(BCD, AB) < 0) BCD.invert();

    var a = 0;
    var b = 1;
    var c = 2;
    var d = 3;

    hull.addFeature(null, ABC, [a, b, c]);
    hull.addFeature(null, ACD, [a, c, d]);
    hull.addFeature(null, ABD, [a, b, d]);
    hull.addFeature(null, BCD, [b, c, d]);

    var assigned = {};
    for (i = 0, len = hull.vertices.length; i < len; i++) {
       assigned[hull.vertices[i].index] = true;
    }


    var cx = A.x + B.x + C.x + D.x;
    var cy = A.y + B.y + C.y + D.y;
    var cz = A.z + B.z + C.z + D.z;
    var referencePoint = new Vec3(cx, cy, cz);
    referencePoint.scale(0.25);

    var features = hull.features;
    var iteration = 0;
    while (iteration++ < maxIterations) {
        var currentFeature = null;
        for (i = 0, len = features.length; i < len; i++) {
            if (!features[i] || features[i].done) continue;
            currentFeature = features[i];
            furthest = null;
            index = null;
            A = hull.vertices[currentFeature.vertexIndices[0]].vertex;
            var s = _hullSupport(vertices, currentFeature.normal);
            furthest = s.vertex;
            index = s.index;
            var dist = Vec3.dot(Vec3.subtract(furthest, A, VEC_REGISTER), currentFeature.normal);

            if (dist < 0.001 || assigned[index]) {
                currentFeature.done = true;
                continue;
            }

            assigned[index] = true;
            hull.addVertex(s);
            hull.reshape(referencePoint);
        }
            // No feature has points 'above' it -> finished
        if (currentFeature === null) break;
    }

    return hull;
}

/**
 * Helper function used in _computePolyhedralProperties.
 * Sets f0 - f2 and g0 - g2 depending on w0 - w2.
 *
 * @method _subexpressions
 * @private
 * @param {Number} w0 Reference x coordinate.
 * @param {Number} w1 Reference y coordinate.
 * @param {Number} w2 Reference z coordinate.
 * @param {Number[]} f One of two output registers to contain the result of the calculation.
 * @param {Number[]} g One of two output registers to contain the result of the calculation.
 */
function _subexpressions(w0, w1, w2, f, g) {
    var t0 = w0 + w1;
    f[0] = t0 + w2;
    var t1 = w0 * w0;
    var t2 = t1 + w1 * t0;
    f[1] = t2 + w2 * f[0];
    f[2] = w0 * t1 + w1 * t2 + w2 * f[1];
    g[0] = f[1] + w0 * (f[0] + w0);
    g[1] = f[1] + w1 * (f[0] + w1);
    g[2] = f[1] + w2 * (f[0] + w2);
}

/**
 * Determines various properties of the volume.
 *
 * @method _computePolyhedralProperties
 * @private
 * @param {Vec3[]} vertices The vertices of the polyhedron.
 * @param {Number[][]} indices Array of arrays of indices of vertices composing the triangular features of the polyhedron,
 * one array for each feature.
 * @return {Object} Object holding the calculated span, volume, center, and euler tensor.
 */
function _computePolyhedralProperties(vertices, indices) {
    // Order: 1, x, y, z, x^2, y^2, z^2, xy, yz, zx
    var integrals = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    var fx = [];
    var fy = [];
    var fz = [];
    var gx = [];
    var gy = [];
    var gz = [];

    var i, len;

    for (i = 0, len = indices.length; i < len; i++) {
        var A = vertices[indices[i][0]].vertex;
        var B = vertices[indices[i][1]].vertex;
        var C = vertices[indices[i][2]].vertex;
        var AB = Vec3.subtract(B, A, AB_REGISTER);
        var AC = Vec3.subtract(C, A, AC_REGISTER);
        var ABC = AB.cross(AC);
        if (Vec3.dot(A, ABC) < 0) ABC.invert();

        var d0 = ABC.x;
        var d1 = ABC.y;
        var d2 = ABC.z;

        var x0 = A.x;
        var y0 = A.y;
        var z0 = A.z;
        var x1 = B.x;
        var y1 = B.y;
        var z1 = B.z;
        var x2 = C.x;
        var y2 = C.y;
        var z2 = C.z;

        _subexpressions(x0, x1, x2, fx, gx);
        _subexpressions(y0, y1, y2, fy, gy);
        _subexpressions(z0, z1, z2, fz, gz);

        integrals[0] += d0 * fx[0];
        integrals[1] += d0 * fx[1];
        integrals[2] += d1 * fy[1];
        integrals[3] += d2 * fz[1];
        integrals[4] += d0 * fx[2];
        integrals[5] += d1 * fy[2];
        integrals[6] += d2 * fz[2];
        integrals[7] += d0 * (y0 * gx[0] + y1 * gx[1] + y2 * gx[2]);
        integrals[8] += d1 * (z0 * gy[0] + z1 * gy[1] + z2 * gy[2]);
        integrals[9] += d2 * (x0 * gz[0] + x1 * gz[1] + x2 * gz[2]);
    }

    integrals[0] /= 6;
    integrals[1] /= 24;
    integrals[2] /= 24;
    integrals[3] /= 24;
    integrals[4] /= 60;
    integrals[5] /= 60;
    integrals[6] /= 60;
    integrals[7] /= 120;
    integrals[8] /= 120;
    integrals[9] /= 120;

    var minX = Infinity, maxX = -Infinity;
    var minY = Infinity, maxY = -Infinity;
    var minZ = Infinity, maxZ = -Infinity;

    for (i = 0, len = vertices.length; i < len; i++) {
        var vertex = vertices[i].vertex;
        if (vertex.x < minX) minX = vertex.x;
        if (vertex.x > maxX) maxX = vertex.x;
        if (vertex.y < minY) minY = vertex.y;
        if (vertex.y > maxY) maxY = vertex.y;
        if (vertex.z < minZ) minZ = vertex.z;
        if (vertex.z > maxZ) maxZ = vertex.z;
    }

    var size = [maxX - minX, maxY - minY, maxZ - minZ];
    var volume = integrals[0];
    var centroid = new Vec3(integrals[1], integrals[2], integrals[3]);
    centroid.scale(1 / volume);

    var eulerTensor = new Mat33([
                                  integrals[4], integrals[7], integrals[9],
                                  integrals[7], integrals[5], integrals[8],
                                  integrals[9], integrals[8], integrals[6]
                                 ]);

    return {
        size: size,
        volume: volume,
        centroid: centroid,
        eulerTensor: eulerTensor
    };
}

module.exports = {
    DynamicGeometry: DynamicGeometry,
    ConvexHull: ConvexHull
};

},{"famous-math":90,"famous-utilities":103}],108:[function(require,module,exports){
'use strict';

var Particle = require('./bodies/Particle');
var Constraint = require('./constraints/Constraint');
var Force = require('./forces/Force');

var Vec3 = require('famous-math').Vec3;
var Quaternion = require('famous-math').Quaternion;

var VEC_REGISTER = new Vec3();
var ZYX_REGISTER = new Vec3();
var QUAT_REGISTER = new Quaternion();
var DELTA_REGISTER = new Vec3();

/**
 * Singleton PhysicsEngine object.
 * Manages bodies, forces, constraints.
 *
 * @class PhysicsEngine
 * @param {Object} options A hash of configurable options.
 */
function PhysicsEngine(options) {
    options = options || {};
    /** @prop bodies The bodies currently active in the engine. */
    this.bodies = [];
    /** @prop forces The forces currently active in the engine. */
    this.forces = [];
    /** @prop constraints The constraints currently active in the engine. */
    this.constraints = [];

    /** @prop step The time between frames in the engine. */
    this.step = options.step || 1000/60;
    /** @prop iterations The number of times each constraint is solved per frame. */
    this.iterations = options.iterations || 10;
    /** @prop _indexPool Pools of indicies to track holes in the arrays. */
    this._indexPools = {
        bodies: [],
        forces: [],
        constraints: []
    };

    this._entityMaps = {
        bodies: {},
        forces: {},
        constraints: {}
    };

    this.speed = options.speed || 1.0;
    this.time = 0;
    this.delta = 0;

    this.origin = options.origin || new Vec3();
    this.orientation = options.orientation ? options.orientation.normalize() :  new Quaternion();

    this.prestep = [];
    this.poststep = [];

    this.frameDependent = options.frameDependent || false;

    this.transformBuffers = {
        position: [0, 0, 0],
        rotation: [0, 0, 0]
    };
}

/**
 * Set the origin of the world.
 *
 * @method setOrigin
 * @chainable
 * @param {Number} x The x component.
 * @param {Number} y The y component.
 * @param {Number} z The z component.
 */
PhysicsEngine.prototype.setOrigin = function setOrigin(x, y, z) {
    this.origin.set(x, y, z);
    return this;
};

/**
 * Set the orientation of the world.
 *
 * @method setOrientation
 * @chainable
 * @param {Number} w The w component.
 * @param {Number} x The x component.
 * @param {Number} y The y component.
 * @param {Number} z The z component.
 */
PhysicsEngine.prototype.setOrientation = function setOrientation(w, x, y, z) {
    this.orientation.set(w, x, y, z).normalize();
    return this;
};

/**
 * Private helper method to store an element in a library array.
 *
 * @method _addElement
 * @private
 * @param {Object} element The body, force, or constraint to add.
 * @param {String} key Where to store the element.
 */
function _addElement(context, element, key) {
    var map = context._entityMaps[key];
    if (map[element._ID] == null) {
        var library = context[key];
        var indexPool = context._indexPools[key];
        if (indexPool.length) map[element._ID] = indexPool.pop();
        else map[element._ID] = library.length;
        library[map[element._ID]] = element;
    }
}

/**
 * Private helper method to remove an element from a library array.
 *
 * @method _removeElement
 * @private
 * @param {Object} element The body, force, or constraint to remove.
 * @param {String} key Where to store the element.
 */
function _removeElement(context, element, key) {
    var map = context._entityMaps[key];
    var index = map[element._ID];
    if (index != null) {
        context._indexPools[key].push(index);
        context[key][index] = null;
        map[element._ID] = null;
    }
}

/**
 * Add a group of bodies, force, or constraints to the engine.
 *
 * @method add
 * @chainable
 */
PhysicsEngine.prototype.add = function add() {
    for (var j = 0, lenj = arguments.length; j < lenj; j++) {
        var entity = arguments[j];
        if (entity instanceof Array) {
            for (var i = 0, len = entity.length; i < len; i++) {
                var e = entity[i];
                this.add(e);
            }
        } else {
            if (entity instanceof Particle) this.addBody(entity);
            else if (entity instanceof Constraint) this.addConstraint(entity);
            else if (entity instanceof Force) this.addForce(entity);
        }
    }
    return this;
};

/**
 * Remove a group of bodies, force, or constraints from the engine.
 *
 * @method remove
 * @chainable
 */
PhysicsEngine.prototype.remove = function remove() {
    for (var j = 0, lenj = arguments.length; j < lenj; j++) {
        var entity = arguments[j];
        if (entity instanceof Array) {
            for (var i = 0, len = entity.length; i < len; i++) {
                var e = entity[i];
                this.add(e);
            }
        } else {
            if (entity instanceof Particle) this.removeBody(entity);
            else if (entity instanceof Constraint) this.removeConstraint(entity);
            else if (entity instanceof Force) this.removeForce(entity);
        }
    }
    return this;
};

/**
 * Begin tracking a body.
 *
 * @method addBody
 * @param {Particle} body The body to track.
 */
PhysicsEngine.prototype.addBody = function addBody(body) {
    _addElement(this, body, 'bodies');
};

/**
 * Begin tracking a force.
 *
 * @method addForce
 * @param {Force} force The force to track.
 */
PhysicsEngine.prototype.addForce = function addForce(force) {
    _addElement(this, force, 'forces');
};

/**
 * Begin tracking a constraint.
 *
 * @method addConstraint
 * @param {Constraint} constraint The constraint to track.
 */
PhysicsEngine.prototype.addConstraint = function addConstraint(constraint) {
    _addElement(this, constraint, 'constraints');
};

/**
 * Stop tracking a body.
 *
 * @method removeBody
 * @param {Particle} body The body to stop tracking.
 */
PhysicsEngine.prototype.removeBody = function removeBody(body) {
    _removeElement(this, body, 'bodies');
};

/**
 * Stop tracking a force.
 *
 * @method removeForce
 * @param {Force} force The force to stop tracking.
 */
PhysicsEngine.prototype.removeForce = function removeForce(force) {
    _removeElement(this, force, 'forces');
};

/**
 * Stop tracking a constraint.
 *
 * @method removeConstraint
 * @param {Constraint} constraint The constraint to stop tracking.
 */
PhysicsEngine.prototype.removeConstraint = function removeConstraint(constraint) {
    _removeElement(this, constraint, 'constraints');
};

/**
 * Update the physics system to reflect the changes since the last frame. Steps forward in increments of
 * PhysicsEngine.step.
 *
 * @method update
 * @param {Number} time
 */
PhysicsEngine.prototype.update = function update(time) {
    if (this.time === 0) this.time = time;

    var bodies = this.bodies;
    var forces = this.forces;
    var constraints = this.constraints;

    var frameDependent = this.frameDependent;
    var step = this.step;
    var dt = step * 0.001;
    var speed = this.speed;

    var delta = this.delta;
    delta += (time - this.time) * speed;
    this.time = time;

    var i, len;
    var force, body, constraint;

    while(delta > step) {
        for (i = 0, len = this.prestep.length; i < len; i++) {
            this.prestep[i](time, dt);
        }

        // Update Forces on particles
        for (i = 0, len = forces.length; i < len; i++) {
            force = forces[i];
            if (force === null) continue;
            force.update(time, dt);
        }

        // Tentatively update velocities
        for (i = 0, len = bodies.length; i < len; i++) {
            body = bodies[i];
            if (body === null) continue;
            _integrateVelocity(body, dt);
        }

        // Prep constraints for solver
        for (i = 0, len = constraints.length; i < len; i++) {
            constraint = constraints[i];
            if (constraint === null) continue;
            constraint.update(time, dt);
        }

        // Iteratively resolve constraints
        for (var j = 0, numIterations = this.iterations; j < numIterations; j++) {
            for (i = 0, len = constraints.length; i < len; i++) {
                constraint = constraints[i];
                if (constraint === null) continue;
                constraint.resolve(time, dt);
            }
        }

        // Increment positions and orientations
        for (i = 0, len = bodies.length; i < len; i++) {
            body = bodies[i];
            if (body === null) continue;
            _integratePose(body, dt);
        }

        for (i = 0, len = this.poststep.length; i < len; i++) {
            this.poststep[i](time, dt);
        }

        if (frameDependent) delta = 0;
        else delta -= step;
    }

    this.delta = delta;
};

/**
 * Get the transform equivalent to the Particle's position and orientation.
 *
 * @method getTransform
 * @return {Object} Position and rotation of the boy, taking into account
 * the origin and orientation of the world.
 */
PhysicsEngine.prototype.getTransform = function getTransform(body) {
    var o = this.origin;
    var oq = this.orientation;
    var transform = this.transformBuffers;

    var p = body.position;
    var q = body.orientation;
    var rot = q;
    var loc = p;

    if (oq.w !== 1) {
        rot = Quaternion.multiply(q, oq, QUAT_REGISTER);
        loc = oq.rotateVector(p, VEC_REGISTER);
    }
    var ZYX = rot.toEuler(ZYX_REGISTER);

    transform.position[0] = o.x+loc.x;
    transform.position[1] = o.y+loc.y;
    transform.position[2] = o.z+loc.z;

    transform.rotation[0] = ZYX.x;
    transform.rotation[1] = ZYX.y;
    transform.rotation[2] = ZYX.z;

    return transform;
};

/**
 * Update the Particle momenta based off of current incident force and torque.
 *
 * @method _integrateVelocity
 * @private
 * @param {Particle} body
 * @param {Number} dt delta time
 */
function _integrateVelocity(body, dt) {
    body.momentum.add(Vec3.scale(body.force, dt, DELTA_REGISTER));
    body.angularMomentum.add(Vec3.scale(body.torque, dt, DELTA_REGISTER));
    Vec3.scale(body.momentum, body.inverseMass, body.velocity);
    body.inverseInertia.vectorMultiply(body.angularMomentum, body.angularVelocity);
    body.force.clear();
    body.torque.clear();
}

/**
 * Update the Particle position and orientation based off current translational and angular velocities.
 *
 * @method _integratePose
 * @private
 * @param {Particle} body
 * @param dt {Number} delta time
 */
function _integratePose(body, dt) {
    if (body.restrictions !== 0) {
        var restrictions = body.restrictions;
        var x = null;
        var y = null;
        var z = null;
        var ax = null;
        var ay = null;
        var az = null;

        if (restrictions & 32) x = 0;
        if (restrictions & 16) y = 0;
        if (restrictions & 8) z = 0;
        if (restrictions & 4) ax = 0;
        if (restrictions & 2) ay = 0;
        if (restrictions & 1) az = 0;

        if (x !== null || y !== null || z !== null) body.setVelocity(x,y,z);
        if (ax !== null || ay !== null || az !== null) body.setAngularVelocity(ax, ay, az);
    }

    body.position.add(Vec3.scale(body.velocity, dt, DELTA_REGISTER));

    var w = body.angularVelocity;
    var q = body.orientation;
    var wx = w.x;
    var wy = w.y;
    var wz = w.z;

    var qw = q.w;
    var qx = q.x;
    var qy = q.y;
    var qz = q.z;

    var hdt = dt * 0.5;
    q.w += (-wx * qx - wy * qy - wz * qz) * hdt;
    q.x += (wx * qw + wy * qz - wz * qy) * hdt;
    q.y += (wy * qw + wz * qx - wx * qz) * hdt;
    q.z += (wz * qw + wx * qy - wy * qx) * hdt;

    q.normalize();

    body.updateInertia();
}

module.exports = PhysicsEngine;

},{"./bodies/Particle":111,"./constraints/Constraint":116,"./forces/Force":128,"famous-math":90}],109:[function(require,module,exports){
'use strict';

var Vec3 = require('famous-math').Vec3;
var ConvexBodyFactory = require('./ConvexBodyFactory');

var _Box = ConvexBodyFactory([
            // Order: back-left,back-right,front-left,front-right
            // Top half
            new Vec3(-100, -100, -100),
            new Vec3(100, -100, -100),
            new Vec3(-100, -100, 100),
            new Vec3(100, -100, 100),
            // Bottom half
            new Vec3(-100, 100, -100),
            new Vec3(100, 100, -100),
            new Vec3(-100, 100, 100),
            new Vec3(100, 100, 100),
        ]);

/**
 * @class Box
 * @extends Particle
 * @param {Object} options
 */
function Box(options) {
    _Box.call(this, options);
    this.normals = [
        // Order: top, right, front
        new Vec3(0, 1, 0),
        new Vec3(1, 0, 0),
        new Vec3(0, 0, 1)
    ];

    this.type = 1 << 1;
}

Box.prototype = Object.create(_Box.prototype);
Box.prototype.constructor = Box;

module.exports = Box;

},{"./ConvexBodyFactory":110,"famous-math":90}],110:[function(require,module,exports){
'use strict';

var Particle = require('../bodies/Particle');
var Mat33 = require('famous-math').Mat33;
var Vec3 = require('famous-math').Vec3;
var Geometry = require('../Geometry');
var ConvexHull = Geometry.ConvexHull;

var TEMP_REGISTER = new Vec3();

/**
 * Returns a constructor for a physical body reflecting the shape defined by input ConvexHull or Vec3 array.
 *
 * @method ConvexBodyFactory
 * @param {ConvexHull | Vec3[]} hull
 * @return {Function} The constructor.
 */
function ConvexBodyFactory(hull) {
    if (!(hull instanceof ConvexHull)) {
        if (!(hull instanceof Array)) throw new Error('ConvexBodyFactory requires a ConvexHull object or an array of Vec3\'s as input.');
        else hull = new ConvexHull(hull);
    }

    /**
     * The body class with inertia and vertices inferred from the input ConvexHull or Vec3 array.
     *
     * @class ConvexBody
     * @param {Object} options The options hash.
     */
    function ConvexBody(options) {
        Particle.call(this, options);

        var originalSize = hull.polyhedralProperties.size;
        var size = options.size || originalSize;

        var scaleX = size[0] / originalSize[0];
        var scaleY = size[1] / originalSize[1];
        var scaleZ = size[2] / originalSize[2];

        this._scale = [scaleX, scaleY, scaleZ];

        var T = new Mat33([scaleX, 0, 0, 0, scaleY, 0, 0, 0, scaleZ]);

        this.hull = hull;

        this.vertices = [];
        for (var i = 0, len = hull.vertices.length; i < len; i++) {
            this.vertices.push(T.vectorMultiply(hull.vertices[i], new Vec3()));
        }

        _computeInertiaProperties.call(this, T);
        this.inverseInertia.copy(this.localInverseInertia);
        this.updateInertia();
    }

    ConvexBody.prototype = Object.create(Particle.prototype);
    ConvexBody.prototype.constructor = ConvexBody;

    /**
     * Set the size and recalculate
     *
     * @method setSize
     * @chainable
     * @param {Number} x The x span.
     * @param {Number} y The y span.
     * @param {Number} z The z span.
     */
    ConvexBody.prototype.setSize = function setSize(x,y,z) {
        var originalSize = hull.polyhedralProperties.size;

        this.size[0] = x;
        this.size[1] = y;
        this.size[2] = z;

        var scaleX = x / originalSize[0];
        var scaleY = y / originalSize[1];
        var scaleZ = z / originalSize[2];

        this._scale = [scaleX, scaleY, scaleZ];

        var T = new Mat33([scaleX, 0, 0, 0, scaleY, 0, 0, 0, scaleZ]);

        var vertices = this.vertices;
        for (var i = 0, len = hull.vertices.length; i < len; i++) {
            T.vectorMultiply(hull.vertices[i], vertices[i]);
        }

        return this;
    };

    /**
     * Update the local inertia and inverse inertia to reflect the current size.
     *
     * @method updateLocalInertia
     * @chainable
     */
    ConvexBody.prototype.updateLocalInertia = function updateInertia() {
        var scaleX = this._scale[0];
        var scaleY = this._scale[1];
        var scaleZ = this._scale[2];

        var T = new Mat33([scaleX, 0, 0, 0, scaleY, 0, 0, 0, scaleZ]);

        _computeInertiaProperties.call(this, T);

        return this;
    };

    /**
     * Retrieve the vertex furthest in a direction. Used internally for collision detection.
     *
     * @method support
     * @return {Vec3} The furthest vertex.
     */
    ConvexBody.prototype.support = function support(direction) {
        var vertices = this.vertices;
        var vertex, dot, furthest;
        var max = -Infinity;
        for (var i = 0, len = vertices.length; i < len; i++) {
            vertex = vertices[i];
            dot = Vec3.dot(vertex,direction);
            if (dot > max) {
                furthest = vertex;
                max = dot;
            }
        }
        return furthest;
    };

    /**
     * Update vertices to reflect current orientation.
     *
     * @method updateShape
     * @chainable
     */
    ConvexBody.prototype.updateShape = function updateShape() {
        var vertices = this.vertices;
        var q = this.orientation;
        var modelVertices = this.hull.vertices;

        var scaleX = this._scale[0];
        var scaleY = this._scale[1];
        var scaleZ = this._scale[2];

        var t = TEMP_REGISTER;
        for (var i = 0, len = vertices.length; i < len; i++) {
            t.copy(modelVertices[i]);
            t.x *= scaleX;
            t.y *= scaleY;
            t.z *= scaleZ;
            Vec3.applyRotation(t, q, vertices[i]);
        }

        return this;
    };

    return ConvexBody;
}

/**
 * Determines mass and inertia tensor based off the density, size, and facet information of the polyhedron.
 *
 * @method _computeInertiaProperties
 * @private
 * @param {Mat33} T The matrix transforming the intial set of vertices to a set reflecting the body size.
 */
function _computeInertiaProperties(T) {
    var polyhedralProperties = this.hull.polyhedralProperties;
    var T_values = T.get();
    var detT = T_values[0] * T_values[4] * T_values[8];

    var E_o = polyhedralProperties.eulerTensor;

    var E = new Mat33();
    Mat33.multiply(T, E_o, E);
    Mat33.multiply(E, T, E);
    var E_values = E.get();

    var Exx = E_values[0];
    var Eyy = E_values[4];
    var Ezz = E_values[8];
    var Exy = E_values[1];
    var Eyz = E_values[7];
    var Exz = E_values[2];

    var newVolume = polyhedralProperties.volume * detT;
    var mass = this.mass;
    var density = mass / newVolume;

    var Ixx = Eyy + Ezz;
    var Iyy = Exx + Ezz;
    var Izz = Exx + Eyy;
    var Ixy = -Exy;
    var Iyz = -Eyz;
    var Ixz = -Exz;

    var centroid = polyhedralProperties.centroid;

    Ixx -= newVolume * (centroid.y * centroid.y + centroid.z * centroid.z);
    Iyy -= newVolume * (centroid.z * centroid.z + centroid.x * centroid.x);
    Izz -= newVolume * (centroid.x * centroid.x + centroid.y * centroid.y);
    Ixy += newVolume * centroid.x * centroid.y;
    Iyz += newVolume * centroid.y * centroid.z;
    Ixz += newVolume * centroid.z * centroid.x;

    Ixx *= density * detT;
    Iyy *= density * detT;
    Izz *= density * detT;
    Ixy *= density * detT;
    Iyz *= density * detT;
    Ixz *= density * detT;

    var inertia = [
        Ixx, Ixy, Ixz,
        Ixy, Iyy, Iyz,
        Ixz, Iyz, Izz
    ];

    this.localInertia.set(inertia);
    Mat33.inverse(this.localInertia, this.localInverseInertia);
}

module.exports = ConvexBodyFactory;

},{"../Geometry":107,"../bodies/Particle":111,"famous-math":90}],111:[function(require,module,exports){
'use strict';

var Vec3 = require('famous-math').Vec3;
var Quaternion = require('famous-math').Quaternion;
var Mat33 = require('famous-math').Mat33;

var CallbackStore = require('famous-utilities').CallbackStore;

var ZERO_VECTOR = new Vec3();

var MAT1_REGISTER = new Mat33();

var _ID = 0;
/**
 * Fundamental physical body. Maintains translational and angular momentum, position and orientation, and other properties
 * such as size and coefficients of restitution and friction used in collision response.
 *
 * @class Particle
 * @extends Particle
 * @param {Object} options sets the initial state of the Particle
 * @constructor
 */
function Particle(options) {
    options = options || {};

    this.events = new CallbackStore();

    this.position = options.position || new Vec3();
    this.orientation = options.orientation || new Quaternion();

    this.velocity = new Vec3();
    this.momentum = new Vec3();
    this.angularVelocity = new Vec3();
    this.angularMomentum = new Vec3();

    this.mass = options.mass || 1;
    this.inverseMass = 1 / this.mass;

    this.force = new Vec3();
    this.torque = new Vec3();

    this.restitution = options.restitution != null ? options.restitution : 0.4;
    this.friction = options.friction != null ? options.friction : 0.2;

    this.inverseInertia = new Mat33([0,0,0,0,0,0,0,0,0]);

    this.localInertia = new Mat33([0,0,0,0,0,0,0,0,0]);
    this.localInverseInertia = new Mat33([0,0,0,0,0,0,0,0,0]);

    this.size = options.size || [0, 0, 0];

    var v = options.velocity;
    var w = options.angularVelocity;
    if (v) this.setVelocity(v.x, v.y, v.z);
    if (w) this.setAngularVelocity(w.x, w.y, w.z);

    this.restrictions = 0;
    this.setRestrictions.apply(this, options.restrictions || []);

    this.collisionMask = options.collisionMask || 1;
    this.collisionGroup = options.collisionGroup || 1;

    this.type = 1 << 0;

    this._ID = _ID++;
}

/**
 * Getter for the restriction bitmask. Converts the restrictions to their string representation.
 *
 * @method getRestrictions
 * @return {String[]} restrictions
 */
Particle.prototype.getRestrictions = function getRestrictions() {
    var linear = '';
    var angular = '';
    var restrictions = this.restrictions;
    if (restrictions & 32) linear += 'x';
    if (restrictions & 16) linear += 'y';
    if (restrictions & 8) linear += 'z';
    if (restrictions & 4) angular += 'x';
    if (restrictions & 2) angular += 'y';
    if (restrictions & 1) angular += 'z';

    return [linear, angular];
};

/**
 * Setter for the particle restriction bitmask.
 *
 * @method setRestrictions
 * @param {String} transRestrictions
 * @param {String} rotRestrictions
 * @chainable
 */
Particle.prototype.setRestrictions = function setRestrictions(transRestrictions, rotRestrictions) {
    transRestrictions = transRestrictions || '';
    rotRestrictions = rotRestrictions || '';
    this.restrictions = 0;
    if (transRestrictions.indexOf('x') > -1) this.restrictions |= 32;
    if (transRestrictions.indexOf('y') > -1) this.restrictions |= 16;
    if (transRestrictions.indexOf('z') > -1) this.restrictions |= 8;
    if (rotRestrictions.indexOf('x') > -1) this.restrictions |= 4;
    if (rotRestrictions.indexOf('y') > -1) this.restrictions |= 2;
    if (rotRestrictions.indexOf('z') > -1) this.restrictions |= 1;
    return this;
};

/**
 * Getter for mass
 *
 * @method getMass
 * @return {Number} mass
 */
Particle.prototype.getMass = function getMass() {
    return this.mass;
};

/**
 * Set the mass of the Particle.  Can be used to change the mass several times
 *
 * @method setMass
 * @param {Number} mass
 * @chainable
 */
Particle.prototype.setMass = function setMass(mass) {
    this.mass = mass;
    this.inverseMass = 1 / mass;
    return this;
};

/**
 * Getter for inverse mass
 *
 * @method getInverseMass
 * @return {Number} inverse mass
 */
Particle.prototype.getInverseMass = function() {
    return this.inverseMass;
};

/**
 * Resets the inertia tensor and its inverse to reflect the current shape.
 *
 * @method updateLocalInertia
 * @chainable
 * @param {Mat33} Mat33
 */
Particle.prototype.updateLocalInertia = function updateLocalInertia() {
    this.localInertia.set([0,0,0,0,0,0,0,0,0]);
    this.localInverseInertia.set([0,0,0,0,0,0,0,0,0]);
    return this;
};

/**
 * Updates the world inverse inertia tensor.
 *
 * @method updateInertia
 * @chainable
 */
Particle.prototype.updateInertia = function updateInertia() {
    var localInvI = this.localInverseInertia;
    var q = this.orientation;
    if (localInvI[0] === localInvI[4] && localInvI[4] === localInvI[8]) return;
    if (q.w === 1) return;
    var R = q.toMatrix(MAT1_REGISTER);
    Mat33.multiply(R, this.inverseInertia, this.inverseInertia);
    Mat33.multiply(this.localInverseInertia, R.transpose(), this.inverseInertia);
    return this;
};

/**
 * Getter for position
 *
 * @method getPosition
 * @return {Vec3} position
 */
Particle.prototype.getPosition = function getPosition() {
    return this.position;
};

/**
 * Setter for position
 *
 * @method setPosition
 * @param {Number} x the x coordinate for position
 * @param {Number} y the y coordinate for position
 * @param {Number} z the z coordinate for position
 * @return {Particle} this
 * @chainable
 */
Particle.prototype.setPosition = function setPosition(x, y, z) {
    this.position.set(x, y, z);
    return this;
};

/**
 * Getter for velocity
 *
 * @method getVelocity
 * @return {Vec3} velocity
 */
Particle.prototype.getVelocity = function getVelocity() {
    return this.velocity;
};

/**
 * Setter for velocity
 *
 * @method setvelocity
 * @param {Number} x the x coordinate for velocity
 * @param {Number} y the y coordinate for velocity
 * @param {Number} z the z coordinate for velocity
 * @chainable
 */
Particle.prototype.setVelocity = function setVelocity(x, y, z) {
    this.velocity.set(x, y, z);
    Vec3.scale(this.velocity, this.mass, this.momentum);
    return this;
};

/**
 * Getter for momenutm
 *
 * @method getMomentum
 * @return {Vec3} momentum
 */
Particle.prototype.getMomentum = function getMomentum() {
    return this.momentum;
};

/**
 * Setter for momentum
 *
 * @method setMomentum
 * @param {Number} x the x coordinate for momentum
 * @param {Number} y the y coordinate for momentum
 * @param {Number} z the z coordinate for momentum
 * @chainable
 */
Particle.prototype.setMomentum = function setMomentum(x, y, z) {
    this.momentum.set(x, y, z);
    Vec3.scale(this.momentum, this.inverseMass, this.velocity);
    return this;
};

/**
 * Getter for orientation
 *
 * @method getOrientation
 * @return {Quaternion} orientation
 */
Particle.prototype.getOrientation = function getOrientation() {
    return this.orientation;
};

/**
 * Setter for orientation
 *
 * @method setOrientation
 * @param {Number} w
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 * @chainable
 */
Particle.prototype.setOrientation = function setOrientation(w,x,y,z) {
    this.orientation.set(w,x,y,z).normalize();
    this.updateInertia();
    return this;
};

/**
 * Getter for angular velocity
 *
 * @method getAngularVelocity
 * @return {Vec3} angularVelocity
 */
Particle.prototype.getAngularVelocity = function getAngularVelocity() {
    return this.angularVelocity;
};

/**
 * Setter for angular velocity
 *
 * @method setAngularVelocity
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 */
Particle.prototype.setAngularVelocity = function setAngularVelocity(x,y,z) {
    this.angularVelocity.set(x,y,z);
    var I = Mat33.inverse(this.inverseInertia, MAT1_REGISTER);
    if (I) I.vectorMultiply(this.angularVelocity, this.angularMomentum);
    else this.angularMomentum.clear();
    return this;
};

/**
 * Getter for angular momentum
 *
 * @method getAngularMomentum
 * @return {Vec3} angular momentum
 */
Particle.prototype.getAngularMomentum = function getAngularMomentum() {
    return this.angularMomentum;
};

/**
 * Setter for angular momentum
 *
 * @method setAngularMomentum
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 */
Particle.prototype.setAngularMomentum = function setAngularMomentum(x,y,z) {
    this.angularMomentum.set(x,y,z);
    this.inverseInertia.vectorMultiply(this.angularMomentum, this.angularVelocity);
    return this;
};

/**
 * Getter for the force on the Particle
 *
 * @method getForce
 * @return {Vec3} force
 */
Particle.prototype.getForce = function getForce() {
    return this.force;
};

/**
 * Setter for the force on the Particle
 *
 * @method setForce
 * @param {Vec3} v the new Force
 * @chainable
 */
Particle.prototype.setForce = function setForce(x, y, z) {
    this.force.set(x, y, z);
    return this;
};

/**
 * Getter for torque.
 *
 * @method getTorque
 */
Particle.prototype.getTorque = function getTorque() {
    return this.torque;
};

/**
 * Setter for torque.
 *
 * @method setTorque
 * @param {Vec3} v
 * @chainable
 */
Particle.prototype.setTorque = function setTorque(x, y, z) {
    this.torque.set(x, y, z);
    return this;
};

/**
 * Extends Particle.applyForce with an optional argument
 * to apply the force at an off-centered location, resulting in a torque.
 *
 * @method applyForce
 * @param force {Vec3} force
 * @param {Vec3} location off-center location on the Particle (optional)
 */
Particle.prototype.applyForce = function applyForce(force) {
    this.force.add(force);
    return this;
};

/**
 * Applied a torque force to a Particle, inducing a rotation.
 *
 * @method applyTorque
 * @param torque {Vec3} torque
 */
Particle.prototype.applyTorque = function applyTorque(torque) {
    this.torque.add(torque);
    return this;
};

/**
 * Applies an impulse to momentum and updates velocity.
 *
 * @method applyImpulse
 * @param {Vec3} impulse
 */
Particle.prototype.applyImpulse = function applyImpulse(impulse) {
    this.momentum.add(impulse);
    Vec3.scale(this.momentum, this.inverseMass, this.velocity);
    return this;
};

/**
 * Applies an angular impulse to angular momentum and updates angular velocity.
 *
 * @method applyAngularImpulse
 * @param {Vec3} angularImpulse
 */
Particle.prototype.applyAngularImpulse = function applyAngularImpulse(angularImpulse) {
    this.angularMomentum.add(angularImpulse);
    this.inverseInertia.vectorMultiply(this.angularMomentum, this.angularVelocity);
    return this;
};

/**
 * Used in collision detection. The support function should accept a Vec3 direction
 * and return the point on the body's shape furthest in that direction. For point particles,
 * this returns the zero vector.
 *
 * @method support
 * @return {Vec3}
 */
Particle.prototype.support = function support() {
    return ZERO_VECTOR;
};

/**
 * Update the body's shape to reflect current orientation. Called in _integratePose.
 * Noop for point particles.
 *
 * @method updateShape
 */
Particle.prototype.updateShape = function updateShape() {};

module.exports = Particle;

},{"famous-math":90,"famous-utilities":103}],112:[function(require,module,exports){
'use strict';

var Particle = require('./Particle');
var Vec3 = require('famous-math').Vec3;

var SUPPORT_REGISTER = new Vec3();

/**
 * Spherical Rigid body
 *
 * @class Sphere
 * @extends Particle
 * @param {Object} options
 */
function Sphere(options) {
    Particle.call(this, options);
    var r  = options.radius || 1;
    this.radius = r;
    this.size = [2*r, 2*r, 2*r];
    this.updateLocalInertia();
    this.inverseInertia.copy(this.localInverseInertia);

    this.type = 1 << 2;
}

Sphere.prototype = Object.create(Particle.prototype);
Sphere.prototype.constructor = Sphere;

/**
 * Getter for radius.
 *
 * @method getRadius
 * @return {Number} radius
 */
Sphere.prototype.getRadius = function getRadius() {
    return this.radius;
};

/**
 * Setter for radius.
 *
 * @method setRadius
 * @param {Number} radius The intended radius of the sphere.
 * @chainable
 */
Sphere.prototype.setRadius = function setRadius(radius) {
    this.radius = radius;
    this.size = [2*this.radius, 2*this.radius, 2*this.radius];
    return this;
};

/**
 * Infers the inertia tensor.
 *
 * @override
 * @method updateInertia
 */
Sphere.prototype.updateLocalInertia = function updateInertia() {
    var m = this.mass;
    var r = this.radius;

    var mrr = m * r * r;

    this.localInertia.set([
        0.4 * mrr, 0, 0,
        0, 0.4 * mrr, 0,
        0, 0, 0.4 * mrr
    ]);

    this.localInverseInertia.set([
        2.5 / mrr, 0, 0,
        0, 2.5 / mrr, 0,
        0, 0, 2.5 / mrr
    ]);
};

/**
 * Returns the point on the sphere furthest in a given direction.
 *
 * @method support
 * @param {Vec3} direction
 * @param {Vec3}
 */
Sphere.prototype.support = function support(direction) {
    return Vec3.scale(direction, this.radius, SUPPORT_REGISTER);
};

/**
 * @exports Sphere
 * @module Sphere
 */
module.exports = Sphere;

},{"./Particle":111,"famous-math":90}],113:[function(require,module,exports){
'use strict';

var Particle = require('./Particle');
var Vec3 = require('famous-math').Vec3;

/**
 * @enum directions
 */
Wall.DOWN = 0;
Wall.UP = 1;
Wall.LEFT = 2;
Wall.RIGHT = 3;
Wall.FORWARD = 4;
Wall.BACKWARD = 5;

/**
 * An axis-aligned boundary. Will not respond to forces or impulses.
 *
 * @class Wall
 * @extends Particle
 * @param {Object} options
 */
function Wall(options) {
    Particle.call(this, options);

    var n = this.normal = new Vec3();

    var d = this.direction = options.direction;
    switch (d) {
        case Wall.DOWN:
            n.set(0, 1, 0);
            break;
        case Wall.UP:
            n.set(0, -1, 0);
            break;
        case Wall.LEFT:
            n.set(-1, 0, 0);
            break;
        case Wall.RIGHT:
            n.set(1, 0, 0);
            break;
        case Wall.FORWARD:
            n.set(0, 0, -1);
            break;
        case Wall.BACKWARD:
            n.set(0, 0, 1);
            break;
        default:
            break;
    }

    this.invNormal = Vec3.clone(n, new Vec3()).invert();

    this.mass = Infinity;
    this.inverseMass = 0;

    this.type = 1 << 3;
}

Wall.prototype = Object.create(Particle.prototype);
Wall.prototype.constructor = Wall;

module.exports = Wall;

},{"./Particle":111,"famous-math":90}],114:[function(require,module,exports){
'use strict';

var Constraint = require('./Constraint');
var Vec3 = require('famous-math').Vec3;
var Mat33 = require('famous-math').Mat33;

var DELTA_REGISTER = new Vec3();

/**
 *  A constraint that keeps a physics body a given direction away from a given
 *  anchor, or another attached body.
 *
 *  @class Angle
 *  @extends Constraint
 *  @param {Particle} a One of the bodies.
 *  @param {Particle} b The other body.
 *  @param {Object} options An object of configurable options.
 */
function Angle(a, b, options) {
    this.a = a;
    this.b = b;

    Constraint.call(this, options);

    this.effectiveInertia = new Mat33();
    this.angularImpulse = new Vec3();
    this.error = 0;
}

Angle.prototype = Object.create(Constraint.prototype);
Angle.prototype.constructor = Angle;

/**
 * Initialize the Angle. Sets defaults if a property was not already set.
 *
 * @method init
 * @param {Object} options The options hash.
 */
Angle.prototype.init = function() {
    this.cosAngle = this.cosAngle || this.a.orientation.dot(this.b.orientation);
};

/**
 * Warmstart the constraint and prepare calculations used in .resolve.
 *
 * @method update
 */
Angle.prototype.update = function update() {
    var a = this.a;
    var b = this.b;

    var q1 = a.orientation;
    var q2 = b.orientation;

    var cosTheta = q1.dot(q2);
    var diff = 2*(cosTheta - this.cosAngle);

    this.error = diff;

    var angularImpulse = this.angularImpulse;
    b.applyAngularImpulse(angularImpulse);
    a.applyAngularImpulse(angularImpulse.invert());

    Mat33.add(a.inverseInertia, b.inverseInertia, this.effectiveInertia);
    this.effectiveInertia.inverse();

    angularImpulse.clear();
};

/**
 * Adds an angular impulse to a physics body's angular velocity.
 *
 * @method resolve
 */
Angle.prototype.resolve = function update() {
    var a = this.a;
    var b = this.b;

    var diffW = DELTA_REGISTER;

    var w1 = a.angularVelocity;
    var w2 = b.angularVelocity;

    Vec3.subtract(w1, w2, diffW);
    diffW.scale(1 + this.error);

    var angularImpulse = diffW.applyMatrix(this.effectiveInertia);

    b.applyAngularImpulse(angularImpulse);
    a.applyAngularImpulse(angularImpulse.invert());
    angularImpulse.invert();
    this.angularImpulse.add(angularImpulse);
};

module.exports = Angle;

},{"./Constraint":116,"famous-math":90}],115:[function(require,module,exports){
'use strict';

var Vec3 = require('famous-math').Vec3;
var Constraint = require('./Constraint');

var SweepAndPrune = require('./collision/SweepAndPrune');
var BruteForce = require('./collision/BruteForce');
var ConvexCollision = require('./collision/ConvexCollisionDetection');
var GJK = ConvexCollision.GJK;
var EPA = ConvexCollision.EPA;
var ContactManifoldTable = require('./collision/ContactManifold');

var ObjectManager = require('famous-utilities').ObjectManager;
ObjectManager.register('CollisionData', CollisionData);
var OMRequestCollisionData = ObjectManager.requestCollisionData;

var VEC_REGISTER = new Vec3();

/**
 * Helper function to clamp a value to a given range.
 *
 * @method clamp
 * @private
 * @param {Number} value
 * @param {Number} lower
 * @param {Number} upper
 * @return {Number}
 */
function clamp(value, lower, upper) {
    return value < lower ? lower : value > upper ? upper : value;
}

/**
 * Object maintaining various figures of a collision. Registered in ObjectManager.
 *
 * @class CollisionData
 * @param {Number} penetration
 * @param {Vec3} normal
 * @param {Vec3} worldContactA
 * @param {Vec3} worldContactB
 * @param {Vec3} localContactA
 * @param {Vec3} localContactB
 */
function CollisionData(penetration, normal, worldContactA, worldContactB, localContactA, localContactB) {
    this.penetration = penetration;
    this.normal = normal;
    this.worldContactA = worldContactA;
    this.worldContactB = worldContactB;
    this.localContactA = localContactA;
    this.localContactB = localContactB;
}

/**
 * Used by ObjectManager to reset the object with different data.
 *
 * @method reset
 * @param {Object[]} args
 * @chainable
 */
CollisionData.prototype.reset = function reset(penetration, normal, worldContactA, worldContactB, localContactA, localContactB) {
    this.penetration = penetration;
    this.normal = normal;
    this.worldContactA = worldContactA;
    this.worldContactB = worldContactB;
    this.localContactA = localContactA;
    this.localContactB = localContactB;

    return this;
};

/**
 * Ridid body Elastic Collision
 *
 * @class Collision
 * @extends Constraint
 * @param {Object} options
 */
function Collision(targets, options) {
    this.targets = [].concat(targets);

    Constraint.call(this, options);
}

Collision.prototype = Object.create(Constraint.prototype);
Collision.prototype.constructor = Collision;

/**
 * Initialize the Collision tracker. Sets defaults if a property was not already set.
 *
 * @method init
 * @param {Object} options The options hash.
 */
Collision.prototype.init = function() {
    if (this.broadPhase) {
        if (this.broadPhase instanceof Function) this.broadPhase = new this.broadPhase(this.targets);
    }
    else this.broadPhase = new SweepAndPrune(this.targets);
    this.contactManifoldTable = this.contactManifoldTable || new ContactManifoldTable();
};

/**
 * Collison detection. Updates the existing contact manifolds, runs the broadphase, and performs narrowphase
 * collision detection. Warm starts the contacts based on the results of the previous physics frame
 * and prepares necesssary calculations for the resolution.
 *
 * @method update
 * @param {Number} time The current time in the physics engine.
 * @param {Number} dt The physics engine frame delta.
 */
 Collision.prototype.update = function update(time, dt) {
    this.contactManifoldTable.update(dt);
    if (this.targets.length === 0) return;
    var i, len;
    for (i = 0, len = this.targets.length; i < len; i++) {
        this.targets[i].updateShape();
    }
    var potentialCollisions = this.broadPhase.update();
    var pair;
    for (i = 0, len = potentialCollisions.length; i < len; i++) {
        (pair = potentialCollisions[i]) && this.applyNarrowPhase(pair);
    }
    this.contactManifoldTable.prepContacts(dt);
};

/**
 * Apply impulses to resolve all Contact constraints.
 *
 * @method resolve
 * @param {Number} time The current time in the physics engine.
 * @param {Number} dt The physics engine frame delta.
 */
Collision.prototype.resolve = function resolve(time, dt) {
    this.contactManifoldTable.resolveManifolds(dt);
};

/**
 * Add a target or targets to the collision system.
 *
 * @method addTarget
 * @param {Particle}
 */
Collision.prototype.addTarget = function addTarget(target) {
    this.targets.push(target);
    this.broadPhase.add(target);
};

/**
 * Remove a target or targets from the collision system.
 *
 * @method addTarget
 * @param {Particle}
 */
Collision.prototype.removeTarget = function removeTarget(target) {
    var index = this.targets.indexOf(target);
    if (index < 0) return;
    this.targets.splice(index, 1);
    this.broadPhase.remove(target);
};


var CONVEX = 1 << 0;
var BOX = 1 << 1;
var SPHERE = 1 << 2;
var WALL = 1 << 3;

var CONVEX_CONVEX = CONVEX | CONVEX;
var BOX_BOX = BOX | BOX;
var BOX_CONVEX = BOX | CONVEX;
var SPHERE_SPHERE = SPHERE | SPHERE;
var BOX_SPHERE = BOX | SPHERE;
var CONVEX_SPHERE = CONVEX | SPHERE;
var CONVEX_WALL = CONVEX | WALL;
var BOX_WALL = BOX | WALL;
var SPHERE_WALL = SPHERE | WALL;

var dispatch = {};
dispatch[CONVEX_CONVEX] = convexIntersectConvex;
dispatch[BOX_BOX] = convexIntersectConvex;
dispatch[BOX_CONVEX] = convexIntersectConvex;
dispatch[CONVEX_SPHERE] = convexIntersectConvex;
dispatch[SPHERE_SPHERE] = sphereIntersectSphere;
dispatch[BOX_SPHERE] = boxIntersectSphere;
dispatch[CONVEX_WALL] = convexIntersectWall;
dispatch[BOX_WALL] = convexIntersectWall;
dispatch[SPHERE_WALL] = convexIntersectWall;

/**
 * Narrowphase collision detection,
 * registers the Contact constraints for colliding bodies.
 *
 * Will detect the type of bodies in the collision.
 *
 * @method applyNarrowPhase
 * @param {Particle[]} targets
 */
Collision.prototype.applyNarrowPhase = function applyNarrowPhase(targets) {
    for (var i = 0, len = targets.length; i < len; i++) {
        for (var j = i + 1; j < len; j++) {
            var  a = targets[i];
            var b = targets[j];

            if ((a.collisionMask & b.collisionGroup && a.collisionGroup & b.collisionMask) === 0) continue;

            var collisionType = a.type | b.type;

            dispatch[collisionType] && dispatch[collisionType](this, a, b);
        }
    }
};

/**
 * Detects sphere-sphere collisions and registers the Contact.
 *
 * @private
 * @method sphereIntersectSphere
 * @param {Object} context
 * @param {Sphere} sphere1
 * @param {Sphere} sphere2
 */
function sphereIntersectSphere(context, sphere1, sphere2) {
    var p1 = sphere1.position;
    var p2 = sphere2.position;
    var relativePosition = Vec3.subtract(p2, p1, new Vec3());
    var distance = relativePosition.length();
    var sumRadii = sphere1.radius + sphere2.radius;
    var n = relativePosition.scale(1/distance);

    var overlap = sumRadii - distance;

    // Distance check
    if (overlap < 0) return;

    var rSphere1 = Vec3.scale(n, sphere1.radius, new Vec3());
    var rSphere2 = Vec3.scale(n, -sphere2.radius, new Vec3());

    var wSphere1 = Vec3.add(p1, rSphere1, new Vec3());
    var wSphere2 = Vec3.add(p2, rSphere2, new Vec3());

    var collisionData = OMRequestCollisionData().reset(overlap, n, wSphere1, wSphere2, rSphere1, rSphere2);

    context.contactManifoldTable.registerContact(sphere1, sphere2, collisionData);
}

/**
* Detects box-sphere collisions and registers the Contact.
*
* @param {Object} context
* @param {Box} box
* @param {Sphere} sphere
*/
function boxIntersectSphere(context, box, sphere) {
    if (box.type === SPHERE) {
        var temp = sphere;
        sphere = box;
        box = temp;
    }

    var pb = box.position;
    var ps = sphere.position;
    var relativePosition = Vec3.subtract(ps, pb, VEC_REGISTER);

    var q = box.orientation;

    var r = sphere.radius;

    var bsize = box.size;
    var halfWidth = bsize[0]*0.5;
    var halfHeight = bsize[1]*0.5;
    var halfDepth = bsize[2]*0.5;

    // x, y, z
    var bnormals = box.normals;
    var n1 = q.rotateVector(bnormals[1], new Vec3());
    var n2 = q.rotateVector(bnormals[0], new Vec3());
    var n3 = q.rotateVector(bnormals[2], new Vec3());

    // Find the point on the cube closest to the center of the sphere
    var closestPoint = new Vec3();
    closestPoint.x = clamp(Vec3.dot(relativePosition,n1), -halfWidth, halfWidth);
    closestPoint.y = clamp(Vec3.dot(relativePosition,n2), -halfHeight, halfHeight);
    closestPoint.z = clamp(Vec3.dot(relativePosition,n3), -halfDepth, halfDepth);
    // The vector found is relative to the center of the unrotated box -- rotate it
    // to find the point w.r.t. to current orientation
    closestPoint.applyRotation(q);

    // The impact point in world space
    var impactPoint = Vec3.add(pb, closestPoint, new Vec3());
    var sphereToImpact = Vec3.subtract(impactPoint, ps, impactPoint);
    var distanceToSphere = sphereToImpact.length();

    // If impact point is not closer to the sphere's center than its radius -> no collision
    var overlap = r - distanceToSphere;
    if (overlap < 0) return;

    var n = Vec3.scale(sphereToImpact, -1 / distanceToSphere, new Vec3());
    var rBox = closestPoint;
    var rSphere = sphereToImpact;

    var wBox = Vec3.add(pb, rBox, new Vec3());
    var wSphere = Vec3.add(ps, rSphere, new Vec3());

    var collisionData = OMRequestCollisionData().reset(overlap, n, wBox, wSphere, rBox, rSphere);

    context.contactManifoldTable.registerContact(box, sphere, collisionData);
}

/**
* Detects convex-convex collisions and registers the Contact. Uses GJK to determine overlap and then
* EPA to determine the actual collision data.
*
* @param {Object} context
* @param {ConvexBody} convex1
* @param {ConvexBody} convex2
*/
function convexIntersectConvex(context, convex1, convex2) {
    var glkSimplex = GJK(convex1, convex2);

    // No simplex -> no collision
    if (!glkSimplex) return;

    var collisionData = EPA(convex1, convex2, glkSimplex);
    if (collisionData !== null) context.contactManifoldTable.registerContact(convex1, convex2, collisionData);
}

/**
* Detects convex-wall collisions and registers the Contact.
*
* @param {Object} context
* @param {ConvexBody} convex
* @param {ConvexBody} wall
*/
function convexIntersectWall(context, convex, wall) {
    if (convex.type === WALL) {
        var temp = wall;
        wall = convex;
        convex = temp;
    }

    var convexPos = convex.position;
    var wallPos = wall.position;

    var n = wall.normal;
    var invN = wall.invNormal;

    var rConvex = convex.support(invN);
    var wConvex = Vec3.add(convexPos, rConvex, new Vec3());

    var diff = Vec3.subtract(wConvex, wallPos, VEC_REGISTER);

    var penetration = Vec3.dot(diff, invN);

    if (penetration < 0) return;

    var wWall = Vec3.scale(n, penetration, new Vec3()).add(wConvex);
    var rWall = Vec3.subtract(wWall, wall.position, new Vec3());

    var collisionData = OMRequestCollisionData().reset(penetration, invN, wConvex, wWall, rConvex, rWall);

    context.contactManifoldTable.registerContact(convex, wall, collisionData);
}

Collision.SweepAndPrune = SweepAndPrune;
Collision.BruteForce = BruteForce.BruteForce;
Collision.BruteForceAABB = BruteForce.BruteForceAABB;

module.exports = Collision;

},{"./Constraint":116,"./collision/BruteForce":123,"./collision/ContactManifold":124,"./collision/ConvexCollisionDetection":125,"./collision/SweepAndPrune":126,"famous-math":90,"famous-utilities":103}],116:[function(require,module,exports){
'use strict';

var _ID = 0;
/**
 * Base Constraint class to be used in the Physics
 * Subclass this class to implement a constraint
 *
 * @virtual
 * @class Constraint
 */
function Constraint(options) {
    options = options || {};
    this.setOptions(options);

    this._ID = _ID++;
}

/**
 * Decorates the Constraint with the options object.
 *
 * @method setOptions
 * @param {Object} Options
 */
Constraint.prototype.setOptions = function setOptions(options) {
    for (var key in options) this[key] = options[key];
    this.init(options);
};

/**
 * Method invoked upon instantiation and the setting of options.
 *
 * @method init
 * @param {Object} options The options hash.
 */
Constraint.prototype.init = function init(options) {};

/**
 * Detect violations of the constraint. Warm start the constraint, if possible.
 *
 * @method update
 * @param {Number} time The current time in the physics engine.
 * @param {Number} dt The physics engine frame delta.
 */
Constraint.prototype.update = function update(time, dt) {};

/**
 * Apply impulses to resolve the constraint.
 *
 * @method resolve
 * @param {Number} time The current time in the physics engine.
 * @param {Number} dt The physics engine frame delta.
 */
Constraint.prototype.resolve = function resolve(time, dt) {};

module.exports = Constraint;

},{}],117:[function(require,module,exports){
'use strict';

var Constraint = require('./Constraint');
var Vec3 = require('famous-math').Vec3;

var IMPULSE_REGISTER = new Vec3();
var NORMAL_REGISTER = new Vec3();

/** @const */
var EPSILSON = 1e-7;
/** @const */
var PI = Math.PI;


/**
 *  A constraint that keeps a physics body on a given implicit curve.
 *
 *  @class Curve
 *  @constructor
 *  @extends Constraint
 */
function Curve(targets, options) {
    if (targets) {
        if (targets instanceof Array) this.targets = targets;
        else this.targets = [targets];
    }
    else this.targets = [];

    Constraint.call(this, options);

    this.impulses = {};
    this.normals = {};
    this.velocityBiases = {};
    this.divisors = {};
}

Curve.prototype = Object.create(Constraint.prototype);
Curve.prototype.constructor = Curve;

/**
 * Initialize the Curve. Sets defaults if a property was not already set.
 *
 * @method init
 */
Curve.prototype.init = function() {
    this.equation1 = this.equation1 || function() {
        return 0;
    };
    this.equation2 = this.equation2 || function(x, y, z) {
        return z;
    };
    this.period = this.period || 1;
    this.dampingRatio = this.dampingRatio || 0.5;

    this.stiffness = 4 * PI * PI / (this.period * this.period);
    this.damping = 4 * PI * this.dampingRatio / this.period;
};

/**
 * Warmstart the constraint and prepare calculations used in the .resolve step.
 *
 * @method update
 * @param {Number} time The current time in the physics engine.
 * @param {Number} dt The physics engine frame delta.
 */
Curve.prototype.update = function update(time, dt) {
    var targets = this.targets;

    var normals = this.normals;
    var velocityBiases = this.velocityBiases;
    var divisors = this.divisors;
    var impulses = this.impulses;

    var impulse = IMPULSE_REGISTER;
    var n = NORMAL_REGISTER;

    var f = this.equation1;
    var g = this.equation2;

    var _c = this.damping;
    var _k = this.stiffness;

    for (var i = 0, len = targets.length; i < len; i++) {
        var body = targets[i];
        var ID = body._ID;
        if (body.immune) continue;

        var p = body.position;
        var m = body.mass;

        var gamma;
        var beta;

        if (this.period === 0) {
            gamma = 0;
            beta = 1;
        } else {
            var c = _c * m;
            var k = _k * m;

            gamma = 1 / (dt*(c + dt*k));
            beta  = dt*k / (c + dt*k);
        }

        var x = p.x;
        var y = p.y;
        var z = p.z;

        var f0 = f(x, y, z);
        var dfx = (f(x + EPSILSON, y, z) - f0) / EPSILSON;
        var dfy = (f(x, y + EPSILSON, z) - f0) / EPSILSON;
        var dfz = (f(x, y, z + EPSILSON) - f0) / EPSILSON;

        var g0 = g(x, y, z);
        var dgx = (g(x + EPSILSON, y, z) - g0) / EPSILSON;
        var dgy = (g(x, y + EPSILSON, z) - g0) / EPSILSON;
        var dgz = (g(x, y, z + EPSILSON) - g0) / EPSILSON;

        n.set(dfx + dgx, dfy + dgy, dfz + dgz);
        n.normalize();

        var baumgarte = beta * (f0 + g0) / dt;
        var divisor = gamma + 1 / m;

        var lambda = impulses[ID] || 0;
        Vec3.scale(n, lambda, impulse);
        body.applyImpulse(impulse);

        normals[ID] = normals[ID] || new Vec3();
        normals[ID].copy(n);
        velocityBiases[ID] = baumgarte;
        divisors[ID] = divisor;
        impulses[ID] = 0;
    }
};

/**
 * Adds a curve impulse to a physics body.
 *
 * @method resolve
 */
Curve.prototype.resolve = function resolve() {
    var targets = this.targets;

    var normals = this.normals;
    var velocityBiases = this.velocityBiases;
    var divisors = this.divisors;
    var impulses = this.impulses;

    var impulse = IMPULSE_REGISTER;

    for (var i = 0, len = targets.length; i < len; i++) {
        var body = targets[i];
        var ID = body._ID;
        if (body.immune) continue;

        var v = body.velocity;
        var n = normals[ID];

        var lambda = -(Vec3.dot(n, v) + velocityBiases[ID]) / divisors[ID];

        Vec3.scale(n, lambda, impulse);
        body.applyImpulse(impulse);


        impulses[ID] += lambda;
    }
};

module.exports = Curve;
},{"./Constraint":116,"famous-math":90}],118:[function(require,module,exports){
'use strict';

var Constraint = require('./Constraint');
var Vec3 = require('famous-math').Vec3;

var NORMAL_REGISTER = new Vec3();
var IMPULSE_REGISTER = new Vec3();
var V_REGISTER = new Vec3();
var P_REGISTER = new Vec3();
var DIRECTION_REGISTER = new Vec3();

/** @const */
var PI = Math.PI;

/**
 *  A constraint that maintains the direction of one body from another.
 *
 *  @class Direction
 *  @extends Constraint
 *  @param {Particle} a One of the bodies.
 *  @param {Particle} b The other body.
 *  @param {Object} options An object of configurable options.
 */
function Direction(a, b, options) {
    this.a = a;
    this.b = b;

    Constraint.call(this, options);

    this.impulse = 0;
    this.distance = 0;
    this.normal = new Vec3();
    this.velocityBias = 0;
    this.divisor = 0;
}

Direction.prototype = Object.create(Constraint.prototype);
Direction.prototype.constructor = Direction;

/**
 * Initialize the Direction. Sets defaults if a property was not already set.
 *
 * @method init
 */
Direction.prototype.init = function() {
    this.direction = this.direction || Vec3.subtract(this.b.position, this.a.position, new Vec3());
    this.direction.normalize();
    this.minLength = this.minLength || 0;
    this.period = this.period || 0.2;
    this.dampingRatio = this.dampingRatio || 0.5;

    this.stiffness = 4 * PI * PI / (this.period * this.period);
    this.damping = 4 * PI * this.dampingRatio / this.period;
};

/**
 * Warmstart the constraint and prepare calculations used in .resolve.
 *
 * @method update
 * @param {Number} time The current time in the physics engine.
 * @param {Number} dt The physics engine frame delta.
 */
Direction.prototype.update = function update(time, dt) {
    var a = this.a;
    var b = this.b;

    var n = NORMAL_REGISTER;
    var diffP = P_REGISTER;
    var impulse = IMPULSE_REGISTER;
    var directionVector = DIRECTION_REGISTER;

    var p1 = a.position;
    var w1 = a.inverseMass;

    var p2 = b.position;
    var w2 = b.inverseMass;

    var direction = this.direction;

    Vec3.subtract(p2, p1, diffP);
    Vec3.scale(direction, Vec3.dot(direction, diffP), directionVector);
    var goal = directionVector.add(p1);

    Vec3.subtract(p2, goal, n);
    var dist = n.length();
    n.normalize();

    var invEffectiveMass = w1 + w2;
    var effectiveMass = 1 / invEffectiveMass;
    var gamma;
    var beta;

    if (this.period === 0) {
        gamma = 0;
        beta  = 1;
    }
    else {
        var c = this.damping * effectiveMass;
        var k = this.stiffness * effectiveMass;

        gamma = 1 / (dt*(c + dt*k));
        beta  = dt*k / (c + dt*k);
    }

    var baumgarte = beta * dist / dt;
    var divisor = gamma + invEffectiveMass;

    var lambda = this.impulse;
    Vec3.scale(n, lambda, impulse);
    b.applyImpulse(impulse);
    a.applyImpulse(impulse.invert());

    this.normal.copy(n);
    this.distance = dist;
    this.velocityBias = baumgarte;
    this.divisor = divisor;
    this.impulse = 0;
};

/**
 * Adds an impulse to a physics body's velocity due to the constraint
 *
 * @method resolve
 */
Direction.prototype.resolve = function update() {
    var a = this.a;
    var b = this.b;

    var impulse  = IMPULSE_REGISTER;
    var diffV = V_REGISTER;

    var minLength = this.minLength;

    var dist = this.distance;
    if (Math.abs(dist) < minLength) return;

    var v1 = a.velocity;
    var v2 = b.velocity;
    var n = this.normal;

    Vec3.subtract(v2, v1, diffV);

    var lambda = -(Vec3.dot(n, diffV) + this.velocityBias) / this.divisor;
    Vec3.scale(n, lambda, impulse);
    b.applyImpulse(impulse);
    a.applyImpulse(impulse.invert());

    this.impulse += lambda;
};

module.exports = Direction;

},{"./Constraint":116,"famous-math":90}],119:[function(require,module,exports){
'use strict';

var Constraint = require('./Constraint');
var Vec3 = require('famous-math').Vec3;

var NORMAL_REGISTER = new Vec3();
var IMPULSE_REGISTER = new Vec3();
var V_REGISTER = new Vec3();
var P_REGISTER = new Vec3();

/** @const */
var PI = Math.PI;

/**
 *  A constraint that keeps two bodies within a certain distance.
 *
 *  @class Distance
 *  @extends Constraint
 *  @param {Particle} a One of the bodies.
 *  @param {Particle} b The other body.
 *  @param {Object} options An object of configurable options.
 */
function Distance(a, b, options) {
    this.a = a;
    this.b = b;

    Constraint.call(this, options);

    this.impulse = 0;
    this.distance = 0;
    this.normal = new Vec3();
    this.velocityBias = 0;
    this.divisor = 0;
}

Distance.prototype = Object.create(Constraint.prototype);
Distance.prototype.constructor = Distance;

/**
 * Initialize the Distance. Sets defaults if a property was not already set.
 *
 * @method init
 */
Distance.prototype.init = function() {
    this.length = this.length || Vec3.subtract(this.b.position, this.a.position, P_REGISTER).length();
    this.minLength = this.minLength || 0;
    this.period = this.period || 0.2;
    this.dampingRatio = this.dampingRatio || 0.5;

    this.stiffness = 4 * PI * PI / (this.period * this.period);
    this.damping = 4 * PI * this.dampingRatio / this.period;
};

/**
 * Detect violations of the constraint. Warm start the constraint, if possible.
 *
 * @method update
 * @param {Number} time The current time in the physics engine.
 * @param {Number} dt The physics engine frame delta.
 */
Distance.prototype.update = function(time, dt) {
    var a = this.a;
    var b = this.b;

    var n = NORMAL_REGISTER;
    var diffP = P_REGISTER;
    var impulse = IMPULSE_REGISTER;

    var length = this.length;

    var p1 = a.position;
    var w1 = a.inverseMass;

    var p2 = b.position;
    var w2 = b.inverseMass;

    Vec3.subtract(p2, p1, diffP);

    var separation = diffP.length();

    Vec3.scale(diffP, 1 / separation, n);

    var dist = separation - length;

    var invEffectiveMass = w1 + w2;
    var effectiveMass = 1 / invEffectiveMass;
    var gamma;
    var beta;

    if (this.period === 0) {
        gamma = 0;
        beta  = 1;
    }
    else {
        var c = this.damping * effectiveMass;
        var k = this.stiffness * effectiveMass;

        gamma = 1 / (dt*(c + dt*k));
        beta  = dt*k / (c + dt*k);
    }

    var baumgarte = beta * dist / dt;
    var divisor = gamma + invEffectiveMass;

    var lambda = this.impulse;
    Vec3.scale(n, lambda, impulse);
    b.applyImpulse(impulse);
    a.applyImpulse(impulse.invert());

    this.normal.copy(n);
    this.distance = dist;
    this.velocityBias = baumgarte;
    this.divisor = divisor;
    this.impulse = 0;
};

/**
 * Apply impulses to resolve the constraint.
 *
 * @method resolve
 */
Distance.prototype.resolve = function resolve() {
    var a = this.a;
    var b = this.b;

    var impulse = IMPULSE_REGISTER;
    var diffV = V_REGISTER;

    var minLength = this.minLength;

    var dist = this.distance;
    if (Math.abs(dist) < minLength) return;

    var v1 = a.getVelocity();
    var v2 = b.getVelocity();

    var n = this.normal;

    Vec3.subtract(v2, v1, diffV);
    var lambda = -(Vec3.dot(n, diffV) + this.velocityBias) / this.divisor;
    Vec3.scale(n, lambda, impulse);
    b.applyImpulse(impulse);
    a.applyImpulse(impulse.invert());

    this.impulse += lambda;
};

module.exports = Distance;

},{"./Constraint":116,"famous-math":90}],120:[function(require,module,exports){
'use strict';

var Constraint = require('./Constraint');
var Vec3 = require('famous-math').Vec3;
var Mat33 = require('famous-math').Mat33;
var Quaternion = require('famous-math').Quaternion;

var VEC1_REGISTER = new Vec3();
var VEC2_REGISTER = new Vec3();
var VEC3_REGISTER = new Vec3();
var VEC4_REGISTER = new Vec3();
var VB1_REGISTER = new Vec3();
var VB2_REGISTER = new Vec3();
var WxR_REGISTER = new Vec3();
var DELTA_REGISTER = new Vec3();

/**
 *  A constraint that confines two bodies to the plane defined by the axis of the hinge.
 *
 *  @class Hinge
 *  @extends Constraint
 *  @param {Options} [options] An object of configurable options.
 *
 */
function Hinge(a, b, options) {
    this.a = a;
    this.b = b;

    Constraint.call(this, options);

    this.impulse = new Vec3();
    this.angImpulseA = new Vec3();
    this.angImpulseB = new Vec3();
    this.error = new Vec3();
    this.errorRot = [0,0];
    this.effMassMatrix = new Mat33();
    this.effMassMatrixRot = [];
}

Hinge.prototype = Object.create(Constraint.prototype);
Hinge.prototype.constructor = Hinge;

/**
 * Initialize the Hinge. Sets defaults if a property was not already set.
 *
 * @method init
 */
Hinge.prototype.init = function() {
    var w = this.anchor;

    var u = this.axis.normalize();

    var a = this.a;
    var b = this.b;

    var q1t = Quaternion.conjugate(a.orientation, new Quaternion());
    var q2t = Quaternion.conjugate(b.orientation, new Quaternion());

    this.rA = Vec3.subtract(w, a.position, new Vec3());
    this.rB = Vec3.subtract(w, b.position, new Vec3());

    this.bodyRA = q1t.rotateVector(this.rA, new Vec3());
    this.bodyRB = q2t.rotateVector(this.rB, new Vec3());

    this.axisA = Vec3.clone(u);
    this.axisB = Vec3.clone(u);

    this.axisBTangent1 = new Vec3();
    this.axisBTangent2 = new Vec3();

    this.t1xA = new Vec3();
    this.t2xA = new Vec3();

    this.bodyAxisA = q1t.rotateVector(u, new Vec3());
    this.bodyAxisB = q2t.rotateVector(u, new Vec3());
};

/**
 * Detect violations of the constraint. Warm start the constraint, if possible.
 *
 * @method update
 * @param {Number} time The current time in the physics engine.
 * @param {Number} dt The physics engine frame delta.
 */
Hinge.prototype.update = function(time, dt) {
    var a = this.a;
    var b = this.b;

    var axisA = a.orientation.rotateVector(this.bodyAxisA, this.axisA);
    var axisB = b.orientation.rotateVector(this.bodyAxisB, this.axisB);
    this.axis.copy(axisB);

    var n = axisB;
    var t1 = this.axisBTangent1;
    var t2 = this.axisBTangent2;

    if (n.x >= 0.57735) {
        t1.set(n.y, -n.x, 0);
    }
    else {
        t1.set(0, n.z, -n.y);
    }
    t1.normalize();
    Vec3.cross(n, t1, t2);

    var t1xA = Vec3.cross(t1, axisA, this.t1xA);
    var t2xA = Vec3.cross(t2, axisA, this.t2xA);

    var rA = a.orientation.rotateVector(this.bodyRA, this.rA);
    var rB = b.orientation.rotateVector(this.bodyRB, this.rB);

    var xRA = new Mat33([0,rA.z,-rA.y,-rA.z,0,rA.x,rA.y,-rA.x,0]);
    var xRB = new Mat33([0,rB.z,-rB.y,-rB.z,0,rB.x,rB.y,-rB.x,0]);

    var RIaRt = Mat33.multiply(xRA, a.inverseInertia, new Mat33()).multiply(xRA.transpose());
    var RIbRt = Mat33.multiply(xRB, b.inverseInertia, new Mat33()).multiply(xRB.transpose());

    var invEffInertia = Mat33.add(RIaRt, RIbRt, RIaRt);

    var worldA = Vec3.add(a.position, this.rA, this.anchor);
    var worldB = Vec3.add(b.position, this.rB, VEC1_REGISTER);

    var invDt = 1/dt;
    Vec3.subtract(worldB, worldA, this.error);
    this.error.scale(0.2*invDt);

    var imA = a.inverseMass;
    var imB = b.inverseMass;

    var invEffMass = new Mat33([imA + imB,0,0,0,imA + imB,0,0,0,imA + imB]);

    Mat33.add(invEffInertia, invEffMass, this.effMassMatrix);
    this.effMassMatrix.inverse();

    var invIAt1xA = a.inverseInertia.vectorMultiply(t1xA, VEC1_REGISTER);
    var invIAt2xA = a.inverseInertia.vectorMultiply(t2xA, VEC2_REGISTER);
    var invIBt1xA = b.inverseInertia.vectorMultiply(t1xA, VEC3_REGISTER);
    var invIBt2xA = b.inverseInertia.vectorMultiply(t2xA, VEC4_REGISTER);

    var a11 = Vec3.dot(t1xA, invIAt1xA) + Vec3.dot(t1xA, invIBt1xA);
    var a12 = Vec3.dot(t1xA, invIAt2xA) + Vec3.dot(t1xA, invIBt2xA);
    var a21 = Vec3.dot(t2xA, invIAt1xA) + Vec3.dot(t2xA, invIBt1xA);
    var a22 = Vec3.dot(t2xA, invIAt2xA) + Vec3.dot(t2xA, invIBt2xA);

    var det = 1 / (a11*a22 - a12*a21);

    this.effMassMatrixRot[0] = a22 * det;
    this.effMassMatrixRot[1] = -a21 * det;
    this.effMassMatrixRot[2] = -a12 * det;
    this.effMassMatrixRot[3] = a11 * det;

    this.errorRot[0] = Vec3.dot(axisA, t1) * 0.2*invDt;
    this.errorRot[1] = Vec3.dot(axisA, t2) * 0.2*invDt;

    var impulse = this.impulse.scale(0.5);
    var angImpulseA = this.angImpulseA.scale(0.5);
    var angImpulseB = this.angImpulseB.scale(0.5);

    b.applyImpulse(impulse);
    b.applyAngularImpulse(angImpulseB);
    impulse.invert();
    a.applyImpulse(impulse);
    a.applyAngularImpulse(angImpulseA);

    impulse.clear();
    angImpulseA.clear();
    angImpulseB.clear();
};

/**
 * Apply impulses to resolve the constraint.
 *
 * @method resolve
 */
Hinge.prototype.resolve = function resolve() {
    var a = this.a;
    var b = this.b;

    var rA = this.rA;
    var rB = this.rB;

    var t1xA = this.t1xA;
    var t2xA = this.t2xA;

    var w1 = a.angularVelocity;
    var w2 = b.angularVelocity;

    var v1 = Vec3.add(a.velocity, Vec3.cross(w1, rA, WxR_REGISTER), VB1_REGISTER);
    var v2 = Vec3.add(b.velocity, Vec3.cross(w2, rB, WxR_REGISTER), VB2_REGISTER);

    var impulse = v1.subtract(v2).subtract(this.error).applyMatrix(this.effMassMatrix);

    var diffW = Vec3.subtract(w2, w1, DELTA_REGISTER);

    var errorRot = this.errorRot;
    var jv1 = Vec3.dot(t1xA, diffW) + errorRot[0];
    var jv2 = Vec3.dot(t2xA, diffW) + errorRot[1];

    var K = this.effMassMatrixRot;

    var l1 = -(K[0]*jv1 + K[1]*jv2);
    var l2 = -(K[2]*jv1 + K[3]*jv2);

    var angImpulse = Vec3.scale(t1xA, l1, VEC2_REGISTER).add(Vec3.scale(t2xA, l2, VEC3_REGISTER));

    var angImpulseB = Vec3.cross(rB, impulse, VEC1_REGISTER).add(angImpulse);
    var angImpulseA = Vec3.cross(rA, impulse, VEC4_REGISTER).invert().subtract(angImpulse);

    b.applyImpulse(impulse);
    b.applyAngularImpulse(angImpulseB);
    impulse.invert();
    a.applyImpulse(impulse);
    a.applyAngularImpulse(angImpulseA);
    impulse.invert();

    this.impulse.add(impulse);
    this.angImpulseA.add(angImpulseA);
    this.angImpulseB.add(angImpulseB);
};

module.exports = Hinge;

},{"./Constraint":116,"famous-math":90}],121:[function(require,module,exports){
'use strict';

var Constraint = require('./Constraint');
var Vec3 = require('famous-math').Vec3;
var Mat33 = require('famous-math').Mat33;
var Quaternion = require('famous-math').Quaternion;

var VEC1_REGISTER = new Vec3();
var VEC2_REGISTER = new Vec3();
var VB1_REGISTER = new Vec3();
var VB2_REGISTER = new Vec3();
var WxR_REGISTER = new Vec3();

/**
 *  A constraint that maintains positions and orientations with respect to a specific anchor point.
 *
 *  @class Point2Point
 *  @extends Constraint
 *  @param {Particle} a One of the bodies.
 *  @param {Particle} b The other body.
 *  @param {Options} options An object of configurable options.
 */
function Point2Point(a, b, options) {
    this.a = a;
    this.b = b;

    Constraint.call(this, options);

    this.impulse = new Vec3();
    this.angImpulseA = new Vec3();
    this.angImpulseB = new Vec3();
    this.error = new Vec3();
    this.effMassMatrix = new Mat33();
}

Point2Point.prototype = Object.create(Constraint.prototype);
Point2Point.prototype.constructor = Point2Point;

/**
 * Initialize the Point2Point. Sets defaults if a property was not already set.
 *
 * @method init
 */
Point2Point.prototype.init = function() {
    var w = this.anchor;

    var a = this.a;
    var b = this.b;

    var q1t = Quaternion.conjugate(a.orientation, new Quaternion());
    var q2t = Quaternion.conjugate(b.orientation, new Quaternion());

    this.rA = Vec3.subtract(w, a.position, new Vec3());
    this.rB = Vec3.subtract(w, b.position, new Vec3());

    this.bodyRA = q1t.rotateVector(this.rA, new Vec3());
    this.bodyRB = q2t.rotateVector(this.rB, new Vec3());
};

/**
 * Detect violations of the constraint. Warm start the constraint, if possible.
 *
 * @method update
 * @param {Number} time The current time in the physics engine.
 * @param {Number} dt The physics engine frame delta.
 */
Point2Point.prototype.update = function(time, dt) {
    var a = this.a;
    var b = this.b;

    var rA = a.orientation.rotateVector(this.bodyRA, this.rA);
    var rB = b.orientation.rotateVector(this.bodyRB, this.rB);

    var xRA = new Mat33([0,rA.z,-rA.y,-rA.z,0,rA.x,rA.y,-rA.x,0]);
    var xRB = new Mat33([0,rB.z,-rB.y,-rB.z,0,rB.x,rB.y,-rB.x,0]);

    var RIaRt = Mat33.multiply(xRA, a.inverseInertia, new Mat33()).multiply(xRA.transpose());
    var RIbRt = Mat33.multiply(xRB, b.inverseInertia, new Mat33()).multiply(xRB.transpose());

    var invEffInertia = Mat33.add(RIaRt, RIbRt, RIaRt);

    var worldA = Vec3.add(a.position, this.rA, this.anchor);
    var worldB = Vec3.add(b.position, this.rB, VEC2_REGISTER);

    Vec3.subtract(worldB, worldA, this.error);
    this.error.scale(0.2/dt);

    var imA = a.inverseMass;
    var imB = b.inverseMass;

    var invEffMass = new Mat33([imA + imB,0,0,0,imA + imB,0,0,0,imA + imB]);

    Mat33.add(invEffInertia, invEffMass, this.effMassMatrix);
    this.effMassMatrix.inverse();

    var impulse = this.impulse;
    var angImpulseA = this.angImpulseA;
    var angImpulseB = this.angImpulseB;

    b.applyImpulse(impulse);
    b.applyAngularImpulse(angImpulseB);
    impulse.invert();
    a.applyImpulse(impulse);
    a.applyAngularImpulse(angImpulseA);

    impulse.clear();
    angImpulseA.clear();
    angImpulseB.clear();
};

/**
 * Apply impulses to resolve the constraint.
 *
 * @method resolve
 */
Point2Point.prototype.resolve = function resolve() {
    var a = this.a;
    var b = this.b;

    var rA = this.rA;
    var rB = this.rB;

    var v1 = Vec3.add(a.velocity, Vec3.cross(a.angularVelocity, rA, WxR_REGISTER), VB1_REGISTER);
    var v2 = Vec3.add(b.velocity, Vec3.cross(b.angularVelocity, rB, WxR_REGISTER), VB2_REGISTER);

    var impulse = v1.subtract(v2).subtract(this.error).applyMatrix(this.effMassMatrix);
    var angImpulseB = Vec3.cross(rB, impulse, VEC1_REGISTER);
    var angImpulseA = Vec3.cross(rA, impulse, VEC2_REGISTER).invert();

    b.applyImpulse(impulse);
    b.applyAngularImpulse(angImpulseB);
    impulse.invert();
    a.applyImpulse(impulse);
    a.applyAngularImpulse(angImpulseA);
    impulse.invert();

    this.impulse.add(impulse);
    this.angImpulseA.add(angImpulseA);
    this.angImpulseB.add(angImpulseB);
};

module.exports = Point2Point;

},{"./Constraint":116,"famous-math":90}],122:[function(require,module,exports){
'use strict';

/**
 * Axis-aligned bounding box. Used in collision broadphases.
 *
 * @class AABB
 */
function AABB(body) {
    this._body = body;
    this._ID = body._ID;
    this.position = null;
    this.vertices = {
        x: [],
        y: [],
        z: []
    };
    this.update();
}

var SPHERE = 1 << 2;
var WALL = 1 << 3;

var DOWN = 0;
var UP = 1;
var LEFT = 2;
var RIGHT = 3;
var FORWARD = 4;
var BACKWARD = 5;

/**
 * Update the bounds to reflect the current orientation and position of the parent Body.
 *
 * @method update
 */
AABB.prototype.update = function() {
    var body = this._body;
    var pos = this.position = body.position;

    var minX = Infinity, maxX = -Infinity;
    var minY = Infinity, maxY = -Infinity;
    var minZ = Infinity, maxZ = -Infinity;

    var type = body.type;
    if (type === SPHERE) {
        maxX = maxY = maxZ = body.radius;
        minX = minY = minZ = -body.radius;
    }
    else if (type === WALL) {
        var d = body.direction;
        maxX = maxY = maxZ = 1e6;
        minX = minY = minZ = -1e6;
        switch (d) {
            case DOWN:
                maxY = 25;
                minY = -1e3;
                break;
            case UP:
                maxY = 1e3;
                minY = -25;
                break;
            case LEFT:
                maxX = 25;
                minX = -1e3;
                break;
            case RIGHT:
                maxX = 1e3;
                minX = -25;
                break;
            case FORWARD:
                maxZ = 25;
                minZ = -1e3;
                break;
            case BACKWARD:
                maxZ = 1e3;
                minZ = -25;
                break;
            default:
                break;
       }
    }
    else if (body.vertices) {
        // ConvexBody
        var bodyVertices = body.vertices;
        for (var i = 0, len = bodyVertices.length; i < len; i++) {
            var vertex = bodyVertices[i];
            if (vertex.x < minX) minX = vertex.x;
            if (vertex.x > maxX) maxX = vertex.x;
            if (vertex.y < minY) minY = vertex.y;
            if (vertex.y > maxY) maxY = vertex.y;
            if (vertex.z < minZ) minZ = vertex.z;
            if (vertex.z > maxZ) maxZ = vertex.z;
        }
    } else {
        // Particle
        maxX = maxY = maxZ = 25;
        minX = minY = minZ = -25;
    }
    var vertices = this.vertices;
    vertices.x[0] = minX + pos.x;
    vertices.x[1] = maxX + pos.x;
    vertices.y[0] = minY + pos.y;
    vertices.y[1] = maxY + pos.y;
    vertices.z[0] = minZ + pos.z;
    vertices.z[1] = maxZ + pos.z;
};

/**
 * Check for overlap between two AABB's.
 *
 * @method checkOverlap
 * @param {AABB} aabb1
 * @param {AABB} aabb2
 */
AABB.checkOverlap = function(aabb1, aabb2) {
    var vertices1 = aabb1.vertices;
    var vertices2 = aabb2.vertices;

    var x10 = vertices1.x[0];
    var x11 = vertices1.x[1];
    var x20 = vertices2.x[0];
    var x21 = vertices2.x[1];
    if ((x20 <= x10 && x10 <= x21) || (x10 <= x20 && x20 <= x11)) {
        var y10 = vertices1.y[0];
        var y11 = vertices1.y[1];
        var y20 = vertices2.y[0];
        var y21 = vertices2.y[1];
        if ((y20 <= y10 && y10 <= y21) || (y10 <= y20 && y20 <= y11)) {
            var z10 = vertices1.z[0];
            var z11 = vertices1.z[1];
            var z20 = vertices2.z[0];
            var z21 = vertices2.z[1];
            if ((z20 <= z10 && z10 <= z21) || (z10 <= z20 && z20 <= z11)) {
                return true;
            }
        }
    }
    return false;
};

AABB.vertexThreshold = 100;

module.exports = AABB;

},{}],123:[function(require,module,exports){
'use strict';

var AABB = require('./AABB');

/**
 * O(n^2) comparisons with an AABB check for a midphase. Likely to be more performant
 * that the BruteForce when the bodies have many vertices. Only feasible for a small number of bodies.
 *
 * @class BruteForAABB
 * @param {Particles[]} targets
 * @param {Object} options
 */
function BruteForceAABB(targets) {
    this._volumes = [];
    this._entityRegistry = {};
    for (var i = 0; i < targets.length; i++) {
        this.add(targets[i]);
    }
}

/**
 * Start tracking a Particle.
 *
 * @method add
 * @param {Particle} body
 */
BruteForceAABB.prototype.add = function add(body) {
    var boundingVolume = new AABB(body);

    this._entityRegistry[body._ID] = body;
    this._volumes.push(boundingVolume);
};

/**
 * Return an array of possible collision pairs, culled by an AABB intersection test.
 *
 * @method update
 * @return {Particle[][]}
 */
BruteForceAABB.prototype.update = function update() {
    var _volumes = this._volumes;
    var _entityRegistry = this._entityRegistry;

    for (var k = 0, len = _volumes.length; k < len; k++) {
        _volumes[k].update();
    }

    var result = [];
    for (var i = 0, numTargets = _volumes.length; i < numTargets; i++) {
        for (var j = i + 1; j < numTargets; j++) {
            if (AABB.checkOverlap(_volumes[i], _volumes[j])) {
                result.push([_entityRegistry[i], _entityRegistry[j]]);
            }
        }
    }
    return result;
};

/**
 * The most simple yet computationally intensive broad-phase. Immediately passes its targets to the narrow-phase,
 * resulting in an O(n^2) process. Only feasible for a relatively small number of bodies.
 *
 * @class BruteForce
 * @param {Particle[]} targets
 */
function BruteForce(targets) {
    this.targets = targets;
}

/**
 * Start tracking a Particle.
 *
 * @method add
 * @param {Particle} body
 */
BruteForce.prototype.add = function add(body) {
    this.targets.push(body);
};

/**
 * Immediately returns an array of possible collisions.
 *
 * @method update
 * @return {Particle[][]}
 */
BruteForce.prototype.update = function update() {
    return [this.targets];
};

module.exports.BruteForceAABB = BruteForceAABB;
module.exports.BruteForce = BruteForce;

},{"./AABB":122}],124:[function(require,module,exports){
'use strict';

var Vec3 = require('famous-math').Vec3;
var ObjectManager = require('famous-utilities').ObjectManager;

ObjectManager.register('Manifold', Manifold);
ObjectManager.register('Contact', Contact);
var OMRequestManifold = ObjectManager.requestManifold;
var OMRequestContact = ObjectManager.requestContact;
var OMFreeManifold = ObjectManager.freeManifold;
var OMFreeContact = ObjectManager.freeContact;

/**
 * Helper function to clamp a value to a given range.
 *
 * @method clamp
 * @param {Number} value
 * @param {Number} lower
 * @param {Number} upper
 * @return {Number}
 * @private
 */
function clamp(value, lower, upper) {
    return value < lower ? lower : value > upper ? upper : value;
}

var VEC1_REGISTER = new Vec3();
var VEC2_REGISTER = new Vec3();
var VB1_REGISTER = new Vec3();
var VB2_REGISTER = new Vec3();
var WxR_REGISTER = new Vec3();
var R1_REGISTER = new Vec3();
var R2_REGISTER = new Vec3();
var NORMALIMPULSE_REGISTER = new Vec3();
var TANGENTIMPULSE1_REGISTER = new Vec3();
var TANGENTIMPULSE2_REGISTER = new Vec3();
var WA_REGISTER = new Vec3();
var WB_REGISTER = new Vec3();
var PENETRATING_REGISTER = new Vec3();
var DRIFTA_REGISTER = new Vec3();
var DRIFTB_REGISTER = new Vec3();

/**
 * Table maintaining and managing current contact manifolds.
 *
 * @class ContactManifoldTable
 */
function ContactManifoldTable() {
    this.manifolds = [];
    this.collisionMatrix = {};
    this._IDPool = [];
}

/**
 * Create a new contact manifold. Tracked by the collisionMatrix according to
 * its low-high ordered ID pair.
 *
 * @method addManifold
 * @param {Number} lowId
 * @param {Number} highID
 * @param {Particle} bodyA
 * @param {Particle} bodyB
 * @return {ContactManifold}
 */
ContactManifoldTable.prototype.addManifold = function addManifold(lowID, highID, bodyA, bodyB) {
    var collisionMatrix = this.collisionMatrix;
    collisionMatrix[lowID] = collisionMatrix[lowID] || {};

    var index = this._IDPool.length ? this._IDPool.pop() : this.manifolds.length;
    this.collisionMatrix[lowID][highID] = index;
    var manifold = OMRequestManifold().reset(lowID, highID, bodyA, bodyB);
    this.manifolds[index] = manifold;

    return manifold;
};

/**
 * Remove a manifold and free it for later reuse.
 *
 * @method removeManifold
 * @param {ContactManifold} manifold
 * @param {Number} index
 */
ContactManifoldTable.prototype.removeManifold = function removeManifold(manifold, index) {
    var collisionMatrix = this.collisionMatrix;

    this.manifolds[index] = null;
    collisionMatrix[manifold.lowID][manifold.highID] = null;
    this._IDPool.push(index);

    OMFreeManifold(manifold);
};

/**
 * Update each of the manifolds, removing those that no longer contain contact points.
 *
 * @method update
 * @param {Number} dt
 */
ContactManifoldTable.prototype.update = function update(dt) {
    var manifolds = this.manifolds;
    for (var i = 0, len = manifolds.length; i < len; i++) {
        var manifold = manifolds[i];
        if (!manifold) continue;
        var persists = manifold.update(dt);
        if (!persists) {
            this.removeManifold(manifold, i);
            manifold.bodyA.events.trigger('collision:end', manifold);
            manifold.bodyB.events.trigger('collision:end', manifold);
        }
    }
};

/**
 * Warm start all Contacts, and perform precalculations needed in the iterative solver.
 *
 * @method prepContacts
 * @param {Number} dt
 */
ContactManifoldTable.prototype.prepContacts = function prepContacts(dt) {
    var manifolds = this.manifolds;
    for (var i = 0, len = manifolds.length; i < len; i++) {
        var manifold = manifolds[i];
        if (!manifold) continue;
        var contacts = manifold.contacts;
        for (var j = 0, lenj = contacts.length; j < lenj; j++) {
            var contact = contacts[j];
            if (!contact) continue;
            contact.update(dt);
        }
    }
};

/**
 * Resolve all contact manifolds.
 *
 * @method resolveManifolds
 */
ContactManifoldTable.prototype.resolveManifolds = function resolveManifolds() {
    var manifolds = this.manifolds;
    for (var i = 0, len = manifolds.length; i < len; i++) {
        var manifold = manifolds[i];
        if (!manifold) continue;
        manifold.resolveContacts();
    }
};

/**
 * Create a new Contact, also creating a new Manifold if one does not already exist for that pair.
 *
 * @method registerContact
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {CollisionData} collisionData
 */
ContactManifoldTable.prototype.registerContact = function registerContact(bodyA, bodyB, collisionData) {
    var lowID;
    var highID;

    if (bodyA._ID < bodyB._ID) {
        lowID = bodyA._ID;
        highID = bodyB._ID;
    } else {
        lowID = bodyB._ID;
        highID = bodyA._ID;
    }

    var manifolds = this.manifolds;
    var collisionMatrix = this.collisionMatrix;
    var manifold;
    if (!collisionMatrix[lowID] || collisionMatrix[lowID][highID] == null) {
        manifold = this.addManifold(lowID, highID, bodyA, bodyB);
        manifold.addContact(bodyA, bodyB, collisionData);
        bodyA.events.trigger('collision:start', manifold);
        bodyB.events.trigger('collision:start', manifold);
    } else {
        manifold = manifolds[ collisionMatrix[lowID][highID] ];
        manifold.contains(collisionData);
        manifold.addContact(bodyA, bodyB, collisionData);
    }
};

var THRESHOLD = 10;

/**
 * Class to keep track of Contact points.
 * @class manifold
 * @param {Number} lowId
 * @param {Number} highId
 * @param {Body} bodyA
 * @param {Body} bodyB
 */
function Manifold(lowID, highID, bodyA, bodyB) {
    this.lowID = lowID;
    this.highID = highID;

    this.contacts = [];
    this.numContacts = 0;

    this.bodyA = bodyA;
    this.bodyB = bodyB;

    this.lru = 0;
}

/**
 * Used by ObjectManager to reset the object with different data.
 *
 * @method reset
 * @param {Object[]} args
 * @chainable
 */
Manifold.prototype.reset = function reset(lowID, highID, bodyA, bodyB) {
    this.lowID = lowID;
    this.highID = highID;

    this.contacts = [];
    this.numContacts = 0;

    this.bodyA = bodyA;
    this.bodyB = bodyB;

    this.lru = 0;

    return this;
};

/**
 * Create a new Contact point and add it to the Manifold.
 *
 * @method addContact
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {CollisionData} collisionData
 */
Manifold.prototype.addContact = function addContact(bodyA, bodyB, collisionData) {
    var index = this.lru;
    if (this.contacts[index]) this.removeContact(this.contacts[index], index);
    this.contacts[index] = OMRequestContact().reset(bodyA, bodyB, collisionData);
    this.lru = (this.lru + 1) % 4;
    this.numContacts++;
};

/**
 * Remove and free a Contact for later reuse.
 *
 * @method removeContact
 * @param {Contact} contact
 * @param {Number} index
 */
Manifold.prototype.removeContact = function removeContact(contact, index) {
    this.contacts[index] = null;
    this.numContacts--;

    ObjectManager.freeCollisionData(contact.data);
    contact.data = null;
    OMFreeContact(contact);
};

/**
 * Check if a Contact already exists for the collision data within a certain tolerance.
 * If found, remove the Contact.
 *
 * @method contains
 * @param {CollisionData} collisionData
 * @return {Boolean}
 */
Manifold.prototype.contains = function contains(collisionData) {
    var wA = collisionData.worldContactA;
    var wB = collisionData.worldContactB;

    var contacts = this.contacts;
    for (var i = 0, len = contacts.length; i < len; i++) {
        var contact = contacts[i];
        if (!contact) continue;
        var data = contact.data;
        var distA = Vec3.subtract(data.worldContactA, wA, DRIFTA_REGISTER).length();
        var distB = Vec3.subtract(data.worldContactB, wB, DRIFTB_REGISTER).length();

        if (distA < THRESHOLD || distB < THRESHOLD) {
            this.removeContact(contact, i);
            return true;
        }
    }

    return false;
};

/**
 * Remove Contacts the local points of which have drifted above a certain tolerance.
 * Return true or false to indicate that the Manifold still contains at least one Contact.
 *
 * @method update
 * @return {Boolean} whether or not the manifold persists
 */
Manifold.prototype.update = function update() {
    var contacts = this.contacts;
    var bodyA = this.bodyA;
    var bodyB = this.bodyB;

    var posA = bodyA.position;
    var posB = bodyB.position;

    for (var i = 0, len = contacts.length; i < len; i++) {
        var contact = contacts[i];
        if (!contact) continue;
        var data = contact.data;
        var n = data.normal;
        var rA = data.localContactA;
        var rB = data.localContactB;

        var cached_wA = data.worldContactA;
        var cached_wB = data.worldContactB;

        var wA = Vec3.add(posA, rA, WA_REGISTER);
        var wB = Vec3.add(posB, rB, WB_REGISTER);

        var notPenetrating = Vec3.dot(Vec3.subtract(wB, wA, PENETRATING_REGISTER), n) > 0;

        var driftA = Vec3.subtract(cached_wA, wA, DRIFTA_REGISTER);
        var driftB = Vec3.subtract(cached_wB, wB, DRIFTB_REGISTER);


        if (driftA.length() >= THRESHOLD || driftB.length() >= THRESHOLD || notPenetrating) {
            this.removeContact(contact, i);
        }
    }

    if (this.numContacts) return true;
    else return false;
};

/**
 * Resolve all contacts.
 *
 * @method resolveContacts
 */
Manifold.prototype.resolveContacts = function resolveContacts() {
    var contacts = this.contacts;
    for (var i = 0, len = contacts.length; i < len; i++) {
        if (!contacts[i]) continue;
        contacts[i].resolve();
    }
};

/**
 * Class to maintain collision data between two bodies.
 * The end of the resolve chain, and where the actual impulses are applied.
 *
 * @class Contact
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {CollisionData} collisionData
 */
function Contact(bodyA, bodyB, collisionData) {
    this.bodyA = bodyA;
    this.bodyB = bodyB;
    this.data = collisionData;

    this.normalImpulse = 0;
    this.tangentImpulse1 = 0;
    this.tangentImpulse2 = 0;

    this.impulse = new Vec3();
    this.angImpulseA = new Vec3();
    this.angImpulseB = new Vec3();

    if (collisionData) this.init();
}

/**
 * Used by ObjectManager to reset the object with different data.
 *
 * @method reset
 * @param {Object[]} args
 * @chainable
 */
Contact.prototype.reset = function reset(bodyA, bodyB, collisionData) {
    this.bodyA = bodyA;
    this.bodyB = bodyB;
    this.data = collisionData;

    this.normalImpulse = 0;
    this.tangentImpulse1 = 0;
    this.tangentImpulse2 = 0;

    this.impulse.clear();
    this.angImpulseA.clear();
    this.angImpulseB.clear();

    this.init();

    return this;
};

/**
 * Initialization method called on instantiantion or reset of the Contact. Performs
 * precalculations that will not change over the life of the Contact.
 *
 * @method init
 */
Contact.prototype.init = function init() {
    var data = this.data;
    var n = data.normal;
    var t1 = new Vec3();
    if (n.x >= 0.57735) {
        t1.set(n.y, -n.x, 0);
    } else {
        t1.set(0, n.z, -n.y);
    }
    t1.normalize();
    var t2 = Vec3.cross(n, t1, new Vec3());

    this.tangent1 = t1;
    this.tangent2 = t2;

    var bodyA = this.bodyA;
    var bodyB = this.bodyB;

    var rBodyA = data.localContactA;
    var rBodyB = data.localContactB;

    var invEffectiveMass = bodyA.inverseMass + bodyB.inverseMass;

    var r1n = Vec3.cross(rBodyA, n, R1_REGISTER);
    var r2n = Vec3.cross(rBodyB, n, R2_REGISTER);
    this.effNormalMass = 1 / (invEffectiveMass +
        Vec3.dot(r1n, bodyA.inverseInertia.vectorMultiply(r1n, VEC1_REGISTER)) +
        Vec3.dot(r2n, bodyB.inverseInertia.vectorMultiply(r2n, VEC1_REGISTER)));

    var r1t1 = Vec3.cross(rBodyA, t1, R1_REGISTER);
    var r2t1 = Vec3.cross(rBodyB, t1, R2_REGISTER);
    this.effTangentialMass1 = 1 / (invEffectiveMass +
        Vec3.dot(r1t1, bodyA.inverseInertia.vectorMultiply(r1t1, VEC1_REGISTER)) +
         Vec3.dot(r2t1, bodyB.inverseInertia.vectorMultiply(r2t1, VEC1_REGISTER)));

    var r1t2 = Vec3.cross(rBodyA, t2, R1_REGISTER);
    var r2t2 = Vec3.cross(rBodyB, t2, R2_REGISTER);
    this.effTangentialMass2 = 1 / (invEffectiveMass +
        Vec3.dot(r1t2, bodyA.inverseInertia.vectorMultiply(r1t2, VEC1_REGISTER)) +
         Vec3.dot(r2t2, bodyB.inverseInertia.vectorMultiply(r2t2, VEC1_REGISTER)));

    this.restitution = Math.min(bodyA.restitution, bodyB.restitution);
    this.friction = bodyA.friction * bodyB.friction;
};

/**
 * Warm start the Contact, prepare for the iterative solver, and reset impulses.
 *
 * @method update
 * @param {Number} dt
 */
Contact.prototype.update = function update(dt) {
    var data = this.data;
    var bodyA = this.bodyA;
    var bodyB = this.bodyB;

    var rBodyA = data.localContactA;
    var rBodyB = data.localContactB;

    var n = data.normal;

    var vb1 = Vec3.add(bodyA.velocity, Vec3.cross(bodyA.angularVelocity, rBodyA, WxR_REGISTER), VB1_REGISTER);
    var vb2 = Vec3.add(bodyB.velocity, Vec3.cross(bodyB.angularVelocity, rBodyB, WxR_REGISTER), VB2_REGISTER);
    var relativeVelocity = vb2.subtract(vb1);
    var contactSpeed = Vec3.dot(relativeVelocity, n);

    var beta = 0.15;
    var slop = 1.5;
    var velocityTolerance = 20.0;

    var restitution = Math.abs(contactSpeed) < velocityTolerance ? 0.0 : this.restitution;
    this.velocityBias = -beta * Math.max(data.penetration - slop, 0.0) / dt;
    this.velocityBias += restitution * contactSpeed;

    var impulse = this.impulse.scale(0.25);
    var angImpulseA = this.angImpulseA.scale(0.25);
    var angImpulseB = this.angImpulseB.scale(0.25);

    bodyB.applyImpulse(impulse);
    bodyB.applyAngularImpulse(angImpulseB);
    impulse.invert();
    bodyA.applyImpulse(impulse);
    bodyA.applyAngularImpulse(angImpulseA);

    this.normalImpulse = 0;
    this.tangentImpulse1 = 0;
    this.tangentImpulse2 = 0;

    impulse.clear();
    angImpulseA.clear();
    angImpulseB.clear();
};

/**
 * Apply impulses to resolve the contact and simulate friction.
 *
 * @method resolve
 */
Contact.prototype.resolve = function resolve() {
    var data = this.data;
    var bodyA = this.bodyA;
    var bodyB = this.bodyB;

    var rBodyA = data.localContactA;
    var rBodyB = data.localContactB;

    var n = data.normal;
    var t1 = this.tangent1;
    var t2 = this.tangent2;

    var vb1 = Vec3.add(bodyA.velocity, Vec3.cross(bodyA.angularVelocity, rBodyA, WxR_REGISTER), VB1_REGISTER);
    var vb2 = Vec3.add(bodyB.velocity, Vec3.cross(bodyB.angularVelocity, rBodyB, WxR_REGISTER), VB2_REGISTER);
    var relativeVelocity = vb2.subtract(vb1);

    var normalLambda = -(Vec3.dot(relativeVelocity, n) + this.velocityBias) * this.effNormalMass;
    var newNormalImpulse = Math.max(this.normalImpulse + normalLambda, 0);
    normalLambda = newNormalImpulse - this.normalImpulse;

    var maxFriction = this.friction * newNormalImpulse;

    var tangentLambda1 = -Vec3.dot(relativeVelocity, t1) * this.effTangentialMass1;
    var newTangentImpulse1 = clamp(this.tangentImpulse1 + tangentLambda1, -maxFriction, maxFriction);
    tangentLambda1 = newTangentImpulse1 - this.tangentImpulse1;

    var tangentLambda2 = -Vec3.dot(relativeVelocity, t2) * this.effTangentialMass2;
    var newTangentImpulse2 = clamp(this.tangentImpulse2 + tangentLambda2, -maxFriction, maxFriction);
    tangentLambda2 = newTangentImpulse2 - this.tangentImpulse2;

    var impulse = Vec3.scale(n, normalLambda, NORMALIMPULSE_REGISTER);
    var tangentImpulse1 = Vec3.scale(t1, tangentLambda1, TANGENTIMPULSE1_REGISTER);
    var tangentImpulse2 = Vec3.scale(t2, tangentLambda2, TANGENTIMPULSE2_REGISTER);

    impulse.add(tangentImpulse1).add(tangentImpulse2);

    var angImpulseB = Vec3.cross(rBodyB, impulse, VEC1_REGISTER);
    var angImpulseA = Vec3.cross(rBodyA, impulse, VEC2_REGISTER).invert();

    bodyB.applyImpulse(impulse);
    bodyB.applyAngularImpulse(angImpulseB);
    impulse.invert();
    bodyA.applyImpulse(impulse);
    bodyA.applyAngularImpulse(angImpulseA);

    this.normalImpulse = newNormalImpulse;
    this.tangentImpulse1 = newTangentImpulse1;
    this.tangentImpulse2 = newTangentImpulse2;

    this.impulse.add(impulse);
    this.angImpulseA.add(angImpulseA);
    this.angImpulseB.add(angImpulseB);
};

module.exports = ContactManifoldTable;

},{"famous-math":90,"famous-utilities":103}],125:[function(require,module,exports){
'use strict';

var Vec3 = require('famous-math').Vec3;
var ObjectManager = require('famous-utilities').ObjectManager;

ObjectManager.register('GJK_EPASupportPoint', GJK_EPASupportPoint);
var OMRequestGJK_EPASupportPoint = ObjectManager.requestGJK_EPASupportPoint;
var OMRequestDynamicGeometry = ObjectManager.requestDynamicGeometry;
var OMFreeGJK_EPASupportPoint = ObjectManager.freeGJK_EPASupportPoint;
var OMFreeDynamicGeometry = ObjectManager.freeDynamicGeometry;
var OMFreeDynamicGeometryFeature = ObjectManager.freeDynamicGeometryFeature;

var P_REGISTER = new Vec3();
var V0_REGISTER = new Vec3();
var V1_REGISTER = new Vec3();
var V2_REGISTER = new Vec3();

var DIRECTION_REGISTER = new Vec3();
var INVDIRECTION_REGISTER = new Vec3();

/**
 * Support point to be added to the DynamicGeometry. The point in Minkowski space as well as the
 * original pair.
 *
 * @class GJK_EPASupportPoint
 * @param {Vec3} vertex
 * @param {Vec3} worldVertexA
 * @param {Vec3} worldVertexAB
 */
function GJK_EPASupportPoint(vertex, worldVertexA, worldVertexB) {
    this.vertex = vertex;
    this.worldVertexA = worldVertexA;
    this.worldVertexB = worldVertexB;
}

/**
 * Used by ObjectManager to reset the object with different data.
 *
 * @method reset
 * @param {Object[]} args
 * @chainable
 */
GJK_EPASupportPoint.prototype.reset = function reset(vertex, worldVertexA, worldVertexB) {
    this.vertex = vertex;
    this.worldVertexA = worldVertexA;
    this.worldVertexB = worldVertexB;

    return this;
};

/**
 * Free the DynamicGeomtetry and associate vertices and features for later reuse.
 *
 * @method freeGJK_EPADynamicGeometry
 * @param {DynamicGeometry} geometry
 */
function freeGJK_EPADynamicGeometry(geometry) {
    var vertices = geometry.vertices;
    var i;
    i = vertices.length;
    while (i--) {
        var v = vertices.pop();
        if (v !== null) OMFreeGJK_EPASupportPoint(v);
    }
    geometry.numVertices = 0;
    var features = geometry.features;
    i = features.length;
    while (i--) {
        var f = features.pop();
        if (f !== null) OMFreeDynamicGeometryFeature(f);
    }
    geometry.numFeatures = 0;
    OMFreeDynamicGeometry(geometry);
}

/**
 * Find the point in Minkowski space furthest in a given direction for two convex Bodies.
 *
 * @method minkowskiSupport
 * @param {Body} body1
 * @param {Body} body2
 * @param {Vec3} direction
 * @return {GJK_EPASupportPoint}
 */
function minkowskiSupport(body1, body2, direction) {
    var inverseDirection = Vec3.scale(direction, -1, INVDIRECTION_REGISTER);

    var furthest1 = body1.support(direction);
    var furthest2 = body2.support(inverseDirection);

    var w1 = Vec3.add(furthest1, body1.position, new Vec3());
    var w2 = Vec3.add(furthest2, body2.position, new Vec3());

    // The vertex in Minkowski space as well as the original pair in world space
    return OMRequestGJK_EPASupportPoint().reset(Vec3.subtract(w1, w2, new Vec3()), w1, w2);
}

/**
 * Gilbert-Johnson-Keerthi collision detection. Returns a DynamicGeometry simplex if the bodies are found
 * to have collided or false for no collsion.
 *
 * @method GJK
 * param {Body} body1
 * param {Body} body2
 * @return {DynamicGeometry | Boolean}
 */
function GJK(body1, body2) {
    var support = minkowskiSupport;
    // Use p2 - p1 to seed the initial choice of direction
    var direction = Vec3.subtract(body2.position, body1.position, DIRECTION_REGISTER).normalize();
    var simplex = OMRequestDynamicGeometry();
    simplex.addVertex(support(body1, body2, direction));
    direction.invert();

    var i = 0;
    var maxIterations = 1e3;
    while(i++ < maxIterations) {
        if (direction.x === 0 && direction.y === 0 && direction.z === 0) break;
        simplex.addVertex(support(body1, body2, direction));
        if (Vec3.dot(simplex.getLastVertex().vertex, direction) < 0) break;
        // If simplex contains origin, return for use in EPA
        if (simplex.simplexContainsOrigin(direction, OMFreeGJK_EPASupportPoint)) return simplex;
    }
    freeGJK_EPADynamicGeometry(simplex);
    return false;
}

/**
 * Expanding Polytope Algorithm--penetration depth, collision normal, and contact points.
 * Returns a CollisonData object.
 *
 * @method EPA
 * @param {Body} body1
 * @param {Body} body2
 * @param {DynamicGeometry} polytope
 * @return {CollisionData}
 */
function EPA(body1, body2, polytope) {
    var support = minkowskiSupport;
    var depthEstimate = Infinity;

    var i = 0;
    var maxIterations = 1e3;
    while(i++ < maxIterations) {
        var closest = polytope.getFeatureClosestToOrigin();
        if (closest === null) return null;
        var direction = closest.normal;
        var point = support(body1, body2, direction);
        depthEstimate = Math.min(depthEstimate, Vec3.dot(point.vertex, direction));
        if (depthEstimate - closest.distance <= 0.01) {
            var supportA = polytope.vertices[closest.vertexIndices[0]];
            var supportB = polytope.vertices[closest.vertexIndices[1]];
            var supportC = polytope.vertices[closest.vertexIndices[2]];

            var A = supportA.vertex;
            var B = supportB.vertex;
            var C = supportC.vertex;
            var P = Vec3.scale(direction, closest.distance, P_REGISTER);

            var V0 = Vec3.subtract(B, A, V0_REGISTER);
            var V1 = Vec3.subtract(C, A, V1_REGISTER);
            var V2 = Vec3.subtract(P, A, V2_REGISTER);

            var d00 = Vec3.dot(V0, V0);
            var d01 = Vec3.dot(V0, V1);
            var d11 = Vec3.dot(V1, V1);
            var d20 = Vec3.dot(V2, V0);
            var d21 = Vec3.dot(V2, V1);
            var denom = d00*d11 - d01*d01;

            var v = (d11*d20 - d01*d21) / denom;
            var w = (d00*d21 - d01*d20) / denom;
            var u = 1.0 - v - w;

            var body1Contact =      supportA.worldVertexA.scale(u)
                               .add(supportB.worldVertexA.scale(v))
                               .add(supportC.worldVertexA.scale(w));

            var body2Contact =      supportA.worldVertexB.scale(u)
                               .add(supportB.worldVertexB.scale(v))
                               .add(supportC.worldVertexB.scale(w));

            var localBody1Contact = Vec3.subtract(body1Contact, body1.position, new Vec3());
            var localBody2Contact = Vec3.subtract(body2Contact, body2.position, new Vec3());

            freeGJK_EPADynamicGeometry(polytope);
            OMFreeGJK_EPASupportPoint(point);

            return ObjectManager.requestCollisionData().reset(closest.distance, direction, body1Contact, body2Contact, localBody1Contact, localBody2Contact);
        } else {
            polytope.addVertex(point);
            polytope.reshape();
        }
    }
    throw new Error('EPA failed to terminate in allotted iterations.');
}

module.exports.GJK = GJK;
module.exports.EPA = EPA;

},{"famous-math":90,"famous-utilities":103}],126:[function(require,module,exports){
'use strict';

var AABB = require('./AABB');

/**
 * @const {String[]} AXES x, y, and z axes
 */
var AXES = ['x', 'y', 'z'];

/**
 * Persistant object maintaining sorted lists of AABB endpoints used in a sweep-and-prune broadphase.
 * Used to accelerate collision detection.
 * http://en.wikipedia.org/wiki/Sweep_and_prune
 *
 * @class SweepAndPrune
 * @param {Body[]} targets
 */
function SweepAndPrune(targets) {
    this._sweepVolumes = [];
    this._entityRegistry = {};
    this._boundingVolumeRegistry = {};
    this.endpoints = {x: [], y: [], z: []};

    this.overlaps = [];
    this.overlapsMatrix = {};
    this._IDPool = [];
    targets = targets || [];
    for (var i = 0; i < targets.length; i++) {
        this.add(targets[i]);
    }
}

/**
 * Start tracking a body in the broad-phase.
 *
 * @method add
 * @param {Body} body
 */
SweepAndPrune.prototype.add = function(body) {
    var boundingVolume = new AABB(body);
    var sweepVolume = new SweepVolume(boundingVolume);

    this._entityRegistry[body._ID] = body;
    this._boundingVolumeRegistry[body._ID] = boundingVolume;
    this._sweepVolumes.push(sweepVolume);
    for (var i = 0; i < 3; i++) {
        var axis = AXES[i];
        this.endpoints[axis].push(sweepVolume.points[axis][0]);
        this.endpoints[axis].push(sweepVolume.points[axis][1]);
    }
};

/**
 * Stop tracking a body in the broad-phase.
 *
 * @method add
 * @param {Body} body
 */
SweepAndPrune.prototype.remove = function remove(body) {
    this._entityRegistry[body._ID] = null;
    this._boundingVolumeRegistry[body._ID] = null;
    var i, len;
    var index;
    for (i = 0, len = this._sweepVolumes.length; i < len; i++) {
        if (this._sweepVolumes[i]._ID === body._ID) {
            index = i;
            break;
        }
    }
    this._sweepVolumes.splice(index, 1);
    var endpoints = this.endpoints;
    var point;

    var xs = [];
    for (i = 0, len = endpoints.x.length; i < len; i++) {
        point = endpoints.x[i];
        if (point._ID !== body._ID) xs.push(point);
    }
    var ys = [];
    for (i = 0, len = endpoints.y.length; i < len; i++) {
        point = endpoints.y[i];
        if (point._ID !== body._ID) ys.push(point);
    }
    var zs = [];
    for (i = 0, len = endpoints.z.length; i < len; i++) {
        point = endpoints.z[i];
        if (point._ID !== body._ID) zs.push(point);
    }
    endpoints.x = xs;
    endpoints.y = ys;
    endpoints.z = zs;
};

/**
 * Update the endpoints of the tracked AABB's and resort the endpoint lists accordingly. Uses an insertion sort,
 * where swaps during the sort are taken to signify a potential change in overlap status for the two
 * relevant AABB's. Returns pairs of overlapping AABB's.
 *
 * @param update
 * @return {Particle[][]}
 */
SweepAndPrune.prototype.update = function() {
    var _sweepVolumes = this._sweepVolumes;
    var _entityRegistry = this._entityRegistry;
    var _boundingVolumeRegistry = this._boundingVolumeRegistry;

    var i, j, k, len;

    for (j = 0, len = _sweepVolumes.length; j < len; j++) {
        _sweepVolumes[j].update();
    }

    var endpoints = this.endpoints;
    var overlaps = this.overlaps;
    var overlapsMatrix = this.overlapsMatrix;
    var _IDPool = this._IDPool;

    for (k = 0; k < 3; k++) {
        var axis = AXES[k];
        // Insertion sort:
        var endpointAxis = endpoints[axis];
        for (j = 1, len = endpointAxis.length; j < len; j++) {
            var current = endpointAxis[j];
            var val = current.value;
            var swap;
            var row;
            var index;
            var lowID;
            var highID;
            var cID;
            var sID;

            i = j - 1;
            while (i >= 0 && (swap = endpointAxis[i]).value > val) {
                // A swap occurence indicates that current and swap either just started or just stopped overlapping

                cID = current._ID;
                sID = swap._ID;

                if (cID < sID) {
                    lowID = cID;
                    highID = sID;
                } else {
                    lowID = sID;
                    highID = cID;
                }

                // If, for this axis, min point of current and max point of swap
                if (~current.side & swap.side) {
                    // Now overlapping on this axis -> possible overlap, do full AABB check
                    if (AABB.checkOverlap(_boundingVolumeRegistry[cID], _boundingVolumeRegistry[sID])) {
                        row = overlapsMatrix[lowID] = overlapsMatrix[lowID] || {};
                        index = row[highID] = _IDPool.length ? _IDPool.pop() : overlaps.length;
                        overlaps[index] = [_entityRegistry[lowID], _entityRegistry[highID]];
                    }
                // // Else if, for this axis, max point of current and min point of swap
                } else if (current.side & ~swap.side) {
                    // Now not overlapping on this axis -> definitely not overlapping
                    if ((row = overlapsMatrix[lowID]) && row[highID] != null) {
                        index = row[highID];
                        overlaps[index] = null;
                        row[highID] = null;
                        _IDPool.push(index);
                    }
                }
                // Else if max of both or min of both, still overlapping

                endpointAxis[i + 1] = swap;
                i--;
            }
            endpointAxis[i + 1] = current;
        }
    }

    return overlaps;
};

/**
 * Object used to associate an AABB with its endpoints in the sorted lists.
 *
 * @class SweepVolume
 * @constructor
 * @param {AABB} boundingVolume
 */
function SweepVolume(boundingVolume) {
    this._boundingVolume = boundingVolume;
    this._ID = boundingVolume._ID;
    this.points = {
        x: [{_ID: boundingVolume._ID, side: 0, value: null}, {_ID: boundingVolume._ID, side: 1, value: null}],
        y: [{_ID: boundingVolume._ID, side: 0, value: null}, {_ID: boundingVolume._ID, side: 1, value: null}],
        z: [{_ID: boundingVolume._ID, side: 0, value: null}, {_ID: boundingVolume._ID, side: 1, value: null}]
    };
    this.update();
}

/**
 * Update the endpoints to reflect the current location of the AABB.
 *
 * @method update
 */
SweepVolume.prototype.update = function() {
    var boundingVolume = this._boundingVolume;
    boundingVolume.update();

    var points = this.points;

    for (var i = 0; i < 3; i++) {
        var axis = AXES[i];
        points[axis][0].value = boundingVolume.vertices[axis][0];
        points[axis][1].value = boundingVolume.vertices[axis][1];
    }
};

module.exports = SweepAndPrune;

},{"./AABB":122}],127:[function(require,module,exports){
'use strict';

var Force = require('./Force');
var Vec3 = require('famous-math').Vec3;

var FORCE_REGISTER = new Vec3();

/**
 * Use drag to oppose momentum of a moving object
 *
 * @class Drag
 * @extends Force
 * @param {Object} options
 */
function Drag(targets, options) {
    Force.call(this, targets, options);
}

Drag.prototype = Object.create(Force.prototype);
Drag.prototype.constructor = Drag;

/**
 * Used to scale velocity in the computation of the drag force.
 *
 * @attribute QUADRATIC
 * @type Function
 * @param {Number} v
 * @return {Number} used to square the magnitude of the velocity
 */
Drag.QUADRATIC = function QUADRATIC(v) {
    return v*v;
};

/**
 * Used to scale velocity in the computation of the drag force.
 *
 * @attribute LINEAR
 * @type Function
 * @param {Number} v
 * @return {Number} strength 1, will not scale the velocity
 */
Drag.LINEAR = function LINEAR(v) {
    return v;
};

/**
 * Initialize the Force. Sets defaults if a property was not already set.
 *
 * @method init
 * @param {Object} options The options hash.
 */
Drag.prototype.init = function() {
    this.max = this.max || Infinity;
    this.strength = this.strength || 1;
    this.type = this.type || Drag.LINEAR;
};

/**
 * Apply the force.
 *
 * @method update
 */
Drag.prototype.update = function update() {
    var targets = this.targets;
    var type = this.type;

    var force = FORCE_REGISTER;

    var max = this.max;
    var strength = this.strength;
    for (var i = 0, len = targets.length; i < len; i++) {
        var target = targets[i];
        var velocity = target.velocity;
        var v = velocity.length();
        var invV = v ? 1 / v : 0;
        var magnitude = -strength * type(v);
        Vec3.scale(velocity, (magnitude < -max ? -max : magnitude) * invV, force);
        target.applyForce(force);
    }
};

module.exports = Drag;

},{"./Force":128,"famous-math":90}],128:[function(require,module,exports){
'use strict';

var _ID = 0;
/**
 * Abstract force manager to apply forces to targets.
 *
 * @class Force
 * @virtual
 * @param {Particle[]} targets The targets of the force.
 * @param {Object} options The options hash.
 */
function Force(targets, options) {
    if (targets) {
        if (targets instanceof Array) this.targets = targets;
        else this.targets = [targets];
    }
    else this.targets = [];

    options = options || {};
    this.setOptions(options);

    this._ID = _ID++;
}

/**
 * Decorates the Force with the options object.
 *
 * @method setOptions
 * @param {Object} options The options hash.
 */
Force.prototype.setOptions = function setOptions(options) {
    for (var key in options) this[key] = options[key];
    this.init(options);
};

/**
 * Add a target or targets to the Force.
 *
 * @method addTarget
 * @param {Particle} target The body to begin targetting.
 */
Force.prototype.addTarget = function addTarget(target) {
    this.targets.push(target);
};

/**
 * Remove a target or targets from the Force.
 *
 * @method addTarget
 * @param {Particle} target The body to stop targetting.
 */
Force.prototype.removeTarget = function removeTarget(target) {
    var index = this.targets.indexOf(target);
    if (index < 0) return;
    this.targets.splice(index, 1);
};

/**
 * Method invoked upon instantiation and the setting of options.
 *
 * @method init
 * @param {Object} options The options hash.
 */
Force.prototype.init = function init(options) {};

/**
 * Apply forces on each target.
 *
 * @method update
 * @param {Number} time The current time in the physics engine.
 * @param {Number} dt The physics engine frame delta.
 */
Force.prototype.update = function update(time, dt) {};

module.exports = Force;

},{}],129:[function(require,module,exports){
'use strict';

var Force = require('./Force');
var Vec3 = require('famous-math').Vec3;

var FORCE_REGISTER = new Vec3();

/**
 * Force that pulls all objects in a direction with constant acceleration
 *
 * @class Gravity1D
 * @extends Force
 * @param {Object} options
 */
function Gravity1D(targets, options) {
    Force.call(this, targets, options);
}

Gravity1D.prototype = Object.create(Force.prototype);
Gravity1D.prototype.constructor = Gravity1D;

/**
 * @enum directions
 */
Gravity1D.DOWN     = 0;
Gravity1D.UP       = 1;
Gravity1D.LEFT     = 2;
Gravity1D.RIGHT    = 3;
Gravity1D.FORWARD  = 4;
Gravity1D.BACKWARD = 5;

/**
 * Initialize the Force. Sets defaults if a property was not already set.
 *
 * @method init
 * @param {Object} options The options hash.
 */
Gravity1D.prototype.init = function(options) {
    this.max = this.max || Infinity;
    if (options.acceleration) {
        this.strength = this.acceleration.length();
        this.direction = -1;
        return;
    }
    var acceleration = this.acceleration = new Vec3();
    var direction = this.direction = this.direction || Gravity1D.DOWN;
    var magnitude = this.strength = this.strength || 200;
    switch (direction) {
        case Gravity1D.DOWN:
            acceleration.set(0, magnitude, 0);
            break;
        case Gravity1D.UP:
            acceleration.set(0, -1 * magnitude, 0);
            break;
        case Gravity1D.LEFT:
            acceleration.set(-1 * magnitude, 0, 0);
            break;
        case Gravity1D.RIGHT:
            acceleration.set(magnitude, 0, 0);
            break;
        case Gravity1D.FORWARD:
            acceleration.set(0, 0, -1 * magnitude);
            break;
        case Gravity1D.BACKWARD:
            acceleration.set(0, 0, magnitude);
            break;
        default:
            break;
    }
};

/**
 * Apply the force.
 *
 * @method update
 */
Gravity1D.prototype.update = function() {
    var targets = this.targets;

    var force = FORCE_REGISTER;

    var max = this.max;
    var acceleration = this.acceleration;
    var a = acceleration.length();
    var invA = a ? 1 / a : 0;
    for (var i = 0, len = targets.length; i < len; i++) {
        var target = targets[i];
        var magnitude = a * target.mass;
        Vec3.scale(acceleration, (magnitude > max ? max : magnitude) * invA, force);
        target.applyForce(force);
    }
};

module.exports = Gravity1D;

},{"./Force":128,"famous-math":90}],130:[function(require,module,exports){
'use strict';

var Force = require('./Force');
var Vec3 = require('famous-math').Vec3;

var FORCE_REGISTER = new Vec3();

/**
 * An inverse square force dependent on the masses of the source and targets.
 *
 * @class Gravity3D
 * @extends Force
 * @param {Object} options
 */
function Gravity3D(source, targets, options) {
    this.source = source || null;
    Force.call(this, targets, options);
}

Gravity3D.prototype = Object.create(Force.prototype);
Gravity3D.prototype.constructor = Gravity3D;

/**
 * Initialize the Force. Sets defaults if a property was not already set.
 *
 * @method init
 */
Gravity3D.prototype.init = function() {
    this.max = this.max || Infinity;
    this.strength = this.strength || 200;
};

/**
 * Apply the force.
 *
 * @method update
 */
Gravity3D.prototype.update = function() {
    var source = this.source;
    var targets = this.targets;

    var force = FORCE_REGISTER;

    var strength = this.strength;
    var max = this.max;
    var anchor = this.anchor || source.position;
    var sourceMass = this.anchor ? 1 : source.mass;
    for (var i = 0, len = targets.length; i < len; i++) {
        var target = targets[i];
        Vec3.subtract(anchor, target.position, force);
        var dist = force.length();
        var invDistance = dist ? 1 / dist : 0;
        var magnitude = strength * sourceMass * target.mass * invDistance * invDistance;
        if (magnitude < 0) {
            magnitude = magnitude < -max ? -max : magnitude;
        } else {
            magnitude = magnitude > max ? max : magnitude;
        }
        force.scale(magnitude * invDistance);
        target.applyForce(force);
        if (source) source.applyForce(force.invert());
    }
};

module.exports = Gravity3D;

},{"./Force":128,"famous-math":90}],131:[function(require,module,exports){
'use strict';

var Force = require('./Force');
var Vec3 = require('famous-math').Vec3;

var TORQUE_REGISTER = new Vec3();

/**
 * A behavior that slows angular velocity by applying torque.
 *
 * @class RotationalDrag
 * @extends Force
 * @param {Object} options options to set on drag
 */
function RotationalDrag(targets, options) {
    Force.call(this, targets, options);
}

RotationalDrag.prototype = Object.create(Force.prototype);
RotationalDrag.prototype.constructor = RotationalDrag;

/**
 * Used to scale angular velocity in the computation of the drag torque.
 *
 * @attribute QUADRATIC
 * @type Function
 * @param {Vec3} omega
 * @return {Number}
 */
RotationalDrag.QUADRATIC = function QUADRATIC(omega) {
    return omega.length();
};

/**
 * Used to scale angular velocity in the computation of the drag torque.
 *
 * @attribute LINEAR
 * @type Function
 * @return {Number}
 */
RotationalDrag.LINEAR = function LINEAR() {
    return 1;
};

/**
 * Initialize the Force. Sets defaults if a property was not already set.
 *
 * @method init
 */
RotationalDrag.prototype.init = function init() {
    this.max = this.max || Infinity;
    this.strength = this.strength || 1;
    this.type = this.type || RotationalDrag.LINEAR;
};

/**
 * Adds a rotational drag force to a physics body's torque accumulator.
 *
 * @method update
 */
RotationalDrag.prototype.update = function update() {
    var targets = this.targets;
    var type = this.type;

    var torque = TORQUE_REGISTER;

    var max = this.max;
    var strength = this.strength;
    for (var i = 0, len = targets.length; i < len; i++) {
        var target = targets[i];
        var omega = target.angularVelocity;
        var magnitude = -strength * type(omega);
        Vec3.scale(omega, magnitude < -max ? -max : magnitude, torque);
        target.applyTorque(torque);
    }
};

module.exports = RotationalDrag;

},{"./Force":128,"famous-math":90}],132:[function(require,module,exports){
'use strict';

var Force = require('./Force');
var Quaternion = require('famous-math').Quaternion;
var Vec3 = require('famous-math').Vec3;
var Mat33 = require('famous-math').Mat33;

var Q_REGISTER = new Quaternion();
var DAMPING_REGISTER = new Vec3();
var XYZ_REGISTER = new Vec3();
var MAT_REGISTER = new Mat33();

/** @const PI */
var PI = Math.PI;

/**
 * A spring-like behavior that attempts to enforce a specfic orientation by applying torque.
 *
 * @class RotationalSpring
 * @extends Force
 * @param {Object} options
 */
function RotationalSpring(source, targets, options) {
    this.source = source || null;
    Force.call(this, targets, options);
}

RotationalSpring.prototype = Object.create(Force.prototype);
RotationalSpring.prototype.constructor = RotationalSpring;

/**
 * Initialize the Force. Sets defaults if a property was not already set.
 *
 * @method init
 * @param {Object} options The options hash.
 */
RotationalSpring.prototype.init = function init(options) {
    if (!this.source) this.anchor = this.anchor ? this.anchor.normalize() : new Quaternion(1,0,0,0);
    if (options.stiffness || options.damping) {
        this.stiffness = this.stiffness || 100;
        this.damping = this.damping || 0;
        this.period = null;
        this.dampingRatio = null;
    }
    else if (options.period || options.dampingRatio) {
        this.period = this.period || 1;
        this.dampingRatio = this.dampingRatio || 0;

        this.stiffness = 2 * PI / this.period;
        this.stiffness *= this.stiffness;
        this.damping = 4 * PI * this.dampingRatio / this.period;
    }
};

/**
 * Adds a torque force to a physics body's torque accumulator.
 *
 * @method update
 */
RotationalSpring.prototype.update = function update() {
    var source = this.source;
    var targets = this.targets;

    var deltaQ = Q_REGISTER;
    var dampingTorque = DAMPING_REGISTER;
    var XYZ = XYZ_REGISTER;
    var effInertia = MAT_REGISTER;

    var max = this.max;
    var stiffness = this.stiffness;
    var damping = this.damping;
    var anchor = this.anchor || source.orientation;
    var invSourceInertia = this.anchor ? null : source.inverseInertia;
    for (var i = 0, len = targets.length; i < len; i++) {
        var target = targets[i];
        var q = target.orientation;
        Quaternion.conjugate(q, deltaQ);
        deltaQ.multiply(anchor);

        if (deltaQ.w >= 1) continue;
        var halftheta = Math.acos(deltaQ.w);
        var length = Math.sqrt(1 - deltaQ.w * deltaQ.w);

        var deltaOmega = XYZ.copy(deltaQ).scale(2 * halftheta / length);

        deltaOmega.scale(stiffness);

        if (invSourceInertia !== null) {
            Mat33.add(invSourceInertia, target.inverseInertia, effInertia).inverse();
        } else {
            Mat33.inverse(target.inverseInertia, effInertia);
        }

        if (damping !== 0) {
            if (source) {
                deltaOmega.add(Vec3.subtract(target.angularVelocity, source.angularVelocity, dampingTorque).scale(-damping));
            }
            else {
                deltaOmega.add(Vec3.scale(target.angularVelocity, -damping, dampingTorque));
            }
        }

        var torque = deltaOmega.applyMatrix(effInertia);
        var magnitude = torque.length();

        if (magnitude > max) torque.scale(max/magnitude);

        target.applyTorque(torque);
        if (source) source.applyTorque(torque.invert());
    }
};

module.exports = RotationalSpring;

},{"./Force":128,"famous-math":90}],133:[function(require,module,exports){
'use strict';

var Force = require('./Force');
var Vec3 = require('famous-math').Vec3;

var FORCE_REGISTER = new Vec3();
var DAMPING_REGISTER = new Vec3();

/**
 * A force that accelerates a Particle towards a specific anchor point. Can be anchored to
 * a Vec3 or another source Particle.
 *
 *  @class Spring
 *  @extends Force
 *  @param {Object} options options to set on drag
 */
function Spring(source, targets, options) {
    this.source = source || null;
    Force.call(this, targets, options);
}

Spring.prototype = Object.create(Force.prototype);
Spring.prototype.constructor = Spring;

/** @const */
var PI = Math.PI;

/**
 * A FENE (Finitely Extensible Nonlinear Elastic) spring force
 *      see: http://en.wikipedia.org/wiki/FENE
 * @attribute FENE
 * @type Function
 * @param {Number} dist current distance target is from source body
 * @param {Number} rMax maximum range of influence
 * @return {Number} unscaled force
 */
Spring.FENE = function(dist, rMax) {
    var rMaxSmall = rMax * 0.99;
    var r = Math.max(Math.min(dist, rMaxSmall), -rMaxSmall);
    return r / (1 - r * r/(rMax * rMax));
};

/**
 * A Hookean spring force, linear in the displacement
 *      see: http://en.wikipedia.org/wiki/Hooke's_law
 * @attribute HOOKE
 * @type Function
 * @param {Number} dist current distance target is from source body
 * @return {Number} unscaled force
 */
Spring.HOOKE = function(dist) {
    return dist;
};

/**
 * Initialize the Force. Sets defaults if a property was not already set.
 *
 * @method init
 * @param {Object} options The options hash.
 */
Spring.prototype.init = function(options) {
    this.max = this.max || Infinity;
    this.length = this.length || 0;
    this.type = this.type || Spring.HOOKE;
    this.maxLength = this.maxLength || Infinity;
    if (options.stiffness || options.damping) {
        this.stiffness = this.stiffness || 100;
        this.damping = this.damping || 0;
        this.period = null;
        this.dampingRatio = null;
    }
    else if (options.period || options.dampingRatio) {
        this.period = this.period || 1;
        this.dampingRatio = this.dampingRatio || 0;

        this.stiffness = 2 * PI / this.period;
        this.stiffness *= this.stiffness;
        this.damping = 4 * PI * this.dampingRatio / this.period;
    }
};

/**
 * Apply the force.
 *
 * @method update
 */
Spring.prototype.update = function() {
    var source = this.source;
    var targets = this.targets;

    var force = FORCE_REGISTER;
    var dampingForce = DAMPING_REGISTER;

    var max = this.max;
    var stiffness = this.stiffness;
    var damping = this.damping;
    var restLength = this.length;
    var maxLength = this.maxLength;
    var anchor = this.anchor || source.position;
    var invSourceMass = this.anchor ? 0 : source.inverseMass;
    var type = this.type;

    for (var i = 0, len = targets.length; i < len; i++) {
        var target = targets[i];
        Vec3.subtract(anchor, target.position, force);
        var dist = force.length();
        var stretch = dist - restLength;

        if (Math.abs(stretch) < 1e-6) continue;

        var effMass = 1 / (target.inverseMass + invSourceMass);
        if (this.period !== null) {
            stiffness *= effMass;
            damping *= effMass;
        }

        force.scale(stiffness * type(stretch, maxLength) / stretch);

        if (damping !== 0) {
            if (source) {
                force.add(Vec3.subtract(target.velocity, source.velocity, dampingForce).scale(-damping));
            }
            else {
                force.add(Vec3.scale(target.velocity, -damping, dampingForce));
            }
        }

        var magnitude = force.length();
        var invMag = magnitude ? 1 / magnitude : 0;

        Vec3.scale(force, (magnitude > max ? max : magnitude) * invMag, force);

        target.applyForce(force);
        if (source) source.applyForce(force.invert());
    }
};

module.exports = Spring;

},{"./Force":128,"famous-math":90}],134:[function(require,module,exports){
'use strict';

module.exports = {
    Particle: require('./bodies/Particle'),
    ConvexBodyFactory: require('./bodies/ConvexBodyFactory'),
    Box: require('./bodies/Box'),
    Sphere: require('./bodies/Sphere'),
    Wall: require('./bodies/Wall'),

    Constraint: require('./constraints/Constraint'),
    Angle: require('./constraints/Angle'),
    Collision: require('./constraints/Collision'),
    Direction: require('./constraints/Direction'),
    Distance: require('./constraints/Distance'),
    Curve: require('./constraints/Curve'),
    Hinge: require('./constraints/Hinge'),
    Point2Point: require('./constraints/Point2Point'),

    Force: require('./forces/Force'),
    Drag: require('./forces/Drag'),
    RotationalDrag: require('./forces/RotationalDrag'),
    Gravity1D: require('./forces/Gravity1D'),
    Gravity3D: require('./forces/Gravity3D'),
    Spring: require('./forces/Spring'),
    RotationalSpring: require('./forces/RotationalSpring'),

    PhysicsEngine: require('./PhysicsEngine'),
    Geometry: require('./Geometry')
};

},{"./Geometry":107,"./PhysicsEngine":108,"./bodies/Box":109,"./bodies/ConvexBodyFactory":110,"./bodies/Particle":111,"./bodies/Sphere":112,"./bodies/Wall":113,"./constraints/Angle":114,"./constraints/Collision":115,"./constraints/Constraint":116,"./constraints/Curve":117,"./constraints/Direction":118,"./constraints/Distance":119,"./constraints/Hinge":120,"./constraints/Point2Point":121,"./forces/Drag":127,"./forces/Force":128,"./forces/Gravity1D":129,"./forces/Gravity3D":130,"./forces/RotationalDrag":131,"./forces/RotationalSpring":132,"./forces/Spring":133}],135:[function(require,module,exports){
arguments[4][78][0].apply(exports,arguments)
},{"dup":78}],136:[function(require,module,exports){
arguments[4][79][0].apply(exports,arguments)
},{"./animationFrame":135,"dup":79}],137:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"dup":2}],138:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"./Dispatch":139,"./Node":142,"./Size":143,"dup":3}],139:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],140:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5}],141:[function(require,module,exports){
arguments[4][6][0].apply(exports,arguments)
},{"./Clock":137,"./Context":138,"dup":6}],142:[function(require,module,exports){
'use strict';

var Transform = require('./Transform');
var Size = require('./Size');

var TRANSFORM_PROCESSOR = new Transform();
var SIZE_PROCESSOR = new Size();

var IDENT = [
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1
];

var ONES = [1, 1, 1];
var QUAT = [0, 0, 0, 1];

/**
 * Nodes define hierarchy and geometrical transformations. They can be moved
 * (translated), scaled and rotated.
 * 
 * A Node is either mounted or unmounted. Unmounted nodes are detached from the
 * scene graph. Unmounted nodes have no parent node, while each mounted node has
 * exactly one parent. Nodes have an arbitary number of children, which can be
 * dynamically added using @{@link addChild}.
 *
 * Each Nodes have an arbitrary number of `components`. Those components can
 * send `draw` commands to the renderer or mutate the node itself, in which case
 * they define behavior in the most explicit way. Components that send `draw`
 * commands aare considered `renderables`. From the node's perspective, there is
 * no distinction between nodes that send draw commands and nodes that define
 * behavior.
 *
 * Because of the fact that Nodes themself are very unopinioted (they don't
 * "render" to anything), they are often being subclassed in order to add e.g.
 * components at initialization to them. Because of this flexibility, they might
 * as well have been called `Entities`.
 *
 * @example
 * // create three detached (unmounted) nodes
 * var parent = new Node();
 * var child1 = new Node();
 * var child2 = new Node();
 *
 * // build an unmounted subtree (parent is still detached)
 * parent.addChild(child1);
 * parent.addChild(child2);
 *
 * // mount parent by adding it to the context
 * var context = Famous.createContext("body");
 * context.addChild(parent);
 *
 * @class Node
 * @constructor
 */
function Node () {
    this._calculatedValues = {
        transform: new Float32Array(IDENT),
        size: new Float32Array(3)
    };

    this._requestingUpdate = false;
    this._inUpdate = false;

    this._updateQueue = [];
    this._nextUpdateQueue = [];

    this._freedComponentIndicies = [];
    this._components = [];

    this._freedChildIndicies = [];
    this._children = [];

    this._parent = null;
    this._globalUpdater = null;

    this.value = new Node.Spec();
}

Node.RELATIVE_SIZE = Size.RELATIVE;
Node.ABSOLUTE_SIZE = Size.ABSOLUTE;
Node.RENDER_SIZE = Size.RENDER;
Node.DEFAULT_SIZE = Size.DEFAULT;

/**
 * A Node spec holds the "data" associated with a Node.
 *
 * @property {String} location path to the node (e.g. "body/0/1")
 * @property {Object} showState
 * @property {Boolean} showState.mounted
 * @property {Boolean} showState.shown
 * @property {Number} showState.opacity
 * @property {Object} offsets
 * @property {Float32Array.<Number>} offsets.mountPoint
 * @property {Float32Array.<Number>} offsets.align
 * @property {Float32Array.<Number>} offsets.origin
 * @property {Object} vectors
 * @property {Float32Array.<Number>} vectors.position
 * @property {Float32Array.<Number>} vectors.rotation
 * @property {Float32Array.<Number>} vectors.scale
 * @property {Object} size
 * @property {Float32Array.<Number>} size.sizeMode
 * @property {Float32Array.<Number>} size.proportional
 * @property {Float32Array.<Number>} size.differential
 * @property {Float32Array.<Number>} size.absolute
 * @property {Float32Array.<Number>} size.render
 */
Node.Spec = function Spec () {
    this.location = null;
    this.showState = {
        mounted: false,
        shown: false,
        opacity: 1
    };
    this.offsets = {
        mountPoint: new Float32Array(3),
        align: new Float32Array(3),
        origin: new Float32Array(3)
    };
    this.vectors = {
        position: new Float32Array(3),
        rotation: new Float32Array(QUAT),
        scale: new Float32Array(ONES)
    };
    this.size = {
        sizeMode: new Float32Array([Size.RELATIVE, Size.RELATIVE, Size.RELATIVE]),
        proportional: new Float32Array(ONES),
        differential: new Float32Array(3),
        absolute: new Float32Array(3),
        render: new Float32Array(3)
    };
    this.UIEvents = [];
};

/**
 * @method getContext
 * @chainable
 *
 * @deprecated Node can be used directly instead!
 * @return {Node} this
 */
Node.prototype.getContext = function getContext () {
    console.warn(
        'Node#getContext is deprecated!\n' +
        'Nodes can be used directly!'
    );
    return this;
};

/**
 * @method getDispatch
 * @chainable
 *
 * @deprecated Node can be used directly instead!
 * @return {Node} this
 */
Node.prototype.getDispatch = function getDispatch () {
    console.warn(
        'Node#getDispatch is deprecated!\n' +
        'Component constructors accept a Node instead!' +
        'Use new Component(node) instead of new Component(node.getDispatch())!'
    );
    return this;
};

/**
 * @method getRenderProxy
 * @chainable
 *
 * @deprecated Node can be used directly instead!
 * @return {Node} this
 */
Node.prototype.getRenderProxy = function getRenderProxy () {
    console.warn(
        'Node#getRenderProxy is deprecated!\n' +
        'RenderProxy functionality has been merged into Node!'
    );
    return this;
};

/**
 * @method getRenderPath
 * @chainable
 *
 * @deprecated Use #getLocation()
 * @return {string} render path
 */
Node.prototype.getRenderPath = function getRenderPath () {
    console.warn(
        'Node#getRenderPath is deprecated!\n' +
        'Use Node#getLocation instead!'
    );
    return this.getLocation();
};

/**
 * @method addRenderable
 * @chainable
 *
 * @deprecated Use addComponent
 * @param {*} component component to be added
 * @return this
 */
Node.prototype.addRenderable = function addRenderable (component) {
    console.warn(
        'Node#addRenderable is deprecated!\n' +
        'use node.addComponent instead'
    );
    this.addComponent(component);
    return this;
};

/**
 * Determine the node's location in the scene graph hierarchy.
 * A location of `body/0/1` can be interpreted as the following scene graph
 * hierarchy (ignoring siblings of ancestors and additional child nodes):
 *
 * `Context:body` -> `Node:0` -> `Node:1`, where `Node:1` is the node the
 * `getLocation` method has been invoked on.
 *
 * @method getLocation
 * 
 * @return {String} location (path), e.g. `body/0/1`
 */
Node.prototype.getLocation = function getLocation () {
    return this.value.location;
};

/**
 * @alias getId
 */
Node.prototype.getId = Node.prototype.getLocation;

/**
 * Dispatches the event on the node by recursively traversing the scene graph
 * upwards.
 *
 * @method emit
 * 
 * @param  {String} event   Event type.
 * @param  {Object} payload Event object to be dispatched.
 */
Node.prototype.emit = function emit (event, payload) {
    var p = this.getParent();
    // the context is its own ancestor
    while (p !== (p = p.getParent()));
    p.getDispatch().dispatch(event, payload);
    return this;
};

// THIS WILL BE DEPRICATED
Node.prototype.sendDrawCommand = function sendDrawCommand (message) {
    this._globalUpdater.message(message);
    return this;
};

/**
 * Recursively serializes the Node, including all previously added components.
 *
 * @method getValue
 * 
 * @return {Object}     Serialized representation of the node, including
 *                      components.
 */
Node.prototype.getValue = function getValue () {
    var numberOfChildren = this._children.length;
    var numberOfComponents = this._components.length;
    var i = 0;

    var value = {
        location: this.value.location,
        spec: this.value,
        components: new Array(numberOfComponents),
        children: new Array(numberOfChildren)
    };

    for (; i < numberOfChildren ; i++)
        value.children[i] = this._children[i].getValue();

    for (i = 0 ; i < numberOfComponents ; i++)
        if (this._components[i].getValue)
            value.components[i] = this._components[i].getValue();

    return value;
};

/**
 * Similar to @{@link getValue}, but returns the actual "computed" value. E.g.
 * a proportional size of 0.5 might resolve into a "computed" size of 200px
 * (assuming the parent has a width of 400px).
 *
 * @method getComputedValue
 * 
 * @return {Object}     Serialized representation of the node, including
 *                      children, excluding components.
 */
Node.prototype.getComputedValue = function getComputedValue () {
    var numberOfChildren = this._children.length;

    var value = {
        location: this.value.location,
        computedValues: this._calculatedValues,
        children: new Array(numberOfChildren)
    };

    for (var i = 0 ; i < numberOfChildren ; i++)
        value.children[i] = this._children[i].getComputedValue();

    return value;
};

/**
 * Retrieves all children of the current node.
 *
 * @method getChildren
 * 
 * @return {Array.<Node>}   An array of children.
 */
Node.prototype.getChildren = function getChildren () {
    return this._children;
};

/**
 * Retrieves the parent of the current node. Unmounted nodes do not have a
 * parent node.
 *
 * @method getParent
 * 
 * @return {Node}       Parent node.
 */
Node.prototype.getParent = function getParent () {
    return this._parent;
};

/**
 * Schedules the @{@link update} function of the node to be invoked on the next
 * frame (if no update during this frame has been scheduled already).
 * If the node is currently being updated (which means one of the requesters
 * invoked requestsUpdate while being updated itself), an update will be
 * scheduled on the next frame.
 *
 * @method requestUpdate
 * 
 * @param  {Object} requester   If the requester has an `onUpdate` method, it
 *                              will be invoked during the next update phase of
 *                              the node.
 */
Node.prototype.requestUpdate = function requestUpdate (requester) {
    if (this._inUpdate) return this.requestUpdateOnNextTick(requester);
    this._updateQueue.push(requester);
    if (!this._requestingUpdate) this._requestUpdate();
    return this;
};

/**
 * Schedules an update on the next tick. Similarily to @{@link requestUpdate},
 * `requestUpdateOnNextTick` schedules the node's `onUpdate` function to be
 * invoked on the frame after the next invocation on the node's onUpdate function.
 *
 * @method requestUpdateOnNextTick
 * 
 * @param  {Object} requester   If the requester has an `onUpdate` method, it
 *                              will be invoked during the next update phase of
 *                              the node.
 */
Node.prototype.requestUpdateOnNextTick = function requestUpdateOnNextTick (requester) {
    this._nextUpdateQueue.push(requester);
    return this;
};

/**
 * If the context has been created using @{@link Famous.createContext}, the
 * @{@link Famous} singleton will be the global updater.
 *
 * @method getUpdater
 * 
 * @return {Object} The global updater.
 */
Node.prototype.getUpdater = function getUpdater () {
    return this._globalUpdater;
};

/**
 * Checks if the node is mounted. Unmounted nodes are detached from the scene
 * graph.
 *
 * @method isMounted
 * 
 * @return {Boolean}    Boolean indicating weather the node is mounted or not.
 */
Node.prototype.isMounted = function isMounted () {
    return this.value.showState.mounted;
};

/**
 * Checks if the node is visible ("shown").
 *
 * @method isShown
 * 
 * @return {Boolean}    Boolean indicating weather the node is visible
 *                      ("shown") or not.
 */
Node.prototype.isShown = function isShown () {
    return this.value.showState.shown;
};

/**
 * Determines the node's relative opacity.
 * The opacity needs to be within [0, 1], where 0 indicates a completely
 * transparent, therefore invisible node, whereas an opacity of 1 means the
 * node is completely solid.
 *
 * @method getOpacity
 * 
 * @return {Number}         Relative opacity of the node.
 */
Node.prototype.getOpacity = function getOpacity () {
    return this.value.showState.opacity;
};

/**
 * Determines the node's previously set mount point.
 * 
 * @method getMountPoint
 * 
 * @return {Float32Array}   An array representing the mount point.
 */
Node.prototype.getMountPoint = function getMountPoint () {
    return this.value.offsets.mountPoint;
};

/**
 * Determines the node's previously set align.
 * 
 * @method getAlign
 * 
 * @return {Float32Array}   An array representing the align.
 */
Node.prototype.getAlign = function getAlign () {
    return this.value.offsets.align;
};

/**
 * Determines the node's previously set origin.
 * 
 * @method getOrigin
 * 
 * @return {Float32Array}   An array representing the origin.
 */
Node.prototype.getOrigin = function getOrigin () {
    return this.value.offsets.origin;
};

/**
 * Determines the node's previously set position.
 *
 * @method getPosition
 * 
 * @return {Float32Array}   An array representing the position.
 */
Node.prototype.getPosition = function getPosition () {
    return this.value.vectors.position;
};

Node.prototype.getRotation = function getRotation () {
    return this.value.vectors.rotation;
};

Node.prototype.getScale = function getScale () {
    return this.value.vectors.scale;
};

Node.prototype.getSizeMode = function getSizeMode () {
    return this.value.size.sizeMode;
};

Node.prototype.getProportionalSize = function getProportionalSize () {
    return this.value.size.proportional;
};

Node.prototype.getDifferentialSize = function getDifferentialSize () {
    return this.value.size.differential;
};

Node.prototype.getAbsoluteSize = function getAbsoluteSize () {
    return this.value.size.absolute;
};

Node.prototype.getRenderSize = function getRenderSize () {
    return this.value.size.render;
};

Node.prototype.getSize = function getSize () {
    return this._calculatedValues.size;
};

Node.prototype.getTransform = function getTransform () {
    return this._calculatedValues.transform;
};

Node.prototype.getUIEvents = function getUIEvents () {
    return this.value.UIEvents;
};

Node.prototype.addChild = function addChild (child) {
    var index = child ? this._children.indexOf(child) : -1;
    child = child ? child : new Node();

    if (index === -1) {
        index = this._freedChildIndicies.length ? this._freedChildIndicies.pop() : this._children.length;
        this._children[index] = child;

        if (this.isMounted() && child.onMount) {
            var myId = this.getId();
            var childId = myId + '/' + index;
            child.onMount(this, childId);
        }

    }

    return child;
};

Node.prototype.removeChild = function removeChild (child) {
    var index = this._children.indexOf(child);
    var added = index !== -1;
    if (added) {
        this._freedChildIndicies.push(index);

        if (this.isMounted() && child.onDismount)
            child.onDismount();

        this._children[index] = null;
    }
    return added;
};

/**
 * Each component can only be added once per node.
 *
 * @method addComponent
 * 
 * @param {Object} component    An component to be added.
 */
Node.prototype.addComponent = function addComponent (component) {
    var index = this._components.indexOf(component);
    if (index === -1) {
        index = this._freedComponentIndicies.length ? this._freedComponentIndicies.pop() : this._components.length;
        this._components[index] = component;

        if (this.isMounted() && component.onMount)
            component.onMount(this, index);

        if (this.isShown() && component.onShow)
            component.onShow();
    }

    return index;
};

/**
 * Removes a previously via @{@link addComponent} added component.
 *
 * @method removeComponent
 * 
 * @param  {Object} component   An component that has previously been added
 *                              using @{@link addComponent}.
 */
Node.prototype.removeComponent = function removeComponent (component) {
    var index = this._components.indexOf(component);
    if (index !== -1) {
        this._freedComponentIndicies.push(index);
        if (this.isShown() && component.onHide)
            component.onHide();

        if (this.isMounted() && component.onDismount)
            component.onDismount();

        this._components[index] = null;
    }
    return component;
};

Node.prototype.addUIEvent = function addUIEvent (eventName) {
    var UIEvents = this.getUIEvents();
    var components = this._components;
    var component;

    var added = UIEvents.indexOf(eventName) !== -1;
    if (!added) {
        UIEvents.push(eventName);
        for (var i = 0, len = components.length ; i < len ; i++) {
            component = components[i];
            if (component.onAddUIEvent) component.onAddUIEvent(eventName);
        }
    }
    return added;
};

Node.prototype._requestUpdate = function _requestUpdate (force) {
    if (force || (!this._requestingUpdate && this._globalUpdater)) {
        this._globalUpdater.requestUpdate(this);
        this._requestingUpdate = true;
    }
};

Node.prototype._vecOptionalSet = function _vecOptionalSet (vec, index, val) {
    if (val != null && vec[index] !== val) {
        vec[index] = val;
        if (!this._requestingUpdate) this._requestUpdate();
        return true;
    }
    return false;
};

Node.prototype.show = function show () {
    var i = 0;
    var items = this._components;
    var len = items.length;
    var item;

    this.value.showState.shown = true;

    for (; i < len ; i++) {
        item = items[i];
        if (item && item.onShow) item.onShow();
    }

    i = 0;
    items = this._children;
    len = items.length;

    for (; i < len ; i++) {
        item = items[i];
        if (item && item.onParentShow) item.onParentShow();
    }
    return this;
};

Node.prototype.hide = function hide () {
    var i = 0;
    var items = this._components;
    var len = items.length;
    var item;

    this.value.showState.shown = false;

    for (; i < len ; i++) {
        item = items[i];
        if (item && item.onHide) item.onHide();
    }

    i = 0;
    items = this._children;
    len = items.length;

    for (; i < len ; i++) {
        item = items[i];
        if (item && item.onParentHide) item.onParentHide();
    }
    return this;
};

Node.prototype.setAlign = function setAlign (x, y, z) {
    var vec3 = this.value.offsets.align;
    var propogate = false;

    propogate = this._vecOptionalSet(vec3, 0, x) || propogate;
    propogate = this._vecOptionalSet(vec3, 1, y) || propogate;
    propogate = this._vecOptionalSet(vec3, 2, (z - 0.5)) || propogate;

    if (propogate) {
        var i = 0;
        var list = this._components;
        var len = list.length;
        var item;
        x = vec3[0];
        y = vec3[1];
        z = vec3[2];
        for (; i < len ; i++) {
            item = list[i];
            if (item && item.onAlignChange) item.onAlignChange(x, y, z);
        }
    }
    return this;
};

Node.prototype.setMountPoint = function setMountPoint (x, y, z) {
    var vec3 = this.value.offsets.mountPoint;
    var propogate = false;

    propogate = this._vecOptionalSet(vec3, 0, x) || propogate;
    propogate = this._vecOptionalSet(vec3, 1, y) || propogate;
    propogate = this._vecOptionalSet(vec3, 2, (z - 0.5)) || propogate;

    if (propogate) {
        var i = 0;
        var list = this._components;
        var len = list.length;
        var item;
        x = vec3[0];
        y = vec3[1];
        z = vec3[2];
        for (; i < len ; i++) {
            item = list[i];
            if (item && item.onMountPointChange) item.onMountPointChange(x, y, z);
        }
    }
    return this;
};

Node.prototype.setOrigin = function setOrigin (x, y, z) {
    var vec3 = this.value.offsets.origin;
    var propogate = false;

    propogate = this._vecOptionalSet(vec3, 0, x) || propogate;
    propogate = this._vecOptionalSet(vec3, 1, y) || propogate;
    propogate = this._vecOptionalSet(vec3, 2, (z - 0.5)) || propogate;

    if (propogate) {
        var i = 0;
        var list = this._components;
        var len = list.length;
        var item;
        x = vec3[0];
        y = vec3[1];
        z = vec3[2];
        for (; i < len ; i++) {
            item = list[i];
            if (item && item.onOriginChange) item.onOriginChange(x, y, z);
        }
    }
    return this;
};


Node.prototype.setPosition = function setPosition (x, y, z) {
    var vec3 = this.value.vectors.position;
    var propogate = false;

    propogate = this._vecOptionalSet(vec3, 0, x) || propogate;
    propogate = this._vecOptionalSet(vec3, 1, y) || propogate;
    propogate = this._vecOptionalSet(vec3, 2, z) || propogate;

    if (propogate) {
        var i = 0;
        var list = this._components;
        var len = list.length;
        var item;
        x = vec3[0];
        y = vec3[1];
        z = vec3[2];
        for (; i < len ; i++) {
            item = list[i];
            if (item && item.onPositionChange) item.onPositionChange(x, y, z);
        }
    }

    return this;
};

Node.prototype.setRotation = function setRotation (x, y, z, w) {
    var quat = this.value.vectors.rotation;
    var propogate = false;
    var qx, qy, qz, qw;

    if (w != null) {
        qx = x;
        qy = y;
        qz = z;
        qw = w;
    }
    else {
        var hx = x * 0.5;
        var hy = y * 0.5;
        var hz = z * 0.5;

        var sx = Math.sin(hx);
        var sy = Math.sin(hy);
        var sz = Math.sin(hz);
        var cx = Math.cos(hx);
        var cy = Math.cos(hy);
        var cz = Math.cos(hz);

        var sysz = sy * sz;
        var cysz = cy * sz;
        var sycz = sy * cz;
        var cycz = cy * cz;

        qx = sx * cycz + cx * sysz;
        qy = cx * sycz - sx * cysz;
        qz = cx * cysz + sx * sycz;
        qw = cx * cycz - sx * sysz;
    }

    propogate = this._vecOptionalSet(quat, 0, qx) || propogate;
    propogate = this._vecOptionalSet(quat, 1, qy) || propogate;
    propogate = this._vecOptionalSet(quat, 2, qz) || propogate;
    propogate = this._vecOptionalSet(quat, 3, qw) || propogate;

    if (propogate) {
        var i = 0;
        var list = this._components;
        var len = list.length;
        var item;
        x = quat[0];
        y = quat[1];
        z = quat[2];
        w = quat[3];
        for (; i < len ; i++) {
            item = list[i];
            if (item && item.onRotationChange) item.onRotationChange(x, y, z, w);
        }
    }
    return this;
};

Node.prototype.setScale = function setScale (x, y, z) {
    var vec3 = this.value.vectors.scale;
    var propogate = false;

    propogate = this._vecOptionalSet(vec3, 0, x) || propogate;
    propogate = this._vecOptionalSet(vec3, 1, y) || propogate;
    propogate = this._vecOptionalSet(vec3, 2, z) || propogate;

    if (propogate) {
        var i = 0;
        var list = this._components;
        var len = list.length;
        var item;
        x = vec3[0];
        y = vec3[1];
        z = vec3[2];
        for (; i < len ; i++) {
            item = list[i];
            if (item && item.onScaleChange) item.onScaleChange(x, y, z);
        }
    }
    return this;
};

Node.prototype.setOpacity = function setOpacity (val) {
    if (val != this.value.showState.opacity) {
        this.value.showState.opacity = val;
        if (!this._requestingUpdate) this._requestUpdate();

        var i = 0;
        var list = this._components;
        var len = list.length;
        var item;
        for (; i < len ; i++) {
            item = list[i];
            if (item && item.onOpacityChange) item.onOpacityChange(val);
        }
    }
    return this;
};

/**
 * Sets the size mode being used for determining the nodes final width, height
 * and depth.
 * Size modes are a way to define the way the node's size is being calculated.
 * Size modes are enums set on the @{@link Size} constructor (and aliased on
 * the Node).
 *
 * @example
 * node.setSizeMode(Node.RELATIVE_SIZE, Node.ABSOLUTE_SIZE, Node.ABSOLUTE_SIZE);
 * // Instead of null, any proporional height or depth can be passed in, since
 * // it would be ignored in any case.
 * node.setProportionalSize(0.5, null, null);
 * node.setAbsoluteSize(null, 100, 200);
 *
 * @method setSizeMode
 * 
 * @param {SizeMode} x    The size mode being used for determining the size in
 *                        x direction ("width").
 * @param {SizeMode} y    The size mode being used for determining the size in
 *                        y direction ("height").
 * @param {SizeMode} z    The size mode being used for determining the size in
 *                        z direction ("depth").
 */
Node.prototype.setSizeMode = function setSizeMode (x, y, z) {
    var vec3 = this.value.size.sizeMode;
    var propogate = false;

    propogate = this._vecOptionalSet(vec3, 0, x) || propogate;
    propogate = this._vecOptionalSet(vec3, 1, y) || propogate;
    propogate = this._vecOptionalSet(vec3, 2, z) || propogate;

    if (propogate) {
        var i = 0;
        var list = this._components;
        var len = list.length;
        var item;
        x = vec3[0];
        y = vec3[1];
        z = vec3[2];
        for (; i < len ; i++) {
            item = list[i];
            if (item && item.onSizeModeChange) item.onSizeModeChange(x, y, z);
        }
    }
    return this;
};

/**
 * A proportional size defines the node's dimensions relative to its parents
 * final size.
 * Proportional sizes need to be within the range of [0, 1].
 *
 * @method setProportionalSize
 * 
 * @param {Number} x    x-Size in pixels ("width").
 * @param {Number} y    y-Size in pixels ("height").
 * @param {Number} z    z-Size in pixels ("depth").
 */
Node.prototype.setProportionalSize = function setProportionalSize (x, y, z) {
    var vec3 = this.value.size.proportional;
    var propogate = false;

    propogate = this._vecOptionalSet(vec3, 0, x) || propogate;
    propogate = this._vecOptionalSet(vec3, 1, y) || propogate;
    propogate = this._vecOptionalSet(vec3, 2, z) || propogate;

    if (propogate) {
        var i = 0;
        var list = this._components;
        var len = list.length;
        var item;
        x = vec3[0];
        y = vec3[1];
        z = vec3[2];
        for (; i < len ; i++) {
            item = list[i];
            if (item && item.onProportionalSizeChange) item.onProportionalSizeChange(x, y, z);
        }
    }
    return this;
};

/**
 * Differential sizing can be used to add or subtract an absolute size from a
 * otherwise proportionally sized node.
 * E.g. a differential width of `-10` and a proportional width of `0.5` is
 * being interpreted as setting the node's size to 50% of its parent's width
 * *minus* 10 pixels.
 *
 * @method setDifferentialSize
 * 
 * @param {Number} x    x-Size to be added to the relatively sized node in
 *                      pixels ("width").
 * @param {Number} y    y-Size to be added to the relatively sized node in
 *                      pixels ("height").
 * @param {Number} z    z-Size to be added to the relatively sized node in
 *                      pixels ("depth").
 */
Node.prototype.setDifferentialSize = function setDifferentialSize (x, y, z) {
    var vec3 = this.value.size.differential;
    var propogate = false;

    propogate = this._vecOptionalSet(vec3, 0, x) || propogate;
    propogate = this._vecOptionalSet(vec3, 1, y) || propogate;
    propogate = this._vecOptionalSet(vec3, 2, z) || propogate;

    if (propogate) {
        var i = 0;
        var list = this._components;
        var len = list.length;
        var item;
        x = vec3[0];
        y = vec3[1];
        z = vec3[2];
        for (; i < len ; i++) {
            item = list[i];
            if (item && item.onDifferentialSizeChange) item.onDifferentialSizeChange(x, y, z);
        }
    }
    return this;
};

/**
 * Sets the nodes size in pixels, independent of its parent.
 *
 * @method setAbsoluteSize
 * 
 * @param {Number} x    x-Size in pixels ("width").
 * @param {Number} y    y-Size in pixels ("height").
 * @param {Number} z    z-Size in pixels ("depth").
 */
Node.prototype.setAbsoluteSize = function setAbsoluteSize (x, y, z) {
    var vec3 = this.value.size.absolute;
    var propogate = false;

    propogate = this._vecOptionalSet(vec3, 0, x) || propogate;
    propogate = this._vecOptionalSet(vec3, 1, y) || propogate;
    propogate = this._vecOptionalSet(vec3, 2, z) || propogate;

    if (propogate) {
        var i = 0;
        var list = this._components;
        var len = list.length;
        var item;
        x = vec3[0];
        y = vec3[1];
        z = vec3[2];
        for (; i < len ; i++) {
            item = list[i];
            if (item && item.onAbsoluteSizeChange) item.onAbsoluteSizeChange(x, y, z);
        }
    }
    return this;
};

Node.prototype._transformChanged = function _transformChanged (transform) {
    var i = 0;
    var items = this._components;
    var len = items.length;
    var item;

    for (; i < len ; i++) {
        item = items[i];
        if (item && item.onTransformChange) item.onTransformChange(transform);
    }

    i = 0;
    items = this._children;
    len = items.length;

    for (; i < len ; i++) {
        item = items[i];
        if (item && item.onParentTransformChange) item.onParentTransformChange(transform);
    }
};

Node.prototype._sizeChanged = function _sizeChanged (size) {
    var i = 0;
    var items = this._components;
    var len = items.length;
    var item;

    for (; i < len ; i++) {
        item = items[i];
        if (item && item.onSizeChange) item.onSizeChange(size);
    }

    i = 0;
    items = this._children;
    len = items.length;

    for (; i < len ; i++) {
        item = items[i];
        if (item && item.onParentSizeChange) item.onParentSizeChange(size);
    }
};

// DEPRICATE
Node.prototype.getFrame = function getFrame () {
    return this._globalUpdater.getFrame();
};

/**
 * Enters the node's update phase while updating its own spec and updating its components.
 *
 * @method update
 * 
 * @param  {Number} time    high-resolution timstamp, usually retrieved using
 *                          requestAnimationFrame
 */
Node.prototype.update = function update (time){
    this._inUpdate = true;
    var nextQueue = this._nextUpdateQueue;
    var queue = this._updateQueue;
    var item;

    while (nextQueue.length) queue.unshift(nextQueue.pop());

    while (queue.length) {
        item = this._components[queue.shift()];
        if (item && item.onUpdate) item.onUpdate(time);
    }

    var mySize = this.getSize();
    var myTransform = this.getTransform();
    var parent = this.getParent();
    var parentSize = parent.getSize();
    var parentTransform = parent.getTransform();
    var sizeChanged = SIZE_PROCESSOR.fromSpecWithParent(parentSize, this.value, mySize);

    var transformChanged = TRANSFORM_PROCESSOR.fromSpecWithParent(parentTransform, this.value, mySize, parentSize, myTransform);
    if (transformChanged) this._transformChanged(myTransform);
    if (sizeChanged) this._sizeChanged(mySize);

    this._inUpdate = false;
    this._requestingUpdate = false;

    if (this._nextUpdateQueue.length) {
        this._globalUpdater.requestUpdateOnNextTick(this);
        this._requestingUpdate = true;
    }
    if (!this.isMounted()) {
        // last update
        this._parent = null;
        this.value.location = null;
        this._globalUpdater = null;
    }
    return this;
};

/**
 * Mounts the node and therefore its subtree by setting it as a child of the
 * passed in parent.
 *
 * @method mount
 * 
 * @param  {Node} parent    parent node
 * @param  {String} myId    path to node (e.g. `body/0/1`)
 */
Node.prototype.mount = function mount (parent, myId) {
    if (this.isMounted()) return;
    var i = 0;
    var list = this._components;
    var len = list.length;
    var item;

    this._parent = parent;
    this._globalUpdater = parent.getUpdater();
    this.value.location = myId;
    this.value.showState.mounted = true;

    for (; i < len ; i++) {
        item = list[i];
        if (item.onMount) item.onMount(this, i);
    }

    i = 0;
    list = this._children;
    len = list.length;
    for (; i < len ; i++) {
        item = list[i];
        if (item.onParentMount) item.onParentMount(this, myId, i);
    }

    if (this._requestingUpdate) this._requestUpdate(true);
    return this;
};

/**
 * Dismounts (detaches) the node from the scene graph by removing it as a
 * child of its parent.
 *
 * @method dismount
 */
Node.prototype.dismount = function dismount () {
    if (!this.isMounted()) return;
    var i = 0;
    var list = this._components;
    var len = list.length;
    var item;

    this.value.showState.mounted = false;

    this._parent.removeChild(this);

    for (; i < len ; i++) {
        item = list[i];
        if (item.onDismount) item.onDismount();
    }

    i = 0;
    list = this._children;
    len = list.length;
    for (; i < len ; i++) {
        item = list[i];
        if (item.onParentDismount) item.onParentDismount();
    }

    if (!this._requestingUpdate) this._requestUpdate();
    this._globalUpdater = null;
    return this;
};

/**
 * Function to be invoked by the parent as soon as the parent is
 * being mounted.
 *
 * @method onParentMount
 * 
 * @param  {Node} parent        The parent node.
 * @param  {String} parentId    The parent id (path to parent).
 * @param  {Number} index       Id the node should be mounted to.
 */
Node.prototype.onParentMount = function onParentMount (parent, parentId, index) {
    return this.mount(parent, parentId + '/' + index);
};

/**
 * Function to be invoked by the parent as soon as the parent is being
 * unmounted.
 *
 * @method onParentDismount
 */
Node.prototype.onParentDismount = function onParentDismount () {
    return this.dismount();
};

/**
 * Method to be called in order to dispatch an event to the node and all its
 * components. Note that this doesn't recurse the subtree.
 *
 * @method receive
 * 
 * @param  {String} type   The event type (e.g. "click").
 * @param  {Object} ev     The event payload object to be dispatched.
 */
Node.prototype.receive = function receive (type, ev) {
    var i = 0;
    var list = this._components;
    var len = list.length;
    var item;
    for (; i < len ; i++) {
        item = list[i];
        if (item && item.onReceive) item.onReceive(type, ev);
    }
    return this;
};


Node.prototype._requestUpdateWithoutArgs = function _requestUpdateWithoutArgs () {
    if (!this._requestingUpdate) this._requestUpdate();
};

Node.prototype.onUpdate = Node.prototype.update;

Node.prototype.onParentShow = Node.prototype.show;

Node.prototype.onParentHide = Node.prototype.hide;

Node.prototype.onParentTransformChange = Node.prototype._requestUpdateWithoutArgs;

Node.prototype.onParentSizeChange = Node.prototype._requestUpdateWithoutArgs;

Node.prototype.onShow = Node.prototype.show;

Node.prototype.onHide = Node.prototype.hide;

Node.prototype.onMount = Node.prototype.mount;

Node.prototype.onDismount = Node.prototype.dismount;

Node.prototype.onReceive = Node.prototype.receive;

module.exports = Node;

},{"./Size":143,"./Transform":144}],143:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],144:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"dup":9}],145:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"./Clock":137,"./Context":138,"./Dispatch":139,"./Event":140,"./Famous":141,"./Node":142,"./Size":143,"./Transform":144,"dup":10}],146:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],147:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./Mat33":146,"dup":12}],148:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"dup":13}],149:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"dup":14}],150:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./Mat33":146,"./Quaternion":147,"./Vec2":148,"./Vec3":149,"dup":15}],151:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],152:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],153:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"./Curves":151,"dup":21}],154:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],155:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"./Curves":151,"./Easing":152,"./Transitionable":153,"./after":154,"dup":23}],156:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],157:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],158:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"./Curves":156,"dup":21}],159:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],160:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"./Curves":156,"./Easing":157,"./Transitionable":158,"./after":159,"dup":23}],161:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24}],162:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25,"famous-transitions":160}],163:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26}],164:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27}],165:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"dup":28}],166:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"dup":29}],167:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],168:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"./CallbackStore":161,"./Color":162,"./KeyCodes":163,"./MethodStore":164,"./ObjectManager":165,"./clone":166,"./flatClone":167,"./keyValueToArrays":169,"./loadURL":170,"./strip":171,"dup":31}],169:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],170:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],171:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],172:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"./Position":180,"dup":35}],173:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"dup":36}],174:[function(require,module,exports){
arguments[4][37][0].apply(exports,arguments)
},{"dup":37}],175:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"dup":38,"famous-utilities":168}],176:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"dup":39,"famous-math":150,"famous-utilities":168}],177:[function(require,module,exports){
arguments[4][40][0].apply(exports,arguments)
},{"./Position":180,"dup":40}],178:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"dup":41,"famous-transitions":155}],179:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"./Position":180,"dup":42}],180:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43,"famous-transitions":155}],181:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"./Position":180,"dup":44}],182:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"./Position":180,"dup":45}],183:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"dup":46,"famous-core":145,"famous-transitions":155}],184:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"famous-math":150,"famous-transitions":155}],185:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"dup":48,"famous-utilities":168}],186:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"./Align":172,"./Camera":173,"./EventEmitter":174,"./EventHandler":175,"./GestureHandler":176,"./MountPoint":177,"./Opacity":178,"./Origin":179,"./Position":180,"./Rotation":181,"./Scale":182,"./Size":183,"./Transform":184,"./UIEventHandler":185,"dup":49}],187:[function(require,module,exports){
'use strict';

var ElementCache = require('./ElementCache');
var math = require('./Math');
var vendorPrefix = require('./VendorPrefix');
var eventMap = require('./events/EventMap');

var TRANSFORM = vendorPrefix('transform');

/**
 * DOMRenderer is a class responsible for adding elements
 * to the DOM and writing to those elements.
 * there is a DOMRenderer per context, represented as an
 * element and a selector. It is instantiated in the 
 * context class.
 *
 * @class DOMRenderer
 * 
 * @param {HTMLElement} an element.
 * @param {String} the selector of the element.
 * @param {Compositor}
 */
function DOMRenderer (element, selector, compositor) {
    this._compositor = compositor; // a reference to the compositor

    this._target = null; // a register for holding the current
                         // element that the Renderer is operating
                         // upon

    this._parent = null; // a register for holding the parent
                         // of the target

    this._path = null; // a register for holding the path of the target
                       // this register must be set first, and then
                       // children, target, and parent are all looked
                       // up from that.

    this._children = []; // a register for holding the children of the
                         // current target.

    this._root = new ElementCache(element, selector); // the root
                                                      // of the dom tree that this
                                                      // renderer is responsible
                                                      // for

    this._boundTriggerEvent = this._triggerEvent.bind(this);

    this._selector = selector;
    
    this._elements = {};

    this._elements[selector] = this._root;

    this.perspectiveTransform = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
    this._VPtransform = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);

    this._eventListeners = {};

    this._size = [null, null];
}

DOMRenderer.prototype.addEventListener = function addEventListener(path, type, properties, preventDefault) {
    if (!this._eventListeners[type]) {
        this._eventListeners[type] = {};
        if (eventMap[type][1]) {
            // Use event delegation
            this._root.element.addEventListener(type, this._boundTriggerEvent);
        } else {
            // Directly link event handler to DOM element
            this._elements[path].element.addEventListener(type, this._boundTriggerEvent);
        }
    }

    this._eventListeners[type][path] = {
        preventDefault: preventDefault
    };
};

DOMRenderer.prototype._triggerEvent = function _triggerEvent(ev) {
    var evPath = ev.path ? ev.path : _getPath(ev);
    for (var i = 0; i < evPath.length; i++) {
        if (!evPath[i].dataset) continue;
        var path = evPath[i].dataset.faPath;
        if (this._eventListeners[ev.type][path]) {

            ev.stopPropagation();
            if (this._eventListeners[ev.type][path].preventDefault) {
                ev.preventDefault();
            }

            var EventConstructor = eventMap[ev.type][0];
            this._compositor.sendEvent(path, ev.type, new EventConstructor(ev));

            break;
        }
    }
};

function _getPath (ev) {
    var path = [];
    var node = ev.target;
    while (node !== document.body) {
        path.push(node);
        node = node.parentNode;
    }
    return path;
}

DOMRenderer.prototype.getSize = function getSize () {
    this._size[0] = this._root.element.offsetWidth;
    this._size[1] = this._root.element.offsetHeight;
    return this._size;
};

DOMRenderer.prototype._getSize = DOMRenderer.prototype.getSize;

DOMRenderer.prototype.draw = function draw (renderState) {
    if (renderState.perspectiveDirty) {
        this.perspectiveDirty = true;

        this.perspectiveTransform[0] = renderState.perspectiveTransform[0];
        this.perspectiveTransform[1] = renderState.perspectiveTransform[1];
        this.perspectiveTransform[2] = renderState.perspectiveTransform[2];
        this.perspectiveTransform[3] = renderState.perspectiveTransform[3];

        this.perspectiveTransform[4] = renderState.perspectiveTransform[4];
        this.perspectiveTransform[5] = renderState.perspectiveTransform[5];
        this.perspectiveTransform[6] = renderState.perspectiveTransform[6];
        this.perspectiveTransform[7] = renderState.perspectiveTransform[7];

        this.perspectiveTransform[8] = renderState.perspectiveTransform[8];
        this.perspectiveTransform[9] = renderState.perspectiveTransform[9];
        this.perspectiveTransform[10] = renderState.perspectiveTransform[10];
        this.perspectiveTransform[11] = renderState.perspectiveTransform[11];

        this.perspectiveTransform[12] = renderState.perspectiveTransform[12];
        this.perspectiveTransform[13] = renderState.perspectiveTransform[13];
        this.perspectiveTransform[14] = renderState.perspectiveTransform[14];
        this.perspectiveTransform[15] = renderState.perspectiveTransform[15];
    }

    if (renderState.viewDirty || renderState.perspectiveDirty) {
        math.multiply(this._VPtransform, this.perspectiveTransform, renderState.viewTransform);
        this._root.element.style[TRANSFORM] = this._stringifyMatrix(this._VPtransform);
    }
};

DOMRenderer.prototype._assertPathLoaded = function _asserPathLoaded () {
    if (!this._path) throw new Error('path not loaded');
};

DOMRenderer.prototype._assertParentLoaded = function _assertParentLoaded () {
    if (!this._parent) throw new Error('parent not loaded');
};

DOMRenderer.prototype._assertChildrenLoaded = function _assertChildrenLoaded () {
    if (!this._children) throw new Error('children not loaded');
};

DOMRenderer.prototype.findParent = function findParent () {
    this._assertPathLoaded();

    var path = this._path;
    var parent;

    while (!parent && path.length) {
        path = path.substring(0, path.lastIndexOf('/'));
        parent = this._elements[path];
    }
    this._parent = parent;
    return parent;
};

DOMRenderer.prototype.findChildren = function findChildren (array) {
    this._assertPathLoaded();
    
    var path = this._path;
    var keys = Object.keys(this._elements);
    var i = 0;
    var len;
    array = array ? array : this._children;

    this._children.length = 0;

    while (i < keys.length) {
        if (keys[i].indexOf(path) === -1 || keys[i] === path) keys.splice(i, 1);
        else i++;
    }
    var currentPath;
    var j = 0;
    for (i = 0 ; i < keys.length ; i++) {
        currentPath = keys[i];
        for (j = 0 ; j < keys.length ; j++) {
            if (i !== j && keys[j].indexOf(currentPath) !== -1) {
                keys.splice(j, 1);
                i--;
            }
        }
    }
    for (i = 0, len = keys.length ; i < len ; i++)
        array[i] = this._elements[keys[i]];

    return array;
};

DOMRenderer.prototype.findTarget = function findTarget () {
    this._target = this._elements[this._path];
    return this._target;
};

DOMRenderer.prototype.loadPath = function loadPath (path) {
    this._path = path;
    return this._path;
};

DOMRenderer.prototype.insertEl = function insertEl (tagName) {
    if (!this._target ||
         this._target.element.tagName.toLowerCase() === tagName.toLowerCase()) {
        
        this.findParent();
        this.findChildren();
        
        this._assertParentLoaded();
        this._assertChildrenLoaded();

        if (this._target) this._parent.element.removeChild(this._target.element);
 
        this._target = new ElementCache(document.createElement(tagName), this._path);
        this._parent.element.appendChild(this._target.element);
        this._elements[this._path] = this._target;
        
        for (var i = 0, len = this._children.length ; i < len ; i++) {
            this._target.element.appendChild(this._children[i].element);
        }
    }
};

DOMRenderer.prototype._assertTargetLoaded = function _assertTargetLoaded () {
    if (!this._target) throw new Error('No target loaded');
};

DOMRenderer.prototype.setProperty = function setProperty (name, value) {
    this._assertTargetLoaded();
    this._target.element.style[name] = value;
};

DOMRenderer.prototype.setSize = function setSize (width, height) {
    this._assertTargetLoaded();
    this._target.element.style.width = (width === true) ? '' : width + 'px';
    this._target.element.style.height = (height === true) ? '' : height + 'px';
};

DOMRenderer.prototype.setAttribute = function setAttribute (name, value) {
    this._assertTargetLoaded();
    this._target.element.setAttribute(name, value);
};

DOMRenderer.prototype.setContent = function setContent (content) {
    this._assertTargetLoaded();
    this.findChildren();

    // TODO Temporary solution
    for (var i = 0 ; i < this._children.length ; i++) {
        this._target.element.removeChild(this._children[i].element);
    }

    this._target.element.innerHTML = content;

    for (var i = 0 ; i < this._children.length ; i++)
        this._target.element.appendChild(this._children[i].element);
};

DOMRenderer.prototype.setMatrix = function setMatrix (transform) { 
    this._assertTargetLoaded();
    this.findParent();
    var worldTransform = this._target.worldTransform;
    var changed = false;

    if (transform)
        for (var i = 0, len = 16 ; i < len ; i++) {
            changed = changed ? changed : worldTransform[i] === transform[i];
            worldTransform[i] = transform[i];
        }
    else changed = true;

    if (changed) {
        math.invert(this._target.invertedParent, this._parent.worldTransform);
        math.multiply(this._target.finalTransform, this._target.invertedParent, worldTransform);

        // TODO: this is a temporary fix for draw commands
        // coming in out of order
        var children = this.findChildren([]);
        var previousPath = this._path;
        var previousTarget = this._target;
        for (var i = 0, len = children.length ; i < len ; i++) {
            this._target = children[i];
            this._path = this._target.path;
            this.setMatrix();
        }
        this._path = previousPath;
        this._target = previousTarget;
    }

    this._target.element.style[TRANSFORM] = this._stringifyMatrix(this._target.finalTransform);
};

DOMRenderer.prototype.addClass = function addClass (domClass) {
    this._assertTargetLoaded();
    this._target.element.classList.add(domClass);
};

DOMRenderer.prototype.removeClass = function removeClass (domClass) {
    this._assertTargetLoaded();
    this._target.element.classList.remove(domClass);
};

DOMRenderer.prototype._stringifyMatrix = function _stringifyMatrix(m) {
    var r = 'matrix3d(';

    r += (m[0] < 0.000001 && m[0] > -0.000001) ? '0,' : m[0] + ',';
    r += (m[1] < 0.000001 && m[1] > -0.000001) ? '0,' : m[1] + ',';
    r += (m[2] < 0.000001 && m[2] > -0.000001) ? '0,' : m[2] + ',';
    r += (m[3] < 0.000001 && m[3] > -0.000001) ? '0,' : m[3] + ',';
    r += (m[4] < 0.000001 && m[4] > -0.000001) ? '0,' : m[4] + ',';
    r += (m[5] < 0.000001 && m[5] > -0.000001) ? '0,' : m[5] + ',';
    r += (m[6] < 0.000001 && m[6] > -0.000001) ? '0,' : m[6] + ',';
    r += (m[7] < 0.000001 && m[7] > -0.000001) ? '0,' : m[7] + ',';
    r += (m[8] < 0.000001 && m[8] > -0.000001) ? '0,' : m[8] + ',';
    r += (m[9] < 0.000001 && m[9] > -0.000001) ? '0,' : m[9] + ',';
    r += (m[10] < 0.000001 && m[10] > -0.000001) ? '0,' : m[10] + ',';
    r += (m[11] < 0.000001 && m[11] > -0.000001) ? '0,' : m[11] + ',';
    r += (m[12] < 0.000001 && m[12] > -0.000001) ? '0,' : m[12] + ',';
    r += (m[13] < 0.000001 && m[13] > -0.000001) ? '0,' : m[13] + ',';
    r += (m[14] < 0.000001 && m[14] > -0.000001) ? '0,' : m[14] + ',';

    r += m[15] + ')';
    return r;
};

module.exports = DOMRenderer;


},{"./ElementCache":188,"./Math":189,"./VendorPrefix":190,"./events/EventMap":193}],188:[function(require,module,exports){
'use strict';

var ident = [
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1
];

function ElementCache (element, path) {
    this.element = element;
    this.path = path;
    this.worldTransform = new Float32Array(ident);
    this.invertedParent = new Float32Array(ident);
    this.finalTransform = new Float32Array(ident);
    this.postRenderSize = new Float32Array(2);
}

module.exports = ElementCache;


},{}],189:[function(require,module,exports){
'use strict';

function invert (out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
        return null;
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
}

function multiply (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3],
        b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7],
        b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11],
        b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];

    var changed = false;
    var out0, out1, out2, out3;

    out0 = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out1 = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out2 = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out3 = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    changed = changed ?
              changed : out0 === out[0] ||
                        out1 === out[1] ||
                        out2 === out[2] ||
                        out3 === out[3];

    out[0] = out0;
    out[1] = out1;
    out[2] = out2;
    out[3] = out3;

    b0 = b4; b1 = b5; b2 = b6; b3 = b7;
    out0 = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out1 = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out2 = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out3 = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    changed = changed ?
              changed : out0 === out[4] ||
                        out1 === out[5] ||
                        out2 === out[6] ||
                        out3 === out[7];

    out[4] = out0;
    out[5] = out1;
    out[6] = out2;
    out[7] = out3;

    b0 = b8; b1 = b9; b2 = b10; b3 = b11;
    out0 = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out1 = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out2 = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out3 = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    changed = changed ?
              changed : out0 === out[8] ||
                        out1 === out[9] ||
                        out2 === out[10] ||
                        out3 === out[11];

    out[8] = out0;
    out[9] = out1;
    out[10] = out2;
    out[11] = out3;

    b0 = b12; b1 = b13; b2 = b14; b3 = b15;
    out0 = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out1 = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out2 = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out3 = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    changed = changed ?
              changed : out0 === out[12] ||
                        out1 === out[13] ||
                        out2 === out[14] ||
                        out3 === out[15];

    out[12] = out0;
    out[13] = out1;
    out[14] = out2;
    out[15] = out3;

    return out;
}

module.exports = {
    multiply: multiply,
    invert: invert
};

},{}],190:[function(require,module,exports){
'use strict';

var PREFIXES = ['', '-ms-', '-webkit-', '-moz-', '-o-'];

/**
 * A helper function for determining if a CSS property
 * has a vendor prefix.
 *
 * @method vendorPrefix
 * @private
 * 
 * @param {String} property
 */
function vendorPrefix(property) {
    for (var i = 0; i < PREFIXES.length; i++) {
        var prefixed = PREFIXES[i] + property;
        if (document.documentElement.style[prefixed] === '') {
            return prefixed;
        }
    }
    return property;
}

module.exports = vendorPrefix;

},{}],191:[function(require,module,exports){
'use strict';

var UIEvent = require('./UIEvent');

function CompositionEvent(ev) {
    // [Constructor(DOMString typeArg, optional CompositionEventInit compositionEventInitDict)]
    // interface CompositionEvent : UIEvent {
    //     readonly    attribute DOMString data;
    // };

    UIEvent.call(this, ev);
    this.data = ev.data;
}

CompositionEvent.prototype = UIEvent.prototype;
CompositionEvent.prototype.constructor = CompositionEvent;

module.exports = CompositionEvent;

},{"./UIEvent":199}],192:[function(require,module,exports){
'use strict';

function Event(ev) {
    // [Constructor(DOMString type, optional EventInit eventInitDict),
    //  Exposed=Window,Worker]
    // interface Event {
    //   readonly attribute DOMString type;
    //   readonly attribute EventTarget? target;
    //   readonly attribute EventTarget? currentTarget;

    //   const unsigned short NONE = 0;
    //   const unsigned short CAPTURING_PHASE = 1;
    //   const unsigned short AT_TARGET = 2;
    //   const unsigned short BUBBLING_PHASE = 3;
    //   readonly attribute unsigned short eventPhase;

    //   void stopPropagation();
    //   void stopImmediatePropagation();

    //   readonly attribute boolean bubbles;
    //   readonly attribute boolean cancelable;
    //   void preventDefault();
    //   readonly attribute boolean defaultPrevented;

    //   [Unforgeable] readonly attribute boolean isTrusted;
    //   readonly attribute DOMTimeStamp timeStamp;

    //   void initEvent(DOMString type, boolean bubbles, boolean cancelable);
    // };

    this.type = ev.type;
    this.defaultPrevented = ev.defaultPrevented;
    this.isTrusted = ev.isTrusted;
    this.timeStamp = ev.timeStamp;
}

Event.prototype.proxy = function proxy (ev) {
    this.prototype.constructor.call(this, ev);
};

module.exports = Event;

},{}],193:[function(require,module,exports){
'use strict';

var CompositionEvent = require('./CompositionEvent');
var Event = require('./Event');
var FocusEvent = require('./FocusEvent');
var InputEvent = require('./InputEvent');
var KeyboardEvent = require('./KeyboardEvent');
var MouseEvent = require('./MouseEvent');
var TouchEvent = require('./TouchEvent');
var UIEvent = require('./UIEvent');
var WheelEvent = require('./WheelEvent');

var EventMap = {
    // UI Events (http://www.w3.org/TR/uievents/)
    'abort': [Event, false],
    'beforeinput': [InputEvent, true],
    'blur': [FocusEvent, false],
    'click': [MouseEvent, true],
    'compositionend': [CompositionEvent, true],
    'compositionstart': [CompositionEvent, true],
    'compositionupdate': [CompositionEvent, true],
    'dblclick': [MouseEvent, true],
    'focus': [FocusEvent, false],
    'focusin': [FocusEvent, true],
    'focusout': [FocusEvent, true],
    'input': [InputEvent, true],
    'keydown': [KeyboardEvent, true],
    'keyup': [KeyboardEvent, true],
    'load': [Event, false],
    'mousedown': [MouseEvent, true],
    'mouseenter': [MouseEvent, false],
    'mouseleave': [MouseEvent, false],

    // bubbles, but will be triggered very frequently
    'mousemove': [MouseEvent, false],

    'mouseout': [MouseEvent, true],
    'mouseover': [MouseEvent, true],
    'mouseup': [MouseEvent, true],
    'resize': [UIEvent, false],

    // might bubble
    'scroll': [UIEvent, false],
    
    'select': [Event, true],
    'unload': [Event, false],
    'wheel': [WheelEvent, true],

    // Touch Events Extension (http://www.w3.org/TR/touch-events-extensions/)
    'touchcancel': [TouchEvent, true],
    'touchend': [TouchEvent, true],
    'touchmove': [TouchEvent, true],
    'touchstart': [TouchEvent, true],
};

module.exports = EventMap;

},{"./CompositionEvent":191,"./Event":192,"./FocusEvent":194,"./InputEvent":195,"./KeyboardEvent":196,"./MouseEvent":197,"./TouchEvent":198,"./UIEvent":199,"./WheelEvent":200}],194:[function(require,module,exports){
'use strict';

var UIEvent = require('./UIEvent');

function FocusEvent(ev) {
    // [Constructor(DOMString typeArg, optional FocusEventInit focusEventInitDict)]
    // interface FocusEvent : UIEvent {
    //     readonly    attribute EventTarget? relatedTarget;
    // };

    UIEvent.call(this, ev);
}

FocusEvent.prototype = UIEvent.prototype;
FocusEvent.prototype.constructor = FocusEvent;

module.exports = FocusEvent;

},{"./UIEvent":199}],195:[function(require,module,exports){
'use strict';

var UIEvent = require('./UIEvent');

function InputEvent(ev) {
    // [Constructor(DOMString typeArg, optional InputEventInit inputEventInitDict)]
    // interface InputEvent : UIEvent {
    //     readonly    attribute DOMString inputType;
    //     readonly    attribute DOMString data;
    //     readonly    attribute boolean   isComposing;
    //     readonly    attribute Range     targetRange;
    // };

    UIEvent.call(this, ev);
    this.inputType = ev.inputType;
    this.data = ev.data;
    this.isComposing = ev.isComposing;
    this.targetRange = ev.targetRange;
}

InputEvent.prototype = UIEvent.prototype;
InputEvent.prototype.constructor = InputEvent;

module.exports = InputEvent;

},{"./UIEvent":199}],196:[function(require,module,exports){
'use strict';

var UIEvent = require('./UIEvent');

function KeyboardEvent(ev) {
    // [Constructor(DOMString typeArg, optional KeyboardEventInit keyboardEventInitDict)]
    // interface KeyboardEvent : UIEvent {
    //     // KeyLocationCode
    //     const unsigned long DOM_KEY_LOCATION_STANDARD = 0x00;
    //     const unsigned long DOM_KEY_LOCATION_LEFT = 0x01;
    //     const unsigned long DOM_KEY_LOCATION_RIGHT = 0x02;
    //     const unsigned long DOM_KEY_LOCATION_NUMPAD = 0x03;
    //     readonly    attribute DOMString     key;
    //     readonly    attribute DOMString     code;
    //     readonly    attribute unsigned long location;
    //     readonly    attribute boolean       ctrlKey;
    //     readonly    attribute boolean       shiftKey;
    //     readonly    attribute boolean       altKey;
    //     readonly    attribute boolean       metaKey;
    //     readonly    attribute boolean       repeat;
    //     readonly    attribute boolean       isComposing;
    //     boolean getModifierState (DOMString keyArg);
    // };
    
    UIEvent.call(this, ev);
    this.DOM_KEY_LOCATION_STANDARD = 0x00;
    this.DOM_KEY_LOCATION_LEFT = 0x01;
    this.DOM_KEY_LOCATION_RIGHT = 0x02;
    this.DOM_KEY_LOCATION_NUMPAD = 0x03;
    this.key = ev.key;
    this.code = ev.code;
    this.location = ev.location;
    this.ctrlKey = ev.ctrlKey;
    this.shiftKey = ev.shiftKey;
    this.altKey = ev.altKey;
    this.metaKey = ev.metaKey;
    this.repeat = ev.repeat;
    this.isComposing = ev.isComposing;
    this.keyArg = ev.keyArg;
}

KeyboardEvent.prototype = UIEvent.prototype;
KeyboardEvent.prototype.constructor = KeyboardEvent;

module.exports = KeyboardEvent;

},{"./UIEvent":199}],197:[function(require,module,exports){
'use strict';

var UIEvent = require('./UIEvent');

function MouseEvent(ev) {
    // [Constructor(DOMString typeArg, optional MouseEventInit mouseEventInitDict)]
    // interface MouseEvent : UIEvent {
    //     readonly    attribute long           screenX;
    //     readonly    attribute long           screenY;
    //     readonly    attribute long           clientX;
    //     readonly    attribute long           clientY;
    //     readonly    attribute boolean        ctrlKey;
    //     readonly    attribute boolean        shiftKey;
    //     readonly    attribute boolean        altKey;
    //     readonly    attribute boolean        metaKey;
    //     readonly    attribute short          button;
    //     readonly    attribute EventTarget?   relatedTarget;
    //     // Introduced in this specification
    //     readonly    attribute unsigned short buttons;
    //     boolean getModifierState (DOMString keyArg);
    // };

    UIEvent.call(this, ev);
    this.screenX = ev.screenX;
    this.screenX = ev.screenX;
    this.screenY = ev.screenY;
    this.clientX = ev.clientX;
    this.clientY = ev.clientY;
    this.ctrlKey = ev.ctrlKey;
    this.shiftKey = ev.shiftKey;
    this.altKey = ev.altKey;
    this.metaKey = ev.metaKey;
    this.button = ev.button;
    this.buttons = ev.buttons;
}

MouseEvent.prototype = UIEvent.prototype;
MouseEvent.prototype.constructor = MouseEvent;

module.exports = MouseEvent;

},{"./UIEvent":199}],198:[function(require,module,exports){
'use strict';

var UIEvent = require('./UIEvent');

function Touch(touch) {
    // interface Touch {
    //     readonly    attribute long        identifier;
    //     readonly    attribute EventTarget target;
    //     readonly    attribute double      screenX;
    //     readonly    attribute double      screenY;
    //     readonly    attribute double      clientX;
    //     readonly    attribute double      clientY;
    //     readonly    attribute double      pageX;
    //     readonly    attribute double      pageY;
    // };
    
    this.identifier = touch.identifier;
    this.target = touch.target;
    this.screenX = touch.screenX;
    this.screenY = touch.screenY;
    this.clientX = touch.clientX;
    this.clientY = touch.clientY;
    this.pageX = touch.pageX;
    this.pageY = touch.pageY;
}

function cloneTouchList(touchList) {
    // interface TouchList {
    //     readonly    attribute unsigned long length;
    //     getter Touch? item (unsigned long index);
    // };
    
    var touchListArray = [];
    for (var i = 0; i < touchList.length; i++) {
        touchListArray[i] = new Touch(touchList[i]);
    }
    return touchListArray;
}

function TouchEvent(ev) {
    // interface TouchEvent : UIEvent {
    //     readonly    attribute TouchList touches;
    //     readonly    attribute TouchList targetTouches;
    //     readonly    attribute TouchList changedTouches;
    //     readonly    attribute boolean   altKey;
    //     readonly    attribute boolean   metaKey;
    //     readonly    attribute boolean   ctrlKey;
    //     readonly    attribute boolean   shiftKey;
    // };

    UIEvent.call(this, ev);
    this.touches = cloneTouchList(ev.touches);
    this.targetTouches = cloneTouchList(ev.targetTouches);
    this.changedTouches = cloneTouchList(ev.changedTouches);
    this.altKey = ev.altKey;
    this.metaKey = ev.metaKey;
    this.ctrlKey = ev.ctrlKey;
    this.shiftKey = ev.shiftKey;
}


TouchEvent.prototype = UIEvent.prototype;
TouchEvent.prototype.constructor = TouchEvent;

module.exports = TouchEvent;

},{"./UIEvent":199}],199:[function(require,module,exports){
'use strict';

var Event = require('./Event');

function UIEvent(ev) {
    // [Constructor(DOMString type, optional UIEventInit eventInitDict)]
    // interface UIEvent : Event {
    //     readonly    attribute Window? view;
    //     readonly    attribute long    detail;
    // };

    Event.call(this, ev);
    this.detail = ev.detail;
}

UIEvent.prototype = Event.prototype;
UIEvent.prototype.constructor = UIEvent;

module.exports = UIEvent;

},{"./Event":192}],200:[function(require,module,exports){
'use strict';

var MouseEvent = require('./MouseEvent');

function WheelEvent(ev) {
    // [Constructor(DOMString typeArg, optional WheelEventInit wheelEventInitDict)]
    // interface WheelEvent : MouseEvent {
    //     // DeltaModeCode
    //     const unsigned long DOM_DELTA_PIXEL = 0x00;
    //     const unsigned long DOM_DELTA_LINE = 0x01;
    //     const unsigned long DOM_DELTA_PAGE = 0x02;
    //     readonly    attribute double        deltaX;
    //     readonly    attribute double        deltaY;
    //     readonly    attribute double        deltaZ;
    //     readonly    attribute unsigned long deltaMode;
    // };

    MouseEvent.call(this, ev);
    this.DOM_DELTA_PIXEL = 0x00;
    this.DOM_DELTA_LINE = 0x01;
    this.DOM_DELTA_PAGE = 0x02;
    this.deltaX = ev.deltaX;
    this.deltaY = ev.deltaY;
    this.deltaZ = ev.deltaZ;
    this.deltaMode = ev.deltaMode;
}

WheelEvent.prototype = MouseEvent.prototype;
WheelEvent.prototype.constructor = WheelEvent;

module.exports = WheelEvent;

},{"./MouseEvent":197}],201:[function(require,module,exports){
'use strict';

module.exports = {
    CompositionEvent: require('./CompositionEvent'),
    Event: require('./Event'),
    EventMap: require('./EventMap'),
    FocusEvent: require('./FocusEvent'),
    InputEvent: require('./InputEvent'),
    KeyboardEvent: require('./KeyboardEvent'),
    MouseEvent: require('./MouseEvent'),
    TouchEvent: require('./TouchEvent'),
    UIEvent: require('./UIEvent'),
    WheelEvent: require('./WheelEvent')
};


},{"./CompositionEvent":191,"./Event":192,"./EventMap":193,"./FocusEvent":194,"./InputEvent":195,"./KeyboardEvent":196,"./MouseEvent":197,"./TouchEvent":198,"./UIEvent":199,"./WheelEvent":200}],202:[function(require,module,exports){
'use strict';

module.exports = {
    DOMRenderer: require('./DOMRenderer'),
    ElementCache: require('./ElementCache'),
    Events: require('./events'),
    Math: require('./Math'),
    VendorPrefix: require('./VendorPrefix')
};

},{"./DOMRenderer":187,"./ElementCache":188,"./Math":189,"./VendorPrefix":190,"./events":201}],203:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],204:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],205:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"./Curves":203,"dup":21}],206:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],207:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"./Curves":203,"./Easing":204,"./Transitionable":205,"./after":206,"dup":23}],208:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24}],209:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25,"famous-transitions":207}],210:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26}],211:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27}],212:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"dup":28}],213:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"dup":29}],214:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],215:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"./CallbackStore":208,"./Color":209,"./KeyCodes":210,"./MethodStore":211,"./ObjectManager":212,"./clone":213,"./flatClone":214,"./keyValueToArrays":216,"./loadURL":217,"./strip":218,"dup":31}],216:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],217:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],218:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],219:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],220:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],221:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"./Curves":219,"dup":21}],222:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],223:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"./Curves":219,"./Easing":220,"./Transitionable":221,"./after":222,"dup":23}],224:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24}],225:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25,"famous-transitions":223}],226:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26}],227:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27}],228:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"dup":28}],229:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"dup":29}],230:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],231:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"./CallbackStore":224,"./Color":225,"./KeyCodes":226,"./MethodStore":227,"./ObjectManager":228,"./clone":229,"./flatClone":230,"./keyValueToArrays":232,"./loadURL":233,"./strip":234,"dup":31}],232:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],233:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],234:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],235:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],236:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./Mat33":235,"dup":12}],237:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"dup":13}],238:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"dup":14}],239:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./Mat33":235,"./Quaternion":236,"./Vec2":237,"./Vec3":238,"dup":15}],240:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],241:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],242:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"./Curves":240,"dup":21}],243:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],244:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"./Curves":240,"./Easing":241,"./Transitionable":242,"./after":243,"dup":23}],245:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24}],246:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25,"famous-transitions":244}],247:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26}],248:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27}],249:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"dup":28}],250:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"dup":29}],251:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],252:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"./CallbackStore":245,"./Color":246,"./KeyCodes":247,"./MethodStore":248,"./ObjectManager":249,"./clone":250,"./flatClone":251,"./keyValueToArrays":253,"./loadURL":254,"./strip":255,"dup":31}],253:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],254:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],255:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],256:[function(require,module,exports){
'use strict';

var Geometry = require('./Geometry');

/**
 * DynamicGeometry is a component that defines the data that should
 *   be drawn to the webGL canvas. Manages vertex data and attributes.
 *
 * @class DynamicGeometry
 * @constructor
 * 
 * @param {Object} options instantiation options
 */
function DynamicGeometry(options) {
    Geometry.call(this, options);

    this.spec.dynamic = true;
}

/**
 * Returns the number of attribute values used to draw the DynamicGeometry.
 *
 * @class DynamicGeometry
 * @constructor
 * 
 * @return {Object} flattened length of the vertex positions attribute
 * in the geometry.
 */
DynamicGeometry.prototype.getLength = function getLength() {
    return this.getVertexPositions().length;
};

/**
 * Gets the buffer object based on buffer name. Throws error
 * if bufferName is not provided.
 *
 * @method getVertexBuffer
 *
 * @param {String} bufferName Name of vertexBuffer to be retrieved.
 * @return {Object} value of buffer with corresponding bufferName.
 */
DynamicGeometry.prototype.getVertexBuffer = function getVertexBuffer(bufferName) {
    if (! bufferName) throw 'getVertexBuffer requires a name';

    var idx = this.spec.bufferNames.indexOf(bufferName);
    if (idx === -1) throw 'buffer does not exist';
    else {
        return this.spec.bufferValues[idx];
    }
};

/**
 * Sets a vertex buffer with given name to input value. Registers a new 
 * buffer if one does not exist with given name.
 * 
 * @method setVertexBuffer
 * @param {String} bufferName Name of vertexBuffer to be set.
 * @param {Array} value Input data to fill target buffer.
 * @param {Number} size Vector size of input buffer data.
 * @return {Object} current geometry.
 */
DynamicGeometry.prototype.setVertexBuffer = function setVertexBuffer(bufferName, value, size) {
    var idx = this.spec.bufferNames.indexOf(bufferName);

    if (idx === -1) {
        idx = this.spec.bufferNames.push(bufferName) - 1;
    }

    this.spec.bufferValues[idx] = value || [];
    this.spec.bufferSpacings[idx] = size || this.DEFAULT_BUFFER_SIZE;

    if (this.spec.invalidations.indexOf(idx) === -1) {
        this.spec.invalidations.push(idx);
    }

    return this;
};

/**
 * Copies and sets all buffers from another geometry instance.
 *
 * @method fromGeometry
 *
 * @param {Object} geometry Geometry instance to copy buffers from.
 * @return {Object} current geometry.
 */
DynamicGeometry.prototype.fromGeometry = function fromGeometry(geometry) {
    var len = geometry.spec.bufferNames.length;
    for (var i = 0; i < len; i++) {
        this.setVertexBuffer(
            geometry.spec.bufferNames[i],
            geometry.spec.bufferValues[i],
            geometry.spec.bufferSpacings[i]
        );
    }
    return this;
};

/**
 *  Set the positions of the vertices in this geometry.
 * 
 *  @method setVertexPositions
 *  @param {Array} value New value for vertex position buffer
 *  @return {Object} current geometry.
 */
DynamicGeometry.prototype.setVertexPositions = function (value) {
    return this.setVertexBuffer('pos', value, 3);
};

/**
 *  Set the normals on this geometry.
 * 
 *  @method setNormals
 *  @param {Array} value Value to set normal buffer to.
 *  @return {Object} current geometry.
 */
DynamicGeometry.prototype.setNormals = function (value) {
    return this.setVertexBuffer('normals', value, 3);
};

/**
 *  Set the texture coordinates on this geometry.
 * 
 *  @method setTextureCoords
 *  @param {Array} value New value for texture coordinates buffer.
 *  @return {Object} current geometry.
 */
DynamicGeometry.prototype.setTextureCoords = function (value) {
    return this.setVertexBuffer('texCoord', value, 2);
};

/**
 *  Set the texture coordinates on this geometry.
 *  @method setTextureCoords
 *  @param {Array} value New value for index buffer
 *  @return {Object} current geometry.
 */
DynamicGeometry.prototype.setIndices = function (value) {
    return this.setVertexBuffer('indices', value, 1);
};

/**
 *  Set the WebGL drawing primitive for this geometry.
 *  @method setDrawType
 *  @param {String} type New drawing primitive for geometry
 *  @return {Object} current geometry.
 */
DynamicGeometry.prototype.setDrawType = function (value) {
    this.spec.type = value.toUpperCase();
    return this;
};

/**
 * Returns the 'pos' vertex buffer of the geometry.
 * @method getVertexPositions
 * @return {Array} Vertex buffer.
 */
DynamicGeometry.prototype.getVertexPositions = function () {
    return this.getVertexBuffer('pos');
};

/**
 * Returns the 'normal' vertex buffer of the geometry.
 * @method getNormals
 * @return {Array} Vertex Buffer.
 */
DynamicGeometry.prototype.getNormals = function () {
    return this.getVertexBuffer('normals');
};

/**
 * Returns the 'textureCoord' vertex buffer of the geometry.
 * @method getTextureCoords
 * @return {Array} Vertex Buffer.
 */
DynamicGeometry.prototype.getTextureCoords = function () {
    return this.getVertexBuffer('texCoord');
};

module.exports = DynamicGeometry;

},{"./Geometry":257}],257:[function(require,module,exports){
'use strict';

var GeometryIds = 0;

// WebGL drawing primitives map. This is generated in geometry to 
// avoid chrome deoptimizations in WebGLRenderer draw function.
// TODO: return draw type data retreival to WebGLRenderer.

var DRAW_TYPES = {
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6
};

/**
 * Geometry is a component that defines the data that should
 * be drawn to the webGL canvas. Manages vertex data and attributes.
 *
 * @class Geometry
 * @constructor
 * 
 * @param {Object} options Instantiation options.
 */
function Geometry(options) {
    this.id = GeometryIds++;
    this.options = options || {};
    this.DEFAULT_BUFFER_SIZE = 3;

    this.spec = {
        id: this.id,
        dynamic: false,
        type: DRAW_TYPES[(this.options.type ? this.options.type.toUpperCase() : 'TRIANGLES')],
        bufferNames: [],
        bufferValues: [],
        bufferSpacings: [],
        invalidations: []
    };

    if (this.options.buffers) {
        var len = this.options.buffers.length;
        for (var i = 0; i < len;) {
            this.spec.bufferNames.push(this.options.buffers[i].name);
            this.spec.bufferValues.push(this.options.buffers[i].data);
            this.spec.bufferSpacings.push(this.options.buffers[i].size || this.DEFAULT_BUFFER_SIZE);
            this.spec.invalidations.push(i++);
        }
    }
}

module.exports = Geometry;

},{}],258:[function(require,module,exports){
'use strict';

var Vec3 = require('famous-math').Vec3;
var Vec2 = require('famous-math').Vec2;

var outputs = [
    new Vec3(),
    new Vec3(),
    new Vec3(),
    new Vec2(),
    new Vec2()
];

/**
 * A helper object used to calculate buffers for complicated geometries.
 * Tailored for the WebGLRenderer, used by most primitives.
 *
 * @static
 * @class GeometryHelper
 */
var GeometryHelper = {};

/**
 * A function that iterates through vertical and horizontal slices
 * based on input detail, and generates vertices and indices for each
 * subdivision.
 *
 * @static
 * @method generateParametric
 *
 * @param {Number} detailX Amount of slices to iterate through.
 * @param {Number} detailY Amount of stacks to iterate through.
 * @param {Function} func Function used to generate vertex positions at each point.
 * 
 * @return {Object} Object containing generated vertices and indices.
 */
GeometryHelper.generateParametric = function generateParametric(detailX, detailY, func) {
    var vertices = [],
        i, theta, phi, result, j;

    // We must wrap around slightly more than once for uv coordinates to look correct.

    var Xrange = Math.PI + (Math.PI / (detailX - 1));
    var out = [];

    for (i = 0; i < detailX + 1; i++) {
        theta = i * Xrange / detailX;
        for (j = 0; j < detailY; j++) {
            phi = j * 2.0 * Xrange / detailY;
            func(theta, phi, out);
            vertices.push(out[0], out[1], out[2]);
        }
    }

    var indices = [],
        v = 0,
        next;
    for (i = 0; i < detailX; i++) {
        for (j = 0; j < detailY; j++) {
            next = (j + 1) % detailY;
            indices.push(v + j, v + j + detailY, v + next);
            indices.push(v + next, v + j + detailY, v + next + detailY);
        }
        v += detailY;
    }

    return {
        vertices: vertices,
        indices: indices
    };
}

/**
 * Calculates normals belonging to each face of a geometry.  
 * Assumes clockwise declaration of vertices.
 *
 * @static
 * @method computeNormals
 *
 * @param {Array} vertices Vertices of all points on the geometry.
 * @param {Array} indices Indices declaring faces of geometry.
 * @param {Array} out Array to be filled and returned.
 * 
 * @return {Array} Calculated face normals.
 */
GeometryHelper.computeNormals = function computeNormals(vertices, indices, out) {
    var normals = out || [];
    var vertexThree;
    var vertexTwo;
    var vertexOne;
    var indexOne;
    var indexTwo;
    var indexThree;
    var start;
    var end;
    var normal;
    var j;
    var len = indices.length / 3;

    for (var i = 0; i < len; i++) {
        j = i * 3;
        indexTwo = indices[j + 0] * 3;
        indexOne = indices[j + 1] * 3;
        indexThree = indices[j + 2] * 3;

        outputs[0].set(vertices[indexOne], vertices[indexOne + 1], vertices[indexOne + 2]);
        outputs[1].set(vertices[indexTwo], vertices[indexTwo + 1], vertices[indexTwo + 2]);
        outputs[2].set(vertices[indexThree], vertices[indexThree + 1], vertices[indexThree + 2]);

        normal = outputs[2].subtract(outputs[0]).cross(outputs[1].subtract(outputs[0]));
        normal = normal.normalize().toArray();

        normals[indexOne + 0] = normal[0];
        normals[indexOne + 1] = normal[1];
        normals[indexOne + 2] = normal[2];

        normals[indexTwo + 0] = normal[0];
        normals[indexTwo + 1] = normal[1];
        normals[indexTwo + 2] = normal[2];

        normals[indexThree + 0] = normal[0];
        normals[indexThree + 1] = normal[1];
        normals[indexThree + 2] = normal[2];
    }

    return normals;
};

/**
 * Divides all inserted triangles into four sub-triangles. Alters the
 * passed in arrays.
 *
 * @static
 * @method subdivide
 *
 * @param {Array} indices Indices declaring faces of geometry
 * @param {Array} vertices Vertices of all points on the geometry
 * @param {Array} texutureCoords Texture coordinates of all points on the geometry
 * 
 */
GeometryHelper.subdivide = function subdivide(indices, vertices, textureCoords) {
    var triangleIndex = indices.length / 3,
        abc,
        face,
        i, j, k, pos, tex;

    while (triangleIndex--) {
        face = indices.slice(triangleIndex * 3, triangleIndex * 3 + 3);

        pos = face.map(function(vertIndex) {
            return new Vec3(vertices[vertIndex * 3], vertices[vertIndex * 3 + 1], vertices[vertIndex * 3 + 2]);
        });
        vertices.push.apply(vertices, Vec3.scale(Vec3.add(pos[0], pos[1], outputs[0]), 0.5, outputs[1]).toArray());
        vertices.push.apply(vertices, Vec3.scale(Vec3.add(pos[1], pos[2], outputs[0]), 0.5, outputs[1]).toArray());
        vertices.push.apply(vertices, Vec3.scale(Vec3.add(pos[0], pos[2], outputs[0]), 0.5, outputs[1]).toArray());

        if (textureCoords) {
            tex = face.map(function(vertIndex) {
                return new Vec2(textureCoords[vertIndex * 2], textureCoords[vertIndex * 2 + 1]);
            });
            textureCoords.push.apply(textureCoords, Vec2.scale(Vec2.add(tex[0], tex[1], outputs[3]), 0.5, outputs[4]).toArray());
            textureCoords.push.apply(textureCoords, Vec2.scale(Vec2.add(tex[1], tex[2], outputs[3]), 0.5, outputs[4]).toArray());
            textureCoords.push.apply(textureCoords, Vec2.scale(Vec2.add(tex[0], tex[2], outputs[3]), 0.5, outputs[4]).toArray());
        }

        i = vertices.length - 3, j = i + 1, k = i + 2;
        indices.push(i, j, k);
        indices.push(face[0], i, k);
        indices.push(i, face[1], j);
        indices[triangleIndex] = k;
        indices[triangleIndex + 1] = j;
        indices[triangleIndex + 2] = face[2];
    }
};

/**
 * Creates duplicate of vertices that are shared between faces.
 * Alters the input vertex and index arrays.
 *
 * @static
 * @method getUniqueFaces
 *
 * @param {Array} vertices Vertices of all points on the geometry
 * @param {Array} indices Indices declaring faces of geometry
 * 
 */
GeometryHelper.getUniqueFaces = function getUniqueFaces(vertices, indices) {
    var triangleIndex = indices.length / 3,
        registered = [],
        index;

    while (triangleIndex--) {
        for (var i = 0; i < 3; i++) {

            index = indices[triangleIndex * 3 + i];

            if (registered[index]) {
                vertices.push(vertices[index * 3], vertices[index * 3 + 1], vertices[index * 3 + 2]);
                indices[triangleIndex * 3 + i] = vertices.length / 3 - 1;
            } else {
                registered[index] = true;
            }
        }
    }
};

/**
 * Divides all inserted triangles into four sub-triangles while maintaining
 * a radius of one. Alters the passed in arrays.
 *
 * @static
 * @method subdivide
 *
 * @param {Array} vertices Vertices of all points on the geometry
 * @param {Array} indices Indices declaring faces of geometry
 * 
 */
GeometryHelper.subdivideSpheroid = function subdivideSpheroid(vertices, indices) {
    var triangleIndex = indices.length / 3,
        abc,
        face,
        i, j, k;

    while (triangleIndex--) {
        face = indices.slice(triangleIndex * 3, triangleIndex * 3 + 3);
        abc = face.map(function(vertIndex) {
            return new Vec3(vertices[vertIndex * 3], vertices[vertIndex * 3 + 1], vertices[vertIndex * 3 + 2]);
        });

        vertices.push.apply(vertices, Vec3.normalize(Vec3.add(abc[0], abc[1], outputs[0]), outputs[1]).toArray());
        vertices.push.apply(vertices, Vec3.normalize(Vec3.add(abc[1], abc[2], outputs[0]), outputs[1]).toArray());
        vertices.push.apply(vertices, Vec3.normalize(Vec3.add(abc[0], abc[2], outputs[0]), outputs[1]).toArray());

        i = vertices.length / 3 - 3, j = i + 1, k = i + 2;

        indices.push(i, j, k);
        indices.push(face[0], i, k);
        indices.push(i, face[1], j);
        indices[triangleIndex * 3] = k;
        indices[triangleIndex * 3 + 1] = j;
        indices[triangleIndex * 3 + 2] = face[2];
    }
};

/**
 * Divides all inserted triangles into four sub-triangles while maintaining
 * a radius of one. Alters the passed in arrays.
 *
 * @static
 * @method getSpheroidNormals
 *
 * @param {Array} vertices Vertices of all points on the geometry
 * @param {Array} out Optional array to be filled with resulting normals.
 * 
 * @return {Array} new list of calculated normals.
 */
GeometryHelper.getSpheroidNormals = function getSpheroidNormals(vertices, out) {
    var out = out || [];
    var length = vertices.length / 3;
    var normalized;

    for(var i = 0; i < length; i++) {
        normalized = new Vec3(
            vertices[i * 3 + 0],
            vertices[i * 3 + 1],
            vertices[i * 3 + 2]
        ).normalize().toArray();

        out[i * 3 + 0] = normalized[0];
        out[i * 3 + 1] = normalized[1];
        out[i * 3 + 2] = normalized[2];
    }

    return out;
};

/**
 * Calculates texture coordinates for spheroid primitives based on
 * input vertices.
 *
 * @static
 * @method getSpheroidUV
 *
 * @param {Array} vertices Vertices of all points on the geometry
 * @param {Array} out Optional array to be filled with resulting texture coordinates.
 * 
 * @return {Array} new list of calculated texture coordinates
 */
GeometryHelper.getSpheroidUV = function getSpheroidUV(vertices, out) {
    var out = out || [];
    var length = vertices.length / 3;
    var vertex;

    var uv = [];

    for(var i = 0; i < length; i++) {
        vertex = outputs[0].set(
            vertices[i * 3],
            vertices[i * 3 + 1],
            vertices[i * 3 + 2]
        )
        .normalize()
        .toArray();

        uv[0] = this.getAzimuth(vertex) * 0.5 / Math.PI + 0.5;
        uv[1] = this.getAltitude(vertex) / Math.PI + 0.5;

        out.push.apply(out, uv);
    }

    return out;
};

/**
 * Iterates through and normalizes a list of vertices.
 *
 * @static
 * @method normalizeAll
 *
 * @param {Array} vertices Vertices of all points on the geometry
 * @param {Array} out Optional array to be filled with resulting normalized vectors.
 * 
 * @return {Array} new list of normalized vertices
 */
GeometryHelper.normalizeAll = function normalizeAll(vertices, out) {
    var out = out || [];
    var vertex;
    var len = vertices.length / 3;

    for (var i = 0; i < len; i++) {
        Array.prototype.push.apply(out, new Vec3(vertices[i * 3], vertices[i * 3 + 1], vertices[i * 3 + 2]).normalize().toArray());
    }

    return out;
};

/**
 * Normalizes a set of vertices to model space.
 *
 * @static
 * @method normalizeVertices
 *
 * @param {Array} vertices Vertices of all points on the geometry
 * @param {Array} out Optional array to be filled with model space position vectors.
 * 
 * @return {Array} Output vertices.
 */
GeometryHelper.normalizeVertices = function normalizeVertices(vertices, out) {
    var out = out || [];
    var len = vertices.length / 3;
    var vectors = [];
    var minX;
    var maxX;
    var minY;
    var maxY;
    var minZ;
    var maxZ;
    var v;

    for (var i = 0; i < len; i++) {
        v = vectors[i] = new Vec3(
            vertices[i * 3],
            vertices[i * 3 + 1],
            vertices[i * 3 + 2]
        );

        if (minX == null || v.x < minX) minX = v.x;
        if (maxX == null || v.x > maxX) maxX = v.x;

        if (minY == null || v.y < minY) minY = v.y;
        if (maxY == null || v.y > maxY) maxY = v.y;

        if (minZ == null || v.z < minZ) minZ = v.z;
        if (maxZ == null || v.z > maxZ) maxZ = v.z;
    };

    var translation = new Vec3(
        getTranslationFactor(maxX, minX),
        getTranslationFactor(maxY, minY),
        getTranslationFactor(maxZ, minZ)
    );

    var scale = Math.min(
        getScaleFactor(maxX + translation.x, minX + translation.x),
        getScaleFactor(maxY + translation.y, minY + translation.y),
        getScaleFactor(maxZ + translation.z, minZ + translation.z)
    );

    for (var i = 0; i < vectors.length; i++) {
        out.push.apply(out, vectors[i].add(translation).scale(scale).toArray());
    }

    return out;
};

/**
 * Determines translation amount for a given axis to normalize model coordinates.
 *
 * @method getTranslationFactor
 * @private
 *
 * @param {Number} max Maximum position value of given axis on the model.
 * @param {Number} min Minimum position value of given axis on the model.
 *
 * @return {Number} Number by which the given axis should be translated for all vertices.
 */
function getTranslationFactor(max, min) {
    return -(min + (max - min) / 2);
}

/**
 * Determines scale amount for a given axis to normalize model coordinates.
 *
 * @method getScaleFactor
 * @private
 *
 * @param {Number} max Maximum scale value of given axis on the model.
 * @param {Number} min Minimum scale value of given axis on the model.
 *
 * @return {Number} Number by which the given axis should be scaled for all vertices.
 */
function getScaleFactor(max, min) {
    return 1 / ((max - min) / 2);
}

/**
 * Finds the azimuth, or angle above the XY plane, of a given vector.
 *
 * @static
 * @method getAzimuth
 *
 * @param {Array} v Vertex to retreive azimuth from.
 * 
 * @return {Number} Azimuth value in radians. 
 */
GeometryHelper.getAzimuth = function azimuth(v) {
    return Math.atan2(v[2], -v[0]);
};

/**
 * Finds the altitude, or angle above the XZ plane, of a given vector.
 *
 * @static
 * @method getAltitude
 *
 * @param {Array} v Vertex to retreive altitude from.
 * 
 * @return {Number} Altitude value in radians. 
 */
GeometryHelper.getAltitude = function altitude(v) {
    return Math.atan2(-v[1], Math.sqrt((v[0] * v[0]) + (v[2] * v[2])));
};

/**
 * Converts a list of indices from 'triangle' to 'line' format.
 *
 * @static
 * @method trianglesToLines
 *
 * @param {Array} indices Indices of all faces on the geometry
 * 
 * @return {Array} new list of line-formatted indices
 */
GeometryHelper.trianglesToLines = function triangleToLines(indices, out) {
    var numVectors = indices.length / 3;
    var out = [];
    var face;
    var j;
    var i;

    for (i = 0; i < numVectors; i++) {
        out.push(indices[i + 0], indices[i + 1]);
        out.push(indices[i + 1], indices[i + 2]);
        out.push(indices[i + 2], indices[i + 0]);
    }

    return out;
};

module.exports = GeometryHelper;

},{"famous-math":239}],259:[function(require,module,exports){
var loadURL        = require('famous-utilities').loadURL;
var GeometryHelper = require('./GeometryHelper');

/*
 * A singleton object that takes that makes requests
 * for OBJ files and returns the formatted data as
 * an argument to a callback function.
 *
 * @static
 * @class OBJLoader
 */

var OBJLoader = {
    cached: {},
    requests: {}
};

/*
 * Takes a path to desired obj file and makes an XMLHttp request
 * if the resource is not cached. Sets up the 'onresponse' function
 * as a callback for formatting and callback invocation.
 *
 * @method load
 *
 * @param {String} url URL of desired obj
 * @param {Function} cb Function to be fired upon successful formatting of obj
 * @param {Object} options Options hash to that can affect the output of the OBJ
 * vertices.
 */
OBJLoader.load = function load(url, cb, options) {
    if (! this.cached[url]) {
        if(! this.requests[url]) {
            this.requests[url] = [cb];
            loadURL(
                url,
                this._onsuccess.bind(
                    this,
                    url,
                    options
                )
            );
        } else {
            this.requests[url].push(cb);
        }
    } else {
        cb(this.cached[url]);
    }
};

/*
 * Fired on response from server for OBJ asset.  Formats the
 * returned string and stores the buffer data in cache.
 * Invokes all queued callbacks before clearing them.
 *
 * @method _onsuccess
 * @private
 *
 * @param {String} URL of requested obj
 * @param {Boolean} value determining whether or not to manually calculate normals
 * @param {String} content of the server response
 */
OBJLoader._onsuccess = function _onsuccess(url, options, text) {
    var buffers = format.call(this, text, options || {});
    this.cached[url] = buffers;

    for (var i = 0; i < this.requests[url].length; i++) {
        this.requests[url][i](buffers);
    }

    this.requests[url] = null;
};

/*
 * Takes raw string format of obj and converts it to a javascript
 * object representing the buffers needed to draw the geometry.
 *
 * @method format
 * @private
 *
 * @param {String} raw obj data in text format
 * @param {Boolean} value determining whether or not to manually calculate normals
 *
 * @return {Object} vertex buffer data
 */
function format(text, options) {
    var text = sanitize(text);

    var lines = text.split('\n');

    var faceTexCoords = [];
    var faceVertices = [];
    var faceNormals = [];

    var normals = [];
    var texCoords = [];
    var vertices = [];

    var i1, i2, i3, i4;
    var split;
    var line;

    var length = lines.length;

    for (var i = 0; i < length; i++) {
        line = lines[i];
        split = lines[i].split(' ');

        // Handle vertex positions

        if (line.indexOf('v ') !== -1) {
            vertices.push([
                parseFloat(split[1]),
                parseFloat(split[2]),
                parseFloat(split[3])
            ]);
        }

        // Handle texture coordinates

        else if(line.indexOf('vt ') !== -1) {
            texCoords.push([
                parseFloat(split[1]),
                parseFloat(split[2])
            ]);
        }

        // Handle vertex normals

        else if (line.indexOf('vn ') !== -1) {
            normals.push([
                parseFloat(split[1]),
                parseFloat(split[2]),
                parseFloat(split[3])
            ]);
        }

        // Handle face

        else if (line.indexOf('f ') !== -1) {

            // Vertex, Normal

            if (split[1].indexOf('//') !== -1) {
                i1 = split[1].split('//');
                i2 = split[2].split('//');
                i3 = split[3].split('//');

                faceVertices.push([
                    parseFloat(i1[0]) - 1,
                    parseFloat(i2[0]) - 1,
                    parseFloat(i3[0]) - 1
                ]);
                faceNormals.push([
                    parseFloat(i1[1]) - 1,
                    parseFloat(i2[1]) - 1,
                    parseFloat(i3[1]) - 1
                ]);

                // Handle quad

                if (split[4]) {
                    i4 = split[4].split('//');
                    faceVertices.push([
                        parseFloat(i1[0]) - 1,
                        parseFloat(i3[0]) - 1,
                        parseFloat(i4[0]) - 1
                    ]);
                    faceNormals.push([
                        parseFloat(i1[2]) - 1,
                        parseFloat(i3[2]) - 1,
                        parseFloat(i4[2]) - 1
                    ]);
                }
            }

            // Vertex, TexCoord, Normal

            else if (split[1].indexOf('/') !== -1) {
                i1 = split[1].split('/');
                i2 = split[2].split('/');
                i3 = split[3].split('/');

                faceVertices.push([
                    parseFloat(i1[0]) - 1,
                    parseFloat(i2[0]) - 1,
                    parseFloat(i3[0]) - 1
                ]);
                faceTexCoords.push([
                    parseFloat(i1[1]) - 1,
                    parseFloat(i2[1]) - 1,
                    parseFloat(i3[1]) - 1
                ]);
                faceNormals.push([
                    parseFloat(i1[2]) - 1,
                    parseFloat(i2[2]) - 1,
                    parseFloat(i3[2]) - 1
                ]);

                // Handle Quad

                if (split[4]) {
                    i4 = split[4].split('/');

                    faceVertices.push([
                        parseFloat(i1[0]) - 1,
                        parseFloat(i3[0]) - 1,
                        parseFloat(i4[0]) - 1
                    ]);
                    faceTexCoords.push([
                        parseFloat(i1[1]) - 1,
                        parseFloat(i3[1]) - 1,
                        parseFloat(i4[1]) - 1
                    ]);
                    faceNormals.push([
                        parseFloat(i1[2]) - 1,
                        parseFloat(i3[2]) - 1,
                        parseFloat(i4[2]) - 1
                    ]);
                }
            }

            // Vertex

            else {
                faceVertices.push([
                    parseFloat(split[1]) - 1,
                    parseFloat(split[2]) - 1,
                    parseFloat(split[3]) - 1
                ]);
                faceTexCoords.push([
                    parseFloat(split[1]) - 1,
                    parseFloat(split[2]) - 1,
                    parseFloat(split[3]) - 1
                ]);
                faceNormals.push([
                    parseFloat(split[1]) - 1,
                    parseFloat(split[2]) - 1,
                    parseFloat(split[3]) - 1
                ]);

                // Handle Quad

                if (split[4]) {
                    faceVertices.push([
                        parseFloat(split[1]) - 1,
                        parseFloat(split[3]) - 1,
                        parseFloat(split[4]) - 1
                    ]);
                    faceTexCoords.push([
                        parseFloat(split[1]) - 1,
                        parseFloat(split[3]) - 1,
                        parseFloat(split[4]) - 1
                    ]);
                    faceNormals.push([
                        parseFloat(split[1]) - 1,
                        parseFloat(split[3]) - 1,
                        parseFloat(split[4]) - 1
                    ]);
                }
            }
        }
    }

    var cached = cacheVertices(
        vertices,
        normals,
        texCoords,
        faceVertices,
        faceNormals,
        faceTexCoords
    );


    cached.vertices = flatten(cached.vertices);
    cached.normals = flatten(cached.normals);
    cached.texCoords = flatten(cached.texCoords);
    cached.indices = flatten(cached.indices);

    if (options.normalize) {
        cached.vertices = GeometryHelper.normalizeVertices(
            cached.vertices
        );
    }

    if (options.computeNormals) {
        cached.normals = GeometryHelper.computeNormals(
            cached.vertices,
            cached.indices
        );
    }

    return {
        vertices: cached.vertices,
        normals: cached.normals,
        textureCoords: cached.texCoords,
        indices: cached.indices
    };
};

/*
 * Replaces all double spaces with single spaces and removes
 * all trailing spaces from lines of a given string.
 *
 * @method sanitize
 * @private
 *
 * @param {String} text String to be sanitized.
 *
 * @return {String} sanitized string.
 */
function sanitize(text) {
    return text.replace(/ +(?= )/g,'').replace(/\s+$/g, '');
}

/*
 * Takes a given pool of attributes and face definitions
 * and removes all duplicate vertices.
 *
 * @method cacheVertices
 * @private
 *
 * @param {Array} v Pool of vertices used in face declarations.
 * @param {Array} n Pool of normals used in face declarations.
 * @param {Array} t Pool of textureCoords used in face declarations.
 * @param {Array} fv Vertex positions at each face in the OBJ.
 * @param {Array} fn Normals at each face in the OBJ.
 * @param {Array} ft Texture coordinates at each face in the OBJ.
 *
 * @return {Object} Object containing the vertices, textureCoordinates and
 * normals of the OBJ.
 */
function cacheVertices(v, n, t, fv, fn, ft) {
    var outNormals = [];
    var outPos = [];
    var outTexCoord = [];
    var outIndices = [];

    var vertexCache = {};

    var positionIndex;
    var normalIndex;
    var texCoordIndex;

    var currentIndex = 0;
    var fvLength = fv.length;
    var fnLength = fn.length;
    var ftLength = ft.length;
    var faceLength;
    var index;

    for (var i = 0; i < fvLength; i++) {
        outIndices[i] = [];
        faceLength = fv[i].length;

        for (var j = 0; j < faceLength; j++) {
            if (ftLength) texCoordIndex = ft[i][j];
            if (fnLength) normalIndex   = fn[i][j];
                          positionIndex = fv[i][j];

            index = vertexCache[positionIndex + ',' + normalIndex + ',' + texCoordIndex];

            if(index === undefined) {
                index = currentIndex++;

                              outPos.push(v[positionIndex]);
                if (fnLength) outNormals.push(n[normalIndex]);
                if (ftLength) outTexCoord.push(t[texCoordIndex]);

                vertexCache[positionIndex + ',' + normalIndex + ',' + texCoordIndex] = index;
            }

            outIndices[i].push(index);
        }
    }

    return {
        vertices: outPos,
        normals: outNormals,
        texCoords: outTexCoord,
        indices: outIndices
    }
}

/*
 * Flattens an array of arrays. Not recursive. Assumes
 * all children are arrays.
 *
 * @method flatten
 * @private
 *
 * @param {Array} arr Input array to be flattened.
 *
 * @return {Array} Flattened version of input array.
 */
function flatten(arr) {
    var len = arr.length;
    var out = [];

    for (var i = 0; i < len; i++) {
        out.push.apply(out, arr[i]);
    }

    return out;
}

module.exports = OBJLoader;

},{"./GeometryHelper":258,"famous-utilities":252}],260:[function(require,module,exports){
'use strict';

module.exports = {
    Box: require('./primitives/Box'),
    Circle: require('./primitives/Circle'),
    Cylinder: require('./primitives/Cylinder'),
    GeodesicSphere: require('./primitives/GeodesicSphere'),
    Icosahedron: require('./primitives/Icosahedron'),
    ParametricCone: require('./primitives/ParametricCone'),
    Plane: require('./primitives/Plane'),
    Sphere: require('./primitives/Sphere'),
    Tetrahedron: require('./primitives/Tetrahedron'),
    Torus: require('./primitives/Torus'),
    Triangle: require('./primitives/Triangle'),
    GeometryHelper: require('./GeometryHelper'),
    DynamicGeometry: require('./DynamicGeometry'),
    Geometry: require('./Geometry'),
    OBJLoader: require('./OBJLoader'),
};
},{"./DynamicGeometry":256,"./Geometry":257,"./GeometryHelper":258,"./OBJLoader":259,"./primitives/Box":261,"./primitives/Circle":262,"./primitives/Cylinder":263,"./primitives/GeodesicSphere":264,"./primitives/Icosahedron":265,"./primitives/ParametricCone":266,"./primitives/Plane":267,"./primitives/Sphere":268,"./primitives/Tetrahedron":269,"./primitives/Torus":270,"./primitives/Triangle":271}],261:[function(require,module,exports){
'use strict';

var Geometry = require('../Geometry');

function pickOctant(i) {
    return [(i & 1) * 2 - 1, (i & 2) - 1, (i & 4) / 2 - 1];
}

var boxData = [
    [0, 4, 2, 6, -1, 0, 0], 
    [1, 3, 5, 7, +1, 0, 0],
    [0, 1, 4, 5, 0, -1, 0],
    [2, 6, 3, 7, 0, +1, 0],
    [0, 2, 1, 3, 0, 0, -1],
    [4, 5, 6, 7, 0, 0, +1]
];

/**
 * This function returns a new static geometry, which is passed
 * custom buffer data.
 *
 * @class BoxGeometry
 * @constructor
 *
 * @param {Object} options Parameters that alter the
 * vertex buffers of the generated geometry.
 * 
 * @return {Object} constructed geometry
 */
function BoxGeometry(options) {
    var options = options || {};

    var vertices      = [];
    var textureCoords = [];
    var normals       = [];
    var indices       = [];

    var data;
    var d;
    var v;
    var i;
    var j;

    for (i = 0; i < boxData.length; i++) {
        data = boxData[i], v = i * 4;
        for (j = 0; j < 4; j++) {
            d = data[j];
            var octant = pickOctant(d);
            vertices.push(octant[0], octant[1], octant[2]);
            textureCoords.push(j & 1, (j & 2) / 2);
            normals.push(data[4], data[5], data[6]);
        }
        indices.push(v, v + 1, v + 2);
        indices.push(v + 2, v + 1, v + 3);
    }

    return new Geometry({
        buffers: [
            { name: 'pos', data: vertices },
            { name: 'texCoord', data: textureCoords, size: 2 },
            { name: 'normals', data: normals },
            { name: 'indices', data: indices, size: 1 }
        ]
    });
};

module.exports = BoxGeometry;

},{"../Geometry":257}],262:[function(require,module,exports){
'use strict';

var Geometry       = require('../Geometry');

/**
 * This function returns a new static geometry, which is passed
 * custom buffer data.
 *
 * @class Circle
 * @constructor
 *
 * @param {Object} options Parameters that alter the
 * vertex buffers of the generated geometry.
 * 
 * @return {Object} constructed geometry
 */
function Circle (options) {
    var options  = options || {};
    var detail   = options.detail || 30;
    var buffers  = getBuffers(detail);

    return new Geometry({
        type: 'TRIANGLE_FAN',
        buffers: [
            { name: 'pos', data: buffers.vertices },
            { name: 'texCoord', data: buffers.textureCoords, size: 2 },
            { name: 'normals', data: buffers.normals }
        ]
    });
}
    
/**
 * Calculates and returns all vertex positions, texture
 * coordinates and normals of the circle primitive.
 *
 * @method getBuffers
 *
 * @param {Number} detail Amount of detail that determines how many
 * vertices are created and where they are placed
 * 
 * @return {Object} constructed geometry
 */
function getBuffers(detail) {
    var theta = 0;
    var x;
    var y;
    var index = detail + 1;
    var nextTheta;
    var vertices      = [0, 0, 0];
    var normals       = [0, 0, 1];
    var textureCoords = [0.5, 0.5];

    while (index--) {
        theta = index / detail * Math.PI * 2;

        x = Math.cos(theta), y = Math.sin(theta);
        vertices.unshift(x, y, 0);
        normals.unshift(0, 0, 1);
        textureCoords.unshift(0.5 + x * 0.5, 0.5 + -y * 0.5);
    }

    return {
        vertices: vertices,
        normals: normals,
        textureCoords: textureCoords
    };
}

module.exports = Circle;

},{"../Geometry":257}],263:[function(require,module,exports){
'use strict';

var Geometry       = require('../Geometry');
var GeometryHelper = require('../GeometryHelper');

/**
 * This class creates a new geometry instance and sets
 * its vertex positions, texture coordinates, normals,
 * and indices to based on the primitive.
 *
 * @class Cylinder
 * @constructor
 * 
 * @param {Object} options Parameters that alter the
 * vertex buffers of the generated geometry.
 *
 * @return {Object} constructed geometry
 */
function Cylinder (options) {
    var options  = options || {};
    var radius   = options.radius || 1;
    var detail   = options.detail || 15;
    var buffers;

    buffers = GeometryHelper.generateParametric(
        1,
        detail,
        Cylinder.generator.bind(null, radius)
    );

    return new Geometry({
        buffers: [
            { name: 'pos', data: buffers.vertices },
            { name: 'texCoord', data: GeometryHelper.getSpheroidUV(buffers.vertices), size: 2 },
            { name: 'normals', data: GeometryHelper.computeNormals(buffers.vertices, buffers.indices) },
            { name: 'indices', data: buffers.indices, size: 1 }
        ]
    });
}

/**
 * Function used in iterative construction of parametric primitive.
 *
 * @static
 * @method generator
 * @param {Number} r Cylinder radius.
 * @param {Number} u Longitudal progress from 0 to PI.
 * @param {Number} v Latitudal progress from 0 to PI.
 *
 * @return {Array} x, y and z coordinate of geometry.
 */
Cylinder.generator = function generator(r, u, v, pos) {
    pos[0] = r * Math.cos(v);
    pos[1] = r * (-1 + u / Math.PI * 2);
    pos[2] = r * Math.sin(v);
}

module.exports = Cylinder;

},{"../Geometry":257,"../GeometryHelper":258}],264:[function(require,module,exports){
'use strict';

var Geometry       = require('../Geometry');
var GeometryHelper = require('../GeometryHelper');

/**
 * This function returns a new static geometry, which is passed
 * custom buffer data.
 *
 * @class GeodesicSphere
 * @constructor
 *
 * @param {Object} options Parameters that alter the
 * vertex buffers of the generated geometry.
 * 
 * @return {Object} constructed geometry
 */
function GeodesicSphere (options) {
    var t = (1 + Math.sqrt(5)) * 0.5;

    var vertices = [
        - 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
         0, - 1, -t,    0,  1, -t,    0, - 1,   t,    0,  1,   t,
         t,  0,   1,    t,  0, -1,   - t,  0,   1,   - t,  0, -1
    ];
    var indices = [
        0,  5, 11,    0,  1,  5,    0,  7,  1,    0, 10,  7,    0, 11, 10,
        1,  9,  5,    5,  4, 11,    11, 2, 10,   10,  6,  7,    7,  8,  1,
        3,  4,  9,    3,  2,  4,    3,  6,  2,    3,  8,  6,    3,  9,  8,
        4,  5,  9,    2, 11,  4,    6, 10,  2,    8,  7,  6,    9,  1,  8
    ];

    vertices = GeometryHelper.normalizeAll(vertices);

    var options = options || {};
    var detail  = options.detail || 3;

    while(--detail) GeometryHelper.subdivideSpheroid(vertices, indices);
    GeometryHelper.getUniqueFaces(vertices, indices);

    var normals       = GeometryHelper.computeNormals(vertices, indices);
    var textureCoords = GeometryHelper.getSpheroidUV(vertices);

    return new Geometry({
        buffers: [
            { name: 'pos', data: vertices },
            { name: 'texCoord', data: textureCoords, size: 2 },
            { name: 'normals', data: normals },
            { name: 'indices', data: indices, size: 1 }
        ]
    });
}

module.exports = GeodesicSphere;

},{"../Geometry":257,"../GeometryHelper":258}],265:[function(require,module,exports){
'use strict';

var Geometry = require('../Geometry');
var GeometryHelper = require('../GeometryHelper');

/**
 * This function returns a new static geometry, which is passed
 * custom buffer data.
 *
 * @class Icosahedron
 * @constructor
 *
 * @param {Object} options Parameters that alter the
 * vertex buffers of the generated geometry.
 * 
 * @return {Object} constructed geometry
 */
function Icosahedron() {
    var t = ( 1 + Math.sqrt( 5 ) ) / 2;

    var geometry;
    var detail;
    var vertices = [
        - 1,   t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
          0, - 1, -t,    0,  1, -t,     0, - 1,  t,    0,   1,  t,
          t,   0,  1,    t,  0, -1,   - t,   0,  1,  - t,   0, -1
    ];
    var indices = [
        0,  5, 11,    0,  1,  5,    0,  7,  1,    0, 10,  7,    0, 11, 10,
        1,  9,  5,    5,  4, 11,    11, 2, 10,   10,  6,  7,    7,  8,  1,
        3,  4,  9,    3,  2,  4,    3,  6,  2,    3,  8,  6,    3,  9,  8,
        4,  5,  9,    2, 11,  4,    6, 10,  2,    8,  7,  6,    9,  1,  8
    ];

    GeometryHelper.getUniqueFaces(vertices, indices);

    var normals       = GeometryHelper.computeNormals(vertices, indices);
    var textureCoords = GeometryHelper.getSpheroidUV(vertices);

    vertices      = GeometryHelper.normalizeAll(vertices);

    return new Geometry({
        buffers: [
            { name: 'pos', data: vertices },
            { name: 'texCoord', data: textureCoords, size: 2 },
            { name: 'normals', data: normals },
            { name: 'indices', data: indices, size: 1 }
        ]
    });
}

module.exports = Icosahedron;

},{"../Geometry":257,"../GeometryHelper":258}],266:[function(require,module,exports){
'use strict';

var Geometry = require('../Geometry');
var GeometryHelper = require('../GeometryHelper');

/**
 * This function returns a new static geometry, which is passed
 * custom buffer data.
 *
 * @class ParametricCone
 * @constructor
 *
 * @param {Object} options Parameters that alter the
 * vertex buffers of the generated geometry.
 * 
 * @return {Object} constructed geometry
 */
function ParametricCone (options) {
    var options  = options || {};
    var detail   = options.detail || 15;
    var radius   = options.radius || 1 / Math.PI;

    var buffers = GeometryHelper.generateParametric(
        detail,
        detail,
        ParametricCone.generator.bind(null, radius)
    );

    return new Geometry({
        buffers: [
            { name: 'pos', data: buffers.vertices },
            { name: 'texCoord', data: GeometryHelper.getSpheroidUV(buffers.vertices), size: 2 },
            { name: 'normals', data: GeometryHelper.computeNormals(buffers.vertices, buffers.indices) },
            { name: 'indices', data: buffers.indices, size: 1 }
        ]
    });
}

/**
 * function used in iterative construction of parametric primitive.
 *
 * @static
 * @method generator
 * @param {Number} r Cone Radius.
 * @param {Number} u Longitudal progress from 0 to PI.
 * @param {Number} v Latitudal progress from 0 to PI.
 * @return {Array} x, y and z coordinate of geometry.
 */

ParametricCone.generator = function generator(r, u, v, pos) {
    pos[0] = r * u * Math.sin(v);
    pos[1] = -r * u * Math.cos(v);
    pos[2] = -u;
}

module.exports = ParametricCone;

},{"../Geometry":257,"../GeometryHelper":258}],267:[function(require,module,exports){
'use strict';

var Geometry = require('../Geometry');

/**
 * This function returns a new static geometry, which is passed
 * custom buffer data.
 *
 * @class Plane
 * @constructor
 *
 * @param {Object} options Parameters that alter the
 * vertex buffers of the generated geometry.
 * 
 * @return {Object} constructed geometry
 */
function Plane(options) {
    var options = options || {};
    var detailX = options.detailX || options.detail || 1;
    var detailY = options.detailY || options.detail || 1;

    var vertices      = [];
    var textureCoords = [];
    var normals       = [];
    var indices       = [];

    for (var y = 0; y <= detailY; y++) {
        var t = y / detailY;
        for (var x = 0; x <= detailX; x++) {
            var s = x / detailX;
            vertices.push(2. * (s - .5), 2 * (t - .5), 0);
            textureCoords.push(s, 1 - t);
            normals.push(0, 0, 1);
            if (x < detailX && y < detailY) {
                var i = x + y * (detailX + 1);
                indices.push(i, i + 1, i + detailX + 1);
                indices.push(i + detailX + 1, i + 1, i + detailX + 2);
            }
        }
    }
    
    return new Geometry({
        buffers: [
            { name: 'pos', data: vertices },
            { name: 'texCoord', data: textureCoords, size: 2 },
            { name: 'normals', data: normals },
            { name: 'indices', data: indices, size: 1 }
        ]
    });
};

module.exports = Plane;

},{"../Geometry":257}],268:[function(require,module,exports){
'use strict';

var Geometry = require('../Geometry');
var GeometryHelper = require('../GeometryHelper');

/**
 * This function returns a new static geometry, which is passed
 * custom buffer data.
 *
 * @class ParametricSphere
 * @constructor
 *
 * @param {Object} options Parameters that alter the
 * vertex buffers of the generated geometry.
 * 
 * @return {Object} constructed geometry
 */
function ParametricSphere (options) {
    options = options || {};
    var detail = options.detail || 10;
    var detailX = options.detailX || detail;    
    var detailY = options.detailY || detail;

    var buffers = GeometryHelper.generateParametric(
          detailX,
          detailY,
          ParametricSphere.generator
    );

    GeometryHelper.getUniqueFaces(buffers.vertices, buffers.indices);

    return new Geometry({
        buffers: [
            { name: 'pos', data: buffers.vertices },
            { name: 'texCoord', data: GeometryHelper.getSpheroidUV(buffers.vertices), size: 2 },
            { name: 'normals', data: GeometryHelper.getSpheroidNormals(buffers.vertices) },
            { name: 'indices', data: buffers.indices, size: 1 }
        ]
    });
}

/**
 * Function used in iterative construction of parametric primitive.
 *
 * @static
 * @method generator
 * @param {Number} u Longitudal progress from 0 to PI.
 * @param {Number} v Latitudal progress from 0 to PI.
 * @return {Array} x, y and z coordinates of geometry
 */
ParametricSphere.generator = function generator(u, v, pos) {
    var x = Math.sin(u) * Math.cos(v);
    var y = Math.cos(u);
    var z = -Math.sin(u) * Math.sin(v);

    pos[0] = x;
    pos[1] = y;
    pos[2] = z;
};

module.exports = ParametricSphere;

},{"../Geometry":257,"../GeometryHelper":258}],269:[function(require,module,exports){
'use strict';

var Geometry = require('../Geometry');
var GeometryHelper = require('../GeometryHelper');

/**
 * This function generates custom buffers and passes them to
 * a new static geometry, which is returned to the user.
 *
 * @class Tetrahedron
 * @constructor
 *
 * @param {Object} options Parameters that alter the
 * vertex buffers of the generated geometry.
 * 
 * @return {Object} constructed geometry
 */
function Tetrahedron(options) {
    var textureCoords = [];
    var normals = [];
    var geometry;
    var detail;
    var i;
    var t = Math.sqrt(3);
    
    var vertices = [
        // Back 
         1, -1, -1 / t,
        -1, -1, -1 / t,
         0,  1,  0,
        
        // Right
         0,  1,  0,
         0, -1, t - 1 / t,
         1, -1, -1 / t,

        // Left
         0,  1,  0,
        -1, -1, -1 / t,
         0, -1,  t - 1 / t,

        // Bottom
         0, -1,  t - 1 / t,
        -1, -1, -1 / t,
         1, -1, -1 / t,
    ];

    var indices = [
        0, 1, 2,
        3, 4, 5,
        6, 7, 8,
        9, 10, 11,
    ];

    for (i = 0; i < 4; i++) {
        textureCoords.push(
            0.0, 0.0,
            0.5, 1.0,
            1.0, 0.0
        );
    }

    options       = options || {};

    while(--detail) GeometryHelper.subdivide(indices, vertices, textureCoords);
    normals       = GeometryHelper.computeNormals(vertices, indices);

    return new Geometry({
        buffers: [
            { name: 'pos', data: vertices },
            { name: 'texCoord', data: textureCoords, size: 2 },
            { name: 'normals', data: normals },
            { name: 'indices', data: indices, size: 1 }
        ]
    });
}

module.exports = Tetrahedron;

},{"../Geometry":257,"../GeometryHelper":258}],270:[function(require,module,exports){
'use strict';

var Geometry = require('../Geometry');
var GeometryHelper = require('../GeometryHelper');

/**
 * This function returns a new static geometry, which is passed
 * custom buffer data.
 *
 * @class Torus
 * @constructor
 *
 * @param {Object} options Parameters that alter the
 * vertex buffers of the generated geometry.
 * 
 * @return {Object} constructed geometry
 */

function Torus(options) {
    var options  = options || {};
    var detail   = options.detail || 30;
    var holeRadius = options.holeRadius || 0.80;
    var tubeRadius = options.tubeRadius || 0.20;

    var buffers = GeometryHelper.generateParametric(
        detail,
        detail,
        Torus.generator.bind(null, holeRadius, tubeRadius)
    );

    return new Geometry({
        buffers: [
            { name: 'pos', data: buffers.vertices },
            { name: 'texCoord', data: GeometryHelper.getSpheroidUV(buffers.vertices), size: 2 },
            { name: 'normals', data: GeometryHelper.computeNormals(buffers.vertices, buffers.indices) },
            { name: 'indices', data: buffers.indices, size: 1 }
        ]
    });
}

/**
 * function used in iterative construction of parametric primitive.
 *
 * @static
 * @method generator
 * @param {Number} c Radius of inner hole.
 * @param {Number} a Radius of tube.
 * @param {Number} u Longitudal progress from 0 to PI.
 * @param {Number} v Latitudal progress from 0 to PI.
 * @return {Array} x, y and z coordinate of the vertex.
 */
Torus.generator = function generator(c, a, u, v, pos) {
    pos[0] = (c + a * Math.cos(2 * v)) * Math.sin(2 * u);
    pos[1] = -(c + a * Math.cos(2 * v)) * Math.cos(2 * u);
    pos[2] = a * Math.sin(2 * v);
}

module.exports = Torus;

},{"../Geometry":257,"../GeometryHelper":258}],271:[function(require,module,exports){
'use strict';

var Geometry       = require('../Geometry');
var GeometryHelper = require('../GeometryHelper');

/**
 * This function returns a new static geometry, which is passed
 * custom buffer data.
 *
 * @class Triangle
 * @constructor
 *
 * @param {Object} options Parameters that alter the
 * vertex buffers of the generated geometry.
 * 
 * @return {Object} constructed geometry
 */
function Triangle (options) {
    var options  = options || {};
    var detail   = options.detail || 1;
    var normals  = [];
    var textureCoords = [
        0.0, 0.0,
        0.5, 1.0,
        1.0, 0.0
    ];
    var indices  = [
        0, 1, 2
    ];
    var vertices = [
        -1,  1, 0,
         0, -1, 0,
         1,  1, 0
    ];

    while(--detail) GeometryHelper.subdivide(indices, vertices, textureCoords);
    normals       = GeometryHelper.computeNormals(vertices, indices);

    return new Geometry({
        buffers: [
            { name: 'pos', data: vertices },
            { name: 'texCoord', data: textureCoords, size: 2 },
            { name: 'normals', data: normals },
            { name: 'indices', data: indices, size: 1 }
        ]
    });
}

module.exports = Triangle;

},{"../Geometry":257,"../GeometryHelper":258}],272:[function(require,module,exports){
module.exports = noop

function noop() {
  throw new Error(
      'You should bundle your code ' +
      'using `glslify` as a transform.'
  )
}

},{}],273:[function(require,module,exports){
module.exports = programify

function programify(vertex, fragment, uniforms, attributes) {
  return {
    vertex: vertex, 
    fragment: fragment,
    uniforms: uniforms, 
    attributes: attributes
  };
}

},{}],274:[function(require,module,exports){
"use strict";
var glslify = require("glslify");
var shaders = require("glslify/simple-adapter.js")("\n#define GLSLIFY 1\n\nmat3 a_x_getNormalMatrix(in mat4 t) {\n  mat3 matNorm;\n  mat4 a = t;\n  float a00 = a[0][0], a01 = a[0][1], a02 = a[0][2], a03 = a[0][3], a10 = a[1][0], a11 = a[1][1], a12 = a[1][2], a13 = a[1][3], a20 = a[2][0], a21 = a[2][1], a22 = a[2][2], a23 = a[2][3], a30 = a[3][0], a31 = a[3][1], a32 = a[3][2], a33 = a[3][3], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32, det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n  det = 1.0 / det;\n  matNorm[0][0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  matNorm[0][1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  matNorm[0][2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  matNorm[1][0] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  matNorm[1][1] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  matNorm[1][2] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  matNorm[2][0] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  matNorm[2][1] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  matNorm[2][2] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  return matNorm;\n}\nfloat b_x_inverse(float m) {\n  return 1.0 / m;\n}\nmat2 b_x_inverse(mat2 m) {\n  return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / (m[0][0] * m[1][1] - m[0][1] * m[1][0]);\n}\nmat3 b_x_inverse(mat3 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11), b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10), b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\nmat4 b_x_inverse(mat4 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3], a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3], a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3], a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32, det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n  return mat4(a11 * b11 - a12 * b10 + a13 * b09, a02 * b10 - a01 * b11 - a03 * b09, a31 * b05 - a32 * b04 + a33 * b03, a22 * b04 - a21 * b05 - a23 * b03, a12 * b08 - a10 * b11 - a13 * b07, a00 * b11 - a02 * b08 + a03 * b07, a32 * b02 - a30 * b05 - a33 * b01, a20 * b05 - a22 * b02 + a23 * b01, a10 * b10 - a11 * b08 + a13 * b06, a01 * b08 - a00 * b10 - a03 * b06, a30 * b04 - a31 * b02 + a33 * b00, a21 * b02 - a20 * b04 - a23 * b00, a11 * b07 - a10 * b09 - a12 * b06, a00 * b09 - a01 * b07 + a02 * b06, a31 * b01 - a30 * b03 - a32 * b00, a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\nfloat c_x_transpose(float m) {\n  return m;\n}\nmat2 c_x_transpose(mat2 m) {\n  return mat2(m[0][0], m[1][0], m[0][1], m[1][1]);\n}\nmat3 c_x_transpose(mat3 m) {\n  return mat3(m[0][0], m[1][0], m[2][0], m[0][1], m[1][1], m[2][1], m[0][2], m[1][2], m[2][2]);\n}\nmat4 c_x_transpose(mat4 m) {\n  return mat4(m[0][0], m[1][0], m[2][0], m[3][0], m[0][1], m[1][1], m[2][1], m[3][1], m[0][2], m[1][2], m[2][2], m[3][2], m[0][3], m[1][3], m[2][3], m[3][3]);\n}\nvec4 applyTransform(vec4 pos) {\n  mat4 MVMatrix = view * transform;\n  pos.x += 1.0;\n  pos.y -= 1.0;\n  pos.xyz *= size * 0.5;\n  pos.y *= -1.0;\n  v_Position = (MVMatrix * pos).xyz;\n  v_EyeVector = (resolution * 0.5) - v_Position;\n  MVMatrix[0][1] *= -1.0;\n  MVMatrix[1][1] *= -1.0;\n  MVMatrix[2][1] *= -1.0;\n  MVMatrix[3][1] *= -1.0;\n  mat4 MVPMatrix = perspective * MVMatrix;\n  pos = MVPMatrix * pos;\n  pos.x /= (resolution.x * 0.5);\n  pos.y /= (resolution.y * 0.5);\n  pos.x -= 1.0;\n  pos.y += 1.0;\n  pos.z *= -0.00001;\n  return pos;\n}\n#vert_definitions\n\nvec3 calculateOffset(vec3 ID) {\n  \n  #vert_applications\n  return vec3(0.0);\n}\nvoid main() {\n  gl_PointSize = 10.0;\n  vec3 invertedNormals = normals;\n  invertedNormals.y *= -1.0;\n  v_Normal = c_x_transpose(mat3(b_x_inverse(transform))) * invertedNormals;\n  v_TextureCoordinate = texCoord;\n  vec3 offsetPos = pos + calculateOffset(positionOffset);\n  gl_Position = applyTransform(vec4(offsetPos, 1.0));\n}", "\n#define GLSLIFY 1\n\n#float_definitions\n\nfloat a_x_applyMaterial(float ID) {\n  \n  #float_applications\n  return 1.;\n}\n#vec_definitions\n\nvec3 a_x_applyMaterial(vec3 ID) {\n  \n  #vec_applications\n  return vec3(.5);\n}\nvec3 b_x_applyLight(in vec3 material) {\n  int numLights = int(u_NumLights);\n  vec3 ambientColor = u_AmbientLight * material;\n  vec3 normal = normalize(v_Normal);\n  vec3 eyeVector = normalize(v_EyeVector);\n  vec3 specular = vec3(0.0);\n  vec3 diffuse = vec3(0.0);\n  for(int i = 0; i < 4; i++) {\n    if(i >= numLights)\n      break;\n    vec3 lightDirection = normalize(u_LightPosition[i].xyz - v_Position);\n    float lambertian = max(dot(lightDirection, normal), 0.0);\n    if(lambertian > 0.0) {\n      diffuse += u_LightColor[i].rgb * material * lambertian;\n    }\n    if(glossiness > 0.0) {\n      vec3 halfVector = normalize(lightDirection + eyeVector);\n      float specular = pow(max(dot(halfVector, normal), 0.0), glossiness);\n      diffuse += u_LightColor[i].rgb * specular;\n    }\n  }\n  return ambientColor + diffuse;\n}\nvoid main() {\n  vec3 material = baseColor.r >= 0.0 ? baseColor : a_x_applyMaterial(baseColor);\n  bool lightsEnabled = (u_FlatShading == 0.0) && (u_NumLights > 0.0 || length(u_AmbientLight) > 0.0);\n  vec3 color = lightsEnabled ? b_x_applyLight(material) : material;\n  gl_FragColor = vec4(color, opacity);\n}", [], []);
module.exports = shaders;
},{"glslify":272,"glslify/simple-adapter.js":273}],275:[function(require,module,exports){
'use strict';

/**
 * Buffer is a private class that wraps the vertex data that defines
 * the the points of the triangles that webgl draws. Each buffer 
 * maps to one attribute of a mesh.
 * 
 * @class Buffer
 * @constructor
 * 
 * @param {Number} target The bind target of the buffer to update: ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER
 * @param {Object} type Array type to be used in calls to gl.bufferData.
 * @param {WebGLContext} gl The WebGL context that the buffer is hosted by.
 * 
 */
function Buffer(target, type, gl) {
    this.buffer = null;
    this.target = target;
    this.type = type;
    this.data = [];
    this.gl = gl;
}

/**
 * Creates a WebGL buffer if one does not yet exist and binds the buffer to
 * to the context.  Runs bufferData with appropriate data.
 * 
 * @method subData
 * 
 */
Buffer.prototype.subData = function subData() {
    var gl = this.gl;
    var data = [];

    // to prevent against maximum call-stack issue.
    for (var i = 0, chunk = 10000; i < this.data.length; i += chunk)
        data = Array.prototype.concat.apply(data, this.data.slice(i, i + chunk));

    this.buffer = this.buffer || gl.createBuffer();
    gl.bindBuffer(this.target, this.buffer);
    gl.bufferData(this.target, new this.type(data), gl.STATIC_DRAW);
};

module.exports = Buffer;

},{}],276:[function(require,module,exports){
'use strict';

var INDICES = 'indices';

var Buffer = require('./Buffer');

/**
 * BufferRegistry is a class that manages allocation of buffers to
 * input geometries.
 * 
 * @class BufferRegistry
 * @constructor
 * 
 * @param {WebGLContext} context WebGL drawing context to be passed to buffers.
 */
function BufferRegistry(context) {
    this.gl = context;

    this.registry = {};
    this._dynamicBuffers = [];
    this._staticBuffers = [];
    
    this._arrayBufferMax = 30000;
    this._elementBufferMax = 30000;
}

/**
 * Binds and fills all the vertex data into webgl buffers.  Will reuse buffers if
 * possible.  Populates registry with the name of the buffer, the WebGL buffer
 * object, spacing of the attribute, the attribute's offset within the buffer, 
 * and finally the length of the buffer.  This information is later accessed by
 * the root to draw the buffers.
 *
 * @method allocate
 *
 * @param {Number} geometryId Id of the geometry instance that holds the buffers.
 * @param {String} name Key of the input buffer in the geometry.
 * @param {Array} value Flat array containing input data for buffer.
 * @param {Number} spacing The spacing, or itemSize, of the input buffer.
 * @param {Boolean} dynamic Boolean denoting whether a geometry is dynamic or static.
 */
BufferRegistry.prototype.allocate = function allocate(geometryId, name, value, spacing, dynamic) {
    var vertexBuffers = this.registry[geometryId] || (this.registry[geometryId] = { keys: [], values: [], spacing: [], offset: [], length: [] });

    var j = vertexBuffers.keys.indexOf(name);
    var isIndex = name === INDICES;
    var bufferFound = false;
    var newOffset;
    var offset = 0;
    var length;
    var buffer;
    var k;

    if (j === -1) {
        j = vertexBuffers.keys.length;
        length = isIndex ? value.length : Math.floor(value.length / spacing);

        if (dynamic) {

            // Use a previously created buffer if available.

            for (k = 0; k < this._staticBuffers.length; k++) {
                
                if (isIndex === this._staticBuffers[k].isIndex) {
                    newOffset = this._staticBuffers[k].offset + value.length;
                    if ((!isIndex && newOffset < this._arrayBufferMax) || (isIndex && newOffset < this._elementBufferMax)) {
                        buffer = this._staticBuffers[k].buffer;
                        offset = this._staticBuffers[k].offset;
                        this._staticBuffers[k].offset += value.length;
                        bufferFound = true;
                        break;
                    }
                }
            }

            // Create a new static buffer in none were found.

            if (!bufferFound) {
                buffer = new Buffer(
                    isIndex ? this.gl.ELEMENT_ARRAY_BUFFER : this.gl.ARRAY_BUFFER,
                    isIndex ? Uint16Array : Float32Array,
                    this.gl
                );

                this._staticBuffers.push({ buffer: buffer, offset: value.length, isIndex: isIndex });
            }
        }
        else {

            // For dynamic geometries, always create new buffer.

            buffer = new Buffer(
                isIndex ? this.gl.ELEMENT_ARRAY_BUFFER : this.gl.ARRAY_BUFFER,
                isIndex ? Uint16Array : Float32Array,
                this.gl
            );

            this._dynamicBuffers.push({ buffer: buffer, offset: value.length });
        }

        // Update the registry for the spec with buffer information.

        vertexBuffers.keys.push(name);
        vertexBuffers.values.push(buffer);
        vertexBuffers.spacing.push(spacing);
        vertexBuffers.offset.push(offset);
        vertexBuffers.length.push(length);
    }
    
    var len = value.length;
    for (var k = 0; k < len; k++) {
        vertexBuffers.values[j].data[offset + k] = value[k];
    }
    vertexBuffers.values[j].subData();
};

module.exports = BufferRegistry;

},{"./Buffer":275}],277:[function(require,module,exports){
'use strict';

// Generates a checkerboard pattern to be used as a placeholder texture
// while an image loads over the network.

module.exports = (function() {
    var context = document.createElement('canvas').getContext('2d');
    context.canvas.width = context.canvas.height = 128;
    for (var y = 0; y < context.canvas.height; y += 16) {
        for (var x = 0; x < context.canvas.width; x += 16) {
            context.fillStyle = (x ^ y) & 16 ? '#FFF' : '#DDD';
            context.fillRect(x, y, 16, 16);
        }
    }
    
    return context.canvas;
})();

},{}],278:[function(require,module,exports){
/**
 * Takes the original rendering contexts' compiler function
 * and augments it with added functionality for parsing and
 * displaying errors.
 *
 * @method debug
 *
 * @returns {Function}
 */
module.exports = function Debug() {
    return _augmentFunction(
        this.gl.compileShader,
        function(shader) {
            if (!this.getShaderParameter(shader, this.COMPILE_STATUS)) {
                var errors = this.getShaderInfoLog(shader);
                var source = this.getShaderSource(shader);
                _processErrors(errors, source);
            }
        }
    );
}

/**
 * Takes a function, keeps the reference and replaces it by a closure that
 * executes the original function and the provided callback.
 *
 * @param {Function} Function
 * @param {Function} Callback
 * @return {Function}
 */
function _augmentFunction(func, callback) {
    return function() {
        var res = func.apply(this, arguments);
        callback.apply(this, arguments);
        return res;
    }
}

/**
 * Parses errors and failed source code from shaders in order
 * to build displayable error blocks.
 * Inspired by Jaume Sanchez Elias.
 *
 * @param {String} Errors
 * @param {String} Source
 */
function _processErrors(errors, source) {

    var css = 'body,html{background:#e3e3e3;font-family:monaco,monospace;font-size:14px;line-height:1.7em}'
            + '#shaderReport{left:0;top:0;right:0;box-sizing:border-box;position:absolute;z-index:1000;color:'
            + '#222;padding:15px;white-space:normal;list-style-type:none;margin:50px auto;max-width:1200px}'
            + '#shaderReport li{background-color:#fff;margin:13px 0;box-shadow:0 1px 2px rgba(0,0,0,.15);'
            + 'padding:20px 30px;border-radius:2px;border-left:20px solid #e01111}span{color:#e01111;'
            + 'text-decoration:underline;font-weight:700}#shaderReport li p{padding:0;margin:0}'
            + '#shaderReport li:nth-child(even){background-color:#f4f4f4}'
            + '#shaderReport li p:first-child{margin-bottom:10px;color:#666}';

    var el = document.createElement('style');
    document.getElementsByTagName('head')[0].appendChild(el);
    el.textContent = css;

    var report = document.createElement('ul');
    report.setAttribute('id', 'shaderReport');
    document.body.appendChild(report);

    var re = /ERROR: [\d]+:([\d]+): (.+)/gmi;
    var lines = source.split('\n');

    var m;
    while ((m = re.exec(errors)) != null) {
        if (m.index === re.lastIndex) re.lastIndex++;
        var li = document.createElement('li');
        var code = '<p><span>ERROR</span> "' + m[2] + '" in line ' + m[1] + '</p>'
        code += '<p><b>' + lines[m[1] - 1].replace(/^[ \t]+/g, '') + '</b></p>';
        li.innerHTML = code;
        report.appendChild(li);
    }
}

},{}],279:[function(require,module,exports){
'use strict';

var Utility = require('famous-utilities');

var vertexWrapper = require('famous-webgl-shaders').vertex;
var fragmentWrapper = require('famous-webgl-shaders').fragment;
var Debug = require('./Debug');

var VERTEX_SHADER = 35633;
var FRAGMENT_SHADER = 35632;
var identityMatrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

var header = 'precision mediump float;\n';

var TYPES = {
    undefined: 'float ',
    1: 'float ',
    2: 'vec2 ',
    3: 'vec3 ',
    4: 'vec4 ',
    16: 'mat4 '
};

var inputTypes = {
    baseColor: 'vec3',
    normal: 'vec3',
    glossiness: 'float',
    metalness: 'float',
    positionOffset: 'vert'
};

var masks =  {
    vert: 1,
    vec3: 2,
    float: 4
};

/**
 * Uniform keys and values
 */
var uniforms = Utility.keyValueToArrays({
    perspective: identityMatrix,
    view: identityMatrix,
    resolution: [0, 0, 0],
    transform: identityMatrix,
    size: [1, 1, 1],
    time: [0],
    opacity: [1],
    metalness: [0],
    glossiness: [0],
    baseColor: [1, 1, 1],
    normal: [1, 1, 1],
    positionOffset: [0, 0, 0],
    u_LightPosition: identityMatrix,
    u_LightColor: identityMatrix,
    u_AmbientLight: [0, 0, 0],
    u_FlatShading: [0],
    u_NumLights: [0]
});

/**
 * Attributes keys and values
 */
var attributes = Utility.keyValueToArrays({
    pos: [0, 0, 0],
    texCoord: [0, 0],
    normals: [0, 0, 0]
});

/**
 * Varyings keys and values
 */
var varyings = Utility.keyValueToArrays({
    v_TextureCoordinate: [0, 0],
    v_Normal: [0, 0, 0],
    v_Position: [0, 0, 0],
    v_EyeVector: [0, 0, 0]
});

/**
 * A class that handles interactions with the WebGL shader program
 * used by a specific context.  It manages creation of the shader program
 * and the attached vertex and fragment shaders.  It is also in charge of
 * passing all uniforms to the WebGLContext.
 *
 * @class Program
 * @constructor
 *
 * @param {WebGL_Context} gl Context to be used to create the shader program.
 */
function Program(gl, options) {
    this.gl = gl;
    this.textureSlots = 1;
    this.options = options || {};

    this.registeredMaterials = {};
    this.flaggedUniforms = [];
    this.cachedUniforms  = {};

    this.definitionVec = [];
    this.definitionFloat = [];
    this.applicationVec = [];
    this.applicationFloat = [];
    this.applicationVert = [];
    this.definitionVert = [];

    this.resetProgram();
}

/**
 * Determines whether a material has already been registered to
 * the shader program.
 *
 * @method registerMaterial
 *
 * @param {String} name Name of target input of material.
 * @param {Object} material Compiled material object being verified.
 *
 * @return {Object} Current program.
 */
Program.prototype.registerMaterial = function registerMaterial(name, material) {
    var compiled = material;
    var type = inputTypes[name];
    var mask = masks[type];

    if ((this.registeredMaterials[material._id] & mask) === mask) return;

    for (var k in compiled.uniforms) {
        if (uniforms.keys.indexOf(k) === -1) {
            uniforms.keys.push(k);
            uniforms.values.push(compiled.uniforms[k]);
        }
    }

    for (var k in compiled.varyings) {
        if (varyings.keys.indexOf(k) === -1) {
            varyings.keys.push(k);
            varyings.values.push(compiled.varyings[k]);
        }
    }

    for (var k in compiled.attributes) {
        if (attributes.keys.indexOf(k) === -1) {
            attributes.keys.push(k);
            attributes.values.push(compiled.attributes[k]);
        }
    }

    this.registeredMaterials[material._id] |= mask;

    if (type == 'float') {
        this.definitionFloat.push(material.defines);
        this.definitionFloat.push('float fa_' + material._id + '() {\n '  + compiled.glsl + ' \n}');
        this.applicationFloat.push('if (int(abs(ID)) == ' + material._id + ') return fa_' + material._id  + '();');
    }

    if (type == 'vec3') {
        this.definitionVec.push(material.defines);
        this.definitionVec.push('vec3 fa_' + material._id + '() {\n '  + compiled.glsl + ' \n}');
        this.applicationVec.push('if (int(abs(ID.x)) == ' + material._id + ') return fa_' + material._id + '();');
    }

    if (type == 'vert') {
        this.definitionVert.push(material.defines);
        this.definitionVert.push('vec3 fa_' + material._id + '() {\n '  + compiled.glsl + ' \n}');
        this.applicationVert.push('if (int(abs(ID.x)) == ' + material._id + ') return fa_' + material._id + '();');
    }

    return this.resetProgram();
};

/**
 * Clears all cached uniforms and attribute locations.  Assembles
 * new fragment and vertex shaders and based on material from
 * currently registered materials.  Attaches said shaders to new
 * shader program and upon success links program to the WebGL
 * context.
 *
 * @method resetProgram
 *
 * @return {Program} Current program.
 */
Program.prototype.resetProgram = function resetProgram() {
    var vsChunkDefines = [];
    var vsChunkApplies = [];
    var fsChunkDefines = [];
    var fsChunkApplies = [];

    var vertexHeader = [header];
    var fragmentHeader = [header];

    var fragmentSource;
    var vertexSource;
    var material;
    var program;
    var chunk;
    var name;
    var value;
    var i;

    this.uniformLocations   = [];
    this.attributeLocations = {};

    this.attributeNames = Utility.clone(attributes.keys);
    this.attributeValues = Utility.clone(attributes.values);

    this.varyingNames = Utility.clone(varyings.keys);
    this.varyingValues = Utility.clone(varyings.values);

    this.uniformNames = Utility.clone(uniforms.keys);
    this.uniformValues = Utility.clone(uniforms.values);

    this.flaggedUniforms = [];
    this.cachedUniforms = {};

    fragmentHeader.push('uniform sampler2D image;\n');

    if (this.applicationVert.length > 1) {
        vertexHeader.push('uniform sampler2D image;\n');
    }

    for(i = 0; i < this.uniformNames.length; i++) {
        name = this.uniformNames[i], value = this.uniformValues[i];
        vertexHeader.push('uniform ' + TYPES[value.length] + name + ';\n');
        fragmentHeader.push('uniform ' + TYPES[value.length] + name + ';\n');
    }

    for(i = 0; i < this.attributeNames.length; i++) {
        name = this.attributeNames[i], value = this.attributeValues[i];
        vertexHeader.push('attribute ' + TYPES[value.length] + name + ';\n');
    }

    for(i = 0; i < this.varyingNames.length; i++) {
        name = this.varyingNames[i], value = this.varyingValues[i];
        vertexHeader.push('varying ' + TYPES[value.length]  + name + ';\n');
        fragmentHeader.push('varying ' + TYPES[value.length] + name + ';\n');
    }

    vertexSource = vertexHeader.join('') + vertexWrapper
        .replace('#vert_definitions', this.definitionVert.join('\n'))
        .replace('#vert_applications', this.applicationVert.join('\n'));

    fragmentSource = fragmentHeader.join('') + fragmentWrapper
        .replace('#vec_definitions', this.definitionVec.join('\n'))
        .replace('#vec_applications', this.applicationVec.join('\n'))
        .replace('#float_definitions', this.definitionFloat.join('\n'))
        .replace('#float_applications', this.applicationFloat.join('\n'));

    program = this.gl.createProgram();

    this.gl.attachShader(
        program,
        this.compileShader(this.gl.createShader(VERTEX_SHADER), vertexSource)
    );

    this.gl.attachShader(
        program,
        this.compileShader(this.gl.createShader(FRAGMENT_SHADER), fragmentSource)
    );

    this.gl.linkProgram(program);

    if (! this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
        console.error('link error: ' + this.gl.getProgramInfoLog(program));
        this.program = null;
    }
    else {
        this.program = program;
        this.gl.useProgram(this.program);
    }

    this.setUniforms(this.uniformNames, this.uniformValues);

    return this;
};

/**
 * Compares the value of the input uniform value against
 * the cached value stored on the Program class.  Updates and
 * creates new entries in the cache when necessary.
 *
 * @method uniformIsCached
 *
 * @param {String} targetName Key of uniform spec being evaluated.
 * @param {Number|Array} value Value of uniform spec being evaluated.
 * @return {Boolean} Value indicating whether the uniform being set
 * is cached.
 */
Program.prototype.uniformIsCached = function(targetName, value) {
    if(this.cachedUniforms[targetName] == null) {
        if (value.length) {
            this.cachedUniforms[targetName] = new Float32Array(value);
        }
        else {
            this.cachedUniforms[targetName] = value;
        }
        return false;
    }
    else if (value.length) {
        var i = value.length;
        while (i--) {
            if(value[i] !== this.cachedUniforms[targetName][i]) {
                i = value.length;
                while(i--) this.cachedUniforms[targetName][i] = value[i];
                return false;
            }
        }
    }

    else if (this.cachedUniforms[targetName] !== value) {
        this.cachedUniforms[targetName] = value;
        return false;
    }

    return true;
};

/**
 * Handles all passing of uniforms to WebGL drawing context.  This
 * function will find the uniform location and then, based on
 * a type inferred from the javascript value of the uniform, it will call
 * the appropriate function to pass the uniform to WebGL.  Finally,
 * setUniforms will iterate through the passed in shaderChunks (if any)
 * and set the appropriate uniforms to specify which chunks to use.
 *
 * @method setUniforms
 *
 * @param {Array} uniformNames Array containing the keys of all uniforms to be set.
 * @param {Array} uniformValue Array containing the values of all uniforms to be set.
 *
 * @return {Program} Current program.
 */
Program.prototype.setUniforms = function (uniformNames, uniformValue) {
    var gl = this.gl;
    var location;
    var value;
    var name;
    var flag;
    var len;
    var i;

    if (!this.program) return;

    len = uniformNames.length;
    for (i = 0; i < len; i++) {
        name = uniformNames[i];
        value = uniformValue[i];

        // Retreive the cached location of the uniform,
        // requesting a new location from the WebGL context
        // if it does not yet exist.

        location = this.uniformLocations[name] || gl.getUniformLocation(this.program, name);
        if (!location) continue;

        this.uniformLocations[name] = location;

        // Check if the value is already set for the
        // given uniform.

        if (this.uniformIsCached(name, value)) continue;

        // Determine the correct function and pass the uniform
        // value to WebGL.

        if (Array.isArray(value) || value instanceof Float32Array) {
            switch (value.length) {
                case 4:  gl.uniform4fv(location, value); break;
                case 3:  gl.uniform3fv(location, value); break;
                case 2:  gl.uniform2fv(location, value); break;
                case 16: gl.uniformMatrix4fv(location, false, value); break;
                case 1:  gl.uniform1fv(location, value); break;
                case 9:  gl.uniformMatrix3fv(location, false, value); break;
                default: throw 'cant load uniform "' + name + '" with value:' + JSON.stringify(value);
            }
        }
        else if (! isNaN(parseFloat(value)) && isFinite(value)) {
            gl.uniform1f(location, value);
        }
        else {
            throw 'set uniform "' + name + '" to invalid type :' + value;
        }
    }
    return this;
};

/**
 * Adds shader source to shader and compiles the input shader.  Checks
 * compile status and logs error if necessary.
 *
 * @method compileShader
 *
 * @param {Object} shader Program to be compiled.
 * @param {String} source Source to be used in the shader.
 *
 * @return {Object} Compiled shader.
 */
Program.prototype.compileShader = function compileShader(shader, source) {
    var i = 1;

    if (this.options.debug) {
        this.gl.compileShader = Debug.call(this);
    }

    this.gl.shaderSource(shader, source);
    this.gl.compileShader(shader);
    if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
        console.error('compile error: ' + this.gl.getShaderInfoLog(shader));
        console.error('1: ' + source.replace(/\n/g, function () { return '\n' + (i+=1) + ': '; }));
    }

    return shader;
};

module.exports = Program;

},{"./Debug":278,"famous-utilities":231,"famous-webgl-shaders":274}],280:[function(require,module,exports){
'use strict';

/**
 * Texture is a private class that stores image data
 * to be accessed from a shader or used as a render target.
 *
 * @class Texture
 * @constructor
 */
function Texture(gl, options) {
    options = options || {};
    this.id = gl.createTexture();
    this.width = options.width || 0;
    this.height = options.height || 0;
    this.format = options.format || gl.RGBA;
    this.type = options.type || gl.UNSIGNED_BYTE;
    this.gl = gl;

    this.bind();

    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
    
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl[options.magFilter] || gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl[options.minFilter] || gl.NEAREST);

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl[options.wrapS] || gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl[options.wrapS] || gl.CLAMP_TO_EDGE);

    gl.texImage2D(gl.TEXTURE_2D, 0, this.format, this.width, this.height, 0, this.format, this.type, null);

    if (options.mipmap !== false && isPowerOfTwo(this.width, this.height)) {
        gl.generateMipmap(gl.TEXTURE_2D);
    }

    this.unbind();
}

/**
 * Binds this texture as the selected target.
 *
 * @method bind
 * @chainable
 *
 * @param {Number} unit The texture slot in which to upload the data.
 *
 * @return {Object} Current texture instance.
 */
Texture.prototype.bind = function bind(unit) {
    this.gl.activeTexture(this.gl.TEXTURE0 + (unit || 0));
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.id);
    return this;
};

/**
 * Erases the texture data in the given texture slot.
 *
 * @method unbind
 * @chainable
 *
 * @param {Number} unit The texture slot in which to clean the data.
 * 
 * @return {Object} Current texture instance.
 */
Texture.prototype.unbind = function unbind(unit) {
    this.gl.activeTexture(this.gl.TEXTURE0 + (unit || 0));
    this.gl.bindTexture(this.gl.TEXTURE_2D, null);
    return this;
};

/**
 * Replaces the image data in the texture with the given image.
 *
 * @method setImage
 * @chainable
 *
 * @param {Image} img The image object to upload pixel data from.
 *
 * @return {Object} Current texture instance.
 */
Texture.prototype.setImage = function setImage(img) {
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.id);
    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.format, this.format, this.type, img);
    this.gl.bindTexture(this.gl.TEXTURE_2D, null);
    return this;
};

/**
 * Replaces the image data in the texture with an array of arbitrary data.
 *
 * @method setArray
 * @chainable
 *
 * @param {Array} input Array to be set as data to texture. 
 *
 * @return {Object} Current texture instance.
 */
Texture.prototype.setArray = function setArray(input) {
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.id);
    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.format, 1, 1, 0, this.format, this.type, new Uint8Array(input));
    this.gl.bindTexture(this.gl.TEXTURE_2D, null);
    return this;
};

/**
 * Dumps the rgb-pixel contents of a texture into an array for debugging purposes
 *
 * @method readBack
 * @chainable
 *
 * @param {Number} x-offset between texture coordinates and snapshot
 * @param {Number} y-offset between texture coordinates and snapshot
 * @param {Number} x-depth of the snapshot
 * @param {Number} y-depth of the snapshot
 * 
 * @return {Array} An array of the pixels contained in the snapshot.
 */
Texture.prototype.readBack = function readBack(x, y, width, height) {
    var gl = this.gl;
    var pixels;
    x = x || 0;
    y = y || 0;
    width = width || this.width;
    height = height || this.height;
    var fb = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.id, 0);
    if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) == gl.FRAMEBUFFER_COMPLETE) {
        pixels = new Uint8Array(width * height * 4);
        gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    }
    return pixels;
};

/*
 * Determines whether both input values are power-of-two numbers.
 *
 * @method isPowerOfTwo
 * @private
 *
 * @param {Number} width Number representing texture width.
 * @param {Number} height Number representing texture height.
 *
 * @return {Boolean} Boolean denoting whether the input dimensions
 * are both power-of-two values.
 */
function isPowerOfTwo(width, height) {
    return (width & width - 1) === 0 
        && (height & height - 1) === 0;
};

module.exports = Texture;

},{}],281:[function(require,module,exports){
'use strict';

var Texture = require('./Texture');
var Program = require('./Program');
var Buffer = require('./Buffer');
var BufferRegistry = require('./BufferRegistry');
var checkers = require('./Checkerboard');
var Plane = require('famous-webgl-geometries').Plane;
var sorter = require('./radixSort');
var Utility = require('famous-utilities');

var identity = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

/**
 * WebGLRenderer is a private class that manages all interactions with the WebGL
 * API.  Each frame it receives commands from the compositor and updates its registries
 * accordingly.  Subsequently, the draw function is called and the WebGLRenderer
 * issues draw calls for all meshes in its registry.
 *
 * @class WebGLRenderer
 * @constructor
 *
 * @param {DOMElement} canvas The dom element that GL will paint itself onto.
 *
 */
function WebGLRenderer(canvas) {
    this.canvas = canvas;

    var gl = this.gl = this.getWebGLContext(this.canvas);

    gl.polygonOffset(0.1, 0.1);
    gl.enable(gl.POLYGON_OFFSET_FILL);
    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.BLEND);
    gl.depthFunc(gl.LEQUAL);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.enable(gl.CULL_FACE);

    this.meshRegistry = {};
    this.meshRegistryKeys = [];

    this.cutoutRegistry = {};
    this.cutoutRegistryKeys = [];
    this.cutoutGeometry;

    /**
     * Lights
     */

    this.numLights = 0;
    this.ambientLightColor = [0, 0, 0];
    this.lightRegistry = {};
    this.lightRegistryKeys = [];
    this.lightPositions = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    this.lightColors = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

    this.textureRegistry = [];
    this.texCache = {};
    this.bufferRegistry = new BufferRegistry(gl);
    this.program = new Program(gl, { debug: false });

    this.state = {
        boundArrayBuffer: null,
        boundElementBuffer: null,
        lastDrawn: null,
        enabledAttributes: {},
        enabledAttributesKeys: []
    };

    this.resolutionName = ['resolution'];
    this.resolutionValues = [];

    this.cachedSize = [];

    this.projectionTransform = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}

/**
 * Attempts to retreive the WebGLRenderer context using several
 * accessors.  For browser compatability.  Throws on error.
 *
 * @method getWebGLContext
 *
 * @param {Object} canvas Canvas element from which the context is retreived.
 *
 * @return {Object} WebGLContext of canvas element.
 */
WebGLRenderer.prototype.getWebGLContext = function getWebGLContext(canvas) {
    var names = ['webgl', 'experimental-webgl', 'webkit-3d', 'moz-webgl'];
    var context = null;
    for (var i = 0; i < names.length; i++) {
        try {
            context = canvas.getContext(names[i]);
        }
        catch (error) {
            var msg = 'Error creating WebGL context: ' + error.toString();
            console.error(msg);
        }
        if (context) {
            break;
        }
    }
    return context ? context : false;
};

/**
 * Adds a new base spec to the light registry at a given path.
 *
 * @method createLight
 *
 * @param {String} Path used as id of new light in lightRegistry.
 *
 * @return {Object} Newly created light spec.
 */
WebGLRenderer.prototype.createLight = function createLight(path) {
    this.numLights++;
    this.lightRegistryKeys.push(path);
    return this.lightRegistry[path] = {
        color: [0, 0, 0],
        position: [0, 0, 0]
    };
};

/**
 * Adds a new base spec to the mesh registry at a given path.
 *
 * @method createMesh
 *
 * @param {String} Path used as id of new mesh in meshRegistry.
 *
 * @return {Object} Newly created mesh spec.
 */
WebGLRenderer.prototype.createMesh = function createMesh(path) {
    this.meshRegistryKeys.push(path);
    var uniforms = Utility.keyValueToArrays({
        opacity: 1,
        transform: identity,
        size: [0, 0, 0],
        baseColor: [0.5, 0.5, 0.5],
        positionOffset: [0, 0, 0],
        u_FlatShading: 0,
        glossiness: 0
    });
    return this.meshRegistry[path] = {
        depth: null,
        uniformKeys: uniforms.keys,
        uniformValues: uniforms.values,
        buffers: {},
        geometry: null,
        drawType: null,
        texture: null,
        visible: true
    };
};


/**
 * Creates or retreives cutout
 *
 * @method getOrSetCutout
 *
 * @param {String} Path used as id of new mesh in meshRegistry.
 *
 * @return {Object} Newly created cutout spec.
 */

WebGLRenderer.prototype.getOrSetCutout = function getOrSetCutout(path) {
    var geometry;

    if (this.cutoutRegistry[path]) {
        return this.cutoutRegistry[path];
    }
    else {
        if (!this.cutoutGeometry) {
            geometry = this.cutoutGeometry = Plane();

            this.bufferRegistry.allocate(geometry.id, 'pos', geometry.spec.bufferValues[0], 3);
            this.bufferRegistry.allocate(geometry.id, 'texCoord', geometry.spec.bufferValues[1], 2);
            this.bufferRegistry.allocate(geometry.id, 'normals', geometry.spec.bufferValues[2], 3);
            this.bufferRegistry.allocate(geometry.id, 'indices', geometry.spec.bufferValues[3], 1);
        }

        this.cutoutRegistryKeys.push(path);

        var uniforms = Utility.keyValueToArrays({
            transform: identity,
            size: [0, 0, 0],
            origin: [0, 0, 0],
            baseColor: [0, 0, 0],
            opacity: 0
        });
        return this.cutoutRegistry[path] = {
            uniformKeys: uniforms.keys,
            uniformValues: uniforms.values,
            geometry: this.cutoutGeometry.id,
            drawType: 4
        };
    }

};

/**
 * Prevents a mesh from being drawn to the canvas.
 *
 * @method hideMesh
 *
 * @param {String} path Path used as id of mesh in mesh registry.
 *
 */
WebGLRenderer.prototype.hideMesh = function hideMesh(path) {
    var mesh = this.meshRegistry[path] || this.createMesh(path);
    mesh.visible = false;
};

/**
 * Allows a mesh to be drawn to the canvas.
 *
 * @method showMesh
 *
 * @param {String} path Path used as id of mesh in mesh registry.
 *
 */
WebGLRenderer.prototype.showMesh = function showMesh(path) {
    var mesh = this.meshRegistry[path] || this.createMesh(path);
    mesh.visible = true;
};


/**
 * Creates or retreives cutout
 *
 * @method setCutoutUniform
 *
 * @param {String} Path used as id of cutout in cutout registry.
 * @param {String} uniformLocation identifier used to upload value
 * @param {Array} value of uniform data 
 *
 */

WebGLRenderer.prototype.setCutoutUniform = function setCutoutUniform(path, uniformName, uniformValue) {
    var cutout = this.getOrSetCutout(path);

    var index = cutout.uniformKeys.indexOf(uniformName);

    cutout.uniformValues[index] = uniformValue;
};


/**
 * Edits the options field on a mesh
 *
 * @method setMeshOptions
 *
 * @param {String} Path used as id of cutout in cutout registry.
 * @param {Object} map of draw options for mesh
 *
**/
WebGLRenderer.prototype.setMeshOptions = function(path, options) {
    var mesh = this.meshRegistry[path] || this.createMesh(path);

    mesh.options = options;
    return this;
};


/**
 * Changes the color of the fixed intensity lighting in the scene
 *
 * @method setAmbientLightColor
 *
 * @param {String} path used as id of light
 * @param {Number} red channel
 * @param {Number} green channel
 * @param {Number} blue channel
 *
**/
WebGLRenderer.prototype.setAmbientLightColor = function setAmbientLightColor(path, r, g, b) {
    this.ambientLightColor[0] = r;
    this.ambientLightColor[1] = g;
    this.ambientLightColor[2] = b;
    return this;
};


/**
 * Changes the location of the light in the scene
 *
 * @method setLightPosition
 *
 * @param {String} path used as id of light
 * @param {Number} x position
 * @param {Number} y position
 * @param {Number} z position
 *
**/
WebGLRenderer.prototype.setLightPosition = function setLightPosition(path, x, y, z) {
    var light = this.lightRegistry[path] || this.createLight(path);

    light.position[0] = x;
    light.position[1] = y;
    light.position[2] = z;
    return this;
};


/**
 * Changes the color of a dynamic intensity lighting in the scene
 *
 * @method setLightColor
 *
 * @param {String} path used as id of light in light Registry.
 * @param {Number} red channel
 * @param {Number} green channel
 * @param {Number} blue channel
 *
**/
WebGLRenderer.prototype.setLightColor = function setLightColor(path, r, g, b) {
    var light = this.lightRegistry[path] || this.createLight(path);

    light.color[0] = r;
    light.color[1] = g;
    light.color[2] = b;
    return this;
};
/**
 * Compiles material spec into program shader
 *
 * @method handleMateriaInput
 *
 * @param {String} Path used as id of cutout in cutout registry.
 * @param {String} which rendering input the material is bound to
 * @param {Object} material spec
 *
**/
WebGLRenderer.prototype.handleMaterialInput = function handleMaterialInput(path, name, material) {
    var mesh = this.meshRegistry[path] || this.createMesh(path);

    mesh.uniformValues[name === 'baseColor' ? 3 : 4][0] = - material._id;
    if (material.texture) mesh.texture = handleTexture.call(this, material.texture);
    this.program.registerMaterial(name, material);
    return this.updateSize();
};

/**
 * Changes the geometry data of a mesh
 *
 * @method setGeometry
 *
 * @param {String} Path used as id of cutout in cutout registry.
 * @param {Object} Geometry object containing vertex data to be drawn
 * @param {Number} primitive identifier
 * @param {Boolean} will the geometry data change?
 *
**/

WebGLRenderer.prototype.setGeometry = function setGeometry(path, geometry, drawType, dynamic) {
    var mesh = this.meshRegistry[path] || this.createMesh(path);

    mesh.geometry = geometry;
    mesh.drawType = drawType;
    mesh.dynamic = dynamic;

    return this;
};

/**
 * Uploads a new value for the uniform data when the mesh is being drawn
 *
 * @method setMeshUniform
 *
 * @param {String} Path used as id of mesh in mesh registry
 * @param {String} uniformLocation identifier used to upload value
 * @param {Array} value of uniform data 
 *
**/
WebGLRenderer.prototype.setMeshUniform = function setMeshUniform(path, uniformName, uniformValue) {
    var mesh = this.meshRegistry[path] || this.createMesh(path);

    var index = mesh.uniformKeys.indexOf(uniformName);

    if (index === -1) {
        mesh.uniformKeys.push(uniformName);
        mesh.uniformValues.push(uniformValue);
    }
    else {
        mesh.uniformValues[index] = uniformValue;
    }
}

/**
 * Triggers the 'draw' phase of the WebGLRenderer.  Iterates through registries
 * to set uniforms, set attributes and issue draw commands for renderables.
 *
 * @method bufferData
 *
 * @param {String} Path used as id of mesh in mesh registry
 * @param {Number} Id of geometry in geometry registry
 * @param {String} Attribute location name
 * @param {Array} Vertex data 
 * @param {Number} The dimensions of the vertex
 */


WebGLRenderer.prototype.bufferData = function bufferData(path, geometryId, bufferName, bufferValue, bufferSpacing) {
    this.bufferRegistry.allocate(geometryId, bufferName, bufferValue, bufferSpacing);

    return this;
};

/**
 * Triggers the 'draw' phase of the WebGLRenderer.  Iterates through registries
 * to set uniforms, set attributes and issue draw commands for renderables.
 *
 * @method draw
 *
 * @param {Object} renderState Parameters provided by the compositor, that
 * affect the rendering of all renderables.
 */
WebGLRenderer.prototype.draw = function draw(renderState) {
    this.setGlobalUniforms(renderState);
    this.meshRegistryKeys = sorter(this.meshRegistryKeys, this.meshRegistry);
    this.drawCutouts();
    this.drawMeshes();
};

WebGLRenderer.prototype.drawMeshes = function drawMeshes() {
    var mesh;
    var buffers;

    for(var i = 0; i < this.meshRegistryKeys.length; i++) {
        mesh = this.meshRegistry[this.meshRegistryKeys[i]];
        buffers = this.bufferRegistry.registry[mesh.geometry];
        
        if (!mesh.visible) continue;

        var gl = this.gl;
        if (mesh.uniformValues[0] < 1) {
            gl.depthMask(false);
            gl.enable(gl.BLEND);
        } else {
            gl.depthMask(true);
            gl.disable(gl.BLEND);
        }

        if (!buffers) continue;

        if (mesh.options) this.handleOptions(mesh.options);
        if (mesh.texture) mesh.texture.bind();
        this.program.setUniforms(mesh.uniformKeys, mesh.uniformValues);
        this.drawBuffers(buffers, mesh.drawType, mesh.geometry);

        if (mesh.texture) mesh.texture.unbind();
        if (mesh.options) this.resetOptions(mesh.options);
    }
}

WebGLRenderer.prototype.drawCutouts = function drawCutouts() {
    var cutout;
    var buffers;

    for (var i = 0, len = this.cutoutRegistryKeys.length; i < len; i++) {
        cutout = this.cutoutRegistry[this.cutoutRegistryKeys[i]];
        buffers = this.bufferRegistry.registry[cutout.geometry];

        this.gl.enable(this.gl.BLEND);
        this.program.setUniforms(cutout.uniformKeys, cutout.uniformValues);
        this.drawBuffers(buffers, cutout.drawType, cutout.geometry);
        this.gl.disable(this.gl.BLEND);
    }
};

WebGLRenderer.prototype.setGlobalUniforms = (function() {
    var uniformNames = [
        'u_NumLights',
        'u_AmbientLight',
        'u_LightPosition',
        'u_LightColor',
        'perspective',
        'time',
        'view'
    ];
    var uniformValues = [];

    return function setGlobalUniforms(renderState) {
        var light;
        var stride;

        /*
         * Set light uniforms
         */

        for(var i = 0; i < this.lightRegistryKeys.length; i++) {
            light = this.lightRegistry[this.lightRegistryKeys[i]];
            stride = i * 4;

            // Build the light positions' 4x4 matrix
            this.lightPositions[0 + stride] = light.position[0];
            this.lightPositions[1 + stride] = light.position[1];
            this.lightPositions[2 + stride] = light.position[2];

            // Build the light colors' 4x4 matrix
            this.lightColors[0 + stride] = light.color[0];
            this.lightColors[1 + stride] = light.color[1];
            this.lightColors[2 + stride] = light.color[2];
        }
        
        uniformValues[0] = this.numLights;
        uniformValues[1] = this.ambientLightColor;
        uniformValues[2] = this.lightPositions;
        uniformValues[3] = this.lightColors;

        /*
         * Set time and projection uniforms
         */

        this.projectionTransform[11] = renderState.perspectiveTransform[11];

        uniformValues[4] = this.projectionTransform;
        uniformValues[5] = Date.now()  % 100000 / 1000;
        uniformValues[6] = renderState.viewTransform;

        this.program.setUniforms(uniformNames, uniformValues);
    }
}());

/**
 * Loads the buffers and issues the draw command for a geometry.
 *
 * @method drawBuffers
 *
 * @param {Object} vertexBuffers All buffers used to draw the geometry.
 * @param {Number} mode Enumerator defining what primitive to draw
 * @param {Number} id ID of geometry being drawn.
 */
WebGLRenderer.prototype.drawBuffers = function drawBuffers(vertexBuffers, mode, id) {
    var gl = this.gl;
    var length = 0;
    var attribute;
    var location;
    var spacing;
    var offset;
    var buffer;
    var iter;
    var j;

    iter = vertexBuffers.keys.length;
    for (var i = 0; i < iter; i++) {
        attribute = vertexBuffers.keys[i];

        // Do not set vertexAttribPointer if index buffer.

        if (attribute === 'indices') {
            j = i; continue;
        }

        // Retreive the attribute location and make sure it is enabled.

        location = this.program.attributeLocations[attribute];

        if (location === -1) continue;
        if (location === undefined) {
            location = gl.getAttribLocation(this.program.program, attribute);
            this.program.attributeLocations[attribute] = location;
            if (location === -1) continue;
        }

        if (!this.state.enabledAttributes[attribute]) {
            gl.enableVertexAttribArray(location);
            this.state.enabledAttributes[attribute] = true;
            this.state.enabledAttributesKeys.push(attribute);
        }

        // Retreive buffer information used to set attribute pointer.

        buffer = vertexBuffers.values[i];
        spacing = vertexBuffers.spacing[i];
        offset = vertexBuffers.offset[i];
        length = vertexBuffers.length[i];

        // Skip bindBuffer if buffer is currently bound.

        if (this.state.boundArrayBuffer !== buffer) {
            gl.bindBuffer(buffer.target, buffer.buffer);
            this.state.boundArrayBuffer = buffer;
        }

        if (this.state.lastDrawn !== id) {
            gl.vertexAttribPointer(location, spacing, gl.FLOAT, gl.FALSE, 0, 4 * offset);
        }
    }

    // Disable any attributes that not currently being used.

    for(var i = 0, len = this.state.enabledAttributesKeys.length; i < len; i++) {
        var key = this.state.enabledAttributes[this.state.enabledAttributesKeys[i]];
        if (this.state.enabledAttributes[key] && vertexBuffers.keys.indexOf(key) === -1) {
            gl.disableVertexAttribArray(this.program.attributeLocations[key]);
            this.state.enabledAttributes[key] = false;
        }
    }

    if (length) {

        // If index buffer, use drawElements.

        if (j !== undefined) {
            buffer = vertexBuffers.values[j];
            offset = vertexBuffers.offset[j];
            spacing = vertexBuffers.spacing[j];
            length = vertexBuffers.length[j];

            // Skip bindBuffer if buffer is currently bound.

            if (this.state.boundElementBuffer !== buffer) {
                gl.bindBuffer(buffer.target, buffer.buffer);
                this.state.boundElementBuffer = buffer;
            }

            gl.drawElements(mode, length, gl.UNSIGNED_SHORT, 2 * offset);
        }
        else {
            gl.drawArrays(mode, 0, length);
        }
    }

    this.state.lastDrawn = id;
};

/**
 * Wraps draw methods in bound frame buffer
 *
 * @method renderOffscreen
 *
 * @param {Function} callback The render function to be called after setup and before cleanup.
 * @param {Array} size Size of framebuffer being drawn to.
 * @param {Object} texture Location where the render data is stored.
 */
function renderOffscreen(callback, size, texture) {
    var gl = this.gl;

    var framebuffer  = this.framebuffer ? this.framebuffer : this.framebuffer = gl.createFramebuffer();
    var renderbuffer = this.renderbuffer ? this.renderbuffer : this.renderbuffer = gl.createRenderbuffer();

    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);

    if (size[0] != renderbuffer.width || size[1] != renderbuffer.height) {
        renderbuffer.width = size[0];
        renderbuffer.height = size[1];
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, size[0], size[1]);
    }

    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture.id, 0);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);

    if (this.debug) checkFrameBufferStatus(gl);

    callback.call(this);

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
};

/**
 * Diagnoses the failed intialization of an FBO.
 *
 * @method checkFrameBufferStatus
 *
 * @param {Object} the WebGLContext that owns this FBO.
 */
function checkFrameBufferStatus(gl) {
    var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

    switch (status) {
        case gl.FRAMEBUFFER_COMPLETE:
            break;
        case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
            throw("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT"); break;
        case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
            throw("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT"); break;
        case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
            throw("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS"); break;
        case gl.FRAMEBUFFER_UNSUPPORTED:
            throw("Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED"); break;
        default:
            throw("Incomplete framebuffer: " + status);
    }
};

/**
 * Updates the width and height of parent canvas, sets the viewport size on
 * the WebGL context and updates the resolution uniform for the shader program.
 * Size is retreived from the container object of the renderer.
 *
 * @method updateSize
 * 
 * @param {Array} width, height and depth of canvas
 * 
 */
WebGLRenderer.prototype.updateSize = function updateSize(size) {
    if (size) {
        this.cachedSize[0] = size[0];
        this.cachedSize[1] = size[1];
        this.cachedSize[2] = (size[0] > size[1]) ? size[0] : size[1];
    }

    this.gl.viewport(0, 0, this.cachedSize[0], this.cachedSize[1]);

    this.resolutionValues[0] = this.cachedSize;
    this.program.setUniforms(this.resolutionName, this.resolutionValues);

    return this;
};

/**
 * Updates the state of the WebGL drawing context based on custom parameters
 * defined on a mesh.
 *
 * @method handleOptions
 *
 * @param {Object} options Draw state options to be set to the context.
 */
WebGLRenderer.prototype.handleOptions = function handleOptions(options) {
    var gl = this.gl;
    if (!options) return;
    if (options.blending) gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
};

/**
 * Resets the state of the WebGL drawing context to default values.
 *
 * @method resetOptions
 *
 * @param {Object} options Draw state options to be set to the context.
 */
WebGLRenderer.prototype.resetOptions = function resetOptions(options) {
    var gl = this.gl;
    if (!options) return;
    if (options.blending) gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
};

/**
 * Loads an image from a string or Image object and executes a callback function.
 *
 * @method loadImage
 * @private
 *
 * @param {Object | String} img The input image data to load as an asset.
 * @param {Function} callback The callback function to be fired when
 * the image has finished loading.
 *
 * @return {Object} Image object being loaded.
 */
function loadImage (img, callback) {
    var obj = (typeof img === 'string' ? new Image() : img) || {};
    obj.crossOrigin = 'anonymous';
    if (! obj.src) obj.src = img;
    if (! obj.complete) obj.onload = function () { callback(obj); };
    else callback(obj);
    return obj;
}

/**
 * Handles loading of texture objects.
 *
 * @method handleTexture
 * @private
 *
 * @param {Object} input The input texture object collected from mesh.
 *
 * @return {Object} Texture instance linked to input data.
 */
function handleTexture(input) {
    var source = input.data;
    var textureId = input.id;
    var options = input.options;
    var texture = this.textureRegistry[textureId];

    if (!texture) {
        if (Array.isArray(source)) {
            texture = new Texture(this.gl, options);
            texture.setArray(source);
        }

        else if (window && source instanceof window.HTMLVideoElement) {
            texture = new Texture(this.gl, options);
            texture.src = texture;
            texture.setImage(checkers);
            source.addEventListener('loadeddata', function() {
                texture.setImage(source);
                setInterval(function () { texture.setImage(source); }, 16);
            });
        }

        else if ('string' === typeof source) {
            texture = new Texture(this.gl, options);
            texture.setImage(checkers);
            loadImage(source, function (img) {
                texture.setImage(img);
            });
        }

        this.textureRegistry[textureId] = texture;
    }

    return texture;
}

module.exports = WebGLRenderer;

},{"./Buffer":275,"./BufferRegistry":276,"./Checkerboard":277,"./Program":279,"./Texture":280,"./radixSort":283,"famous-utilities":231,"famous-webgl-geometries":260}],282:[function(require,module,exports){
'use strict';

module.exports = {
    Buffer: require('./Buffer'),
    BufferRegistry: require('./BufferRegistry'),
    Checkerboard: require('./Checkerboard'),
    Program: require('./Program'),
    WebGLRenderer: require('./WebGLRenderer'),
    Texture: require('./Texture')
};

},{"./Buffer":275,"./BufferRegistry":276,"./Checkerboard":277,"./Program":279,"./Texture":280,"./WebGLRenderer":281}],283:[function(require,module,exports){
var radixBits = 11,
    maxRadix = 1 << (radixBits),
    radixMask = maxRadix - 1,
    buckets = new Array(maxRadix * Math.ceil(64 / radixBits)),
    msbMask = 1 << ((32 - 1) % radixBits),
    lastMask = (msbMask << 1) - 1,
    passCount = ((32 / radixBits) + 0.999999999999999) | 0,
    maxOffset = maxRadix * (passCount - 1),
    normalizer = Math.pow(20, 6);

var buffer = new ArrayBuffer(4);
var floatView = new Float32Array(buffer, 0, 1);
var intView = new Int32Array(buffer, 0, 1);

function comp(list, registry, i) {
    var key = list[i];
    var item = registry[key];
    return (item.depth ? item.depth : registry[key].uniformValues[1][14]) + normalizer;
}

function mutator(list, registry, i, value) {
    var key = list[i];
    registry[key].depth = intToFloat(value) - normalizer;
    return key;
}
function clean(list, registry, i) {
    registry[list[i]].depth = null;
}

function floatToInt(k) {
    floatView[0] = k;
    return intView[0];
}

function intToFloat(k) {
    intView[0] = k;
    return floatView[0];
}

function sort(list, registry) {
    var pass = 0;
    var out = [];

    var i, j, k, n, div, offset, swap, id, sum, tsum, size;

    passCount = ((32 / radixBits) + 0.999999999999999) | 0;

    for (i = 0, n = maxRadix * passCount; i < n; i++) buckets[i] = 0;

    for (i = 0, n = list.length; i < n; i++) {
        div = floatToInt(comp(list, registry, i));
        div ^= div >> 31 | 0x80000000;
        for (j = 0, k = 0; j < maxOffset; j += maxRadix, k += radixBits) {
            buckets[j + (div >>> k & radixMask)]++;
        }
        buckets[j + (div >>> k & lastMask)]++;
    }

    for (j = 0; j <= maxOffset; j += maxRadix) {
        for (id = j, sum = 0; id < j + maxRadix; id++) {
            tsum = buckets[id] + sum;
            buckets[id] = sum - 1;
            sum = tsum;
        }
    }
    if (--passCount) {
        for (i = 0, n = list.length; i < n; i++) {
            div = floatToInt(comp(list, registry, i));
            out[++buckets[div & radixMask]] = mutator(list, registry, i, div ^= div >> 31 | 0x80000000);
        }
        swap = out, out = list, list = swap;
        while (++pass < passCount) {
            for (i = 0, n = list.length, offset = pass * maxRadix, size = pass * radixBits; i < n; i++) {
                div = floatToInt(comp(list, registry, i));
                out[++buckets[offset + (div >>> size & radixMask)]] = list[i];
            }
            swap = out, out = list, list = swap;
        }
    }

    for (i = 0, n = list.length, offset = pass * maxRadix, size = pass * radixBits; i < n; i++) {
        div = floatToInt(comp(list, registry, i));
        out[++buckets[offset + (div >>> size & lastMask)]] = mutator(list, registry, i, div ^ (~div >> 31 | 0x80000000));
        clean(list, registry, i);
    }

    return out;

}

module.exports = sort;

},{}],284:[function(require,module,exports){
'use strict';

var VirtualElement = require('famous-dom-renderers').VirtualElement;
var strip = require('famous-utilities').strip;
var flatClone = require('famous-utilities').flatClone;

var Context = require('./Context');

/**
 * Instantiates a new Compositor, used for routing commands received from the
 * WebWorker to the WebGL and DOM renderer.
 *
 * @class Compositor
 * @constructor
 */
function Compositor() {
    this._contexts = {};
    this._outCommands = [];
    this._inCommands = [];

    this.clearCommands();
}

/**
 * Schedules an event to be sent to the WebWorker the next time the out command
 * queue is being flushed.
 *
 * @method sendEvent
 * @private
 *
 * @param  {String} path    render path to the node the event should be
 *                          triggered on (*targeted event*)
 * @param  {String} ev      event type
 * @param  {Object} payload event object (serializable using structured
 *                          cloning algorithm)
 */
Compositor.prototype.sendEvent = function sendEvent(path, ev, payload) {
    this._outCommands.push('WITH', path, 'TRIGGER', ev, payload);
};

/**
 * Internal helper method used by `drawCommands`.
 *
 * @method handleWith
 * @private
 *
 * @param  {Array} commands     remaining message queue received from the
 *                              WebWorker, used to shift single messages from
 */
Compositor.prototype.handleWith = function handleWith (iterator, commands) {
    var path = commands[iterator];
    var pathArr = path.split('/');
    var context = this.getOrSetContext(pathArr.shift());
    return context.receive(pathArr, path, commands, iterator);
};

/**
 * Retrieves the top-level VirtualElement attached to the passed in document
 * selector.
 * If no such element exists, one will be instantiated, therefore representing
 * the equivalent of a Context in the Main Thread.
 *
 * @method getOrSetContext
 * @private
 *
 * @param  {String} selector            document query selector used for
 *                                      retrieving the DOM node the
 *                                      VirtualElement should be attached to
 * @return {Object} result
 * @return {VirtualElement} result.DOM  final VirtualElement
 */
Compositor.prototype.getOrSetContext = function getOrSetContext(selector) {
    if (this._contexts[selector]) return this._contexts[selector];
    else return (this._contexts[selector] = new Context(selector, this));
};

/**
 * Internal helper method used by `drawCommands`.
 *
 * @method giveSizeFor
 * @private
 *
 * @param  {Array} commands     remaining message queue received from the
 *                              WebWorker, used to shift single messages from
 */
Compositor.prototype.giveSizeFor = function giveSizeFor(iterator, commands) {
    var selector = commands[iterator];
    var size = this.getOrSetContext(selector).getRootSize();
    this.sendResize(selector, size);
    var _this = this;
    if (selector === 'body')
        window.addEventListener('resize', function() {
            if (!_this._sentResize) {
                _this.sendResize(selector, _this.getOrSetContext(selector).getRootSize());
            }
        });
};

/**
 * Internal helper method used for notifying the WebWorker about externally
 * resized contexts (e.g. by resizing the browser window).
 *
 * @method sendResize
 * @private
 *
 * @param  {String} selector    render path to the node (context) that should
 *                              be resized
 * @param  {Array} size         new context size
 */
Compositor.prototype.sendResize = function sendResize (selector, size) {
    this._outCommands.push('WITH', selector, 'TRIGGER', 'CONTEXT_RESIZE', size);
    this._sentResize = true;
};

Compositor.prototype._wrapProxyFunction = function _wrapProxyFunction(id) {
    var _this = this;
    return function() {
        var i;

        for (i = 0; i < arguments.length; i++) {
            if (typeof arguments[i] === 'object') {
                arguments[i] = strip(flatClone(arguments[i]));
            }
        }
        _this._outCommands.push('INVOKE', id, Array.prototype.slice.call(arguments));
    };
};

Compositor.prototype.invoke = function invoke (target, methodName, args, functionArgs) {
    var targetObject = window[target];

    for (var i = 0; i < args.length; i++) {
        if (functionArgs[i] != null) {
            args[i] = this._wrapProxyFunction(functionArgs[i]);
        }
    }

    targetObject[methodName].apply(targetObject, args);
};

/**
 * Processes the previously via `receiveCommands` updated incoming "in"
 * command queue.
 * Called by ThreadManager.
 *
 * @method drawCommands
 *
 * @return {Array} outCommands  set of commands to be sent back to the
 *                              WebWorker
 */
Compositor.prototype.drawCommands = function drawCommands() {
    var commands = this._inCommands;
    var localIterator = 0;
    var command = commands[localIterator];
    while (command) {
        switch (command) {
            case 'WITH':
                localIterator = this.handleWith(++localIterator, commands);
                break;

            case 'INVOKE':
                this.invoke(
                    commands[++localIterator],
                    commands[++localIterator],
                    commands[++localIterator],
                    commands[++localIterator]
                );
                break;

            case 'NEED_SIZE_FOR':
                this.giveSizeFor(++localIterator, commands);
                break;
        }
        command = commands[++localIterator];
    }

    // TODO: Switch to associative arrays here...

    for (var key in this._contexts) {
        this._contexts[key].draw();
    }

    return this._outCommands;
};

/**
 * Used by ThreadManager to update the interal queue of incoming commands.
 * Receiving commands does not immediately start the rederning process.
 *
 * @param  {Array} commands     command queue to be processed by the
 *                              compositor's `drawCommands` method
 */
Compositor.prototype.receiveCommands = function receiveCommands(commands) {
    var len = commands.length;
    for (var i = 0; i < len; i++) {
        this._inCommands.push(commands[i]);
    }
};

/**
 * Flushes the queue of outgoing "out" commands.
 * Called by ThreadManager.
 *
 * @method clearCommands
 */
Compositor.prototype.clearCommands = function clearCommands() {
    this._inCommands.length = 0;
    this._outCommands.length = 0;
    this._sentResize = false;
};

module.exports = Compositor;

},{"./Context":285,"famous-dom-renderers":202,"famous-utilities":215}],285:[function(require,module,exports){
var WebGLRenderer = require('famous-webgl-renderers').WebGLRenderer;
var Camera = require('famous-components').Camera;
var DOMRenderer = require('famous-dom-renderers').DOMRenderer;

function Context(selector, compositor) {
    this._compositor = compositor;
    this._rootEl = document.querySelector(selector);

    if (this._rootEl === document.body) {
        window.addEventListener('resize', this.updateSize.bind(this));
    }

    var DOMLayerEl = document.createElement('div');
    DOMLayerEl.style.width = '100%';
    DOMLayerEl.style.height = '100%';
    DOMLayerEl.style.transformStyle = 'preserve-3d';
    DOMLayerEl.style.webkitTransformStyle = 'preserve-3d';
    this._rootEl.appendChild(DOMLayerEl);
    this.DOMRenderer = new DOMRenderer(DOMLayerEl, selector, compositor); 
 
    this.WebGLRenderer = null;
    this.canvas = null;

    this._renderState = {
        projectionType: Camera.ORTHOGRAPHIC_PROJECTION,
        perspectiveTransform: new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
        viewTransform: new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
        viewDirty: false,
        perspectiveDirty: false
    };

    this._size = [];
    this._children = {};
    this._elementHash = {};

    this._meshTransform = [];
    this._meshSize = [0, 0, 0];

    this.updateSize();
}

Context.prototype.updateSize = function () {
    var newSize = this.DOMRenderer._getSize();

    var width = newSize[0];
    var height = newSize[1];

    this._size[0] = width;
    this._size[1] = height;
    this._size[2] = (width > height) ? width : height;

    if (this.canvas) {
        this.canvas.width  = width;
        this.canvas.height = height;
    }

    if (this.WebGLRenderer) this.WebGLRenderer.updateSize(this._size);

    return this;
}

Context.prototype.draw = function draw() {
    this.DOMRenderer.draw(this._renderState);
    if (this.WebGLRenderer) this.WebGLRenderer.draw(this._renderState);

    if (this._renderState.perspectiveDirty) this._renderState.perspectiveDirty = false;
    if (this._renderState.viewDirty) this._renderState.viewDirty = false;
};

Context.prototype.getRootSize = function getRootSize() {
    return this.DOMRenderer.getSize();
};

Context.prototype.initWebGL = function initWebGL() {
    this.canvas = document.createElement('canvas');
    this.canvas.className = 'famous-webgl';
    this._rootEl.appendChild(this.canvas);
    this.WebGLRenderer = new WebGLRenderer(this.canvas);
    this.updateSize();
};

Context.prototype.receive = function receive(pathArr, path, commands, iterator) {
    var pointer;
    var parentEl;
    var element;
    var id;
    var localIterator = iterator;

    var command = commands[++localIterator];
    this.DOMRenderer.loadPath(path);
    this.DOMRenderer.findTarget();
    while (command) {

        switch (command) {
            case 'INIT_DOM':
                this.DOMRenderer.insertEl(commands[++localIterator]);
                break;

            case 'CHANGE_TRANSFORM':
                for (var i = 0 ; i < 16 ; i++) this._meshTransform[i] = commands[++localIterator];

                this.DOMRenderer.setMatrix(this._meshTransform);

                if (this.WebGLRenderer)
                    this.WebGLRenderer.setCutoutUniform(path, 'transform', this._meshTransform);
                
                break;

            case 'CHANGE_SIZE':
                var width = commands[++localIterator];
                var height = commands[++localIterator];

                this.DOMRenderer.setSize(width, height);
                if (this.WebGLRenderer) {
                    this._meshSize[0] = width;
                    this._meshSize[1] = height;
                    this.WebGLRenderer.setCutoutUniform(path, 'size', this._meshSize);
                }
                break;

            case 'CHANGE_PROPERTY':
                if (this.WebGLRenderer) this.WebGLRenderer.getOrSetCutout(path);
                this.DOMRenderer.setProperty(commands[++localIterator], commands[++localIterator]);
                break;

            case 'CHANGE_CONTENT':
                if (this.WebGLRenderer) this.WebGLRenderer.getOrSetCutout(path);
                this.DOMRenderer.setContent(commands[++localIterator]);
                break;

            case 'CHANGE_ATTRIBUTE':
                if (this.WebGLRenderer) this.WebGLRenderer.getOrSetCutout(path);
                this.DOMRenderer.setAttribute(commands[++localIterator], commands[++localIterator]);
                break;

            case 'ADD_CLASS':
                if (this.WebGLRenderer) this.WebGLRenderer.getOrSetCutout(path);
                this.DOMRenderer.addClass(commands[++localIterator]); 
                break;

            case 'REMOVE_CLASS':
                if (this.WebGLRenderer) this.WebGLRenderer.getOrSetCutout(path);
                this.DOMRenderer.removeClass(commands[++localIterator]);
                break;

            case 'ADD_EVENT_LISTENER':
                if (this.WebGLRenderer) this.WebGLRenderer.getOrSetCutout(path);

                var type = commands[++localIterator];
                var properties = commands[++localIterator];
                var preventDefault = commands[++localIterator];

                this.DOMRenderer.addEventListener(path, type, properties, preventDefault);
                break;

            case 'GL_SET_DRAW_OPTIONS': 
                if (!this.WebGLRenderer) this.initWebGL();
                this.WebGLRenderer.setMeshOptions(path, commands[++localIterator]);
                break;

            case 'GL_AMBIENT_LIGHT':
                if (!this.WebGLRenderer) this.initWebGL();
                this.WebGLRenderer.setAmbientLightColor(
                    path,
                    commands[++localIterator],
                    commands[++localIterator],
                    commands[++localIterator]
                );
                break;

            case 'GL_LIGHT_POSITION':
                if (!this.WebGLRenderer) this.initWebGL();
                this.WebGLRenderer.setLightPosition(
                    path,
                    commands[++localIterator],
                    commands[++localIterator],
                    commands[++localIterator]
                );
                break;

            case 'GL_LIGHT_COLOR':
                if (!this.WebGLRenderer) this.initWebGL();
                this.WebGLRenderer.setLightColor(
                    path,
                    commands[++localIterator],
                    commands[++localIterator],
                    commands[++localIterator]
                );
                break;

            case 'MATERIAL_INPUT':
                if (!this.WebGLRenderer) this.initWebGL();
                this.WebGLRenderer.handleMaterialInput(
                    path,
                    commands[++localIterator],
                    commands[++localIterator]
                );
                break;

            case 'GL_SET_GEOMETRY':
                if (!this.WebGLRenderer) this.initWebGL();
                this.WebGLRenderer.setGeometry(
                    path,
                    commands[++localIterator],
                    commands[++localIterator],
                    commands[++localIterator]
                );
                break;

            case 'GL_UNIFORMS':
                if (!this.WebGLRenderer) this.initWebGL();
                this.WebGLRenderer.setMeshUniform(
                    path,
                    commands[++localIterator],
                    commands[++localIterator]
                );
                break;

            case 'GL_BUFFER_DATA':
                if (!this.WebGLRenderer) this.initWebGL();
                this.WebGLRenderer.bufferData(
                    path,
                    commands[++localIterator],
                    commands[++localIterator],
                    commands[++localIterator],
                    commands[++localIterator]
                );
                break;

            case 'GL_HIDE_MESH':
                if (!this.WebGLRenderer) this.initWebGL();
                this.WebGLRenderer.hideMesh(path);
                break;

            case 'GL_SHOW_MESH':
                if (!this.WebGLRenderer) this.initWebGL();
                this.WebGLRenderer.showMesh(path);
                break;

            case 'PINHOLE_PROJECTION':
                this._renderState.projectionType = Camera.PINHOLE_PROJECTION;
                this._renderState.perspectiveTransform[11] = -1 / commands[++localIterator];

                this._renderState.perspectiveDirty = true;
                break;

            case 'ORTHOGRAPHIC_PROJECTION':
                this._renderState.projectionType = Camera.ORTHOGRAPHIC_PROJECTION;
                this._renderState.perspectiveTransform[11] = 0;

                this._renderState.perspectiveDirty = true;
                break;

            case 'CHANGE_VIEW_TRANSFORM':
                this._renderState.viewTransform[0] = commands[++localIterator];
                this._renderState.viewTransform[1] = commands[++localIterator];
                this._renderState.viewTransform[2] = commands[++localIterator];
                this._renderState.viewTransform[3] = commands[++localIterator];

                this._renderState.viewTransform[4] = commands[++localIterator];
                this._renderState.viewTransform[5] = commands[++localIterator];
                this._renderState.viewTransform[6] = commands[++localIterator];
                this._renderState.viewTransform[7] = commands[++localIterator];

                this._renderState.viewTransform[8] = commands[++localIterator];
                this._renderState.viewTransform[9] = commands[++localIterator];
                this._renderState.viewTransform[10] = commands[++localIterator];
                this._renderState.viewTransform[11] = commands[++localIterator];

                this._renderState.viewTransform[12] = commands[++localIterator];
                this._renderState.viewTransform[13] = commands[++localIterator];
                this._renderState.viewTransform[14] = commands[++localIterator];
                this._renderState.viewTransform[15] = commands[++localIterator];

                this._renderState.viewDirty = true;
                break;

            case 'WITH': return localIterator - 1;
        }

        command = commands[++localIterator];
    }

    return localIterator;
};

module.exports = Context;

},{"famous-components":186,"famous-dom-renderers":202,"famous-webgl-renderers":282}],286:[function(require,module,exports){
'use strict';

/**
 * The ThreadManager is being updated by an Engine by consecutively calling its
 * `update` method. It can either manage a real Web-Worker or the global
 * Famous core singleton.
 *
 * @example
 * var compositor = new Compositor();
 * 
 * // Using a Web Worker
 * var worker = new Worker('worker.bundle.js');
 * var threadmanger = new ThreadManager(worker, compositor);
 * 
 * // Without using a Web Worker
 * var threadmanger = new ThreadManager(Famous, compositor);
 * 
 * @class  ThreadManager
 * @constructor
 * 
 * @param {Famous|Worker} thread        The thread being used to receive
 *                                      messages from and post messages to.
 *                                      Expected to expose a WebWorker-like
 *                                      API, which means providing a way to
 *                                      listen for updates by setting its
 *                                      `onmessage` property and sending
 *                                      updates using `postMessage`.
 * @param {Compositor} compositor       an instance of Compositor used to
 *                                      extract enqueued draw commands from to
 *                                      be sent to the thread
 */
function ThreadManager (thread, compositor) {
    this._thread = thread;
    this._compositor = compositor;

    var _this = this;
    this._thread.onmessage = function (ev) {
        _this._compositor.receiveCommands(ev.data ? ev.data : ev);
    };
    this._thread.onerror = function (error) {
        console.error(error);
    };
}

/**
 * Returns the thread being used by the ThreadManager.
 * This could either be an an actual web worker or a `Famous` singleton.
 *
 * @method getThread
 * 
 * @return {Worker|Famous}  Either a web worker or a `Famous` singleton.
 */
ThreadManager.prototype.getThread = function getThread() {
    return this._thread;
};

/**
 * Returns the compositor being used by this ThreadManager.
 *
 * @method getCompositor
 * 
 * @return {Compositor}     The compositor used by the ThreadManager.
 */
ThreadManager.prototype.getCompositor = function getCompositor() {
    return this._compositor;
};

/**
 * Update method being invoked by the Engine on every `requestAnimationFrame`.
 * Used for updating the notion of time within the managed thread by sending
 * a FRAME command and sending messages to 
 * 
 * @method update
 * 
 * @param  {Number} time unix timestamp to be passed down to the worker as a
 *                       FRAME command
 */
ThreadManager.prototype.update = function update (time) {
    this._thread.postMessage(['FRAME', time]);
    var threadMessages = this._compositor.drawCommands();
    this._thread.postMessage(threadMessages);
    this._compositor.clearCommands();
};

module.exports = ThreadManager;

},{}],287:[function(require,module,exports){
'use strict';

module.exports = {
    Compositor: require('./Compositor'),
    ThreadManager: require('./ThreadManager')
};

},{"./Compositor":284,"./ThreadManager":286}],288:[function(require,module,exports){
'use strict';

var sessionHistorySupport = window.history && window.history.pushState && window.history.replaceState;

/**
 * A stateless shim for hash routing. Used by router.
 *   Supports hash bang routing and HTML5 pushState.
 *   Falls back to hash bang urls when pushState is not supported.
 *   Implements subset of W3C spec in respect to
 *   http://www.w3.org/TR/2011/WD-html5-20110113/history.html#history-0
 *
 * @History
 * @class
 * @constructor
 * @private
 *
 * @example
 * var history = History();
 * console.log(history.hashBangUrls);
 * history.pushState({}, document.title, '/route');
 *
 * @param {Object} options
 * @param {Boolean} options.hashBangUrls force history to use URLs
 *   in the form of /#!/route
 * @param {String} root
 */
function History(options) {
    if (!(this instanceof History)) return new History(options);

    options = options || {};
    this._root = options.root || '';
    this._sessionHistorySupport = sessionHistorySupport;
    this.hashBangUrls = options.hashBangUrls || !this._sessionHistorySupport;
    this._location = window.location;
}

/**
 * @property {Boolean} hashBangUrls
 * @readonly
 */
History.prototype.hashBangUrls = false;

/**
 * Register a function to be invoked on every state change.
 *
 * @method onStateChange
 * @chainable
 *
 * @param {Function} handler callback to invoke on state change
 *
 * @return {History} this
 */
History.prototype.onStateChange = function onStateChange(handler) {
    // prefer HTML5 history API over hashchange when possible
    if (this._sessionHistorySupport) {
        window.addEventListener('popstate', handler);
        window.addEventListener('pushstate', handler);
    }
    else if (this.hashBangUrls && 'onhashchange' in window) {
        window.addEventListener('hashchange', handler);
    }
    else {
        // only possible solution at this point is to use an ugly combination
        // of setInterval and window.location.pathname
    }
    return this;
};

/**
 * Deregister a state change handler that has been previously registered
 *   through onStateChange.
 *
 * @method offStateChange
 * @chainable
 *
 * @param {Function} handler handler previously registered through onStateChange
 *
 * @return {History} this
 */
History.prototype.offStateChange = function offStateChange(handler) {
    window.removeEventListener('popstate', handler);
    window.removeEventListener('pushstate', handler);
    window.removeEventListener('hashchange', handler);
    return this;
};

/**
 * Shim for window.history.pushState
 * 
 * @method pushState
 * @chainable
 *
 * @params {Object} data state object passed through session API if possible,
 *   not accessable later on, used to make arguments list complaint with W3C
 *   spec
 * @params {String=document.title} title new document title, not associated with
 *   new state
 * @params {String} url
 *
 * @return {History} this
 */
History.prototype.pushState = function pushState(data, title, url) {
    document.title = title || document.title;
    if (this.hashBangUrls) {
        if (this._sessionHistorySupport) {
            window.history.pushState(data, title, '#!' + url);
        }
        else {
            window.location.hash = url;
        }
    }
    else {
        window.history.pushState(data, title, url);
    }
    return this;
};

/**
 * Shim for window.history.replaceState
 * 
 * @method replaceState
 * @chainable
 *
 * @params {Object} data state object passed through session API if possible,
 *   not accessable later on, used to make arguments list complaint with W3C
 *   spec
 * @params {String=document.title} title new document title, not associated with
 *   new state
 * @params {String} url
 *
 * @return {History} this
 */
History.prototype.replaceState = function replaceState(data, title, url) {
    document.title = title || document.title;
    if (this.hashBangUrls) {
        if (this._sessionHistorySupport) {
            window.history.replaceState(data, title, '#!' + url);
        }
        else {
            url = ('' + window.location).split('#')[0] + '#!' + url;
            window.location.replace(url);
        }
    }
    else {
        window.history.replaceState(data, title, url);
    }
    return this;
};

/**
 * Return current normalized state (routed pathname).
 * Not compliant with [W3C spec 5.4 Session history and
 * navigation](http://www.w3.org/TR/2011/WD-html5-20110113/history.html)
 *
 * @method getState
 *
 * @return {String|null} state as normalized pathname
 */
History.prototype.getState = function getState() {
    if (!this._location.pathname.match('^' + this._root)) {
        return null;
    }
    if (this.hashBangUrls) {
        return this._location.hash.substring(2);
    }
    else {
        return decodeURI(this._location.pathname).substring(this._root.length);
    }
};

module.exports = History;

},{}],289:[function(require,module,exports){
'use strict';

var _History = require('./History');

/**
 * A simple router supporting HTML5 pushState and hashbang  routing ("#!/").
 * 
 * @example
 * var router = Router({
 *     '/example-route-0': function() {
 *         console.log('/example-route-0');
 *     },
 *     '/example-route-1': function() {
 *         console.log('/example-route-1');
 *     },
 *     '/example-route-2': function() {
 *         console.log('/example-route-2');
 *     },
 *     '/example-route-3': function() {
 *         console.log('/example-route-3');
 *     }
 * });
 *
 * var currentState = 0;
 * var interval = setInterval(function() {
 *     if (currentState === 4) return clearTimeout(interval);
 *     router.navigate('/example-route-' + currentState, { invoke: true });
 *     currentState++;
 * }, 1000);
 * 
 * @class Router
 * @constructor
 *
 * @param {Object} routes
 * @param {Object} options
 * @param {Boolean} options.silent
 * @param {Boolean} options.hashBangUrls
 * @param {Object} options.proxy
 * @param {String} options.root
 * @param {Boolean} options.validate check for unknown routes
 */
function Router(routes, options) {
    if (!(this instanceof Router)) return new Router(routes, options);
    
    routes = routes || {};
    options = options || {};

    this._root = options.root || '';

    this._routes = [];
    this.proxy = options.proxy || {};
    if (options.validate) this.validate = true;

    // Avoids cylic routing by storing the last routed state
    // Seems like W3C spec doesn't mention if pushState event should be
    // dispatched on page load.
    this._lastState = null;

    _addInitialRoutes.call(this, routes);

    this._history = _History({
        hashBangUrls: options.hashBangUrls,
        root: this._root
    }).onStateChange(_onStateChange.bind(this));

    if (!options.silent) this.start();
}

/**
 * Starts the router by invoking the route handler bound to the current
 *   pathname. Will be called by constructor, unless silent option is
 *   in use.
 *
 * @method start
 * @chainable
 *
 * @return {Router} this
 */
Router.prototype.start = function start() {
    this.invoke();
    return this;
};

/**
 * Navigates to the given route. If no route is give, navigate to the current
 *   pathname (used during initialization).
 *
 * @method navigate
 * @chainable
 *
 * @param {String} [state=current pathname]
 * @param {Object} options
 * @param {Boolean} options.replace
 * @param {Boolean} options.invoke
 *
 * @return {Router} this
 */
Router.prototype.navigate = function navigate(state, options) {
    options = options || {};
    state = state || this._history.getState();
    if (this._lastState === state) return this;

    var method = options.replace ? 'replaceState' : 'pushState';
    this._history[method](null, null, state);

    if (options.invoke) this.invoke();
    return this;
};

/**
 * Dynamically adds a route to the register.
 *
 * @method addRoute
 * @chainable
 *
 * @param {String|RegExp} route
 * @param {Function} handler
 *
 * @return {Router} this
 */
Router.prototype.addRoute = function addRoute(route, handler) {
    if (typeof route === 'string') route = _createRegExpRoute(route);
    this._routes.push({ regExp: route, handler: handler });
    return this;
};

/**
 * Invokes the handler bound to the given state.
 *
 * @method invoke
 * @chainable
 *
 * @param {String} [state=current pathname] route
 *
 * @return {Router} this
 */
Router.prototype.invoke = function invoke(state) {
    if (this._lastState === state) return this;
    state = state || this._history.getState();
    if (state === null) return;
    var unknown = this._routes.every(function (route) {
        var result = _checkRoute.call(this, route, state);
        if (result) {
            if (typeof route.handler === 'string' && this.proxy[route.handler]) {
                this.proxy[route.handler].apply(null, result);
            }
            else {
                route.handler.apply(null, result);
            }
        }
        return !result;
    }.bind(this));
    if (unknown && this.validate) throw new Error('Unknown route');
    return this;
};

function _checkRoute(route, state) {
    var result = state.match(route.regExp);
    if (!result) return false;

    // no support for nested capturing groups
    result = result.slice(1);
    return result;
}

function _createRegExpRoute(route) {
    // TODO could be extended to splats etc.
    route = route.replace(/\:\w+/, function (param) {
        param = param.substring(1);
        return '(' + param + ')';
    });
    return new RegExp('^' + route + '$');
}

function _onStateChange() {
    /* jshint validthis: true */
    this.invoke();
}

function _addInitialRoutes(routes, scope) {
    /* jshint validthis: true */
    scope = scope || '';
    if (Array.isArray(routes)) {
        // composing nested sets of regular expressions of regular expressions
        // including lookarounds might lead to unexpected behavior. For now,
        // those can't be traversed.
        routes.forEach(function(routeSpec) {
            this.addRoute(routeSpec.route, routeSpec.handler);
        }.bind(this));
    } else {
        for (var route in routes) {
            var handler = routes[route];
            if (handler instanceof Function || typeof handler === 'string') {
                this.addRoute(scope + route, routes[route]);
            }
            else {
                _addInitialRoutes.call(this, routes[route], scope + route);
            }
        }
    }
}

module.exports = Router;

},{"./History":288}],290:[function(require,module,exports){
'use strict';

module.exports = {
    History: require('./History'),
    Router: require('./Router')
};

},{"./History":288,"./Router":289}],291:[function(require,module,exports){
module.exports = function (css, customDocument) {
  var doc = customDocument || document;
  if (doc.createStyleSheet) {
    var sheet = doc.createStyleSheet()
    sheet.cssText = css;
    return sheet.ownerNode;
  } else {
    var head = doc.getElementsByTagName('head')[0],
        style = doc.createElement('style');

    style.type = 'text/css';

    if (style.styleSheet) {
      style.styleSheet.cssText = css;
    } else {
      style.appendChild(doc.createTextNode(css));
    }

    head.appendChild(style);
    return style;
  }
};

module.exports.byUrl = function(url) {
  if (document.createStyleSheet) {
    return document.createStyleSheet(url).ownerNode;
  } else {
    var head = document.getElementsByTagName('head')[0],
        link = document.createElement('link');

    link.rel = 'stylesheet';
    link.href = url;

    head.appendChild(link);
    return link;
  }
};

},{}],292:[function(require,module,exports){
var css = "html {\n    width: 100%;\n    height: 100%;\n    margin: 0px;\n    padding: 0px;\n    overflow: hidden;\n    -webkit-transform-style: preserve-3d;\n    transform-style: preserve-3d;\n}\n\nbody {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    margin: 0px;\n    padding: 0px;\n    -webkit-transform-style: preserve-3d;\n    transform-style: preserve-3d;\n    -webkit-font-smoothing: antialiased;\n    -webkit-tap-highlight-color: transparent;\n    -webkit-perspective: 0;\n    perspective: none;\n    overflow: hidden;\n}\n\n.famous-container, .famous-group {\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    bottom: 0px;\n    right: 0px;\n    overflow: visible;\n    -webkit-transform-style: preserve-3d;\n    transform-style: preserve-3d;\n    -webkit-backface-visibility: visible;\n    backface-visibility: visible;\n    pointer-events: none;\n}\n\n.famous-group {\n    width: 0px;\n    height: 0px;\n    margin: 0px;\n    padding: 0px;\n    -webkit-transform-style: preserve-3d;\n    transform-style: preserve-3d;\n}\n\n.fa-surface {\n    position: absolute;\n    -webkit-transform-origin: 0% 0%;\n    transform-origin: 0% 0%;\n    -webkit-backface-visibility: visible;\n    backface-visibility: visible;\n    -webkit-transform-style: preserve-3d;\n    transform-style: preserve-3d; /* performance */\n    -webkit-tap-highlight-color: transparent;\n    pointer-events: auto;\n    z-index: 1; /* HACK to account for browser issues with eventing on the same z-plane*/\n}\n\n.fa-content {\n    position: absolute;\n}\n\n.famous-container-group {\n    position: relative;\n    width: 100%;\n    height: 100%;\n}\n\n.fa-container {\n    position: absolute;\n    -webkit-transform-origin: center center;\n    transform-origin: center center;\n    overflow: hidden;\n}\n\ncanvas.famous-webgl {\n    pointer-events: none;\n    position: absolute;\n    z-index: 1;\n    top: 0px;\n    left: 0px;\n}"; (require("/Users/morgantheplant/Code/refactor/vectr/node_modules/famous/node_modules/famous-stylesheets/node_modules/cssify"))(css); module.exports = css;
},{"/Users/morgantheplant/Code/refactor/vectr/node_modules/famous/node_modules/famous-stylesheets/node_modules/cssify":291}],293:[function(require,module,exports){
'use strict';

require('./famous.css');

},{"./famous.css":292}],294:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"dup":16}],295:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./Curves":294,"dup":17}],296:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"./Curves":294,"./Transitionable":295,"dup":18}],297:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"dup":16}],298:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./Curves":297,"dup":17}],299:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"./Curves":297,"./Transitionable":298,"dup":18}],300:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24}],301:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25,"famous-transitions":299}],302:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26}],303:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27}],304:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"dup":28}],305:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"dup":29}],306:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],307:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"./CallbackStore":300,"./Color":301,"./KeyCodes":302,"./MethodStore":303,"./ObjectManager":304,"./clone":305,"./flatClone":306,"./keyValueToArrays":308,"./loadURL":309,"./strip":310,"dup":31}],308:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],309:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],310:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],311:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],312:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./Mat33":311,"dup":12}],313:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"dup":13}],314:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"dup":14}],315:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./Mat33":311,"./Quaternion":312,"./Vec2":313,"./Vec3":314,"dup":15}],316:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],317:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],318:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"./Curves":316,"dup":21}],319:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],320:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"./Curves":316,"./Easing":317,"./Transitionable":318,"./after":319,"dup":23}],321:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24}],322:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25,"famous-transitions":320}],323:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26}],324:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27}],325:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"dup":28}],326:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"dup":29}],327:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],328:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"./CallbackStore":321,"./Color":322,"./KeyCodes":323,"./MethodStore":324,"./ObjectManager":325,"./clone":326,"./flatClone":327,"./keyValueToArrays":329,"./loadURL":330,"./strip":331,"dup":31}],329:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],330:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],331:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],332:[function(require,module,exports){
arguments[4][256][0].apply(exports,arguments)
},{"./Geometry":333,"dup":256}],333:[function(require,module,exports){
arguments[4][257][0].apply(exports,arguments)
},{"dup":257}],334:[function(require,module,exports){
arguments[4][258][0].apply(exports,arguments)
},{"dup":258,"famous-math":315}],335:[function(require,module,exports){
arguments[4][259][0].apply(exports,arguments)
},{"./GeometryHelper":334,"dup":259,"famous-utilities":328}],336:[function(require,module,exports){
arguments[4][260][0].apply(exports,arguments)
},{"./DynamicGeometry":332,"./Geometry":333,"./GeometryHelper":334,"./OBJLoader":335,"./primitives/Box":337,"./primitives/Circle":338,"./primitives/Cylinder":339,"./primitives/GeodesicSphere":340,"./primitives/Icosahedron":341,"./primitives/ParametricCone":342,"./primitives/Plane":343,"./primitives/Sphere":344,"./primitives/Tetrahedron":345,"./primitives/Torus":346,"./primitives/Triangle":347,"dup":260}],337:[function(require,module,exports){
arguments[4][261][0].apply(exports,arguments)
},{"../Geometry":333,"dup":261}],338:[function(require,module,exports){
arguments[4][262][0].apply(exports,arguments)
},{"../Geometry":333,"dup":262}],339:[function(require,module,exports){
arguments[4][263][0].apply(exports,arguments)
},{"../Geometry":333,"../GeometryHelper":334,"dup":263}],340:[function(require,module,exports){
arguments[4][264][0].apply(exports,arguments)
},{"../Geometry":333,"../GeometryHelper":334,"dup":264}],341:[function(require,module,exports){
arguments[4][265][0].apply(exports,arguments)
},{"../Geometry":333,"../GeometryHelper":334,"dup":265}],342:[function(require,module,exports){
arguments[4][266][0].apply(exports,arguments)
},{"../Geometry":333,"../GeometryHelper":334,"dup":266}],343:[function(require,module,exports){
arguments[4][267][0].apply(exports,arguments)
},{"../Geometry":333,"dup":267}],344:[function(require,module,exports){
arguments[4][268][0].apply(exports,arguments)
},{"../Geometry":333,"../GeometryHelper":334,"dup":268}],345:[function(require,module,exports){
arguments[4][269][0].apply(exports,arguments)
},{"../Geometry":333,"../GeometryHelper":334,"dup":269}],346:[function(require,module,exports){
arguments[4][270][0].apply(exports,arguments)
},{"../Geometry":333,"../GeometryHelper":334,"dup":270}],347:[function(require,module,exports){
arguments[4][271][0].apply(exports,arguments)
},{"../Geometry":333,"../GeometryHelper":334,"dup":271}],348:[function(require,module,exports){
'use strict';

var TextureRegistry = require('./TextureRegistry');

/** 
 * A list of glsl expressions which can interface with javascript data and
 * connected to each other to build custom shaders. 
 *
 */
var expressions = {};

var snippets = {

    /* Abs - The abs function returns the absolute value of x, i.e. x when x is positive or zero and -x for negative x. The input parameter can be a floating scalar or a float vector. In case of a float vector the operation is done component-wise.
     */ 

    abs: {glsl: 'abs(%1);'},
    /* Sign - The sign function returns 1.0 when x is positive, 0.0 when x is zero and -1.0 when x is negative. The input parameter can be a floating scalar or a float vector. In case of a float vector the operation is done component-wise. */


    sign: {glsl: 'sign(%1);'},

    /* Floor - The floor function returns the largest integer number that is smaller or equal to x. The input parameter can be a floating scalar or a float vector. In case of a float vector the operation is done component-wise. */

    floor: {glsl: 'floor(%1);'},

    /* Ceiling - The ceiling function returns the smallest number that is larger or equal to x. The input parameter can be a floating scalar or a float vector. In case of a float vector the operation is done component-wise. */

    ceiling: {glsl: 'ceil(%1);'},

    /* The mod expression returns the remained of the division operation of the two inputs. */
    mod: {glsl: 'mod(%1, %2);'},

    /* Min - The min function returns the smaller of the two arguments. The input parameters can be floating scalars or float vectors. In case of float vectors the operation is done component-wise. */

    min: {glsl: 'min(%1, %2);'},

    /* Max - The max function returns the larger of the two arguments. The input parameters can be floating scalars or float vectors. In case of float vectors the operation is done component-wise. */ 

    max: {glsl: 'max(%1, %2);'},
    /* Clamp - The clamp function returns x if it is larger than minVal and smaller than maxVal. In case x is smaller than minVal, minVal is returned. If x is larger than maxVal, maxVal is returned. The input parameters can be floating scalars or float vectors. In case of float vectors the operation is done component-wise. */

    clamp: {glsl: 'clamp(%1, %2, %3);'},

    /* Mix - The mix function returns the linear blend of x and y, i.e. the product of x and (1 - a) plus the product of y and a. The input parameters can be floating scalars or float vectors. In case of float vectors the operation is done component-wise. */

    mix: {glsl: 'mix(%1, %2, %3);'},

    /* Step - The step function returns 0.0 if x is smaller then edge and otherwise 1.0. The input parameters can be floating scalars or float vectors. In case of float vectors the operation is done component-wise. */

    step: {glsl: 'step(%1, %2, %3);'},
    
    /* Smoothstep - The smoothstep function returns 0.0 if x is smaller then edge0 and 1.0 if x is larger than edge1. Otherwise the return value is interpolated between 0.0 and 1.0 using Hermite polynomirals. The input parameters can be floating scalars or float vectors. In case of float vectors the operation is done component-wise. */ 

    smoothstep: {glsl: 'smoothstep(%1);'},


    /* fragCoord - The fragCoord function returns the fragment's position in screenspace. */

    fragCoord: {glsl: 'gl_FragColor.xy;'},

    /* Sin - The sin function returns the sine of an angle in radians. The input parameter can be a floating scalar or a float vector. In case of a float vector the sine is calculated separately for every component. */


    sin: {glsl: 'sin(%1);'},

    /* Cos - The cos function returns the cosine of an angle in radians. The input parameter can be a floating scalar or a float vector. */

    cos: {glsl: 'cos(%1);'},

    /* Pow - The power function returns x raised to the power of y. The input parameters can be floating scalars or float vectors. In case of float vectors the operation is done component-wise. */ 

    pow: {glsl: 'pow(%1, %2);'},

    /* Sqrt - The sqrt function returns the square root of x. The input parameter can be a floating scalar or a float vector. In case of a float vector the operation is done component-wise. */ 

    /* fragCoord - The time function returns the elapsed time in the unix epoch in milliseconds.*/

    time: {glsl: 'time;'},

    /* The Add function takes two inputs, adds them together and outputs the result. This addition operation is performed on a per channel basis, meaning that the inputs' R channels get added, G channels get added, B channels get added, etc. Both inputs must have the same number of channels unless one of them is a single Constant value. Constants can be added to a vector with any number of inputs. */
    add: {glsl: '%1 + %2;'},

    /* The Add function takes two inputs, adds them together and outputs the result. This addition operation is performed on a per channel basis, meaning that the inputs' R channels get added, G channels get added, B channels get added, etc. Both inputs must have the same number of channels unless one of them is a single Constant value. Constants can be added to a vector with any number of inputs. */
    multiply: {glsl: '%1 * %2;'},


    /* The normal function returns the 3-dimensional surface normal, which is a vector that is perpendicular to the tangent plane at that point.*/
    normal: {glsl:'(v_Normal + 1.0) * 0.5;'},

    /* The uv function returns the 2-dimensional vector that maps the object's 3-dimensional vertices to a 2D plane. */
    uv: {glsl:'vec3(v_TextureCoordinate, 1);'},

    /* The mesh position function returns the transformed fragment's position in world-space.  */
    meshPosition: {glsl:'(v_Position + 1.0) * 0.5;'},


    /* The image function fetches the model's */
    image: {glsl:'texture2D(image, v_TextureCoordinate).rgb;'},


    /* The constant function returns a static value which is defined at compile-time that cannot be changed dynamically.*/
    constant: {glsl: '%1;'},
    
    /* The Parameter expression has values that can be modified (dynamically during runtime in some cases) in a MaterialInstance of the base material containing the parameter. These expressions should be given unique names, via the Parameter Name property, to be used when identifying the specific parameter in the MaterialInstance. If two parameters of the same type have the same name in the same material, they will be assumed to be the same parameter. Changing the value of the parameter in the MaterialInstance would change the value of both the parameter expressions in the material. A default value for the parameter will also be set in the base material. This will be the value of the parameter in the MaterialInstance unless it is overridden and modified there. */

    parameter: {uniforms: {parameter: 1}, glsl: 'parameter;'}
};

expressions.registerExpression = function registerExpression(name, schema) {
    this[name] = function (inputs, options) {
        return new Material(name, schema, inputs, options);
    };
};

for (var name in snippets) {
    expressions.registerExpression(name, snippets[name]);
}

/**
 * Material is a public class that composes a material-graph out of expressions
 *
 *
 * @class Material
 * @constructor
 *
 * @param {Object} definiton of nascent expression with shader code, inputs and uniforms
 * @param {Array} list of Material expressions, images, or constant
 * @param {Object} map of uniform data of float, vec2, vec3, vec4
 */

function Material(name, chunk, inputs, options) {
    options = options || {};

    this.name = name;
    this.chunk = chunk;
    this.inputs = inputs ? (Array.isArray(inputs) ? inputs : [inputs]): [];
    this.uniforms = options.uniforms || {};
    this.varyings = options.varyings;
    this.attributes = options.attributes;
    if (options.texture) {
        this.texture = options.texture.__isATexture__ ? options.texture : TextureRegistry.register(null, options.texture);
    }

    this._id = Material.id++;

    this.invalidations = [];
}

Material.id = 1;

/**
 * Iterates over material graph
 *
 * @method traverse
 * @chainable
 *
 * @param {Function} invoked upon every expression in the graph
 */

Material.prototype.traverse = function traverse(callback) {
    var len = this.inputs && this.inputs.length, idx = -1;

    while (++idx < len) traverse.call(this.inputs[idx], callback, idx);

    callback(this);

    return this;
};

Material.prototype.setUniform = function setUniform(name, value) {
    this.uniforms[name] = value;

    this.invalidations.push(name);
};

/**
 * Converts material graph into chunk
 *
 * @method _compile
 * @protected
 *
 */

Material.prototype._compile = function _compile() {
    var glsl = '';
    var uniforms = {};
    var varyings = {};
    var attributes = {};
    var defines = [];
    var texture;

    this.traverse(function (node, depth) {
        if (! node.chunk) return;
        glsl += 'vec3 ' + makeLabel(node) + '=' + processGLSL(node.chunk.glsl, node.inputs) + '\n ';
        if (node.uniforms) extend(uniforms, node.uniforms);
        if (node.varyings) extend(varyings, node.varyings);
        if (node.attributes) extend(attributes, node.attributes);
        if (node.chunk.defines) defines.push(node.chunk.defines);
        if (node.texture) texture = node.texture;
    });

    return {
        _id: this._id,
        glsl: glsl + 'return ' + makeLabel(this) + ';',
        defines: defines.join('\n'),
        uniforms: uniforms,
        varyings: varyings,
        attributes: attributes,
        texture: texture
    };
};

function extend (a, b) { for (var k in b) a[k] = b[k]; }

function processGLSL(str, inputs) {
    return str.replace(/%\d/g, function (s) {
        return makeLabel(inputs[s[1]-1]);
    });
}
function makeLabel (n) {
    if (Array.isArray(n)) return arrayToVec(n);
    if (typeof n == 'object') return 'fa_' + (n._id);
    else return JSON.stringify(n);
}

function arrayToVec(array) {
    var len = array.length;
    return 'vec' + len + '(' + array.join(',')  + ')';
}

module.exports = expressions;
expressions.Material = Material;
expressions.Texture = function (source) {
    if (typeof window === 'undefined') return console.error('Texture constructor cannot be run inside of a worker');
    return expressions.image([], { texture: source });
};

},{"./TextureRegistry":349}],349:[function(require,module,exports){
'use strict';

/*
 * A singleton object that holds texture instances in a registry which
 * can be accessed by key.  Allows for texture sharing and easy referencing.
 *
 * @static
 * @class TextureRegistry
 */
var TextureRegistry = {
	registry: {},
	textureIds: 1
};

/*
 * Registers a new Texture object with a unique id and input parameters to be
 * handled by the WebGLRenderer.  If no accessor is input the texture will be 
 * created but not store in the registry.
 *
 * @method register
 *
 * @param {String} accessor Key used to later access the texture object.
 * @param {Object | Array | String} data Data to be used in the WebGLRenderer to
 * generate texture data.
 * @param {Object} options Optional parameters to affect the rendering of the
 * WebGL texture.
 *
 * @return {Object} Newly generated texture object.
 */
TextureRegistry.register = function register(accessor, data, options) {
	if (accessor) return (this.registry[accessor] = { id: this.textureIds++, __isATexture__: true, data: data, options: options });
	else return { id: this.textureIds++, data: data, __isATexture__: true, options: options };
};

/*
 * Retreives the texture object from registry.  Throws if no texture is
 * found at given key.
 *
 * @method get
 *
 * @param {String} accessor Key of a desired texture in the registry.
 *
 * @return {Object} Desired texture object.
 */
TextureRegistry.get = function get(accessor) {
	if (!this.registry[accessor]) {
		throw 'Texture "' + accessor + '" not found!';
	}
	else {
		return this.registry[accessor];
	}
}

module.exports = TextureRegistry;

},{}],350:[function(require,module,exports){
'use strict';

module.exports = {
    Material: require('./Material'),
    TextureRegistry: require('./TextureRegistry')
};
},{"./Material":348,"./TextureRegistry":349}],351:[function(require,module,exports){
arguments[4][11][0].apply(exports,arguments)
},{"dup":11}],352:[function(require,module,exports){
arguments[4][12][0].apply(exports,arguments)
},{"./Mat33":351,"dup":12}],353:[function(require,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"dup":13}],354:[function(require,module,exports){
arguments[4][14][0].apply(exports,arguments)
},{"dup":14}],355:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./Mat33":351,"./Quaternion":352,"./Vec2":353,"./Vec3":354,"dup":15}],356:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],357:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],358:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"./Curves":356,"dup":21}],359:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],360:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"./Curves":356,"./Easing":357,"./Transitionable":358,"./after":359,"dup":23}],361:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24}],362:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25,"famous-transitions":360}],363:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26}],364:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27}],365:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"dup":28}],366:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"dup":29}],367:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],368:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"./CallbackStore":361,"./Color":362,"./KeyCodes":363,"./MethodStore":364,"./ObjectManager":365,"./clone":366,"./flatClone":367,"./keyValueToArrays":369,"./loadURL":370,"./strip":371,"dup":31}],369:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],370:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],371:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],372:[function(require,module,exports){
arguments[4][256][0].apply(exports,arguments)
},{"./Geometry":373,"dup":256}],373:[function(require,module,exports){
arguments[4][257][0].apply(exports,arguments)
},{"dup":257}],374:[function(require,module,exports){
arguments[4][258][0].apply(exports,arguments)
},{"dup":258,"famous-math":355}],375:[function(require,module,exports){
arguments[4][259][0].apply(exports,arguments)
},{"./GeometryHelper":374,"dup":259,"famous-utilities":368}],376:[function(require,module,exports){
arguments[4][260][0].apply(exports,arguments)
},{"./DynamicGeometry":372,"./Geometry":373,"./GeometryHelper":374,"./OBJLoader":375,"./primitives/Box":377,"./primitives/Circle":378,"./primitives/Cylinder":379,"./primitives/GeodesicSphere":380,"./primitives/Icosahedron":381,"./primitives/ParametricCone":382,"./primitives/Plane":383,"./primitives/Sphere":384,"./primitives/Tetrahedron":385,"./primitives/Torus":386,"./primitives/Triangle":387,"dup":260}],377:[function(require,module,exports){
arguments[4][261][0].apply(exports,arguments)
},{"../Geometry":373,"dup":261}],378:[function(require,module,exports){
arguments[4][262][0].apply(exports,arguments)
},{"../Geometry":373,"dup":262}],379:[function(require,module,exports){
arguments[4][263][0].apply(exports,arguments)
},{"../Geometry":373,"../GeometryHelper":374,"dup":263}],380:[function(require,module,exports){
arguments[4][264][0].apply(exports,arguments)
},{"../Geometry":373,"../GeometryHelper":374,"dup":264}],381:[function(require,module,exports){
arguments[4][265][0].apply(exports,arguments)
},{"../Geometry":373,"../GeometryHelper":374,"dup":265}],382:[function(require,module,exports){
arguments[4][266][0].apply(exports,arguments)
},{"../Geometry":373,"../GeometryHelper":374,"dup":266}],383:[function(require,module,exports){
arguments[4][267][0].apply(exports,arguments)
},{"../Geometry":373,"dup":267}],384:[function(require,module,exports){
arguments[4][268][0].apply(exports,arguments)
},{"../Geometry":373,"../GeometryHelper":374,"dup":268}],385:[function(require,module,exports){
arguments[4][269][0].apply(exports,arguments)
},{"../Geometry":373,"../GeometryHelper":374,"dup":269}],386:[function(require,module,exports){
arguments[4][270][0].apply(exports,arguments)
},{"../Geometry":373,"../GeometryHelper":374,"dup":270}],387:[function(require,module,exports){
arguments[4][271][0].apply(exports,arguments)
},{"../Geometry":373,"../GeometryHelper":374,"dup":271}],388:[function(require,module,exports){
'use strict';
var Geometry = require('famous-webgl-geometries');

/**
 * The Mesh class is responsible for providing the API for how
 * a RenderNode will interact with the WebGL API by adding
 * a set of commands to the renderer.
 *
 * @class Mesh
 * @constructor
 * @renderable
 * @param {LocalDispatch} dispatch LocalDispatch to be retrieved
 * @param {object} Options Optional params for configuring Mesh
 */
function Mesh (node, options) {
    this._node = node;
    this._changeQueue = [];
    this._initialized = false;
    this._requestingUpdate = false;
    this._inDraw = false;
    this.value = {
        drawOptions: null,
        color: null,
        expressions: {},
        geometry: null,
        flatShading: null,
        glossiness: null,
        positionOffset: null,
        normals: null
    };

    if (options) this.setDrawOptions(options);
    this._id = node.addComponent(this);
}

/**
 * Pass custom options to Mesh, such as a 3 element map
 * which displaces the position of each vertex in world space.
 *
 * @method setDrawOptions
 * @chainable
 *
 * @param {Object} Options
 * @chainable
 */
Mesh.prototype.setDrawOptions = function setOptions (options) {
    if (this.value.drawOptions.blendMode) {
        this.value.drawOptions.blendMode = options.blendMode;
        this._changeQueue.push('GL_SET_DRAW_OPTIONS');
        this._changeQueue.push(options);
    } else {
        this.vale.drawOptions = {
            blendMode: options.blendMode
        };
        this._changeQueue.push('GL_SET_DRAW_OPTIONS');
        this._changeQueue.push(options);
    }
    return this;
};

/**
 * Get the mesh's custom options.
 *
 * @method getDrawOptions
 * @returns {Object} Options
 */
Mesh.prototype.getDrawOptions = function getDrawOptions () {
    return this.value.drawOptions;
};

/**
 * Set the geometry of a mesh.
 *
 * @method setGeometry
 * @chainable
 *
 * @param {Geometry} geometry instance to be associated with the mesh
 * @param {Object} Options Various configurations for geometries.
 * @chainable
 */
Mesh.prototype.setGeometry = function setGeometry (geometry, options) {
    if (typeof geometry === 'string') {
        if (!Geometry[geometry]) throw 'Invalid geometry: "' + geometry + '".';
        else geometry = new Geometry[geometry](options);
    }

    if (this.value.geometry !== geometry || this._inDraw) {
        if (this._initialized) {
            this._changeQueue.push('GL_SET_GEOMETRY');
            this._changeQueue.push(geometry.id);
            this._changeQueue.push(geometry.spec.type);
            this._changeQueue.push(geometry.spec.dynamic);
        }
        this._requestUpdate();
        this.value.geometry = geometry;
    }

    return this;
};

/**
 * Get the geometry of a mesh.
 *
 * @method getGeometry
 * @returns {Geometry} geometry Geometry of mesh
 */
Mesh.prototype.getGeometry = function getGeometry () {
    return this.value.geometry;
};

/**
* Changes the color of Mesh, passing either a material expression or
* color using the 'Color' utility component.
*
* @method setBaseColor
* @param {Object|Color} Material, image, vec3, or Color instance
* @chainable
*/
Mesh.prototype.setBaseColor = function setBaseColor (color) {
    var uniformValue;
    if (color._compile) {
        this.value.expressions.baseColor = color;
        uniformValue = color._compile(); 
    } else if (color.getNormalizedRGB) {
        this.value.expressions.baseColor = null;
        this.value.color = color;
        uniformValue = color.getNormalizedRGB();
    }

    if (this._initialized) {
        // If a material expression
        if (color._compile) {
            this._changeQueue.push('MATERIAL_INPUT');
        }

        // If a color component
        else if (color.getNormalizedRGB) {
            this._changeQueue.push('GL_UNIFORMS');
        }
        this._changeQueue.push('baseColor');
        this._changeQueue.push(uniformValue);
    }

    this._requestUpdate();

    return this;
};

/**
 * Returns either the material expression or the color instance of Mesh.
 *
 * @method getBaseColor
 * @returns {MaterialExpress|Color}
 */
Mesh.prototype.getBaseColor = function getBaseColor () {
    return this.value.expressions.baseColor || this.value.color;
};

/**
 * Change whether the Mesh is affected by light. Default is true.
 *
 * @method setFlatShading
 * @param {boolean} Boolean
 * @chainable
 */
Mesh.prototype.setFlatShading = function setFlatShading (bool) {
    if (this._inDraw || this.value.flatShading !== bool) {
        this.value.flatShading = bool;
        if (this._initialized) {
            this._changeQueue.push('GL_UNIFORMS');
            this._changeQueue.push('u_FlatShading');
            this._changeQueue.push(bool ? 1 : 0);        
        }
        this._requestUpdate();
    }

    return this;
};

/**
 * Returns a boolean for whether Mesh is affected by light.
 *
 * @method getFlatShading
 * @returns {Boolean} Boolean
 */
Mesh.prototype.getFlatShading = function getFlatShading () {
    return this.value.flatShading;
};


/**
 * Defines a 3-element map which is used to provide significant physical
 * detail to the surface by perturbing the facing direction of each individual
 * pixel.
 *
 * @method normal
 * @chainable
 *
 * @param {Object|Array} Material, Image or vec3
 * @return {Element} current Mesh
 */
Mesh.prototype.setNormals = function setNormals (materialExpression) {
    if (materialExpression._compile) {
        this.value.expressions.normals = materialExpression;
        materialExpression = materialExpression._compile();
    }

    if (this._initialized) {
        this._changeQueue.push(materialExpression._compile ? 'MATERIAL_INPUT' : 'UNIFORM_INPUT');
        this._changeQueue.push('normal');
        this._changeQueue.push(materialExpression);
    }

    this._requestUpdate();

    return this;
};

/**
 * Returns the Normals expression of Mesh
 *
 * @method getNormals
 * @returns The normals expression for Mesh
 */
Mesh.prototype.getNormals = function getNormals (materialExpression) {
    return this.value.expressions.normals;
};

/**
 * Defines the glossiness of the mesh from either a material expression or a
 * scalar value
 *
 * @method setGlossiness
 * @param {MaterialExpression|Number}
 * @param {Object} Optional tweening parameter
 * @param {Function} Callback
 * @chainable
 */
Mesh.prototype.setGlossiness = function setGlossiness (materialExpression) {
    var glossiness;

    if (materialExpression._compile) {
        this.value.expressions.glossiness = materialExpression;
        glossiness = materialExpression._compile();
    }
    else {
        this.value.expressions.glossiness = null;
        this.value.glossiness = materialExpression;
        glossiness = this.value.glossiness;
    }

    if (this._initialized) {
        this._changeQueue.push(materialExpression._compile ? 'MATERIAL_INPUT' : 'GL_UNIFORMS');
        this._changeQueue.push('glossiness');
        this._changeQueue.push(glossiness);
    }

    this._requestUpdate();

    return this;
};

/**
 * Returns material expression or scalar value for glossiness.
 *
 * @method getGlossiness
 * @returns {MaterialExpress|Number}
 */
Mesh.prototype.getGlossiness = function getGlossiness () {
    return this.value.expressions.glossiness || this.value.glossiness;
};

/**
 * Defines 3 element map which displaces the position of each vertex in world
 * space.
 *
 * @method setPositionOffset
 * @chainable
 *
 * @param {MaterialExpression|Array}
 * @param {Object} Optional tweening parameter
 * @param {Function} Callback
 * @chainable
 */
Mesh.prototype.setPositionOffset = function positionOffset (materialExpression) {
    var uniformValue;

    if (materialExpression._compile) {
        this.value.expressions.positionOffset = materialExpression;
        uniformValue = materialExpression._compile();
    }
    else {
        this.value.expressions.positionOffset = null;
        this.value.positionOffset = materialExpression;
        uniformValue = this.value.positionOffset;
    }

    if (this._initialized) {
        this._changeQueue.push(materialExpression._compile ? 'MATERIAL_INPUT' : 'GL_UNIFORMS');
        this._changeQueue.push('positionOffset');
        this._changeQueue.push(uniformValue);
    }

    this._requestUpdate();

    return this;
};

/**
 * Returns position offset.
 *
 * @method getPositionOffset
 * @returns {MaterialExpress|Number}
 */
Mesh.prototype.getPositionOffset = function getPositionOffset (materialExpression) {
    return this.value.expressions.positionOffset || this.value.positionOffset;
};

/**
 * Get the mesh's custom options.
 *
 * @method getDrawOptions
 * @returns {Object} Options
 */
Mesh.prototype.getMaterialExpressions = function getMaterialExpressions () {
    return this.value.expressions;
};

Mesh.prototype.getValue = function getValue () {
    return this.value;
};

Mesh.prototype._pushInvalidations = function pushInvalidations (expressionName) {
    var uniformKey;
    var expression = this.value.expressions[expressionName];
    if (expression) {
        var i = expression.invalidations.length;
        while (i--) {
            uniformKey = expression.invalidations.pop();
            this._node.sendDrawCommand('GL_UNIFORMS');
            this._node.sendDrawCommand(uniformKey);
            this._node.sendDrawCommand(expression.uniforms[uniformKey]);
        }
    }
};

/**
* Sends draw commands to the renderer
*
* @private
* @method onUpdate
*/
Mesh.prototype.onUpdate = function onUpdate () {
    var node = this._node;
    var queue = this._changeQueue;

    if (node) {
        node.sendDrawCommand('WITH');
        node.sendDrawCommand(node.getLocation());

        if (this.value.geometry) {
        i = this.value.geometry.spec.invalidations.length;
            while (i--) {
                var bufferIndex = this.value.geometry.spec.invalidations.pop();
                node.sendDrawCommand('GL_BUFFER_DATA');
                node.sendDrawCommand(this.value.geometry.id);
                node.sendDrawCommand(this.value.geometry.spec.bufferNames[i]);
                node.sendDrawCommand(this.value.geometry.spec.bufferValues[i]);
                node.sendDrawCommand(this.value.geometry.spec.bufferSpacings[i]);
            }
        }

        // If any invalidations exist, push them into the queue
        if (this.value.color && this.value.color.isActive()) {
            this._node.sendDrawCommand('GL_UNIFORMS');
            this._node.sendDrawCommand('baseColor');
            this._node.sendDrawCommand(this.value.color.getNormalizedRGB());
            this._node.requestUpdateOnNextTick(this._id);
        } else {
            this._requestingUpdate = false;
        }

        // If any invalidations exist, push them into the queue
        this._pushInvalidations('baseColor');
        this._pushInvalidations('positionOffset');

        for (var i = 0; i < queue.length; i++) {
            node.sendDrawCommand(queue[i]);
        }

        queue.length = 0;
    }

};

Mesh.prototype.onMount = function onMount (node, id) {
    this._node = node;
    this._id = id;

    this.draw();
};

Mesh.prototype.onDismount = function onDismount () {
    this._initialized = false;
    this.onHide();
};

Mesh.prototype.onShow = function onShow () {
    this._changeQueue.push('GL_HIDE_MESH');
};

Mesh.prototype.onHide = function onHide () {
    this._changeQueue.push('GL_HIDE_MESH');
};

/**
 * Receives transform change updates from the scene graph.
 *
 * @private
 */
Mesh.prototype.onTransformChange = function onTransformChange (transform) {
    if (this._initialized) {
        this._changeQueue.push('GL_UNIFORMS');
        this._changeQueue.push('transform');
        this._changeQueue.push(transform);        
    }

    this._requestUpdate();
};

/**
 * Receives size change updates from the scene graph.
 *
 * @private
 */
Mesh.prototype.onSizeChange = function onSizeChange (size) {
    if (this._initialized) {
        this._changeQueue.push('GL_UNIFORMS');
        this._changeQueue.push('size');
        this._changeQueue.push(size);
    }

    this._requestUpdate();
};

/**
 * Receives opacity change updates from the scene graph.
 *
 * @private
 */
Mesh.prototype.onOpacityChange = function onOpacityChange (opacity) {
    if (this._initialized) {
        this._changeQueue.push('GL_UNIFORMS');
        this._changeQueue.push('opacity');
        this._changeQueue.push(opacity);
    }
    
    this._requestUpdate();
};

Mesh.prototype.onAddUIEvent = function onAddUIEvent (UIEvent, methods, properties) {
    //TODO
};

Mesh.prototype._requestUpdate = function _requestUpdate () {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }
};

Mesh.prototype.init = function init () {
    this._initialized = true;
    this.onTransformChange(this._node.getTransform());
    this.onSizeChange(this._node.getSize());
    this.onOpacityChange(this._node.getOpacity());
    this._requestUpdate();
};

Mesh.prototype.draw = function draw () {
    var key;
    var i;
    var len;

    this._inDraw = true;

    this.init();

    var value = this.getValue();
    if (value.geometry != null) this.setGeometry(value.geometry);
    if (value.color != null) this.setBaseColor(value.color);
    if (value.drawOptions != null) this.setDrawOptions(value.drawOptions);
    if (value.flatShading != null) this.setFlatShading(value.flatShading);
    if (value.expressions.normals != null) this.setNormals(value.expressions.normals);
    if (value.expressions.baseColor != null) this.setBaseColor(value.expressions.baseColor);
    if (value.expressions.glossiness != null) this.setGlossiness(value.expressions.glossiness);
    if (value.expressions.positionOffset != null) this.setPositionOffset(value.expressions.positionOffset);

    this._inDraw = false;
};

module.exports = Mesh;

},{"famous-webgl-geometries":376}],389:[function(require,module,exports){
'use strict';

module.exports = {
    Mesh: require('./Mesh'),
    PointLight: require('./lights/PointLight'),
    AmbientLight: require('./lights/AmbientLight'),
};

},{"./Mesh":388,"./lights/AmbientLight":390,"./lights/PointLight":392}],390:[function(require,module,exports){
'use strict';

var Light = require('./Light');


/**
 * AmbientLight extends the functionality of Light. It sets the ambience in
 * the scene. Ambience is a light source that emits light in the entire
 * scene, evenly.
 *
 * @class AmbientLight
 * @constructor
 * @component
 * @param {LocalDispatch} dispatch LocalDispatch to be retrieved
 * from the corresponding Render Node
 */
function AmbientLight(node) {
    Light.call(this, node);
    this.commands.color = 'GL_AMBIENT_LIGHT';
};

/**
* Returns the definition of the Class: 'AmbientLight'
*
* @method toString
* @return {string} definition
*/
AmbientLight.toString = function toString() {
    return 'AmbientLight';
};

/**
 * Extends Light constructor
 */
AmbientLight.prototype = Object.create(Light.prototype);

/**
 * Sets AmbientLight as the constructor
 */
AmbientLight.prototype.constructor = AmbientLight;

module.exports = AmbientLight;

},{"./Light":391}],391:[function(require,module,exports){
'use strict';

/**
 * The blueprint for all light components for inheriting common functionality.
 *
 * @class Light
 * @constructor
 * @component
 * @param {Node} node The controlling node
 * from the corresponding Render Node
 */
function Light(node) {
    this._node = node;
    this._id = node.addComponent(this);
    this._requestingUpdate = false;
    this.queue = [];
    this._color;
    this.commands = { color: 'GL_LIGHT_COLOR' };
};

/**
* Returns the definition of the Class: 'Light'
*
* @method toString
* @return {String} definition
*/
Light.toString = function toString() {
    return 'Light';
};

/**
* Changes the color of the light, using the 'Color' utility component.
*
* @method setColor
* @param {Color} Color instance
* @chainable
*/
Light.prototype.setColor = function setColor(color) {
    if (!color.getNormalizedRGB) return false;
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }
    this._color = color;
    this.queue.push(this.commands.color);
    var rgb = this._color.getNormalizedRGB();
    this.queue.push(rgb[0]);
    this.queue.push(rgb[1]);
    this.queue.push(rgb[2]);
    return this;
};

/**
* Returns the current color.

* @method getColor
* @returns {Color} Color.
*/
Light.prototype.getColor = function getColor(option) {
    return this._color;
};

/**
* Sends draw commands to the renderer
*
* @private
* @method onUpdate
*/
Light.prototype.onUpdate = function clean() {
    var path = this._node.getLocation();

    this._node
        .sendDrawCommand('WITH')
        .sendDrawCommand(path);

    var i = this.queue.length;
    while (i--) {
        this._node.sendDrawCommand(this.queue.shift());
    }

    if (this._color && this._color.isActive()) {
        this._node.sendDrawCommand(this.commands.color);
        var rgb = this._color.getNormalizedRGB();
        this._node.sendDrawCommand(rgb[0]);
        this._node.sendDrawCommand(rgb[1]);
        this._node.sendDrawCommand(rgb[2]);
        this._node.requestUpdateOnNextTick(this._id);
    } else {
        this._requestingUpdate = false;
    }
};

module.exports = Light;

},{}],392:[function(require,module,exports){
'use strict';

var Light = require('./Light');

/**
 * PointLight extends the functionality of Light. PointLight is a light source
 * that emits light in all directions from a point in space.
 *
 * @class PointLight
 * @constructor
 * @component
 * @param {LocalDispatch} dispatch LocalDispatch to be retrieved
 * from the corresponding Render Node
 */
function PointLight(node) {
    Light.call(this, node);
    this.commands.position = 'GL_LIGHT_POSITION';
    this.onTransformChange(node.getTransform());
};

/**
* Returns the definition of the Class: 'PointLight'
*
* @method toString
* @return {string} definition
*/
PointLight.toString = function toString() {
    return 'PointLight';
};

/**
 * Extends Light constructor
 */
PointLight.prototype = Object.create(Light.prototype);

/**
 * Sets PointLight as the constructor
 */
PointLight.prototype.constructor = PointLight;

/**
 * Receives transform change updates from the scene graph.
 *
 * @private
 */
PointLight.prototype.onTransformChange = function onTransformChange (transform) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }
    this.queue.push(this.commands.position);
    this.queue.push(transform[12]);
    this.queue.push(transform[13]);
    this.queue.push(transform[14]);
};

module.exports = PointLight;

},{"./Light":391}],393:[function(require,module,exports){
arguments[4][272][0].apply(exports,arguments)
},{"dup":272}],394:[function(require,module,exports){
arguments[4][273][0].apply(exports,arguments)
},{"dup":273}],395:[function(require,module,exports){
arguments[4][274][0].apply(exports,arguments)
},{"dup":274,"glslify":393,"glslify/simple-adapter.js":394}],396:[function(require,module,exports){
'use strict';

var FamousPlatform = require('famous');
var Size = FamousPlatform.components.Size;
var Position = FamousPlatform.components.Position;
var Rotation = FamousPlatform.components.Rotation;
var Align = FamousPlatform.components.Align;
var Origin = FamousPlatform.components.Origin;
var MountPoint = FamousPlatform.components.MountPoint;
var DOMElement = FamousPlatform.domRenderables.DOMElement;
var PhysicsEngine = FamousPlatform.physics.PhysicsEngine;
var Famous = FamousPlatform.core.Famous;
var Clock = Famous.getClock();
var physics = FamousPlatform.physics;
var math = FamousPlatform.math;
var UIEventHandler = FamousPlatform.components.UIEventHandler;
var Collision = physics.Collision;
var Box = physics.Box;
var Vec3 = math.Vec3;
var Wall = physics.Wall;
var Gravity = physics.Gravity1D;
var Transitionable = FamousPlatform.transitions.Transitionable;
var audio = new Audio('./sounds/plasma.mp3');

function Game(node) {
  this.simulation = new PhysicsEngine();
  this.node = node;
  this.mainBgPos = 0;

  this.mainEl = new DOMElement(this.node, {
    properties: {
      'background-image': 'url(./images/city2.png)',
      // 'background-color': 'teal',
      'background-repeat': 'repeat-x',
      'background-position': 'center',
      'background-position': '10px'
    }
  });

  this.currentEvent = null;
  this.stepsAmount = null;
  this.eventDuration = null;
  this.timer = 0;
  this.score = 0;

  this.bullets = [];
  this.enemies = [];

  //update the physics engine
  var updater = {
    onUpdate: (function (t) {
      this.simulation.update(t);
      this.update();
      Famous.requestUpdateOnNextTick(updater);
    }).bind(this)
  };

  Famous.requestUpdateOnNextTick(updater);

  _createKeyEvents.call(this);
  _createPlayer.call(this);
  _createTitles.call(this);
  _createBodies.call(this);

  createEnemy.call(this);
  createEnemy.call(this);
  createEnemy.call(this);
  createEnemy.call(this);

  var sizer = new Size(node);
  sizer.onSizeChange = (function (size) {
    this.mainHeight = size[0];
    this.mainWidth = size[1]
    // this.wall3.setPosition(this.mainWidth,0,0);
    // this.wall4.setPosition(0,this.mainHeight,0)

    ;
  }).bind(this);
}

Game.prototype.update = function () {

  //loop through bullet views and update to corresponding box in PE
  if (this.bullets.length > 0) {
    for (var i = 0; i < this.bullets.length; i++) {
      var bulletPosition = this.simulation.getTransform(this.bullets[i][0]).position;
      this.bullets[i][1].set(bulletPosition[0], bulletPosition[1], 2);
    }
  }

  //loop through enemies and update to corresponding box in PE
  if (this.enemies.length > 0) {
    for (var i = 0; i < this.enemies.length; i++) {
      var enemyPosition = this.simulation.getTransform(this.enemies[i][0]).position;
      this.enemies[i][1].set(enemyPosition[0], enemyPosition[1], 0);
    }
  }

  //box that updates player
  var boxTransform = this.simulation.getTransform(this.box).position;
  var x = boxTransform[0];
  var y = boxTransform[1];
  var z = boxTransform[2];

  this.player.position.set(x, y, z);

  //starts the sprite animations when a new event is called
  if (this.currentEvent !== null) {

    this.timer++;

    //calls sprite frame on 'this.eventDuration' intervals
    if (this.timer % this.eventDuration === 0) {
      this.currentEvent.call(this);
      this.player.currentStep++;
    }

    //reset to defaults when sprite animation is finished
    if (this.player.currentStep > this.stepsAmount) {
      this.currentEvent = null;
      this.timer = 0;
      this.player.currentStep = 0;
      this.player.backgroundPosition = 0;
      this.player.jumping = false;
    }
  }
};

function _createKeyEvents() {
  //hack until figure out keydown event
  window.addEventListener('keydown', (function (e) {

    //up
    if (e.which === 38) {
      initEvent.call(this, 13, 6, Jump);
    }

    //left
    if (e.which === 37) {
      initEvent.call(this, 13, 4, moveLeft);
    }
    //right
    if (e.which === 39) {
      initEvent.call(this, 13, 4, moveRight);
    }

    //spacebar
    if (e.which === 32) {
      console.log('pew');

      initEvent.call(this, 7, 5, shoot);
      new Audio('./sounds/plasma.mp3').play();
      createBullet.call(this);
    }
  }).bind(this));
}

function _createPlayer() {
  //player
  var playerNode = this.node.addChild();

  this.player = {
    node: playerNode,
    el: new DOMElement(playerNode),
    health: 50,
    currentStep: 0,
    backgroundPosition: 0,
    direction: 'right',
    movement: [],
    jumping: false,
    size: new Size(playerNode),
    position: new Position(playerNode),
    mountpoint: new MountPoint(playerNode)
  };

  this.player.el.setProperty('background-image', 'url(./images/vctrmanidle.png)');
  //size and center player
  this.player.size.setMode(1, 1);
  this.player.size.setAbsolute(96, 96);
  this.player.mountpoint.set(0.5, 0.5);
}

function _createTitles() {
  //titles
  var titles = this.node.addChild();
  this.titles = {
    align: new Align(titles),
    size: new Size(titles),
    el: new DOMElement(titles)
  };
  //size and set title
  this.titles.align.set(0.01, 0.01);
  this.titles.size.setMode(1, 1);
  this.titles.size.setAbsolute(150, 50);
  this.titles.el.setContent('score: ' + this.score + ' health: ' + this.player.health);
  this.titles.el.setProperty('color', 'white');
}

function _createBodies() {

  //create box for player
  this.box = new Box({
    size: [90, 90, 50],
    mass: 10,
    restrictions: ['z'],
    position: new Vec3(500, 50, 0)
  });

  //id player for collision events
  this.box.player = true;

  //set up boundaries
  this.wall1 = new Wall({ direction: physics.Wall.RIGHT, restitution: 5, friction: 2 });
  this.wall2 = new Wall({ direction: physics.Wall.DOWN, restitution: 5, friction: 2 });
  this.wall3 = new Wall({ direction: physics.Wall.LEFT, restitution: 5, friction: 2 });
  this.wall4 = new Wall({ direction: physics.Wall.UP, restitution: 5, friction: 2 });

  //best practice here for width/height?
  this.wall3.setPosition(window.innerWidth, 0, 0);
  this.wall4.setPosition(0, window.innerHeight, 0);

  this.gravity = new Gravity([this.box]);
  this.enemyCollision = new Collision([this.wall1, this.wall2, this.wall3, this.wall4]);

  this.collision = new Collision([this.box, this.wall1, this.wall2, this.wall3, this.wall4]);
  this.simulation.add(this.gravity, this.box, this.collision, this.enemyCollision);
}

function createEnemy() {

  var enemy = new Box({
    size: [90, 90, 50],
    mass: 50,
    restrictions: ['z'],
    position: new Vec3(Math.random() * window.innerWidth, -200, 0)
  });

  //id as enemy for collision events
  enemy.enemy = true;

  var enemyNode = this.node.addChild();
  //this.gravity.addTarget(enemy)
  this.simulation.addBody(enemy, this.gravity);
  //better implementation?
  //add el to enemy so we can modify it in bullet collision
  enemy.enemyEl = new DOMElement(enemyNode);
  var enemyPosition = new Position(enemyNode);
  var enemySize = new Size(enemyNode);
  var enemyMountPoint = new MountPoint(enemyNode);
  //enemy.enemyEl.setProperty('background-color', 'red')
  enemySize.setMode(1, 1, 0);
  enemySize.setAbsolute(90, 90, 0);
  enemyMountPoint.set(0.5, 0.5);
  enemyPosition.set(10, 10);
  this.collision.addTarget(enemy);
  this.enemyCollision.addTarget(enemy);
  this.enemies.push([enemy, enemyPosition]);
  enemy.enemyEl.setContent('<img src="./images/live.gif" />');

  //enemy collision event
  enemy.events.on('collision:start', (function (e) {
    //if collided with a player
    if (e.bodyA.player || e.bodyB.player) {
      //decrease health
      this.player.health--;

      //console.log('ouch', this.player.health)
      //update scoreboard
      //this.titles.el.setContent('score: '+this.score+ ' health: '+ this.player.health)

      //alert if no more health
    }
  }).bind(this));
}

function createBullet() {

  //init position of bullet
  var boxTransform = this.simulation.getTransform(this.box).position;
  var x = boxTransform[0] + 10;
  var y = boxTransform[1];

  var bullet = new Box({
    size: [10, 10, 50],
    mass: 110,
    restrictions: ['z'],
    position: new Vec3(x, y, 0)
  });

  //id as bullet for checking collision events
  bullet.bullet = true;

  this.enemyCollision.addTarget(bullet);
  this.simulation.addBody(bullet);

  var bulletShell = this.node.addChild();
  var bulletEl = new DOMElement(bulletShell);
  var bulletPosition = new Position(bulletShell);
  var bulletSize = new Size(bulletShell);
  bulletEl.setProperty('background-color', 'rgba(228, 240, 253, 0.76)');
  bulletEl.setProperty('border-radius', '50%');
  bulletEl.setProperty('box-shadow', '0px 0px 10px rgb(228, 240, 253)');
  bulletSize.setMode(1, 1, 1);
  bulletSize.setAbsolute(10, 10, 10);

  this.bullets.push([bullet, bulletPosition]);

  //set velocity based on player direction

  if (this.player.direction === 'left') {
    bullet.setVelocity(-1000, 0, 0);
  }

  if (this.player.direction === 'right') {
    bullet.setVelocity(1000, 0, 0);
  }

  this.collided = false;
  //bullet collision events
  bullet.events.on('collision:start', (function (e) {
    //check if collided body is an enemy
    if (e.bodyA.enemy) {
      this.score++;

      //on hit update score and change enemy image to dead
      //var updatedScore = 'score: '+this.score+ ' health: '+ this.player.health
      //console.log(updatedScore, this.titles.el.setContent(updatedScore))
      //this.titles.el.setContent()
      e.bodyA.enemyEl.setContent('<img src="./images/dead.png" />');
      //only play sound on bullet's first hit
      if (!this.collided) {
        new Audio('./sounds/hit.mp3').play();
        this.collided = true;
      }
    }
  }).bind(this));
}

//makes sure events aren't called twice
function initEvent(steps, duration, callback) {

  if (this.currentEvent !== callback) {
    this.player.currentStep = 0;
    this.currentEvent = callback;
    this.stepsAmount = steps;
    this.eventDuration = duration;
  }
}

function shoot() {

  //shoot right and not jumping sprite
  if (this.player.direction === 'right' && !this.player.jumping) {
    //move sprite frame
    if (this.player.currentStep > 0 && this.player.currentStep <= 7) {
      this.player.backgroundPosition -= 168;
      var num = this.player.backgroundPosition;
      this.player.el.setProperty('background-position', num + 'px');
    }
    //init sprite
    if (this.player.currentStep === 0 && !this.player.jumping) {
      this.player.size.setMode(1, 1);
      this.player.size.setAbsolute(168, 96);
      this.player.el.setProperty('background-position', 0 + 'px');
      this.player.el.setProperty('background-image', 'url(./images/shootRight.png)');
      this.player.backgroundPosition = 0;
    }
  }

  //shoot left and not jumping sprite
  if (this.player.direction === 'left' && !this.player.jumping) {
    //move sprite frame
    if (this.player.currentStep > 0 && this.player.currentStep <= 7) {
      this.player.backgroundPosition += 168;
      var num = this.player.backgroundPosition;
      this.player.el.setProperty('background-position', num + 'px');
    }
    //init sprite
    if (this.player.currentStep === 0 && !this.player.jumping) {
      this.player.size.setMode(1, 1);
      this.player.size.setAbsolute(168, 96);
      this.player.backgroundPosition = 168;
      this.player.el.setProperty('background-image', 'url(./images/shootLeft.png)');
      this.player.el.setProperty('background-position', 168 + 'px');
    }
  }

  //shoot right and jumping sprite
  if (this.player.direction === 'right' && this.player.jumping) {
    //move sprite frame
    if (this.player.currentStep > 1 && this.player.currentStep <= 7) {
      this.player.backgroundPosition -= 185;
      var num = this.player.backgroundPosition;
      this.player.el.setProperty('background-position', num + 'px');
    }
    //init sprite
    if (this.player.currentStep === 0 && this.player.jumping) {
      this.player.backgroundPosition = 0;
      this.player.size.setMode(1, 1);
      this.player.size.setAbsolute(185, 100);
      this.player.el.setProperty('background-position', 4 + 'px');
      this.player.el.setProperty('background-image', 'url(./images/jumpShootRight.png)');
      this.player.jumping = true;
    }
  }

  //shoot left and jumping sprite
  if (this.player.direction === 'left' && this.player.jumping) {
    //move sprite frame
    if (this.player.currentStep > 1 && this.player.currentStep <= 7) {
      this.player.backgroundPosition += 185;
      var num = this.player.backgroundPosition;
      this.player.el.setProperty('background-position', num + 'px');
    }
    //init sprite
    if (this.player.currentStep === 0 && this.player.jumping) {
      this.player.backgroundPosition = 185;
      this.player.size.setMode(1, 1);
      this.player.size.setAbsolute(185, 100);
      this.player.el.setProperty('background-position', 185 + 'px');
      this.player.el.setProperty('background-image', 'url(./images/jumpShootLeft.png)');
      this.player.jumping = true;
    }
  }
}

function moveRight() {
  var bgpos = this.mainBgPos -= 1;
  this.mainEl.setProperty('background-position', bgpos + 'px');

  this.player.direction = 'right';
  //do not start moverRight sprite if jumping
  if (!this.player.jumping) {
    //move sprite frame
    if (this.player.currentStep > 0 && this.player.currentStep <= 14) {
      this.player.backgroundPosition -= 96;
      var num = this.player.backgroundPosition;
      this.player.el.setProperty('background-position', num + 'px');
    }
    //init move right sprite
    if (this.player.currentStep === 0) {
      this.player.el.setProperty('background-image', 'url(./images/moveRight.png)');
      this.player.backgroundPosition = 0;
      this.player.size.setMode(1, 1);
      this.player.size.setAbsolute(96, 96);
      this.player.el.setProperty('background-position', 0 + 'px');
    }
  }
  this.box.setVelocity(50, this.box.getVelocity()[1], this.box.getVelocity()[2]);
}

function moveLeft() {
  var bgpos = this.mainBgPos += 1;
  this.mainEl.setProperty('background-position', bgpos + 'px');
  this.player.direction = 'left';
  //do not start moveLeft sprite if jumping
  if (!this.player.jumping) {
    //move sprite frame
    if (this.player.currentStep > 0 && this.player.currentStep <= 14) {
      this.player.backgroundPosition += 96;
      var num = this.player.backgroundPosition;
      this.player.el.setProperty('background-position', num + 'px');
    }
    //init move left sprite
    if (this.player.currentStep === 0) {
      this.player.el.setProperty('background-image', 'url(./images/moveLeft.png)');
      this.player.backgroundPosition = 0;
      this.player.size.setMode(1, 1);
      this.player.size.setAbsolute(96, 96);
      this.player.el.setProperty('background-position', 0 + 'px');
    }
  }
  this.box.setVelocity(-100, this.box.getVelocity()[1], this.box.getVelocity()[2]);
}

function Jump() {
  this.player.jumping = true;
  //right jump
  if (this.player.direction === 'right') {
    //move sprite frame
    if (this.player.currentStep > 0 && this.player.currentStep <= 13) {
      this.player.backgroundPosition -= 96;
      var num = this.player.backgroundPosition;
      this.player.el.setProperty('background-position', num + 'px');
    }
    //init jump right sprite    
    if (this.player.currentStep === 0) {
      this.player.el.setProperty('background-image', 'url(./images/jumpRight.png)');
      this.player.size.setMode(1, 1);
      this.player.size.setAbsolute(96, 96);
      this.player.backgroundPosition = 0;
      this.player.el.setProperty('background-position', 0 + 'px');
    }
  }
  //left jump
  if (this.player.direction === 'left') {
    //move sprite frame
    if (this.player.currentStep > 0 && this.player.currentStep <= 13) {
      this.player.backgroundPosition += 96;
      var num = this.player.backgroundPosition;
      this.player.el.setProperty('background-position', num + 'px');
    }
    //init jump left sprite   
    if (this.player.currentStep === 0) {
      this.player.el.setProperty('background-image', 'url(./images/jumpLeft.png)');
      this.player.size.setMode(1, 1);
      this.player.size.setAbsolute(96, 96);
      this.player.backgroundPosition = 0;
      this.player.el.setProperty('background-position', 0 + 'px');
    }
  }
  this.box.setVelocity(this.box.getVelocity()[0], -80, this.box.getVelocity()[2]);
}

module.exports = Game;
//this.enemyCollision = new Collision()

},{"famous":1}],397:[function(require,module,exports){
'use strict';

var FamousPlatform = require('famous');
var Compositor = FamousPlatform.renderers.Compositor;
var ThreadManager = FamousPlatform.renderers.ThreadManager;
var Engine = FamousPlatform.engine;
var DOMElement = FamousPlatform.domRenderables.DOMElement;
var Famous = FamousPlatform.core.Famous;

// Boilerplate
var compositor = new Compositor();
var threadmanger = new ThreadManager(Famous, compositor);
var engine = new Engine();
engine.update(threadmanger);

// App Code
var context = Famous.createContext();
var root = context.addChild();

var Game = require('./Game');
var game = new Game(root);

},{"./Game":396,"famous":1}]},{},[397])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1wYWNrL19wcmVsdWRlLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1jb21wb25lbnRzL25vZGVfbW9kdWxlcy9mYW1vdXMtY29yZS9zcmMvQ2xvY2suanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtY29tcG9uZW50cy9ub2RlX21vZHVsZXMvZmFtb3VzLWNvcmUvc3JjL0NvbnRleHQuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtY29tcG9uZW50cy9ub2RlX21vZHVsZXMvZmFtb3VzLWNvcmUvc3JjL0Rpc3BhdGNoLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL2ZhbW91cy1jb3JlL3NyYy9FdmVudC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1jb21wb25lbnRzL25vZGVfbW9kdWxlcy9mYW1vdXMtY29yZS9zcmMvRmFtb3VzLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL2ZhbW91cy1jb3JlL3NyYy9Ob2RlLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL2ZhbW91cy1jb3JlL3NyYy9TaXplLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL2ZhbW91cy1jb3JlL3NyYy9UcmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtY29tcG9uZW50cy9ub2RlX21vZHVsZXMvZmFtb3VzLWNvcmUvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL2ZhbW91cy1tYXRoL3NyYy9NYXQzMy5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1jb21wb25lbnRzL25vZGVfbW9kdWxlcy9mYW1vdXMtbWF0aC9zcmMvUXVhdGVybmlvbi5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1jb21wb25lbnRzL25vZGVfbW9kdWxlcy9mYW1vdXMtbWF0aC9zcmMvVmVjMi5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1jb21wb25lbnRzL25vZGVfbW9kdWxlcy9mYW1vdXMtbWF0aC9zcmMvVmVjMy5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1jb21wb25lbnRzL25vZGVfbW9kdWxlcy9mYW1vdXMtbWF0aC9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtY29tcG9uZW50cy9ub2RlX21vZHVsZXMvZmFtb3VzLXRyYW5zaXRpb25zL3NyYy9DdXJ2ZXMuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtY29tcG9uZW50cy9ub2RlX21vZHVsZXMvZmFtb3VzLXRyYW5zaXRpb25zL3NyYy9UcmFuc2l0aW9uYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1jb21wb25lbnRzL25vZGVfbW9kdWxlcy9mYW1vdXMtdHJhbnNpdGlvbnMvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL2ZhbW91cy11dGlsaXRpZXMvbm9kZV9tb2R1bGVzL2ZhbW91cy10cmFuc2l0aW9ucy9zcmMvQ3VydmVzLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL2ZhbW91cy11dGlsaXRpZXMvbm9kZV9tb2R1bGVzL2ZhbW91cy10cmFuc2l0aW9ucy9zcmMvRWFzaW5nLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL2ZhbW91cy11dGlsaXRpZXMvbm9kZV9tb2R1bGVzL2ZhbW91cy10cmFuc2l0aW9ucy9zcmMvVHJhbnNpdGlvbmFibGUuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtY29tcG9uZW50cy9ub2RlX21vZHVsZXMvZmFtb3VzLXV0aWxpdGllcy9ub2RlX21vZHVsZXMvZmFtb3VzLXRyYW5zaXRpb25zL3NyYy9hZnRlci5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1jb21wb25lbnRzL25vZGVfbW9kdWxlcy9mYW1vdXMtdXRpbGl0aWVzL25vZGVfbW9kdWxlcy9mYW1vdXMtdHJhbnNpdGlvbnMvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL2ZhbW91cy11dGlsaXRpZXMvc3JjL0NhbGxiYWNrU3RvcmUuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtY29tcG9uZW50cy9ub2RlX21vZHVsZXMvZmFtb3VzLXV0aWxpdGllcy9zcmMvQ29sb3IuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtY29tcG9uZW50cy9ub2RlX21vZHVsZXMvZmFtb3VzLXV0aWxpdGllcy9zcmMvS2V5Q29kZXMuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtY29tcG9uZW50cy9ub2RlX21vZHVsZXMvZmFtb3VzLXV0aWxpdGllcy9zcmMvTWV0aG9kU3RvcmUuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtY29tcG9uZW50cy9ub2RlX21vZHVsZXMvZmFtb3VzLXV0aWxpdGllcy9zcmMvT2JqZWN0TWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1jb21wb25lbnRzL25vZGVfbW9kdWxlcy9mYW1vdXMtdXRpbGl0aWVzL3NyYy9jbG9uZS5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1jb21wb25lbnRzL25vZGVfbW9kdWxlcy9mYW1vdXMtdXRpbGl0aWVzL3NyYy9mbGF0Q2xvbmUuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtY29tcG9uZW50cy9ub2RlX21vZHVsZXMvZmFtb3VzLXV0aWxpdGllcy9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtY29tcG9uZW50cy9ub2RlX21vZHVsZXMvZmFtb3VzLXV0aWxpdGllcy9zcmMva2V5VmFsdWVUb0FycmF5cy5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1jb21wb25lbnRzL25vZGVfbW9kdWxlcy9mYW1vdXMtdXRpbGl0aWVzL3NyYy9sb2FkVVJMLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLWNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL2ZhbW91cy11dGlsaXRpZXMvc3JjL3N0cmlwLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLWNvbXBvbmVudHMvc3JjL0FsaWduLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLWNvbXBvbmVudHMvc3JjL0NhbWVyYS5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1jb21wb25lbnRzL3NyYy9FdmVudEVtaXR0ZXIuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtY29tcG9uZW50cy9zcmMvRXZlbnRIYW5kbGVyLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLWNvbXBvbmVudHMvc3JjL0dlc3R1cmVIYW5kbGVyLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLWNvbXBvbmVudHMvc3JjL01vdW50UG9pbnQuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtY29tcG9uZW50cy9zcmMvT3BhY2l0eS5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1jb21wb25lbnRzL3NyYy9PcmlnaW4uanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtY29tcG9uZW50cy9zcmMvUG9zaXRpb24uanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtY29tcG9uZW50cy9zcmMvUm90YXRpb24uanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtY29tcG9uZW50cy9zcmMvU2NhbGUuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtY29tcG9uZW50cy9zcmMvU2l6ZS5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1jb21wb25lbnRzL3NyYy9UcmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtY29tcG9uZW50cy9zcmMvVUlFdmVudEhhbmRsZXIuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtY29tcG9uZW50cy9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtZG9tLXJlbmRlcmFibGVzL3NyYy9ET01FbGVtZW50LmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLWRvbS1yZW5kZXJhYmxlcy9zcmMvSFRNTEVsZW1lbnQuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtZG9tLXJlbmRlcmFibGVzL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2ZhbW91cy1wb2x5ZmlsbHMvc3JjL2FuaW1hdGlvbkZyYW1lLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLWVuZ2luZS9ub2RlX21vZHVsZXMvZmFtb3VzLXBvbHlmaWxscy9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtZW5naW5lL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1waHlzaWNzL3NyYy9HZW9tZXRyeS5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1waHlzaWNzL3NyYy9QaHlzaWNzRW5naW5lLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXBoeXNpY3Mvc3JjL2JvZGllcy9Cb3guanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtcGh5c2ljcy9zcmMvYm9kaWVzL0NvbnZleEJvZHlGYWN0b3J5LmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXBoeXNpY3Mvc3JjL2JvZGllcy9QYXJ0aWNsZS5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1waHlzaWNzL3NyYy9ib2RpZXMvU3BoZXJlLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXBoeXNpY3Mvc3JjL2JvZGllcy9XYWxsLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXBoeXNpY3Mvc3JjL2NvbnN0cmFpbnRzL0FuZ2xlLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXBoeXNpY3Mvc3JjL2NvbnN0cmFpbnRzL0NvbGxpc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1waHlzaWNzL3NyYy9jb25zdHJhaW50cy9Db25zdHJhaW50LmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXBoeXNpY3Mvc3JjL2NvbnN0cmFpbnRzL0N1cnZlLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXBoeXNpY3Mvc3JjL2NvbnN0cmFpbnRzL0RpcmVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1waHlzaWNzL3NyYy9jb25zdHJhaW50cy9EaXN0YW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1waHlzaWNzL3NyYy9jb25zdHJhaW50cy9IaW5nZS5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1waHlzaWNzL3NyYy9jb25zdHJhaW50cy9Qb2ludDJQb2ludC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1waHlzaWNzL3NyYy9jb25zdHJhaW50cy9jb2xsaXNpb24vQUFCQi5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1waHlzaWNzL3NyYy9jb25zdHJhaW50cy9jb2xsaXNpb24vQnJ1dGVGb3JjZS5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1waHlzaWNzL3NyYy9jb25zdHJhaW50cy9jb2xsaXNpb24vQ29udGFjdE1hbmlmb2xkLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXBoeXNpY3Mvc3JjL2NvbnN0cmFpbnRzL2NvbGxpc2lvbi9Db252ZXhDb2xsaXNpb25EZXRlY3Rpb24uanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtcGh5c2ljcy9zcmMvY29uc3RyYWludHMvY29sbGlzaW9uL1N3ZWVwQW5kUHJ1bmUuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtcGh5c2ljcy9zcmMvZm9yY2VzL0RyYWcuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtcGh5c2ljcy9zcmMvZm9yY2VzL0ZvcmNlLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXBoeXNpY3Mvc3JjL2ZvcmNlcy9HcmF2aXR5MUQuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtcGh5c2ljcy9zcmMvZm9yY2VzL0dyYXZpdHkzRC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1waHlzaWNzL3NyYy9mb3JjZXMvUm90YXRpb25hbERyYWcuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtcGh5c2ljcy9zcmMvZm9yY2VzL1JvdGF0aW9uYWxTcHJpbmcuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtcGh5c2ljcy9zcmMvZm9yY2VzL1NwcmluZy5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1waHlzaWNzL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1yZW5kZXJlcnMvbm9kZV9tb2R1bGVzL2ZhbW91cy1jb21wb25lbnRzL25vZGVfbW9kdWxlcy9mYW1vdXMtY29yZS9zcmMvTm9kZS5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1yZW5kZXJlcnMvbm9kZV9tb2R1bGVzL2ZhbW91cy1kb20tcmVuZGVyZXJzL3NyYy9ET01SZW5kZXJlci5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1yZW5kZXJlcnMvbm9kZV9tb2R1bGVzL2ZhbW91cy1kb20tcmVuZGVyZXJzL3NyYy9FbGVtZW50Q2FjaGUuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtcmVuZGVyZXJzL25vZGVfbW9kdWxlcy9mYW1vdXMtZG9tLXJlbmRlcmVycy9zcmMvTWF0aC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1yZW5kZXJlcnMvbm9kZV9tb2R1bGVzL2ZhbW91cy1kb20tcmVuZGVyZXJzL3NyYy9WZW5kb3JQcmVmaXguanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtcmVuZGVyZXJzL25vZGVfbW9kdWxlcy9mYW1vdXMtZG9tLXJlbmRlcmVycy9zcmMvZXZlbnRzL0NvbXBvc2l0aW9uRXZlbnQuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtcmVuZGVyZXJzL25vZGVfbW9kdWxlcy9mYW1vdXMtZG9tLXJlbmRlcmVycy9zcmMvZXZlbnRzL0V2ZW50LmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXJlbmRlcmVycy9ub2RlX21vZHVsZXMvZmFtb3VzLWRvbS1yZW5kZXJlcnMvc3JjL2V2ZW50cy9FdmVudE1hcC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1yZW5kZXJlcnMvbm9kZV9tb2R1bGVzL2ZhbW91cy1kb20tcmVuZGVyZXJzL3NyYy9ldmVudHMvRm9jdXNFdmVudC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1yZW5kZXJlcnMvbm9kZV9tb2R1bGVzL2ZhbW91cy1kb20tcmVuZGVyZXJzL3NyYy9ldmVudHMvSW5wdXRFdmVudC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1yZW5kZXJlcnMvbm9kZV9tb2R1bGVzL2ZhbW91cy1kb20tcmVuZGVyZXJzL3NyYy9ldmVudHMvS2V5Ym9hcmRFdmVudC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1yZW5kZXJlcnMvbm9kZV9tb2R1bGVzL2ZhbW91cy1kb20tcmVuZGVyZXJzL3NyYy9ldmVudHMvTW91c2VFdmVudC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1yZW5kZXJlcnMvbm9kZV9tb2R1bGVzL2ZhbW91cy1kb20tcmVuZGVyZXJzL3NyYy9ldmVudHMvVG91Y2hFdmVudC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1yZW5kZXJlcnMvbm9kZV9tb2R1bGVzL2ZhbW91cy1kb20tcmVuZGVyZXJzL3NyYy9ldmVudHMvVUlFdmVudC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1yZW5kZXJlcnMvbm9kZV9tb2R1bGVzL2ZhbW91cy1kb20tcmVuZGVyZXJzL3NyYy9ldmVudHMvV2hlZWxFdmVudC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1yZW5kZXJlcnMvbm9kZV9tb2R1bGVzL2ZhbW91cy1kb20tcmVuZGVyZXJzL3NyYy9ldmVudHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtcmVuZGVyZXJzL25vZGVfbW9kdWxlcy9mYW1vdXMtZG9tLXJlbmRlcmVycy9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtcmVuZGVyZXJzL25vZGVfbW9kdWxlcy9mYW1vdXMtd2ViZ2wtcmVuZGVyZXJzL25vZGVfbW9kdWxlcy9mYW1vdXMtd2ViZ2wtZ2VvbWV0cmllcy9zcmMvRHluYW1pY0dlb21ldHJ5LmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXJlbmRlcmVycy9ub2RlX21vZHVsZXMvZmFtb3VzLXdlYmdsLXJlbmRlcmVycy9ub2RlX21vZHVsZXMvZmFtb3VzLXdlYmdsLWdlb21ldHJpZXMvc3JjL0dlb21ldHJ5LmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXJlbmRlcmVycy9ub2RlX21vZHVsZXMvZmFtb3VzLXdlYmdsLXJlbmRlcmVycy9ub2RlX21vZHVsZXMvZmFtb3VzLXdlYmdsLWdlb21ldHJpZXMvc3JjL0dlb21ldHJ5SGVscGVyLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXJlbmRlcmVycy9ub2RlX21vZHVsZXMvZmFtb3VzLXdlYmdsLXJlbmRlcmVycy9ub2RlX21vZHVsZXMvZmFtb3VzLXdlYmdsLWdlb21ldHJpZXMvc3JjL09CSkxvYWRlci5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1yZW5kZXJlcnMvbm9kZV9tb2R1bGVzL2ZhbW91cy13ZWJnbC1yZW5kZXJlcnMvbm9kZV9tb2R1bGVzL2ZhbW91cy13ZWJnbC1nZW9tZXRyaWVzL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1yZW5kZXJlcnMvbm9kZV9tb2R1bGVzL2ZhbW91cy13ZWJnbC1yZW5kZXJlcnMvbm9kZV9tb2R1bGVzL2ZhbW91cy13ZWJnbC1nZW9tZXRyaWVzL3NyYy9wcmltaXRpdmVzL0JveC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1yZW5kZXJlcnMvbm9kZV9tb2R1bGVzL2ZhbW91cy13ZWJnbC1yZW5kZXJlcnMvbm9kZV9tb2R1bGVzL2ZhbW91cy13ZWJnbC1nZW9tZXRyaWVzL3NyYy9wcmltaXRpdmVzL0NpcmNsZS5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1yZW5kZXJlcnMvbm9kZV9tb2R1bGVzL2ZhbW91cy13ZWJnbC1yZW5kZXJlcnMvbm9kZV9tb2R1bGVzL2ZhbW91cy13ZWJnbC1nZW9tZXRyaWVzL3NyYy9wcmltaXRpdmVzL0N5bGluZGVyLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXJlbmRlcmVycy9ub2RlX21vZHVsZXMvZmFtb3VzLXdlYmdsLXJlbmRlcmVycy9ub2RlX21vZHVsZXMvZmFtb3VzLXdlYmdsLWdlb21ldHJpZXMvc3JjL3ByaW1pdGl2ZXMvR2VvZGVzaWNTcGhlcmUuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtcmVuZGVyZXJzL25vZGVfbW9kdWxlcy9mYW1vdXMtd2ViZ2wtcmVuZGVyZXJzL25vZGVfbW9kdWxlcy9mYW1vdXMtd2ViZ2wtZ2VvbWV0cmllcy9zcmMvcHJpbWl0aXZlcy9JY29zYWhlZHJvbi5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1yZW5kZXJlcnMvbm9kZV9tb2R1bGVzL2ZhbW91cy13ZWJnbC1yZW5kZXJlcnMvbm9kZV9tb2R1bGVzL2ZhbW91cy13ZWJnbC1nZW9tZXRyaWVzL3NyYy9wcmltaXRpdmVzL1BhcmFtZXRyaWNDb25lLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXJlbmRlcmVycy9ub2RlX21vZHVsZXMvZmFtb3VzLXdlYmdsLXJlbmRlcmVycy9ub2RlX21vZHVsZXMvZmFtb3VzLXdlYmdsLWdlb21ldHJpZXMvc3JjL3ByaW1pdGl2ZXMvUGxhbmUuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtcmVuZGVyZXJzL25vZGVfbW9kdWxlcy9mYW1vdXMtd2ViZ2wtcmVuZGVyZXJzL25vZGVfbW9kdWxlcy9mYW1vdXMtd2ViZ2wtZ2VvbWV0cmllcy9zcmMvcHJpbWl0aXZlcy9TcGhlcmUuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtcmVuZGVyZXJzL25vZGVfbW9kdWxlcy9mYW1vdXMtd2ViZ2wtcmVuZGVyZXJzL25vZGVfbW9kdWxlcy9mYW1vdXMtd2ViZ2wtZ2VvbWV0cmllcy9zcmMvcHJpbWl0aXZlcy9UZXRyYWhlZHJvbi5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1yZW5kZXJlcnMvbm9kZV9tb2R1bGVzL2ZhbW91cy13ZWJnbC1yZW5kZXJlcnMvbm9kZV9tb2R1bGVzL2ZhbW91cy13ZWJnbC1nZW9tZXRyaWVzL3NyYy9wcmltaXRpdmVzL1RvcnVzLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXJlbmRlcmVycy9ub2RlX21vZHVsZXMvZmFtb3VzLXdlYmdsLXJlbmRlcmVycy9ub2RlX21vZHVsZXMvZmFtb3VzLXdlYmdsLWdlb21ldHJpZXMvc3JjL3ByaW1pdGl2ZXMvVHJpYW5nbGUuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtcmVuZGVyZXJzL25vZGVfbW9kdWxlcy9mYW1vdXMtd2ViZ2wtcmVuZGVyZXJzL25vZGVfbW9kdWxlcy9mYW1vdXMtd2ViZ2wtc2hhZGVycy9ub2RlX21vZHVsZXMvZ2xzbGlmeS9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXJlbmRlcmVycy9ub2RlX21vZHVsZXMvZmFtb3VzLXdlYmdsLXJlbmRlcmVycy9ub2RlX21vZHVsZXMvZmFtb3VzLXdlYmdsLXNoYWRlcnMvbm9kZV9tb2R1bGVzL2dsc2xpZnkvc2ltcGxlLWFkYXB0ZXIuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtcmVuZGVyZXJzL25vZGVfbW9kdWxlcy9mYW1vdXMtd2ViZ2wtcmVuZGVyZXJzL25vZGVfbW9kdWxlcy9mYW1vdXMtd2ViZ2wtc2hhZGVycy9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtcmVuZGVyZXJzL25vZGVfbW9kdWxlcy9mYW1vdXMtd2ViZ2wtcmVuZGVyZXJzL3NyYy9CdWZmZXIuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtcmVuZGVyZXJzL25vZGVfbW9kdWxlcy9mYW1vdXMtd2ViZ2wtcmVuZGVyZXJzL3NyYy9CdWZmZXJSZWdpc3RyeS5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1yZW5kZXJlcnMvbm9kZV9tb2R1bGVzL2ZhbW91cy13ZWJnbC1yZW5kZXJlcnMvc3JjL0NoZWNrZXJib2FyZC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1yZW5kZXJlcnMvbm9kZV9tb2R1bGVzL2ZhbW91cy13ZWJnbC1yZW5kZXJlcnMvc3JjL0RlYnVnLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXJlbmRlcmVycy9ub2RlX21vZHVsZXMvZmFtb3VzLXdlYmdsLXJlbmRlcmVycy9zcmMvUHJvZ3JhbS5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1yZW5kZXJlcnMvbm9kZV9tb2R1bGVzL2ZhbW91cy13ZWJnbC1yZW5kZXJlcnMvc3JjL1RleHR1cmUuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtcmVuZGVyZXJzL25vZGVfbW9kdWxlcy9mYW1vdXMtd2ViZ2wtcmVuZGVyZXJzL3NyYy9XZWJHTFJlbmRlcmVyLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXJlbmRlcmVycy9ub2RlX21vZHVsZXMvZmFtb3VzLXdlYmdsLXJlbmRlcmVycy9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtcmVuZGVyZXJzL25vZGVfbW9kdWxlcy9mYW1vdXMtd2ViZ2wtcmVuZGVyZXJzL3NyYy9yYWRpeFNvcnQuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtcmVuZGVyZXJzL3NyYy9Db21wb3NpdG9yLmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXJlbmRlcmVycy9zcmMvQ29udGV4dC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1yZW5kZXJlcnMvc3JjL1RocmVhZE1hbmFnZXIuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtcmVuZGVyZXJzL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1yb3V0ZXIvc3JjL0hpc3RvcnkuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtcm91dGVyL3NyYy9Sb3V0ZXIuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtcm91dGVyL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1zdHlsZXNoZWV0cy9ub2RlX21vZHVsZXMvY3NzaWZ5L2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtc3R5bGVzaGVldHMvc3JjL2ZhbW91cy5jc3MiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtc3R5bGVzaGVldHMvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2ZhbW91cy9ub2RlX21vZHVsZXMvZmFtb3VzLXdlYmdsLW1hdGVyaWFscy9zcmMvTWF0ZXJpYWwuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtd2ViZ2wtbWF0ZXJpYWxzL3NyYy9UZXh0dXJlUmVnaXN0cnkuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtd2ViZ2wtbWF0ZXJpYWxzL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy13ZWJnbC1yZW5kZXJhYmxlcy9zcmMvTWVzaC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy13ZWJnbC1yZW5kZXJhYmxlcy9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtd2ViZ2wtcmVuZGVyYWJsZXMvc3JjL2xpZ2h0cy9BbWJpZW50TGlnaHQuanMiLCJub2RlX21vZHVsZXMvZmFtb3VzL25vZGVfbW9kdWxlcy9mYW1vdXMtd2ViZ2wtcmVuZGVyYWJsZXMvc3JjL2xpZ2h0cy9MaWdodC5qcyIsIm5vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy13ZWJnbC1yZW5kZXJhYmxlcy9zcmMvbGlnaHRzL1BvaW50TGlnaHQuanMiLCIvVXNlcnMvbW9yZ2FudGhlcGxhbnQvQ29kZS9yZWZhY3Rvci92ZWN0ci9zcmMvR2FtZS5qcyIsIi9Vc2Vycy9tb3JnYW50aGVwbGFudC9Db2RlL3JlZmFjdG9yL3ZlY3RyL3NyYy9tYWluLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9JQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNydUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbmVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3poQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2WEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeGRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25WQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Y0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqd0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcmFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ROQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcnVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDclZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDenlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9SQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdGZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQ3pEQSxJQUFJLGNBQWMsR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDdkMsSUFBSSxJQUFJLEdBQUcsY0FBYyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUM7QUFDMUMsSUFBSSxRQUFRLEdBQUcsY0FBYyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUM7QUFDbEQsSUFBSSxRQUFRLEdBQUcsY0FBYyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUM7QUFDbEQsSUFBSSxLQUFLLEdBQUcsY0FBYyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUM7QUFDNUMsSUFBSSxNQUFNLEdBQUcsY0FBYyxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUM7QUFDOUMsSUFBSSxVQUFVLEdBQUcsY0FBYyxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUM7QUFDdEQsSUFBSSxVQUFVLEdBQUcsY0FBYyxDQUFDLGNBQWMsQ0FBQyxVQUFVLENBQUM7QUFDMUQsSUFBSSxhQUFhLEdBQUcsY0FBYyxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUM7QUFDekQsSUFBSSxNQUFNLEdBQUcsY0FBYyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUM7QUFDeEMsSUFBSSxLQUFLLEdBQUcsTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDO0FBQzlCLElBQUksT0FBTyxHQUFHLGNBQWMsQ0FBQyxPQUFPLENBQUM7QUFDckMsSUFBSSxJQUFJLEdBQUcsY0FBYyxDQUFDLElBQUksQ0FBQztBQUMvQixJQUFJLGNBQWMsR0FBRyxjQUFjLENBQUMsVUFBVSxDQUFDLGNBQWMsQ0FBQztBQUM5RCxJQUFJLFNBQVMsR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDO0FBQ2xDLElBQUksR0FBRyxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUM7QUFDdEIsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztBQUNyQixJQUFJLElBQUksR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDO0FBQ3hCLElBQUksT0FBTyxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUE7QUFDL0IsSUFBSSxjQUFjLEdBQUcsY0FBYyxDQUFDLFdBQVcsQ0FBQyxjQUFjLENBQUM7QUFDL0QsSUFBSSxLQUFLLEdBQUcsSUFBSSxLQUFLLENBQUMscUJBQXFCLENBQUMsQ0FBQzs7QUFHN0MsU0FBUyxJQUFJLENBQUMsSUFBSSxFQUFDO0FBQ2pCLE1BQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxhQUFhLEVBQUUsQ0FBQztBQUN0QyxNQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztBQUNqQixNQUFJLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQzs7QUFFbkIsTUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFO0FBQ3RDLGNBQVUsRUFBRTtBQUNWLHdCQUFrQixFQUFFLHlCQUF5Qjs7QUFFN0MseUJBQW1CLEVBQUUsVUFBVTtBQUMvQiwyQkFBcUIsRUFBRSxRQUFRO0FBQy9CLDJCQUFxQixFQUFFLE1BQU07S0FDOUI7R0FDRixDQUFDLENBQUE7O0FBRUYsTUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUM7QUFDekIsTUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUM7QUFDeEIsTUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUM7QUFDMUIsTUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUM7QUFDZixNQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQzs7QUFFZixNQUFJLENBQUMsT0FBTyxHQUFHLEVBQUUsQ0FBQztBQUNsQixNQUFJLENBQUMsT0FBTyxHQUFHLEVBQUUsQ0FBQzs7O0FBR2xCLE1BQUksT0FBTyxHQUFHO0FBQ1osWUFBUSxFQUFFLENBQUEsVUFBUyxDQUFDLEVBQUU7QUFDcEIsVUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUE7QUFDekIsVUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFBO0FBQ2IsWUFBTSxDQUFDLHVCQUF1QixDQUFDLE9BQU8sQ0FBQyxDQUFDO0tBQ3pDLENBQUEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO0dBQ2IsQ0FBQTs7QUFFRCxRQUFNLENBQUMsdUJBQXVCLENBQUMsT0FBTyxDQUFDLENBQUM7O0FBRXhDLGtCQUFnQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQTtBQUMzQixlQUFhLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFBO0FBQ3hCLGVBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUE7QUFDeEIsZUFBYSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQTs7QUFHekIsYUFBVyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQTtBQUNyQixhQUFXLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFBO0FBQ3RCLGFBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUE7QUFDdEIsYUFBVyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQTs7QUFFdEIsTUFBSSxLQUFLLEdBQUcsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUE7QUFDMUIsT0FBSyxDQUFDLFlBQVksR0FBRyxDQUFBLFVBQVMsSUFBSSxFQUFDO0FBQ2pDLFFBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFBO0FBQ3pCLFFBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQzs7OztBQUFBLEtBQUE7R0FJekIsQ0FBQSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQTtDQUliOztBQUVELElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLFlBQVU7OztBQUdoQyxNQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBQztBQUN6QixTQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUM7QUFDMUMsVUFBSSxjQUFjLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQTtBQUM5RSxVQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLEVBQUUsY0FBYyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFBO0tBQ2hFO0dBQ0Y7OztBQUdELE1BQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFDO0FBQ3pCLFNBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBQztBQUMxQyxVQUFJLGFBQWEsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFBO0FBQzdFLFVBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsRUFBRSxhQUFhLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUE7S0FDOUQ7R0FDRjs7O0FBR0QsTUFBSSxZQUFZLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLFFBQVEsQ0FBQztBQUNuRSxNQUFJLENBQUMsR0FBRyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUE7QUFDdkIsTUFBSSxDQUFDLEdBQUcsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFBO0FBQ3ZCLE1BQUksQ0FBQyxHQUFHLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQTs7QUFFdkIsTUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLENBQUE7OztBQUkvQixNQUFHLElBQUksQ0FBQyxZQUFZLEtBQUcsSUFBSSxFQUFDOztBQUUxQixRQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7OztBQUdiLFFBQUcsSUFBSSxDQUFDLEtBQUssR0FBQyxJQUFJLENBQUMsYUFBYSxLQUFLLENBQUMsRUFBQztBQUNyQyxVQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQTtBQUM1QixVQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsRUFBRSxDQUFBO0tBQzFCOzs7QUFHRCxRQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxXQUFXLEVBQUM7QUFDNUMsVUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUM7QUFDekIsVUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUM7QUFDZixVQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsR0FBRyxDQUFDLENBQUM7QUFDNUIsVUFBSSxDQUFDLE1BQU0sQ0FBQyxrQkFBa0IsR0FBRyxDQUFDLENBQUM7QUFDbkMsVUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO0tBQzdCO0dBRUY7Q0FHRixDQUFBOztBQUtELFNBQVMsZ0JBQWdCLEdBQUU7O0FBRXpCLFFBQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLEVBQUUsQ0FBQSxVQUFTLENBQUMsRUFBQzs7O0FBRzVDLFFBQUcsQ0FBQyxDQUFDLEtBQUssS0FBSyxFQUFFLEVBQUM7QUFDZixlQUFTLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFBO0tBQ25DOzs7QUFHRCxRQUFHLENBQUMsQ0FBQyxLQUFLLEtBQUssRUFBRSxFQUFDO0FBQ2YsZUFBUyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQTtLQUN2Qzs7QUFFRCxRQUFHLENBQUMsQ0FBQyxLQUFLLEtBQUssRUFBRSxFQUFDO0FBQ2hCLGVBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUE7S0FDdkM7OztBQUdELFFBQUcsQ0FBQyxDQUFDLEtBQUssS0FBSyxFQUFFLEVBQUM7QUFDakIsYUFBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQTs7QUFFaEIsZUFBUyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQTtBQUNqQyxVQUFJLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFBO0FBQ3ZDLGtCQUFZLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFBO0tBRXpCO0dBRUYsQ0FBQSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFBO0NBRWQ7O0FBR0QsU0FBUyxhQUFhLEdBQUU7O0FBRXRCLE1BQUksVUFBVSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUE7O0FBRXJDLE1BQUksQ0FBQyxNQUFNLEdBQUc7QUFDWixRQUFJLEVBQUUsVUFBVTtBQUNoQixNQUFFLEVBQUUsSUFBSSxVQUFVLENBQUMsVUFBVSxDQUFDO0FBQzlCLFVBQU0sRUFBRSxFQUFFO0FBQ1YsZUFBVyxFQUFFLENBQUM7QUFDZCxzQkFBa0IsRUFBRSxDQUFDO0FBQ3JCLGFBQVMsRUFBRSxPQUFPO0FBQ2xCLFlBQVEsRUFBRSxFQUFFO0FBQ1osV0FBTyxFQUFFLEtBQUs7QUFDZCxRQUFJLEVBQUUsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDO0FBQzFCLFlBQVEsRUFBRSxJQUFJLFFBQVEsQ0FBQyxVQUFVLENBQUM7QUFDbEMsY0FBVSxFQUFFLElBQUksVUFBVSxDQUFDLFVBQVUsQ0FBQztHQUN2QyxDQUFBOztBQUVELE1BQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxrQkFBa0IsRUFBRSwrQkFBK0IsQ0FBQyxDQUFBOztBQUUvRSxNQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxDQUFBO0FBQzdCLE1BQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxFQUFFLEVBQUMsRUFBRSxDQUFDLENBQUE7QUFDbkMsTUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBQyxHQUFHLENBQUMsQ0FBQTtDQUVwQzs7QUFJRCxTQUFTLGFBQWEsR0FBRTs7QUFFdEIsTUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQTtBQUNqQyxNQUFJLENBQUMsTUFBTSxHQUFHO0FBQ1osU0FBSyxFQUFFLElBQUksS0FBSyxDQUFDLE1BQU0sQ0FBQztBQUN4QixRQUFJLEVBQUUsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDO0FBQ3RCLE1BQUUsRUFBRSxJQUFJLFVBQVUsQ0FBQyxNQUFNLENBQUM7R0FDM0IsQ0FBQTs7QUFFRCxNQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFDLElBQUksQ0FBQyxDQUFBO0FBQ2hDLE1BQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLENBQUE7QUFDN0IsTUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsRUFBQyxFQUFFLENBQUMsQ0FBQTtBQUNwQyxNQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsU0FBUyxHQUFDLElBQUksQ0FBQyxLQUFLLEdBQUUsV0FBVyxHQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUE7QUFDaEYsTUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQTtDQUU3Qzs7QUFFRCxTQUFTLGFBQWEsR0FBRTs7O0FBR3RCLE1BQUksQ0FBQyxHQUFHLEdBQUcsSUFBSSxHQUFHLENBQUM7QUFDakIsUUFBSSxFQUFFLENBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLENBQUM7QUFDaEIsUUFBSSxFQUFFLEVBQUU7QUFDUixnQkFBWSxFQUFFLENBQUMsR0FBRyxDQUFDO0FBQ25CLFlBQVEsRUFBRSxJQUFJLElBQUksQ0FBQyxHQUFHLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQztHQUM3QixDQUFDLENBQUM7OztBQUdILE1BQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQzs7O0FBR3ZCLE1BQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxJQUFJLENBQUMsRUFBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsV0FBVyxFQUFFLENBQUMsRUFBRSxRQUFRLEVBQUUsQ0FBQyxFQUFDLENBQUMsQ0FBQztBQUNwRixNQUFJLENBQUMsS0FBSyxHQUFHLElBQUksSUFBSSxDQUFDLEVBQUMsU0FBUyxFQUFFLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLFdBQVcsRUFBRSxDQUFDLEVBQUUsUUFBUSxFQUFFLENBQUMsRUFBQyxDQUFDLENBQUM7QUFDbkYsTUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLElBQUksQ0FBQyxFQUFDLFNBQVMsRUFBRSxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxXQUFXLEVBQUUsQ0FBQyxFQUFFLFFBQVEsRUFBRSxDQUFDLEVBQUMsQ0FBQyxDQUFDO0FBQ25GLE1BQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxJQUFJLENBQUMsRUFBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsV0FBVyxFQUFFLENBQUMsRUFBRSxRQUFRLEVBQUUsQ0FBQyxFQUFDLENBQUMsQ0FBQzs7O0FBR2pGLE1BQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxVQUFVLEVBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzlDLE1BQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUMsRUFBQyxNQUFNLENBQUMsV0FBVyxFQUFDLENBQUMsQ0FBQyxDQUFBOztBQUU5QyxNQUFJLENBQUMsT0FBTyxHQUFHLElBQUksT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUE7QUFDdEMsTUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLFNBQVMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFBOztBQUVyRixNQUFJLENBQUMsU0FBUyxHQUFHLElBQUksU0FBUyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQTtBQUMxRixNQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUE7Q0FJaEY7O0FBR0QsU0FBUyxXQUFXLEdBQUU7O0FBRXBCLE1BQUksS0FBSyxHQUFHLElBQUksR0FBRyxDQUFDO0FBQ2xCLFFBQUksRUFBRSxDQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxDQUFDO0FBQ2hCLFFBQUksRUFBRSxFQUFFO0FBQ1IsZ0JBQVksRUFBRSxDQUFDLEdBQUcsQ0FBQztBQUNuQixZQUFRLEVBQUUsSUFBSSxJQUFJLENBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFDLE1BQU0sQ0FBQyxVQUFVLEVBQUUsQ0FBQyxHQUFHLEVBQUMsQ0FBQyxDQUFDO0dBQzdELENBQUMsQ0FBQzs7O0FBR0gsT0FBSyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7O0FBRW5CLE1BQUksU0FBUyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUE7O0FBRXBDLE1BQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUE7OztBQUc1QyxPQUFLLENBQUMsT0FBTyxHQUFHLElBQUksVUFBVSxDQUFDLFNBQVMsQ0FBQyxDQUFBO0FBQ3pDLE1BQUksYUFBYSxHQUFHLElBQUksUUFBUSxDQUFDLFNBQVMsQ0FBQyxDQUFBO0FBQzNDLE1BQUksU0FBUyxHQUFHLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFBO0FBQ25DLE1BQUksZUFBZSxHQUFHLElBQUksVUFBVSxDQUFDLFNBQVMsQ0FBQyxDQUFBOztBQUUvQyxXQUFTLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLENBQUE7QUFDeEIsV0FBUyxDQUFDLFdBQVcsQ0FBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxDQUFBO0FBQzlCLGlCQUFlLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBQyxHQUFHLENBQUMsQ0FBQTtBQUM1QixlQUFhLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBQyxFQUFFLENBQUMsQ0FBQTtBQUN4QixNQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQTtBQUMvQixNQUFJLENBQUMsY0FBYyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQTtBQUNwQyxNQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLEtBQUssRUFBRSxhQUFhLENBQUMsQ0FBQyxDQUFBO0FBQ3pDLE9BQUssQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLGlDQUFpQyxDQUFDLENBQUE7OztBQUczRCxPQUFLLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxpQkFBaUIsRUFBRSxDQUFBLFVBQVMsQ0FBQyxFQUFDOztBQUU1QyxRQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxJQUFJLENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFDOztBQUVsQyxVQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDOzs7Ozs7O0tBUXRCO0dBRUgsQ0FBQSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFBO0NBR2I7O0FBSUQsU0FBUyxZQUFZLEdBQUU7OztBQUdyQixNQUFJLFlBQVksR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsUUFBUSxDQUFDO0FBQ25FLE1BQUksQ0FBQyxHQUFHLFlBQVksQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7QUFDN0IsTUFBSSxDQUFDLEdBQUcsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDOztBQUV4QixNQUFJLE1BQU0sR0FBRyxJQUFJLEdBQUcsQ0FBQztBQUNuQixRQUFJLEVBQUUsQ0FBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsQ0FBQztBQUNoQixRQUFJLEVBQUUsR0FBRztBQUNULGdCQUFZLEVBQUUsQ0FBQyxHQUFHLENBQUM7QUFDbkIsWUFBUSxFQUFFLElBQUksSUFBSSxDQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDO0dBQzFCLENBQUMsQ0FBQzs7O0FBR0gsUUFBTSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUM7O0FBRXJCLE1BQUksQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFBO0FBQ3JDLE1BQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFBOztBQUUvQixNQUFJLFdBQVcsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFBO0FBQ3RDLE1BQUksUUFBUSxHQUFHLElBQUksVUFBVSxDQUFDLFdBQVcsQ0FBQyxDQUFBO0FBQzFDLE1BQUksY0FBYyxHQUFHLElBQUksUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFBO0FBQzlDLE1BQUksVUFBVSxHQUFHLElBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFBO0FBQ3RDLFVBQVEsQ0FBQyxXQUFXLENBQUMsa0JBQWtCLEVBQUUsMkJBQTJCLENBQUMsQ0FBQTtBQUNyRSxVQUFRLENBQUMsV0FBVyxDQUFDLGVBQWUsRUFBRSxLQUFLLENBQUMsQ0FBQTtBQUM1QyxVQUFRLENBQUMsV0FBVyxDQUFDLFlBQVksRUFBRSxpQ0FBaUMsQ0FBQyxDQUFBO0FBQ3JFLFlBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsQ0FBQTtBQUN6QixZQUFVLENBQUMsV0FBVyxDQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxDQUFDLENBQUE7O0FBRWhDLE1BQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxFQUFFLGNBQWMsQ0FBQyxDQUFDLENBQUE7Ozs7QUFJM0MsTUFBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsS0FBSyxNQUFNLEVBQUM7QUFDakMsVUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLEVBQUMsQ0FBQyxDQUFDLENBQUE7R0FDaEM7O0FBRUQsTUFBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsS0FBSyxPQUFPLEVBQUM7QUFDbkMsVUFBTSxDQUFDLFdBQVcsQ0FBQyxJQUFJLEVBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxDQUFBO0dBQzdCOztBQUlELE1BQUksQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDOztBQUV0QixRQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxpQkFBaUIsRUFBRSxDQUFBLFVBQVMsQ0FBQyxFQUFDOztBQUU3QyxRQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFDO0FBQ2YsVUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDOzs7Ozs7QUFNYixPQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsaUNBQWlDLENBQUMsQ0FBQTs7QUFFL0QsVUFBRyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUM7QUFDaEIsWUFBSSxLQUFLLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQTtBQUNwQyxZQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQztPQUN0QjtLQUVBO0dBQ0YsQ0FBQSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFBO0NBSWQ7OztBQUdELFNBQVMsU0FBUyxDQUFDLEtBQUssRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFDOztBQUUzQyxNQUFHLElBQUksQ0FBQyxZQUFZLEtBQUssUUFBUSxFQUFDO0FBQ2hDLFFBQUksQ0FBQyxNQUFNLENBQUMsV0FBVyxHQUFHLENBQUMsQ0FBQztBQUM1QixRQUFJLENBQUMsWUFBWSxHQUFHLFFBQVEsQ0FBQztBQUM3QixRQUFJLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQztBQUN6QixRQUFJLENBQUMsYUFBYSxHQUFHLFFBQVEsQ0FBQztHQUMvQjtDQUVGOztBQUVELFNBQVMsS0FBSyxHQUFFOzs7QUFHZCxNQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxLQUFLLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxFQUFDOztBQUUzRCxRQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsV0FBVyxHQUFHLENBQUMsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsSUFBSSxDQUFDLEVBQUM7QUFDN0QsVUFBSSxDQUFDLE1BQU0sQ0FBQyxrQkFBa0IsSUFBRSxHQUFHLENBQUE7QUFDbkMsVUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQTtBQUN4QyxVQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUMscUJBQXFCLEVBQUUsR0FBRyxHQUFHLElBQUksQ0FBQyxDQUFBO0tBQzlEOztBQUVELFFBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxXQUFXLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLEVBQUM7QUFDdkQsVUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsQ0FBQTtBQUM3QixVQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxFQUFDLEVBQUUsQ0FBQyxDQUFBO0FBQ3BDLFVBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxxQkFBcUIsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUE7QUFDM0QsVUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDLGtCQUFrQixFQUFFLDhCQUE4QixDQUFDLENBQUE7QUFDOUUsVUFBSSxDQUFDLE1BQU0sQ0FBQyxrQkFBa0IsR0FBRyxDQUFDLENBQUE7S0FDbkM7R0FDRjs7O0FBR0QsTUFBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsS0FBSyxNQUFNLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sRUFBQzs7QUFFMUQsUUFBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsR0FBRyxDQUFDLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxXQUFXLElBQUksQ0FBQyxFQUFDO0FBQzdELFVBQUksQ0FBQyxNQUFNLENBQUMsa0JBQWtCLElBQUUsR0FBRyxDQUFBO0FBQ25DLFVBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsa0JBQWtCLENBQUE7QUFDeEMsVUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDLHFCQUFxQixFQUFFLEdBQUcsR0FBRyxJQUFJLENBQUMsQ0FBQTtLQUM5RDs7QUFFRCxRQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsV0FBVyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxFQUFDO0FBQ3ZELFVBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLENBQUE7QUFDN0IsVUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsRUFBQyxFQUFFLENBQUMsQ0FBQTtBQUNwQyxVQUFJLENBQUMsTUFBTSxDQUFDLGtCQUFrQixHQUFHLEdBQUcsQ0FBQTtBQUNwQyxVQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUMsa0JBQWtCLEVBQUUsNkJBQTZCLENBQUMsQ0FBQTtBQUM3RSxVQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUMscUJBQXFCLEVBQUUsR0FBRyxHQUFHLElBQUksQ0FBQyxDQUFBO0tBRTlEO0dBQ0Y7OztBQUdELE1BQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLEtBQUssT0FBTyxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxFQUFDOztBQUUxRCxRQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsV0FBVyxHQUFHLENBQUMsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsSUFBSSxDQUFDLEVBQUM7QUFDN0QsVUFBSSxDQUFDLE1BQU0sQ0FBQyxrQkFBa0IsSUFBRSxHQUFHLENBQUE7QUFDbkMsVUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQTtBQUN4QyxVQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUMscUJBQXFCLEVBQUUsR0FBRyxHQUFHLElBQUksQ0FBQyxDQUFBO0tBQzlEOztBQUVELFFBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxXQUFXLEtBQUssQ0FBQyxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxFQUFDO0FBQ3RELFVBQUksQ0FBQyxNQUFNLENBQUMsa0JBQWtCLEdBQUcsQ0FBQyxDQUFBO0FBQ2xDLFVBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLENBQUE7QUFDN0IsVUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsRUFBQyxHQUFHLENBQUMsQ0FBQTtBQUNyQyxVQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUMscUJBQXFCLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFBO0FBQzNELFVBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxrQkFBa0IsRUFBRSxrQ0FBa0MsQ0FBQyxDQUFBO0FBQ2xGLFVBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztLQUM1QjtHQUNGOzs7QUFHRCxNQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxLQUFLLE1BQU0sSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sRUFBQzs7QUFFekQsUUFBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsR0FBRyxDQUFDLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxXQUFXLElBQUksQ0FBQyxFQUFDO0FBQzdELFVBQUksQ0FBQyxNQUFNLENBQUMsa0JBQWtCLElBQUUsR0FBRyxDQUFBO0FBQ25DLFVBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsa0JBQWtCLENBQUE7QUFDeEMsVUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDLHFCQUFxQixFQUFFLEdBQUcsR0FBRyxJQUFJLENBQUMsQ0FBQTtLQUM5RDs7QUFFRCxRQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsV0FBVyxLQUFLLENBQUMsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sRUFBQztBQUN0RCxVQUFJLENBQUMsTUFBTSxDQUFDLGtCQUFrQixHQUFHLEdBQUcsQ0FBQTtBQUNwQyxVQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxDQUFBO0FBQzdCLFVBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLEVBQUMsR0FBRyxDQUFDLENBQUE7QUFDckMsVUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDLHFCQUFxQixFQUFFLEdBQUcsR0FBRyxJQUFJLENBQUMsQ0FBQTtBQUM3RCxVQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUMsa0JBQWtCLEVBQUUsaUNBQWlDLENBQUMsQ0FBQTtBQUNqRixVQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7S0FDNUI7R0FDRjtDQUdGOztBQUlELFNBQVMsU0FBUyxHQUFFO0FBQ3BCLE1BQUksS0FBSyxHQUFHLElBQUksQ0FBQyxTQUFTLElBQUUsQ0FBQyxDQUFBO0FBQzVCLE1BQUksQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLHFCQUFxQixFQUFFLEtBQUssR0FBRyxJQUFJLENBQUMsQ0FBQTs7QUFFM0QsTUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLEdBQUcsT0FBTyxDQUFBOztBQUUvQixNQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLEVBQUM7O0FBRXRCLFFBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxXQUFXLEdBQUcsQ0FBQyxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsV0FBVyxJQUFJLEVBQUUsRUFBQztBQUM5RCxVQUFJLENBQUMsTUFBTSxDQUFDLGtCQUFrQixJQUFFLEVBQUUsQ0FBQTtBQUNsQyxVQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLGtCQUFrQixDQUFBO0FBQ3hDLFVBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxxQkFBcUIsRUFBRSxHQUFHLEdBQUcsSUFBSSxDQUFDLENBQUE7S0FDOUQ7O0FBRUQsUUFBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsS0FBSyxDQUFDLEVBQUM7QUFDL0IsVUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDLGtCQUFrQixFQUFFLDZCQUE2QixDQUFDLENBQUE7QUFDN0UsVUFBSSxDQUFDLE1BQU0sQ0FBQyxrQkFBa0IsR0FBRyxDQUFDLENBQUE7QUFDbEMsVUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsQ0FBQTtBQUM3QixVQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsRUFBRSxFQUFDLEVBQUUsQ0FBQyxDQUFBO0FBQ25DLFVBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxxQkFBcUIsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUE7S0FDNUQ7R0FDRjtBQUNELE1BQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLEVBQUUsRUFBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQTtDQUU3RTs7QUFFRCxTQUFTLFFBQVEsR0FBRTtBQUNqQixNQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsU0FBUyxJQUFFLENBQUMsQ0FBQTtBQUM3QixNQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxxQkFBcUIsRUFBRSxLQUFLLEdBQUcsSUFBSSxDQUFDLENBQUE7QUFDNUQsTUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLEdBQUcsTUFBTSxDQUFBOztBQUU5QixNQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLEVBQUM7O0FBRXRCLFFBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxXQUFXLEdBQUcsQ0FBQyxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsV0FBVyxJQUFJLEVBQUUsRUFBQztBQUM5RCxVQUFJLENBQUMsTUFBTSxDQUFDLGtCQUFrQixJQUFFLEVBQUUsQ0FBQTtBQUNsQyxVQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLGtCQUFrQixDQUFBO0FBQ3hDLFVBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxxQkFBcUIsRUFBRSxHQUFHLEdBQUcsSUFBSSxDQUFDLENBQUE7S0FDOUQ7O0FBRUQsUUFBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsS0FBSyxDQUFDLEVBQUM7QUFDL0IsVUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDLGtCQUFrQixFQUFFLDRCQUE0QixDQUFDLENBQUE7QUFDNUUsVUFBSSxDQUFDLE1BQU0sQ0FBQyxrQkFBa0IsR0FBRyxDQUFDLENBQUE7QUFDbEMsVUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsQ0FBQTtBQUM3QixVQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsRUFBRSxFQUFDLEVBQUUsQ0FBQyxDQUFBO0FBQ25DLFVBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxxQkFBcUIsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUE7S0FDNUQ7R0FDRjtBQUNELE1BQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUMsR0FBRyxFQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFBO0NBRS9FOztBQUVELFNBQVMsSUFBSSxHQUFFO0FBQ2IsTUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDOztBQUUzQixNQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxLQUFLLE9BQU8sRUFBQzs7QUFFbkMsUUFBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsR0FBRyxDQUFDLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxXQUFXLElBQUksRUFBRSxFQUFDO0FBQzVELFVBQUksQ0FBQyxNQUFNLENBQUMsa0JBQWtCLElBQUUsRUFBRSxDQUFBO0FBQ2xDLFVBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsa0JBQWtCLENBQUE7QUFDeEMsVUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDLHFCQUFxQixFQUFFLEdBQUcsR0FBRyxJQUFJLENBQUMsQ0FBQTtLQUVoRTs7QUFFRCxRQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsV0FBVyxLQUFLLENBQUMsRUFBQztBQUMvQixVQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUMsa0JBQWtCLEVBQUUsNkJBQTZCLENBQUMsQ0FBQTtBQUM3RSxVQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxDQUFBO0FBQzdCLFVBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxFQUFFLEVBQUMsRUFBRSxDQUFDLENBQUE7QUFDbkMsVUFBSSxDQUFDLE1BQU0sQ0FBQyxrQkFBa0IsR0FBRyxDQUFDLENBQUE7QUFDbEMsVUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDLHFCQUFxQixFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQTtLQUM1RDtHQUNGOztBQUVELE1BQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLEtBQUssTUFBTSxFQUFDOztBQUVsQyxRQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsV0FBVyxHQUFHLENBQUMsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsSUFBSSxFQUFFLEVBQUM7QUFDNUQsVUFBSSxDQUFDLE1BQU0sQ0FBQyxrQkFBa0IsSUFBRSxFQUFFLENBQUE7QUFDbEMsVUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQTtBQUN4QyxVQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUMscUJBQXFCLEVBQUUsR0FBRyxHQUFHLElBQUksQ0FBQyxDQUFBO0tBRWhFOztBQUVELFFBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxXQUFXLEtBQUssQ0FBQyxFQUFDO0FBQy9CLFVBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxrQkFBa0IsRUFBRSw0QkFBNEIsQ0FBQyxDQUFBO0FBQzVFLFVBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLENBQUE7QUFDN0IsVUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEVBQUUsRUFBQyxFQUFFLENBQUMsQ0FBQTtBQUNuQyxVQUFJLENBQUMsTUFBTSxDQUFDLGtCQUFrQixHQUFHLENBQUMsQ0FBQTtBQUNsQyxVQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUMscUJBQXFCLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFBO0tBQzVEO0dBRUY7QUFDRCxNQUFJLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsRUFBRSxFQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQTtDQUU5RTs7QUFFRCxNQUFNLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQTs7OztBQy9pQnJCLFlBQVksQ0FBQzs7QUFFYixJQUFJLGNBQWMsR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDdkMsSUFBSSxVQUFVLEdBQUcsY0FBYyxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUM7QUFDckQsSUFBSSxhQUFhLEdBQUcsY0FBYyxDQUFDLFNBQVMsQ0FBQyxhQUFhLENBQUM7QUFDM0QsSUFBSSxNQUFNLEdBQUcsY0FBYyxDQUFDLE1BQU0sQ0FBQztBQUNuQyxJQUFJLFVBQVUsR0FBRyxjQUFjLENBQUMsY0FBYyxDQUFDLFVBQVUsQ0FBQztBQUMxRCxJQUFJLE1BQU0sR0FBRyxjQUFjLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQzs7O0FBR3hDLElBQUksVUFBVSxHQUFHLElBQUksVUFBVSxFQUFFLENBQUM7QUFDbEMsSUFBSSxZQUFZLEdBQUcsSUFBSSxhQUFhLENBQUMsTUFBTSxFQUFFLFVBQVUsQ0FBQyxDQUFDO0FBQ3pELElBQUksTUFBTSxHQUFHLElBQUksTUFBTSxFQUFFLENBQUM7QUFDMUIsTUFBTSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQzs7O0FBRzVCLElBQUksT0FBTyxHQUFHLE1BQU0sQ0FBQyxhQUFhLEVBQUUsQ0FBQztBQUNyQyxJQUFJLElBQUksR0FBRyxPQUFPLENBQUMsUUFBUSxFQUFFLENBQUM7O0FBRTlCLElBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQTtBQUM1QixJQUFJLElBQUksR0FBRyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBjb21wb25lbnRzOiByZXF1aXJlKCdmYW1vdXMtY29tcG9uZW50cycpLFxuICAgIGNvcmU6IHJlcXVpcmUoJ2ZhbW91cy1jb3JlJyksXG4gICAgZW5naW5lOiByZXF1aXJlKCdmYW1vdXMtZW5naW5lJyksXG4gICAgZG9tUmVuZGVyYWJsZXM6IHJlcXVpcmUoJ2ZhbW91cy1kb20tcmVuZGVyYWJsZXMnKSxcbiAgICBtYXRoOiByZXF1aXJlKCdmYW1vdXMtbWF0aCcpLFxuICAgIHBoeXNpY3M6IHJlcXVpcmUoJ2ZhbW91cy1waHlzaWNzJyksXG4gICAgcmVuZGVyZXJzOiByZXF1aXJlKCdmYW1vdXMtcmVuZGVyZXJzJyksXG4gICAgc3R5bGVzaGVldHM6IHJlcXVpcmUoJ2ZhbW91cy1zdHlsZXNoZWV0cycpLFxuICAgIHJvdXRlcjogcmVxdWlyZSgnZmFtb3VzLXJvdXRlcicpLFxuICAgIHRyYW5zaXRpb25zOiByZXF1aXJlKCdmYW1vdXMtdHJhbnNpdGlvbnMnKSxcbiAgICB1dGlsaXRpZXM6IHJlcXVpcmUoJ2ZhbW91cy11dGlsaXRpZXMnKSxcbiAgICB3ZWJnbFJlbmRlcmFibGVzOiByZXF1aXJlKCdmYW1vdXMtd2ViZ2wtcmVuZGVyYWJsZXMnKSxcbiAgICB3ZWJnbEdlb21ldHJpZXM6IHJlcXVpcmUoJ2ZhbW91cy13ZWJnbC1nZW9tZXRyaWVzJyksXG4gICAgd2ViZ2xNYXRlcmlhbHM6IHJlcXVpcmUoJ2ZhbW91cy13ZWJnbC1tYXRlcmlhbHMnKSxcbiAgICB3ZWJnbFNoYWRlcnM6IHJlcXVpcmUoJ2ZhbW91cy13ZWJnbC1zaGFkZXJzJyksXG4gICAgcG9seWZpbGxzOiByZXF1aXJlKCdmYW1vdXMtcG9seWZpbGxzJylcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRXF1aXZhbGVudCBvZiBhbiBFbmdpbmUgaW4gdGhlIFdvcmtlciBUaHJlYWQuIFVzZWQgdG8gc3luY2hyb25pemUgYW5kIG1hbmFnZVxuICogdGltZSBhY3Jvc3MgZGlmZmVyZW50IFRocmVhZHMuXG4gKlxuICogQGNsYXNzICBDbG9ja1xuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBDbG9jayAoKSB7XG4gICAgdGhpcy5fdGltZSA9IDA7XG4gICAgdGhpcy5fZnJhbWUgPSAwO1xuICAgIHRoaXMuX3RpbWVyUXVldWUgPSBbXTtcbiAgICB0aGlzLl91cGRhdGluZ0luZGV4ID0gMDtcbn1cblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBpbnRlcm5hbCBjbG9jayB0aW1lLlxuICpcbiAqIEBtZXRob2QgIHN0ZXBcbiAqIEBjaGFpbmFibGVcbiAqIFxuICogQHBhcmFtICB7TnVtYmVyfSB0aW1lIGhpZ2ggcmVzb2x1dGlvbiB0aW1zdGFtcCB1c2VkIGZvciBpbnZva2luZyB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICBgdXBkYXRlYCBtZXRob2Qgb24gYWxsIHJlZ2lzdGVyZWQgb2JqZWN0c1xuICogQHJldHVybiB7Q2xvY2t9ICAgICAgIHRoaXNcbiAqL1xuQ2xvY2sucHJvdG90eXBlLnN0ZXAgPSBmdW5jdGlvbiBzdGVwICh0aW1lKSB7XG4gICAgdGhpcy5fZnJhbWUrKztcbiAgICB0aGlzLl90aW1lID0gdGltZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3RpbWVyUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuX3RpbWVyUXVldWVbaV0odGhpcy5fdGltZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3RpbWVyUXVldWUuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbnRlcm5hbCBjbG9jayB0aW1lLlxuICpcbiAqIEBtZXRob2QgIGdldFRpbWVcbiAqIEBkZXByZWNhdGVkIFVzZSAjbm93IGluc3RlYWRcbiAqIFxuICogQHBhcmFtICB7TnVtYmVyfSB0aW1lIGhpZ2ggcmVzb2x1dGlvbiB0aW1zdGFtcCB1c2VkIGZvciBpbnZva2luZyB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICBgdXBkYXRlYCBtZXRob2Qgb24gYWxsIHJlZ2lzdGVyZWQgb2JqZWN0c1xuICovXG5DbG9jay5wcm90b3R5cGUuZ2V0VGltZSA9IGZ1bmN0aW9uIGdldFRpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpbWU7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGludGVybmFsIGNsb2NrIHRpbWUuXG4gKlxuICogQG1ldGhvZCAgbm93XG4gKiBcbiAqIEBwYXJhbSAge051bWJlcn0gdGltZSBoaWdoIHJlc29sdXRpb24gdGltc3RhbXAgdXNlZCBmb3IgaW52b2tpbmcgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgYHVwZGF0ZWAgbWV0aG9kIG9uIGFsbCByZWdpc3RlcmVkIG9iamVjdHNcbiAqL1xuQ2xvY2sucHJvdG90eXBlLm5vdyA9IGZ1bmN0aW9uIG5vdyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpbWU7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiBmcmFtZXMgZWxhcHNlZCBzbyBmYXIuXG4gKlxuICogQG1ldGhvZCBnZXRGcmFtZVxuICogXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGZyYW1lc1xuICovXG5DbG9jay5wcm90b3R5cGUuZ2V0RnJhbWUgPSBmdW5jdGlvbiBnZXRGcmFtZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZyYW1lO1xufTtcblxuLyoqXG4gKiBXcmFwcyBhIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgYWZ0ZXIgYSBjZXJ0YWluIGFtb3VudCBvZiB0aW1lLlxuICogQWZ0ZXIgYSBzZXQgZHVyYXRpb24gaGFzIHBhc3NlZCwgaXQgZXhlY3V0ZXMgdGhlIGZ1bmN0aW9uIGFuZFxuICogcmVtb3ZlcyBpdCBhcyBhIGxpc3RlbmVyIHRvICdwcmVyZW5kZXInLlxuICpcbiAqIEBtZXRob2Qgc2V0VGltZW91dFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIHJ1biBhZnRlciBhIHNwZWNpZmllZCBkdXJhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5IG1pbGxpc2Vjb25kcyBmcm9tIG5vdyB0byBleGVjdXRlIHRoZSBmdW5jdGlvblxuICpcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0aW1lciBmdW5jdGlvbiB1c2VkIGZvciBDbG9jayNjbGVhclRpbWVyXG4gKi9cbkNsb2NrLnByb3RvdHlwZS5zZXRUaW1lb3V0ID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBkZWxheSkge1xuICAgIHZhciBwYXJhbXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHZhciBzdGFydGVkQXQgPSB0aGlzLl90aW1lO1xuICAgIHZhciB0aW1lciA9IGZ1bmN0aW9uKHRpbWUpIHtcbiAgICAgICAgaWYgKHRpbWUgLSBzdGFydGVkQXQgPj0gZGVsYXkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIHBhcmFtcyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICB0aGlzLl90aW1lclF1ZXVlLnB1c2godGltZXIpO1xuICAgIHJldHVybiB0aW1lcjtcbn07XG5cblxuLyoqXG4gKiBXcmFwcyBhIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgYWZ0ZXIgYSBjZXJ0YWluIGFtb3VudCBvZiB0aW1lLlxuICogIEFmdGVyIGEgc2V0IGR1cmF0aW9uIGhhcyBwYXNzZWQsIGl0IGV4ZWN1dGVzIHRoZSBmdW5jdGlvbiBhbmRcbiAqICByZXNldHMgdGhlIGV4ZWN1dGlvbiB0aW1lLlxuICpcbiAqIEBtZXRob2Qgc2V0SW50ZXJ2YWxcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBydW4gYWZ0ZXIgYSBzcGVjaWZpZWQgZHVyYXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBkdXJhdGlvbiBpbnRlcnZhbCB0byBleGVjdXRlIGZ1bmN0aW9uIGluIG1pbGxpc2Vjb25kc1xuICpcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0aW1lciBmdW5jdGlvbiB1c2VkIGZvciBDbG9jayNjbGVhclRpbWVyXG4gKi9cbkNsb2NrLnByb3RvdHlwZS5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uIHNldEludGVydmFsKGNhbGxiYWNrLCBkZWxheSkge1xuICAgIHZhciBwYXJhbXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHZhciBzdGFydGVkQXQgPSB0aGlzLl90aW1lO1xuICAgIHZhciB0aW1lciA9IGZ1bmN0aW9uKHRpbWUpIHtcbiAgICAgICAgaWYgKHRpbWUgLSBzdGFydGVkQXQgPj0gZGVsYXkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIHBhcmFtcyk7XG4gICAgICAgICAgICBzdGFydGVkQXQgPSB0aW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHRoaXMuX3RpbWVyUXVldWUucHVzaCh0aW1lcik7XG4gICAgcmV0dXJuIHRpbWVyO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIHByZXZpb3VzbHkgdmlhIGBDbG9jayNzZXRUaW1lb3V0YCBvciBgQ2xvY2sjc2V0SW50ZXJ2YWxgXG4gKiByZWdpc3RlcmVkIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKlxuICogQG1ldGhvZCBjbGVhclRpbWVyXG4gKiBAY2hhaW5hYmxlXG4gKiBcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFjayAgcHJldmlvdXNseSBieSBgQ2xvY2sjc2V0VGltZW91dGAgb3JcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYENsb2NrI3NldEludGVydmFsYCByZXR1cm5lZCBjYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybiB7Q2xvY2t9ICAgICAgICAgICAgICB0aGlzXG4gKi9cbkNsb2NrLnByb3RvdHlwZS5jbGVhclRpbWVyID0gZnVuY3Rpb24gKHRpbWVyKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5fdGltZXJRdWV1ZS5pbmRleE9mKHRpbWVyKTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHRoaXMuX3RpbWVyUXVldWUuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENsb2NrO1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBEaXNwYXRjaCA9IHJlcXVpcmUoJy4vRGlzcGF0Y2gnKTtcbnZhciBOb2RlID0gcmVxdWlyZSgnLi9Ob2RlJyk7XG52YXIgU2l6ZSA9IHJlcXVpcmUoJy4vU2l6ZScpO1xuXG4vKipcbiAqIENvbnRleHQgaXMgdGhlIGJvdHRvbSBvZiB0aGUgc2NlbmUgZ3JhcGguIEl0IGlzIGl0J3Mgb3duXG4gKiBwYXJlbnQgYW5kIHByb3ZpZGVzIHRoZSBnbG9iYWwgdXBkYXRlciB0byB0aGUgc2NlbmUgZ3JhcGguXG4gKlxuICogQGNsYXNzIENvbnRleHRcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvciBhIHN0cmluZyB3aGljaCBpcyBhIGRvbSBzZWxlY3RvclxuICogICAgICAgICAgICAgICAgIHNpZ25pZnlpbmcgd2hpY2ggZG9tIGVsZW1lbnQgdGhlIGNvbnRleHRcbiAqICAgICAgICAgICAgICAgICBzaG91bGQgYmUgc2V0IHVwb25cbiAqIEBwYXJhbSB7RmFtb3VzfSBhIGNsYXNzIHdoaWNoIGNvbmZvcm1zIHRvIEZhbW91cycgaW50ZXJmYWNlXG4gKiAgICAgICAgICAgICAgICAgaXQgbmVlZHMgdG8gYmUgYWJsZSB0byBzZW5kIG1ldGhvZHMgdG9cbiAqICAgICAgICAgICAgICAgICB0aGUgcmVuZGVyZXJzIGFuZCB1cGRhdGUgbm9kZXMgaW4gdGhlIHNjZW5lIGdyYXBoXG4gKi9cbmZ1bmN0aW9uIENvbnRleHQgKHNlbGVjdG9yLCB1cGRhdGVyKSB7XG4gICAgaWYgKCFzZWxlY3RvcikgdGhyb3cgbmV3IEVycm9yKCdDb250ZXh0IG5lZWRzIHRvIGJlIGNyZWF0ZWQgd2l0aCBhIERPTSBzZWxlY3RvcicpO1xuICAgIGlmICghdXBkYXRlcikgdGhyb3cgbmV3IEVycm9yKCdDb250ZXh0IG5lZWRzIHRvIGJlIGNyZWF0ZWQgd2l0aCBhIGNsYXNzIGxpa2UgRmFtb3VzJyk7XG5cbiAgICBOb2RlLmNhbGwodGhpcyk7ICAgICAgICAgLy8gQ29udGV4dCBpbmhlcml0cyBmcm9tIG5vZGVcblxuICAgIHRoaXMuX3VwZGF0ZXIgPSB1cGRhdGVyOyAvLyBUaGUgdXBkYXRlciB0aGF0IHdpbGwgYm90aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZW5kIG1lc3NhZ2VzIHRvIHRoZSByZW5kZXJlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHVwZGF0ZSBkaXJ0eSBub2RlcyBcblxuICAgIHRoaXMuX2Rpc3BhdGNoID0gbmV3IERpc3BhdGNoKHRoaXMpOyAvLyBpbnN0YW50aWF0ZXMgYSBkaXNwYXRjaGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIHNlbmQgZXZlbnRzIHRvIHRoZSBzY2VuZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBncmFwaCBiZWxvdyB0aGlzIGNvbnRleHRcbiAgICBcbiAgICB0aGlzLl9zZWxlY3RvciA9IHNlbGVjdG9yOyAvLyByZWZlcmVuY2UgdG8gdGhlIERPTSBzZWxlY3RvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoYXQgcmVwcmVzZW50cyB0aGUgZWxlbW5lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGUgZG9tIHRoYXQgdGhpcyBjb250ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5oYWJpdHNcblxuICAgIHRoaXMub25Nb3VudCh0aGlzLCBzZWxlY3Rvcik7IC8vIE1vdW50IHRoZSBjb250ZXh0IHRvIGl0c2VsZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIChpdCBpcyBpdHMgb3duIHBhcmVudClcbiAgICBcbiAgICB0aGlzLl91cGRhdGVyICAgICAgICAgICAgICAgICAgLy8gbWVzc2FnZSBhIHJlcXVlc3QgZm9yIHRoZSBkb21cbiAgICAgICAgLm1lc3NhZ2UoJ05FRURfU0laRV9GT1InKSAgLy8gc2l6ZSBvZiB0aGUgY29udGV4dCBzbyB0aGF0XG4gICAgICAgIC5tZXNzYWdlKHNlbGVjdG9yKTsgICAgICAgIC8vIHRoZSBzY2VuZSBncmFwaCBoYXMgYSB0b3RhbCBzaXplXG5cbiAgICB0aGlzLnNob3coKTsgLy8gdGhlIGNvbnRleHQgYmVnaW5zIHNob3duIChpdCdzIGFscmVhZHkgcHJlc2VudCBpbiB0aGUgZG9tKVxuXG59XG5cbi8vIENvbnRleHQgaW5oZXJpdHMgZnJvbSBub2RlXG5Db250ZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTm9kZS5wcm90b3R5cGUpO1xuQ29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb250ZXh0O1xuXG4vKipcbiAqIENvbnRleHQgZ2V0VXBkYXRlciBmdW5jdGlvbiByZXR1cm5zIHRoZSBwYXNzZWQgaW4gdXBkYXRlclxuICpcbiAqIEByZXR1cm4ge0ZhbW91c30gdGhlIHVwZGF0ZXIgZm9yIHRoaXMgQ29udGV4dFxuICovXG5Db250ZXh0LnByb3RvdHlwZS5nZXRVcGRhdGVyID0gZnVuY3Rpb24gZ2V0VXBkYXRlciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VwZGF0ZXI7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHNlbGVjdG9yIHRoYXQgdGhlIGNvbnRleHQgd2FzIGluc3RhbnRpYXRlZCB3aXRoXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSBkb20gc2VsZWN0b3JcbiAqL1xuQ29udGV4dC5wcm90b3R5cGUuZ2V0U2VsZWN0b3IgPSBmdW5jdGlvbiBnZXRTZWxlY3RvciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlbGVjdG9yO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBkaXNwYXRjaGVyIG9mIHRoZSBjb250ZXh0LiBVc2VkIHRvIHNlbmQgZXZlbnRzXG4gKiB0byB0aGUgbm9kZXMgaW4gdGhlIHNjZW5lIGdyYXBoLlxuICpcbiAqIEByZXR1cm4ge0Rpc3BhdGNofSB0aGUgQ29udGV4dCdzIERpc3BhdGNoXG4gKi9cbkNvbnRleHQucHJvdG90eXBlLmdldERpc3BhdGNoID0gZnVuY3Rpb24gZ2V0RGlzcGF0Y2ggKCkge1xuICAgIHJldHVybiB0aGlzLl9kaXNwYXRjaDtcbn07XG5cbi8qKlxuICogUmVjZWl2ZXMgYW4gZXZlbnQuIElmIHRoZSBldmVudCBpcyAnQ09OVEVYVF9SRVNJWkUnIGl0IHNldHMgdGhlIHNpemUgb2YgdGhlIHNjZW5lXG4gKiBncmFwaCB0byB0aGUgcGF5bG9hZCwgd2hpY2ggbXVzdCBiZSBhbiBhcnJheSBvZiBudW1iZXJzIG9mIGF0IGxlYXN0XG4gKiBsZW5ndGggdGhyZWUgcmVwcmVzZW50aW5nIHRoZSBwaXhlbCBzaXplIGluIDMgZGltZW5zaW9ucy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7Kn0gcGF5bG9hZFxuICovXG5Db250ZXh0LnByb3RvdHlwZS5vblJlY2VpdmUgPSBmdW5jdGlvbiBvblJlY2VpdmUgKGV2ZW50LCBwYXlsb2FkKSB7XG4gICAgLy8gVE9ETzogSW4gdGhlIGZ1dHVyZSB0aGUgZG9tIGVsZW1lbnQgdGhhdCB0aGUgY29udGV4dCBpcyBhdHRhY2hlZCB0b1xuICAgIC8vIHNob3VsZCBoYXZlIGEgcmVwcmVzZW50YXRpb24gYXMgYSBjb21wb25lbnQuIEl0IHdvdWxkIGJlIHJlbmRlciBzaXplZFxuICAgIC8vIGFuZCB0aGUgY29udGV4dCB3b3VsZCByZWNlaXZlIGl0cyBzaXplIHRoZSBzYW1lIHdheSB0aGF0IGFueSByZW5kZXIgc2l6ZVxuICAgIC8vIGNvbXBvbmVudCByZWNlaXZlcyBpdHMgc2l6ZS5cbiAgICBpZiAoZXZlbnQgPT09ICdDT05URVhUX1JFU0laRScpIHtcbiAgICAgICAgXG4gICAgICAgIGlmIChwYXlsb2FkLmxlbmd0aCA8IDIpIFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnQ09OVEVYVF9SRVNJWkVcXCdzIHBheWxvYWQgbmVlZHMgdG8gYmUgYXQgbGVhc3QgYSBwYWlyJyArXG4gICAgICAgICAgICAgICAgICAgICcgb2YgcGl4ZWwgc2l6ZXMnXG4gICAgICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuc2V0U2l6ZU1vZGUoU2l6ZS5BQlNPTFVURSwgU2l6ZS5BQlNPTFVURSwgU2l6ZS5BQlNPTFVURSk7XG4gICAgICAgIHRoaXMuc2V0QWJzb2x1dGVTaXplKHBheWxvYWRbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWRbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWRbMl0gPyBwYXlsb2FkWzJdIDogMCk7XG5cbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRleHQ7XG5cbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gVE9ETzogRGlzcGF0Y2ggc2hvdWxkIGJlIGdlbmVyYWxpemVkIHNvIHRoYXQgaXQgY2FuIHdvcmsgb24gYW55IE5vZGVcbi8vIG5vdCBqdXN0IENvbnRleHRzLlxuXG5cbi8qKlxuICogVGhlIERpc3BhdGNoIGNsYXNzIGlzIHVzZWQgdG8gcHJvcG9nYXRlIGV2ZW50cyBkb3duIHRoZVxuICogc2NlbmUgZ3JhcGguXG4gKlxuICogQHBhcmFtIHtDb250ZXh0fSBDb250ZXh0IG9uIHdoaWNoIGl0IG9wZXJhdGVzXG4gKi9cbmZ1bmN0aW9uIERpc3BhdGNoIChjb250ZXh0KSB7XG5cbiAgICBpZiAoIWNvbnRleHQpIHRocm93IG5ldyBFcnJvcignRGlzcGF0Y2ggbmVlZHMgdG8gYmUgaW5zdGFudGlhdGVkIG9uIGEgbm9kZScpO1xuICAgIFxuICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0OyAvLyBBIHJlZmVyZW5jZSB0byB0aGUgY29udGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvbiB3aGljaCB0aGUgZGlzcGF0Y2hlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvcGVyYXRlc1xuXG4gICAgdGhpcy5fcXVldWUgPSBbXTsgLy8gVGhlIHF1ZXVlIGlzIHVzZWQgZm9yIHR3byBwdXJwb3Nlc1xuICAgICAgICAgICAgICAgICAgICAgIC8vIDEuIEl0IGlzIHVzZWQgdG8gbGlzdCBpbmRpY2llcyBpbiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAvLyAgICBOb2RlcyBwYXRoIHdoaWNoIGFyZSB0aGVuIHVzZWQgdG8gbG9va3VwXG4gICAgICAgICAgICAgICAgICAgICAgLy8gICAgYSBub2RlIGluIHRoZSBzY2VuZSBncmFwaC5cbiAgICAgICAgICAgICAgICAgICAgICAvLyAyLiBJdCBpcyB1c2VkIHRvIGFzc2lzdCBkaXNwYXRjaGluZ1xuICAgICAgICAgICAgICAgICAgICAgIC8vICAgIHN1Y2ggdGhhdCBpdCBpcyBwb3NzaWJsZSB0byBkbyBhIGJyZWFkdGggZmlyc3RcbiAgICAgICAgICAgICAgICAgICAgICAvLyAgICB0cmF2ZXJzYWwgb2YgdGhlIHNjZW5lIGdyYXBoLlxufVxuXG4vKipcbiAqIGxvb2t1cE5vZGUgdGFrZXMgYSBwYXRoIGFuZCByZXR1cm5zIHRoZSBub2RlIGF0IHRoZSBsb2NhdGlvbiBzcGVjaWZpZWRcbiAqIGJ5IHRoZSBwYXRoLCBpZiBvbmUgZXhpc3RzLiBJZiBub3QsIGl0IHJldHVybnMgdW5kZWZpbmVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBUaGUgbG9jYXRpb24gb2YgdGhlIG5vZGUgc3BlY2lmaWVkIGJ5IGl0cyBwYXRoXG4gKiBcbiAqIEByZXR1cm4ge05vZGUgfCB1bmRlZmluZWR9IFRoZSBub2RlIGF0IHRoZSByZXF1ZXN0ZWQgcGF0aFxuICovXG5EaXNwYXRjaC5wcm90b3R5cGUubG9va3VwTm9kZSA9IGZ1bmN0aW9uIGxvb2t1cE5vZGUgKGxvY2F0aW9uKSB7XG4gICAgaWYgKCFsb2NhdGlvbikgdGhyb3cgbmV3IEVycm9yKCdsb29rdXBOb2RlIG11c3QgYmUgY2FsbGVkIHdpdGggYSBwYXRoJyk7XG5cbiAgICB2YXIgcGF0aCA9IHRoaXMuX3F1ZXVlO1xuXG4gICAgX3NwbGl0VG8obG9jYXRpb24sIHBhdGgpO1xuICAgIFxuICAgIGlmIChwYXRoWzBdICE9PSB0aGlzLl9jb250ZXh0LmdldFNlbGVjdG9yKCkpIHJldHVybiB2b2lkIDA7XG5cbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jb250ZXh0LmdldENoaWxkcmVuKCk7XG4gICAgdmFyIGNoaWxkO1xuICAgIHZhciBpID0gMTtcbiAgICBwYXRoWzBdID0gdGhpcy5fY29udGV4dDtcblxuICAgIHdoaWxlIChpIDwgcGF0aC5sZW5ndGgpIHtcbiAgICAgICAgY2hpbGQgPSBjaGlsZHJlbltwYXRoW2ldXTtcbiAgICAgICAgcGF0aFtpXSA9IGNoaWxkO1xuICAgICAgICBpZiAoY2hpbGQpIGNoaWxkcmVuID0gY2hpbGQuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgZWxzZSByZXR1cm4gdm9pZCAwO1xuICAgICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoaWxkO1xufTtcblxuLyoqXG4gKiBkaXNwYXRjaCB0YWtlcyBhbiBldmVudCBuYW1lIGFuZCBhIHBheWxvYWQgYW5kIGRpc3BhdGNoZXMgaXQgdG8gdGhlXG4gKiBlbnRpcmUgc2NlbmUgZ3JhcGggYmVsb3cgdGhlIG5vZGUgdGhhdCB0aGUgZGlzcGF0Y2hlciBpcyBvbi4gVGhlIG5vZGVzXG4gKiByZWNlaXZlIHRoZSBldmVudHMgaW4gYSBicmVhZHRoIGZpcnN0IHRyYXZlcnNhbCwgbWVhbmluZyB0aGF0IHBhcmVudHNcbiAqIGhhdmUgdGhlIG9wcG9ydHVuaXR5IHRvIHJlYWN0IHRvIHRoZSBldmVudCBiZWZvcmUgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IG5hbWVcbiAqIEBwYXJhbSB7QW55fSBwYXlsb2FkXG4gKi9cbkRpc3BhdGNoLnByb3RvdHlwZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIGRpc3BhdGNoIChldmVudCwgcGF5bG9hZCkge1xuICAgIGlmICghZXZlbnQpIHRocm93IG5ldyBFcnJvcignZGlzcGF0Y2ggcmVxdWlyZXMgYW4gZXZlbnQgbmFtZSBhcyBpdFxcJ3MgZmlyc3QgYXJndW1lbnQnKTtcblxuICAgIHZhciBxdWV1ZSA9IHRoaXMuX3F1ZXVlO1xuICAgIHZhciBpdGVtO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW47XG4gICAgdmFyIGNoaWxkcmVuO1xuXG4gICAgcXVldWUubGVuZ3RoID0gMDtcbiAgICBxdWV1ZS5wdXNoKHRoaXMuX2NvbnRleHQpO1xuXG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBpdGVtID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgaWYgKGl0ZW0ub25SZWNlaXZlKSBpdGVtLm9uUmVjZWl2ZShldmVudCwgcGF5bG9hZCk7XG4gICAgICAgIGNoaWxkcmVuID0gaXRlbS5nZXRDaGlsZHJlbigpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGggOyBpIDwgbGVuIDsgaSsrKSBxdWV1ZS5wdXNoKGNoaWxkcmVuW2ldKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIGRpc3BhdGNoVUlldmVudCB0YWtlcyBhIHBhdGgsIGFuIGV2ZW50IG5hbWUsIGFuZCBhIHBheWxvYWQgYW5kIGRpc3BhdGNoZXMgdGhlbSBpblxuICogYSBtYW5uZXIgYW5vbG9nb3VzIHRvIERPTSBidWJibGluZy4gSXQgZmlyc3QgdHJhdmVyc2VzIGRvd24gdG8gdGhlIG5vZGUgc3BlY2lmaWVkIGF0XG4gKiB0aGUgcGF0aC4gVGhhdCBub2RlIHJlY2VpdmVzIHRoZSBldmVudCBmaXJzdCwgYW5kIHRoZW4gZXZlcnkgYW5jZXN0b3IgcmVjZWl2ZXMgdGhlIGV2ZW50XG4gKiB1bnRpbCB0aGUgY29udGV4dC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdGhlIHBhdGggb2YgdGhlIG5vZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSB0aGUgZXZlbnQgbmFtZVxuICogQHBhcmFtIHtBbnl9IHRoZSBwYXlsb2FkXG4gKi9cbkRpc3BhdGNoLnByb3RvdHlwZS5kaXNwYXRjaFVJRXZlbnQgPSBmdW5jdGlvbiBkaXNwYXRjaFVJRXZlbnQgKHBhdGgsIGV2ZW50LCBwYXlsb2FkKSB7XG4gICAgaWYgKCFwYXRoKSB0aHJvdyBuZXcgRXJyb3IoJ2Rpc3BhdGNoVUlFdmVudCBuZWVkcyBhIHZhbGlkIHBhdGggdG8gZGlzcGF0Y2ggdG8nKTtcbiAgICBpZiAoIWV2ZW50KSB0aHJvdyBuZXcgRXJyb3IoJ2Rpc3BhdGNoVUlFdmVudCBuZWVkcyBhbiBldmVudCBuYW1lIGFzIGl0cyBzZWNvbmQgYXJndW1lbnQnKTtcblxuICAgIHZhciBxdWV1ZSA9IHRoaXMuX3F1ZXVlO1xuICAgIHZhciBub2RlO1xuXG4gICAgcGF5bG9hZC5ub2RlID0gdGhpcy5sb29rdXBOb2RlKHBhdGgpOyAvLyBBZnRlciB0aGlzIGNhbGwsIHRoZSBwYXRoIGlzIGxvYWRlZCBpbnRvIHRoZSBxdWV1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gKGxvb2tVcCBub2RlIGRvZXNuJ3QgY2xlYXIgdGhlIHF1ZXVlIGFmdGVyIHRoZSBsb29rdXApXG5cbiAgICB3aGlsZSAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIG5vZGUgPSBxdWV1ZS5wb3AoKTsgLy8gcG9wIG5vZGVzIG9mZiBvZiB0aGUgcXVldWUgdG8gbW92ZSB1cCB0aGUgYW5jZXN0b3IgY2hhaW4uXG4gICAgICAgIGlmIChub2RlLm9uUmVjZWl2ZSkgbm9kZS5vblJlY2VpdmUoZXZlbnQsIHBheWxvYWQpO1xuICAgIH1cbn07XG5cbi8qKlxuICogX3NwbGl0VG8gaXMgYSBwcml2YXRlIG1ldGhvZCB3aGljaCB0YWtlcyBhIHBhdGggYW5kIHNwbGl0cyBpdCBhdCBldmVyeSAnLydcbiAqIHB1c2hpbmcgdGhlIHJlc3VsdCBpbnRvIHRoZSBzdXBwbGllZCBhcnJheS4gVGhpcyBpcyBhIGRlc3RydWN0aXZlIGNoYW5nZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IHRoZSBzcGVjaWZpZWQgcGF0aFxuICogQHBhcmFtIHtBcnJheX0gdGhlIGFycmF5IHRvIHdoaWNoIHRoZSByZXN1bHQgc2hvdWxkIGJlIHdyaXR0ZW5cbiAqL1xuZnVuY3Rpb24gX3NwbGl0VG8gKHN0cmluZywgdGFyZ2V0KSB7XG4gICAgdGFyZ2V0Lmxlbmd0aCA9IDA7IC8vIGNsZWFycyB0aGUgYXJyYXkgZmlyc3QuXG4gICAgdmFyIGxhc3QgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHN0cmluZy5sZW5ndGggOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgIGlmIChzdHJpbmdbaV0gPT09ICcvJykge1xuICAgICAgICAgICAgdGFyZ2V0LnB1c2goc3RyaW5nLnN1YnN0cmluZyhsYXN0LCBpKSk7XG4gICAgICAgICAgICBsYXN0ID0gaSArIDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaSAtIGxhc3QgPiAwKSB0YXJnZXQucHVzaChzdHJpbmcuc3Vic3RyaW5nKGxhc3QsIGkpKTtcblxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGlzcGF0Y2g7XG5cbiIsIi8vIFRPRE86IFRoaXMgd2lsbCB3cmFwIFVJIGV2ZW50cyBhcyB0aGUgYnViYmxlIGluIHRoZSBzY2VuZSBncmFwaCB0byBhbGxvdyAuc3RvcFByb3BvZ2F0aW9uKCkgdG8gYmUgY2FsbGVkXG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIENoZWNrIHRvIHNlZSBpZiB3ZSdyZSBpbiBhIHdvcmtlclxudmFyIGlzV29ya2VyID0gdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYud2luZG93ICE9PSBzZWxmO1xuXG52YXIgQ2xvY2sgPSByZXF1aXJlKCcuL0Nsb2NrJyk7XG52YXIgQ29udGV4dCA9IHJlcXVpcmUoJy4vQ29udGV4dCcpO1xuXG4vKipcbiAqIEZhbW91cyBoYXMgdHdvIHJlc3BvbnNpYmlsaXRpZXMsIG9uZSB0byBhY3QgYXMgdGhlIGhpZ2hlc3QgbGV2ZWxcbiAqIHVwZGF0ZXIgYW5kIGFub3RoZXIgdG8gc2VuZCBtZXNzYWdlcyBvdmVyIHRvIHRoZSByZW5kZXJlcnMuIEl0IGlzXG4gKiBhIHNpbmdsZXRvbi5cbiAqL1xuZnVuY3Rpb24gRmFtb3VzICgpIHtcbiAgICB0aGlzLl91cGRhdGVRdWV1ZSA9IFtdOyAvLyBUaGUgdXBkYXRlUXVldWUgaXMgYSBwbGFjZSB3aGVyZSBub2Rlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbiBwbGFjZSB0aGVtc2VsdmVzIGluIG9yZGVyIHRvIGJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlZCBvbiB0aGUgZnJhbWUuXG4gICAgXG4gICAgdGhpcy5fbmV4dFVwZGF0ZVF1ZXVlID0gW107IC8vIHRoZSBuZXh0VXBkYXRlUXVldWUgaXMgdXNlZCB0byBxdWV1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGVzIGZvciB0aGUgbmV4dCB0aWNrLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHByZXZlbnRzIGluZmluaXRlIGxvb3BzIHdoZXJlIGR1cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbiB1cGRhdGUgYSBub2RlIGNvbnRpbnVvdXNseSBwdXRzIGl0c2VsZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBiYWNrIGluIHRoZSB1cGRhdGUgcXVldWUuXG5cbiAgICB0aGlzLl9jb250ZXh0cyA9IHt9OyAvLyBhIGhhc2ggb2YgYWxsIG9mIHRoZSBjb250ZXh0J3MgdGhhdCB0aGlzIGZhbW91c1xuICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzIHJlc3BvbnNpYmxlIGZvci5cblxuICAgIHRoaXMuX21lc3NhZ2VzID0gW107IC8vIGEgcXVldWUgb2YgYWxsIG9mIHRoZSBkcmF3IGNvbW1hbmRzIHRvIHNlbmQgdG8gdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHJlbmRlcmVycyB0aGlzIGZyYW1lLlxuXG4gICAgdGhpcy5faW5VcGRhdGUgPSBmYWxzZTsgLy8gd2hlbiB0aGUgZmFtb3VzIGlzIHVwZGF0aW5nIHRoaXMgaXMgdHJ1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbGwgcmVxdWVzdHMgZm9yIHVwZGF0ZXMgd2lsbCBnZXQgcHV0IGluIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5leHRVcGRhdGVRdWV1ZVxuXG4gICAgdGhpcy5fY2xvY2sgPSBuZXcgQ2xvY2soKTsgLy8gYSBjbG9jayB0byBrZWVwIHRyYWNrIG9mIHRpbWUgZm9yIHRoZSBzY2VuZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdyYXBoLlxuXG4gICAgLy8gaWYgZmFtb3VzIGlzIGluIGEgd29ya2VyIHdlIHdpcmUgdGhlIGV2ZW50IGxpc3RlbmVyIGhlcmUuXG4gICAgLy8gb3RoZXJ3aXNlIHRoZSB0aHJlYWQgbWFuYWdlciB3aWxsIHBvc3RNZXNzYWdlIGRpcmVjdGx5IHRvXG4gICAgLy8gZmFtb3VzXG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAoaXNXb3JrZXIpXG4gICAgICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgX3RoaXMucG9zdE1lc3NhZ2UoZXYuZGF0YSk7XG4gICAgICAgIH0pO1xufVxuXG4vKipcbiAqIF91cGRhdGUgaXMgdGhlIGJvZHkgb2YgdGhlIHVwZGF0ZSBsb29wLiBUaGUgZnJhbWUgY29uc2lzdHMgb2ZcbiAqIHB1bGxpbmcgaW4gYXBwZW5kaW5nIHRoZSBuZXh0VXBkYXRlUXVldWUgdG8gdGhlIGN1cnJlbnRVcGRhdGUgcXVldWVcbiAqIHRoZW4gbW92aW5nIHRocm91Z2ggdGhlIHVwZGF0ZVF1ZXVlIGFuZCBjYWxsaW5nIG9uVXBkYXRlIHdpdGggdGhlIGN1cnJlbnRcbiAqIHRpbWUgb24gYWxsIG5vZGVzLiBXaGlsZSBfdXBkYXRlIGlzIGNhbGxlZCBfaW5VcGRhdGUgaXMgc2V0IHRvIHRydWUgYW5kIFxuICogYWxsIHJlcXVlc3RzIHRvIGJlIHBsYWNlZCBpbiB0aGUgdXBkYXRlIHF1ZXVlIHdpbGwgYmUgZm9yd2FyZGVkIHRvIHRoZSBcbiAqIG5leHRVcGRhdGVRdWV1ZS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gVGhlIGN1cnJlbnQgdGltZVxuICovXG5GYW1vdXMucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiBfdXBkYXRlICh0aW1lKSB7XG4gICAgdGhpcy5faW5VcGRhdGUgPSB0cnVlO1xuICAgIHZhciBuZXh0UXVldWUgPSB0aGlzLl9uZXh0VXBkYXRlUXVldWU7XG4gICAgdmFyIHF1ZXVlID0gdGhpcy5fdXBkYXRlUXVldWU7XG4gICAgdmFyIGl0ZW07XG5cbiAgICB3aGlsZSAobmV4dFF1ZXVlLmxlbmd0aCkgcXVldWUudW5zaGlmdChuZXh0UXVldWUucG9wKCkpO1xuXG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBpdGVtID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5vblVwZGF0ZSkgaXRlbS5vblVwZGF0ZSh0aW1lKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pblVwZGF0ZSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiByZXF1ZXN0VXBkYXRlcyB0YWtlcyBhIGNsYXNzIHRoYXQgaGFzIGFuIG9uVXBkYXRlIG1ldGhvZCBhbmQgcHV0cyBpdFxuICogaW50byB0aGUgdXBkYXRlUXVldWUgdG8gYmUgdXBkYXRlZCBhdCB0aGUgbmV4dCBmcmFtZS5cbiAqIElmIEZhbW91cyBpcyBjdXJyZW50bHkgaW4gYW4gdXBkYXRlLCByZXF1ZXN0VXBkYXRlXG4gKiBwYXNzZXMgaXRzIGFyZ3VtZW50IHRvIHJlcXVlc3RVcGRhdGVPbk5leHRUaWNrLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhbiBvYmplY3Qgd2l0aCBhbiBvblVwZGF0ZSBtZXRob2RcbiAqL1xuRmFtb3VzLnByb3RvdHlwZS5yZXF1ZXN0VXBkYXRlID0gZnVuY3Rpb24gcmVxdWVzdFVwZGF0ZSAocmVxdWVzdGVyKSB7XG4gICAgaWYgKCFyZXF1ZXN0ZXIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdyZXF1ZXN0VXBkYXRlIG11c3QgYmUgY2FsbGVkIHdpdGggYSBjbGFzcyB0byBiZSB1cGRhdGVkJ1xuICAgICAgICApO1xuXG4gICAgaWYgKHRoaXMuX2luVXBkYXRlKSB0aGlzLnJlcXVlc3RVcGRhdGVPbk5leHRUaWNrKHJlcXVlc3Rlcik7XG4gICAgZWxzZSB0aGlzLl91cGRhdGVRdWV1ZS5wdXNoKHJlcXVlc3Rlcik7XG59O1xuXG4vKipcbiAqIHJlcXVlc3RVcGRhdGVPbk5leHRUaWNrIGlzIHJlcXVlc3RzIGFuIHVwZGF0ZSBvbiB0aGUgbmV4dCBmcmFtZS5cbiAqIElmIEZhbW91cyBpcyBub3QgY3VycmVudGx5IGluIGFuIHVwZGF0ZSB0aGFuIGl0IGlzIGZ1bmN0aW9uYWxseSBlcXVpdmFsZW50XG4gKiB0byByZXF1ZXN0VXBkYXRlLiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgdXNlZCB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzIHdoZXJlXG4gKiBhIGNsYXNzIGlzIHVwZGF0ZWQgb24gdGhlIGZyYW1lIGJ1dCBuZWVkcyB0byBiZSB1cGRhdGVkIGFnYWluIG5leHQgZnJhbWUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFuIG9iamVjdCB3aXRoIGFuIG9uVXBkYXRlIG1ldGhvZFxuICovXG5GYW1vdXMucHJvdG90eXBlLnJlcXVlc3RVcGRhdGVPbk5leHRUaWNrID0gZnVuY3Rpb24gcmVxdWVzdFVwZGF0ZU9uTmV4dFRpY2sgKHJlcXVlc3Rlcikge1xuICAgIHRoaXMuX25leHRVcGRhdGVRdWV1ZS5wdXNoKHJlcXVlc3Rlcik7XG59O1xuXG4vKipcbiAqIHBvc3RNZXNzYWdlIHNlbmRzIGEgbWVzc2FnZSBxdWV1ZSBpbnRvIEZhbW91cyB0byBiZSBwcm9jZXNzZWQuXG4gKiBUaGVzZSBtZXNzYWdlcyB3aWxsIGJlIGludGVycHJldGVkIGFuZCBzZW50IGludG8gdGhlIHNjZW5lIGdyYXBoXG4gKiBhcyBldmVudHMgaWYgbmVjZXNzYXJ5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFuIGFycmF5IG9mIGNvbW1hbmRzLlxuICogQGNoYWluYWJsZVxuICogXG4gKiBAcmV0dXJuIHtGYW1vdXN9IHRoaXNcbiAqL1xuRmFtb3VzLnByb3RvdHlwZS5wb3N0TWVzc2FnZSA9IGZ1bmN0aW9uIHBvc3RNZXNzYWdlIChtZXNzYWdlcykge1xuICAgIGlmICghbWVzc2FnZXMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdwb3N0TWVzc2FnZSBtdXN0IGJlIGNhbGxlZCB3aXRoIGFuIGFycmF5IG9mIG1lc3NhZ2VzJ1xuICAgICAgICApO1xuXG4gICAgdmFyIGNvbW1hbmQ7XG5cbiAgICB3aGlsZSAobWVzc2FnZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb21tYW5kID0gbWVzc2FnZXMuc2hpZnQoKTtcbiAgICAgICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICAgICAgICBjYXNlICdXSVRIJzpcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVdpdGgobWVzc2FnZXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnRlJBTUUnOlxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRnJhbWUobWVzc2FnZXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnSU5WT0tFJzpcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUludm9rZShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNlaXZlZCB1bmtub3duIGNvbW1hbmQ6ICcgKyBjb21tYW5kKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogaGFuZGxlV2l0aCBpcyBhIG1ldGhvZCB0aGF0IHRha2VzIGFuIGFycmF5IG9mIG1lc3NhZ2VzIGZvbGxvd2luZyB0aGVcbiAqIFdJVEggY29tbWFuZC4gSXQnbGwgdGhlbiBpc3N1ZSB0aGUgbmV4dCBjb21tYW5kcyB0byB0aGUgcGF0aCBzcGVjaWZpZWRcbiAqIGJ5IHRoZSBXSVRIIGNvbW1hbmQuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgb2YgbWVzc2FnZXMuXG4gKiBAY2hhaW5hYmxlXG4gKlxuICogQHJldHVybiB7RmFtb3VzfSB0aGlzXG4gKi9cbkZhbW91cy5wcm90b3R5cGUuaGFuZGxlV2l0aCA9IGZ1bmN0aW9uIGhhbmRsZVdpdGggKG1lc3NhZ2VzKSB7XG4gICAgdmFyIHBhdGggPSBtZXNzYWdlcy5zaGlmdCgpO1xuICAgIHZhciBjb21tYW5kID0gbWVzc2FnZXMuc2hpZnQoKTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuO1xuXG4gICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICAgIGNhc2UgJ1RSSUdHRVInOiAvLyB0aGUgVFJJR0dFUiBjb21tYW5kIHNlbmRzIGEgVUlFdmVudCB0byB0aGUgc3BlY2lmaWVkIHBhdGhcbiAgICAgICAgICAgIHZhciB0eXBlID0gbWVzc2FnZXMuc2hpZnQoKTtcbiAgICAgICAgICAgIHZhciBldiA9IG1lc3NhZ2VzLnNoaWZ0KCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuZ2V0Q29udGV4dChwYXRoKS5nZXREaXNwYXRjaCgpLmRpc3BhdGNoVUlFdmVudChwYXRoLCB0eXBlLCBldik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjZWl2ZWQgdW5rbm93biBjb21tYW5kOiAnICsgY29tbWFuZCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIGhhbmRsZUZyYW1lIGlzIGNhbGxlZCB3aGVuIHRoZSByZW5kZXJlcnMgaXNzdWUgYSBGUkFNRSBjb21tYW5kIHRvIFxuICogRmFtb3VzLiBGYW1vdXMgd2lsbCB0aGVuIHN0ZXAgdXBkYXRpbmcgdGhlIHNjZW5lIGdyYXBoIHRvIHRoZSBjdXJyZW50IHRpbWUuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgb2YgbWVzc2FnZXMuXG4gKiBAY2hhaW5hYmxlXG4gKlxuICogQHJldHVybiB7RmFtb3VzfSB0aGlzXG4gKi9cbkZhbW91cy5wcm90b3R5cGUuaGFuZGxlRnJhbWUgPSBmdW5jdGlvbiBoYW5kbGVGcmFtZSAobWVzc2FnZXMpIHtcbiAgICBpZiAoIW1lc3NhZ2VzKSB0aHJvdyBuZXcgRXJyb3IoJ2hhbmRsZUZyYW1lIG11c3QgYmUgY2FsbGVkIHdpdGggYW4gYXJyYXkgb2YgbWVzc2FnZXMnKTtcbiAgICBpZiAoIW1lc3NhZ2VzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdGUkFNRSBtdXN0IGJlIHNlbnQgd2l0aCBhIHRpbWUnKTtcblxuICAgIHRoaXMuc3RlcChtZXNzYWdlcy5zaGlmdCgpKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogc3RlcCB1cGRhdGVzIHRoZSBjbG9jayBhbmQgdGhlIHNjZW5lIGdyYXBoIGFuZCB0aGVuIHNlbmRzIHRoZSBkcmF3IGNvbW1hbmRzXG4gKiB0aGF0IGFjY3VtdWxhdGVkIGluIHRoZSB1cGRhdGUgdG8gdGhlIHJlbmRlcmVycy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gY3VycmVudCBlbmdpbmUgdGltZVxuICogQGNoYWluYWJsZVxuICpcbiAqIEByZXR1cm4ge0ZhbW91c30gdGhpc1xuICovXG5GYW1vdXMucHJvdG90eXBlLnN0ZXAgPSBmdW5jdGlvbiBzdGVwICh0aW1lKSB7XG4gICAgaWYgKHRpbWUgPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKCdzdGVwIG11c3QgYmUgY2FsbGVkIHdpdGggYSB0aW1lJyk7XG5cbiAgICB0aGlzLl9jbG9jay5zdGVwKHRpbWUpO1xuXG4gICAgdGhpcy5fdXBkYXRlKHRpbWUpO1xuXG4gICAgaWYgKHRoaXMuX21lc3NhZ2VzLmxlbmd0aCkge1xuICAgICAgICBpZiAoaXNXb3JrZXIpIHNlbGYucG9zdE1lc3NhZ2UodGhpcy5fbWVzc2FnZXMpO1xuICAgICAgICBlbHNlIHRoaXMub25tZXNzYWdlKHRoaXMuX21lc3NhZ2VzKTtcbiAgICB9XG4gICAgXG4gICAgdGhpcy5fbWVzc2FnZXMubGVuZ3RoID0gMDtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiByZXR1cm5zIHRoZSBjb250ZXh0IG9mIGEgcGFydGljdWxhciBwYXRoLiBUaGUgY29udGV4dCBpcyBsb29rZWQgdXAgYnkgdGhlIHNlbGVjdG9yXG4gKiBwb3J0aW9uIG9mIHRoZSBwYXRoIGFuZCBpcyBsaXN0ZWQgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIHN0cmluZyB0byB0aGUgZmlyc3RcbiAqICcvJy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdGhlIHBhdGggdG8gbG9vayB1cCB0aGUgY29udGV4dCBmb3IuXG4gKlxuICogQHJldHVybiB7Q29udGV4dCB8IFVuZGVmaW5lZH0gdGhlIGNvbnRleHQgaWYgZm91bmQsIGVsc2UgdW5kZWZpbmVkLlxuICovXG5GYW1vdXMucHJvdG90eXBlLmdldENvbnRleHQgPSBmdW5jdGlvbiBnZXRDb250ZXh0IChzZWxlY3Rvcikge1xuICAgIGlmICghc2VsZWN0b3IpIHRocm93IG5ldyBFcnJvcignZ2V0Q29udGV4dCBtdXN0IGJlIGNhbGxlZCB3aXRoIGEgc2VsZWN0b3InKTtcbiAgICBcbiAgICB2YXIgaW5kZXggPSBzZWxlY3Rvci5pbmRleE9mKCcvJyk7XG4gICAgc2VsZWN0b3IgPSBpbmRleCA9PT0gLTEgPyBzZWxlY3RvciA6IHNlbGVjdG9yLnN1YnN0cmluZygwLCBpbmRleCk7XG5cbiAgICByZXR1cm4gdGhpcy5fY29udGV4dHNbc2VsZWN0b3JdO1xufTtcblxuLyoqXG4gKiByZXR1cm5zIHRoZSBpbnN0YW5jZSBvZiBjbG9jayB3aXRoaW4gZmFtb3VzLlxuICpcbiAqIEByZXR1cm4ge0Nsb2NrfSBGYW1vdXMncyBjbG9ja1xuICovXG5GYW1vdXMucHJvdG90eXBlLmdldENsb2NrID0gZnVuY3Rpb24gZ2V0Q2xvY2sgKCkge1xuICAgIHJldHVybiB0aGlzLl9jbG9jaztcbn07XG5cbi8qKlxuICogcXVldWVzIGEgbWVzc2FnZSB0byBiZSB0cmFuc2ZlcmVkIHRvIHRoZSByZW5kZXJlcnMuXG4gKlxuICogQHBhcmFtIHtBbnl9IERyYXcgQ29tbWFuZFxuICogQGNoYWluYWJsZVxuICpcbiAqIEByZXR1cm4ge0ZhbW91c30gdGhpc1xuICovXG5GYW1vdXMucHJvdG90eXBlLm1lc3NhZ2UgPSBmdW5jdGlvbiBtZXNzYWdlIChjb21tYW5kKSB7XG4gICAgdGhpcy5fbWVzc2FnZXMucHVzaChjb21tYW5kKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNvbnRleHQgdW5kZXIgd2hpY2ggYSBzY2VuZSBncmFwaCBjb3VsZCBiZSBidWlsdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYSBkb20gc2VsZWN0b3IgZm9yIHdoZXJlIHRoZSBjb250ZXh0IHNob3VsZCBiZSBwbGFjZWRcbiAqXG4gKiBAcmV0dXJuIHtDb250ZXh0fSBhIG5ldyBpbnN0YW5jZSBvZiBDb250ZXh0LlxuICovXG5GYW1vdXMucHJvdG90eXBlLmNyZWF0ZUNvbnRleHQgPSBmdW5jdGlvbiBjcmVhdGVDb250ZXh0IChzZWxlY3Rvcikge1xuICAgIHNlbGVjdG9yID0gc2VsZWN0b3IgfHwgJ2JvZHknO1xuXG4gICAgaWYgKHRoaXMuX2NvbnRleHRzW3NlbGVjdG9yXSkgdGhpcy5fY29udGV4dHNbc2VsZWN0b3JdLmRpc21vdW50KCk7XG4gICAgdGhpcy5fY29udGV4dHNbc2VsZWN0b3JdID0gbmV3IENvbnRleHQoc2VsZWN0b3IsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzLl9jb250ZXh0c1tzZWxlY3Rvcl07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBGYW1vdXMoKTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKTtcbnZhciBTaXplID0gcmVxdWlyZSgnLi9TaXplJyk7XG5cbnZhciBUUkFOU0ZPUk1fUFJPQ0VTU09SID0gbmV3IFRyYW5zZm9ybSgpO1xudmFyIFNJWkVfUFJPQ0VTU09SID0gbmV3IFNpemUoKTtcblxudmFyIElERU5UID0gW1xuICAgIDEsIDAsIDAsIDAsXG4gICAgMCwgMSwgMCwgMCxcbiAgICAwLCAwLCAxLCAwLFxuICAgIDAsIDAsIDAsIDFcbl07XG5cbnZhciBPTkVTID0gWzEsIDEsIDFdO1xudmFyIFFVQVQgPSBbMCwgMCwgMCwgMV07XG5cbi8qKlxuICogTm9kZXMgZGVmaW5lIGhpZXJhcmNoeSBhbmQgZ2VvbWV0cmljYWwgdHJhbnNmb3JtYXRpb25zLiBUaGV5IGNhbiBiZSBtb3ZlZFxuICogKHRyYW5zbGF0ZWQpLCBzY2FsZWQgYW5kIHJvdGF0ZWQuXG4gKiBcbiAqIEEgTm9kZSBpcyBlaXRoZXIgbW91bnRlZCBvciB1bm1vdW50ZWQuIFVubW91bnRlZCBub2RlcyBhcmUgZGV0YWNoZWQgZnJvbSB0aGVcbiAqIHNjZW5lIGdyYXBoLiBVbm1vdW50ZWQgbm9kZXMgaGF2ZSBubyBwYXJlbnQgbm9kZSwgd2hpbGUgZWFjaCBtb3VudGVkIG5vZGUgaGFzXG4gKiBleGFjdGx5IG9uZSBwYXJlbnQuIE5vZGVzIGhhdmUgYW4gYXJiaXRhcnkgbnVtYmVyIG9mIGNoaWxkcmVuLCB3aGljaCBjYW4gYmVcbiAqIGR5bmFtaWNhbGx5IGFkZGVkIHVzaW5nIEB7QGxpbmsgYWRkQ2hpbGR9LlxuICpcbiAqIEVhY2ggTm9kZXMgaGF2ZSBhbiBhcmJpdHJhcnkgbnVtYmVyIG9mIGBjb21wb25lbnRzYC4gVGhvc2UgY29tcG9uZW50cyBjYW5cbiAqIHNlbmQgYGRyYXdgIGNvbW1hbmRzIHRvIHRoZSByZW5kZXJlciBvciBtdXRhdGUgdGhlIG5vZGUgaXRzZWxmLCBpbiB3aGljaCBjYXNlXG4gKiB0aGV5IGRlZmluZSBiZWhhdmlvciBpbiB0aGUgbW9zdCBleHBsaWNpdCB3YXkuIENvbXBvbmVudHMgdGhhdCBzZW5kIGBkcmF3YFxuICogY29tbWFuZHMgYWFyZSBjb25zaWRlcmVkIGByZW5kZXJhYmxlc2AuIEZyb20gdGhlIG5vZGUncyBwZXJzcGVjdGl2ZSwgdGhlcmUgaXNcbiAqIG5vIGRpc3RpbmN0aW9uIGJldHdlZW4gbm9kZXMgdGhhdCBzZW5kIGRyYXcgY29tbWFuZHMgYW5kIG5vZGVzIHRoYXQgZGVmaW5lXG4gKiBiZWhhdmlvci5cbiAqXG4gKiBCZWNhdXNlIG9mIHRoZSBmYWN0IHRoYXQgTm9kZXMgdGhlbXNlbGYgYXJlIHZlcnkgdW5vcGluaW90ZWQgKHRoZXkgZG9uJ3RcbiAqIFwicmVuZGVyXCIgdG8gYW55dGhpbmcpLCB0aGV5IGFyZSBvZnRlbiBiZWluZyBzdWJjbGFzc2VkIGluIG9yZGVyIHRvIGFkZCBlLmcuXG4gKiBjb21wb25lbnRzIGF0IGluaXRpYWxpemF0aW9uIHRvIHRoZW0uIEJlY2F1c2Ugb2YgdGhpcyBmbGV4aWJpbGl0eSwgdGhleSBtaWdodFxuICogYXMgd2VsbCBoYXZlIGJlZW4gY2FsbGVkIGBFbnRpdGllc2AuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIGNyZWF0ZSB0aHJlZSBkZXRhY2hlZCAodW5tb3VudGVkKSBub2Rlc1xuICogdmFyIHBhcmVudCA9IG5ldyBOb2RlKCk7XG4gKiB2YXIgY2hpbGQxID0gbmV3IE5vZGUoKTtcbiAqIHZhciBjaGlsZDIgPSBuZXcgTm9kZSgpO1xuICpcbiAqIC8vIGJ1aWxkIGFuIHVubW91bnRlZCBzdWJ0cmVlIChwYXJlbnQgaXMgc3RpbGwgZGV0YWNoZWQpXG4gKiBwYXJlbnQuYWRkQ2hpbGQoY2hpbGQxKTtcbiAqIHBhcmVudC5hZGRDaGlsZChjaGlsZDIpO1xuICpcbiAqIC8vIG1vdW50IHBhcmVudCBieSBhZGRpbmcgaXQgdG8gdGhlIGNvbnRleHRcbiAqIHZhciBjb250ZXh0ID0gRmFtb3VzLmNyZWF0ZUNvbnRleHQoXCJib2R5XCIpO1xuICogY29udGV4dC5hZGRDaGlsZChwYXJlbnQpO1xuICpcbiAqIEBjbGFzcyBOb2RlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gTm9kZSAoKSB7XG4gICAgdGhpcy5fY2FsY3VsYXRlZFZhbHVlcyA9IHtcbiAgICAgICAgdHJhbnNmb3JtOiBuZXcgRmxvYXQzMkFycmF5KElERU5UKSxcbiAgICAgICAgc2l6ZTogbmV3IEZsb2F0MzJBcnJheSgzKVxuICAgIH07XG5cbiAgICB0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy5faW5VcGRhdGUgPSBmYWxzZTtcblxuICAgIHRoaXMuX3VwZGF0ZVF1ZXVlID0gW107XG4gICAgdGhpcy5fbmV4dFVwZGF0ZVF1ZXVlID0gW107XG5cbiAgICB0aGlzLl9mcmVlZENvbXBvbmVudEluZGljaWVzID0gW107XG4gICAgdGhpcy5fY29tcG9uZW50cyA9IFtdO1xuXG4gICAgdGhpcy5fZnJlZWRDaGlsZEluZGljaWVzID0gW107XG4gICAgdGhpcy5fY2hpbGRyZW4gPSBbXTtcblxuICAgIHRoaXMuX3BhcmVudCA9IG51bGw7XG4gICAgdGhpcy5fZ2xvYmFsVXBkYXRlciA9IG51bGw7XG5cbiAgICB0aGlzLnZhbHVlID0gbmV3IE5vZGUuU3BlYygpO1xufVxuXG5Ob2RlLlJFTEFUSVZFX1NJWkUgPSBTaXplLlJFTEFUSVZFO1xuTm9kZS5BQlNPTFVURV9TSVpFID0gU2l6ZS5BQlNPTFVURTtcbk5vZGUuUkVOREVSX1NJWkUgPSBTaXplLlJFTkRFUjtcbk5vZGUuREVGQVVMVF9TSVpFID0gU2l6ZS5ERUZBVUxUO1xuXG4vKipcbiAqIEEgTm9kZSBzcGVjIGhvbGRzIHRoZSBcImRhdGFcIiBhc3NvY2lhdGVkIHdpdGggYSBOb2RlLlxuICpcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBsb2NhdGlvbiBwYXRoIHRvIHRoZSBub2RlIChlLmcuIFwiYm9keS8wLzFcIilcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBzaG93U3RhdGVcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc2hvd1N0YXRlLm1vdW50ZWRcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc2hvd1N0YXRlLnNob3duXG4gKiBAcHJvcGVydHkge051bWJlcn0gc2hvd1N0YXRlLm9wYWNpdHlcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBvZmZzZXRzXG4gKiBAcHJvcGVydHkge0Zsb2F0MzJBcnJheS48TnVtYmVyPn0gb2Zmc2V0cy5tb3VudFBvaW50XG4gKiBAcHJvcGVydHkge0Zsb2F0MzJBcnJheS48TnVtYmVyPn0gb2Zmc2V0cy5hbGlnblxuICogQHByb3BlcnR5IHtGbG9hdDMyQXJyYXkuPE51bWJlcj59IG9mZnNldHMub3JpZ2luXG4gKiBAcHJvcGVydHkge09iamVjdH0gdmVjdG9yc1xuICogQHByb3BlcnR5IHtGbG9hdDMyQXJyYXkuPE51bWJlcj59IHZlY3RvcnMucG9zaXRpb25cbiAqIEBwcm9wZXJ0eSB7RmxvYXQzMkFycmF5LjxOdW1iZXI+fSB2ZWN0b3JzLnJvdGF0aW9uXG4gKiBAcHJvcGVydHkge0Zsb2F0MzJBcnJheS48TnVtYmVyPn0gdmVjdG9ycy5zY2FsZVxuICogQHByb3BlcnR5IHtPYmplY3R9IHNpemVcbiAqIEBwcm9wZXJ0eSB7RmxvYXQzMkFycmF5LjxOdW1iZXI+fSBzaXplLnNpemVNb2RlXG4gKiBAcHJvcGVydHkge0Zsb2F0MzJBcnJheS48TnVtYmVyPn0gc2l6ZS5wcm9wb3J0aW9uYWxcbiAqIEBwcm9wZXJ0eSB7RmxvYXQzMkFycmF5LjxOdW1iZXI+fSBzaXplLmRpZmZlcmVudGlhbFxuICogQHByb3BlcnR5IHtGbG9hdDMyQXJyYXkuPE51bWJlcj59IHNpemUuYWJzb2x1dGVcbiAqIEBwcm9wZXJ0eSB7RmxvYXQzMkFycmF5LjxOdW1iZXI+fSBzaXplLnJlbmRlclxuICovXG5Ob2RlLlNwZWMgPSBmdW5jdGlvbiBTcGVjICgpIHtcbiAgICB0aGlzLmxvY2F0aW9uID0gbnVsbDtcbiAgICB0aGlzLnNob3dTdGF0ZSA9IHtcbiAgICAgICAgbW91bnRlZDogZmFsc2UsXG4gICAgICAgIHNob3duOiBmYWxzZSxcbiAgICAgICAgb3BhY2l0eTogMVxuICAgIH07XG4gICAgdGhpcy5vZmZzZXRzID0ge1xuICAgICAgICBtb3VudFBvaW50OiBuZXcgRmxvYXQzMkFycmF5KDMpLFxuICAgICAgICBhbGlnbjogbmV3IEZsb2F0MzJBcnJheSgzKSxcbiAgICAgICAgb3JpZ2luOiBuZXcgRmxvYXQzMkFycmF5KDMpXG4gICAgfTtcbiAgICB0aGlzLnZlY3RvcnMgPSB7XG4gICAgICAgIHBvc2l0aW9uOiBuZXcgRmxvYXQzMkFycmF5KDMpLFxuICAgICAgICByb3RhdGlvbjogbmV3IEZsb2F0MzJBcnJheShRVUFUKSxcbiAgICAgICAgc2NhbGU6IG5ldyBGbG9hdDMyQXJyYXkoT05FUylcbiAgICB9O1xuICAgIHRoaXMuc2l6ZSA9IHtcbiAgICAgICAgc2l6ZU1vZGU6IG5ldyBGbG9hdDMyQXJyYXkoW1NpemUuUkVMQVRJVkUsIFNpemUuUkVMQVRJVkUsIFNpemUuUkVMQVRJVkVdKSxcbiAgICAgICAgcHJvcG9ydGlvbmFsOiBuZXcgRmxvYXQzMkFycmF5KE9ORVMpLFxuICAgICAgICBkaWZmZXJlbnRpYWw6IG5ldyBGbG9hdDMyQXJyYXkoMyksXG4gICAgICAgIGFic29sdXRlOiBuZXcgRmxvYXQzMkFycmF5KDMpLFxuICAgICAgICByZW5kZXI6IG5ldyBGbG9hdDMyQXJyYXkoMylcbiAgICB9O1xuICAgIHRoaXMuVUlFdmVudHMgPSBbXTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBnZXRDb250ZXh0XG4gKiBAY2hhaW5hYmxlXG4gKlxuICogQGRlcHJlY2F0ZWQgTm9kZSBjYW4gYmUgdXNlZCBkaXJlY3RseSBpbnN0ZWFkIVxuICogQHJldHVybiB7Tm9kZX0gdGhpc1xuICovXG5Ob2RlLnByb3RvdHlwZS5nZXRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q29udGV4dCAoKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgICAnTm9kZSNnZXRDb250ZXh0IGlzIGRlcHJlY2F0ZWQhXFxuJyArXG4gICAgICAgICdOb2RlcyBjYW4gYmUgdXNlZCBkaXJlY3RseSEnXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQG1ldGhvZCBnZXREaXNwYXRjaFxuICogQGNoYWluYWJsZVxuICpcbiAqIEBkZXByZWNhdGVkIE5vZGUgY2FuIGJlIHVzZWQgZGlyZWN0bHkgaW5zdGVhZCFcbiAqIEByZXR1cm4ge05vZGV9IHRoaXNcbiAqL1xuTm9kZS5wcm90b3R5cGUuZ2V0RGlzcGF0Y2ggPSBmdW5jdGlvbiBnZXREaXNwYXRjaCAoKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgICAnTm9kZSNnZXREaXNwYXRjaCBpcyBkZXByZWNhdGVkIVxcbicgK1xuICAgICAgICAnQ29tcG9uZW50IGNvbnN0cnVjdG9ycyBhY2NlcHQgYSBOb2RlIGluc3RlYWQhJyArXG4gICAgICAgICdVc2UgbmV3IENvbXBvbmVudChub2RlKSBpbnN0ZWFkIG9mIG5ldyBDb21wb25lbnQobm9kZS5nZXREaXNwYXRjaCgpKSEnXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQG1ldGhvZCBnZXRSZW5kZXJQcm94eVxuICogQGNoYWluYWJsZVxuICpcbiAqIEBkZXByZWNhdGVkIE5vZGUgY2FuIGJlIHVzZWQgZGlyZWN0bHkgaW5zdGVhZCFcbiAqIEByZXR1cm4ge05vZGV9IHRoaXNcbiAqL1xuTm9kZS5wcm90b3R5cGUuZ2V0UmVuZGVyUHJveHkgPSBmdW5jdGlvbiBnZXRSZW5kZXJQcm94eSAoKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgICAnTm9kZSNnZXRSZW5kZXJQcm94eSBpcyBkZXByZWNhdGVkIVxcbicgK1xuICAgICAgICAnUmVuZGVyUHJveHkgZnVuY3Rpb25hbGl0eSBoYXMgYmVlbiBtZXJnZWQgaW50byBOb2RlISdcbiAgICApO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGdldFJlbmRlclBhdGhcbiAqIEBjaGFpbmFibGVcbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgI2dldExvY2F0aW9uKClcbiAqIEByZXR1cm4ge3N0cmluZ30gcmVuZGVyIHBhdGhcbiAqL1xuTm9kZS5wcm90b3R5cGUuZ2V0UmVuZGVyUGF0aCA9IGZ1bmN0aW9uIGdldFJlbmRlclBhdGggKCkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ05vZGUjZ2V0UmVuZGVyUGF0aCBpcyBkZXByZWNhdGVkIVxcbicgK1xuICAgICAgICAnVXNlIE5vZGUjZ2V0TG9jYXRpb24gaW5zdGVhZCEnXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5nZXRMb2NhdGlvbigpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGFkZFJlbmRlcmFibGVcbiAqIEBjaGFpbmFibGVcbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgYWRkQ29tcG9uZW50XG4gKiBAcGFyYW0geyp9IGNvbXBvbmVudCBjb21wb25lbnQgdG8gYmUgYWRkZWRcbiAqIEByZXR1cm4gdGhpc1xuICovXG5Ob2RlLnByb3RvdHlwZS5hZGRSZW5kZXJhYmxlID0gZnVuY3Rpb24gYWRkUmVuZGVyYWJsZSAoY29tcG9uZW50KSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgICAnTm9kZSNhZGRSZW5kZXJhYmxlIGlzIGRlcHJlY2F0ZWQhXFxuJyArXG4gICAgICAgICd1c2Ugbm9kZS5hZGRDb21wb25lbnQgaW5zdGVhZCdcbiAgICApO1xuICAgIHRoaXMuYWRkQ29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIERldGVybWluZSB0aGUgbm9kZSdzIGxvY2F0aW9uIGluIHRoZSBzY2VuZSBncmFwaCBoaWVyYXJjaHkuXG4gKiBBIGxvY2F0aW9uIG9mIGBib2R5LzAvMWAgY2FuIGJlIGludGVycHJldGVkIGFzIHRoZSBmb2xsb3dpbmcgc2NlbmUgZ3JhcGhcbiAqIGhpZXJhcmNoeSAoaWdub3Jpbmcgc2libGluZ3Mgb2YgYW5jZXN0b3JzIGFuZCBhZGRpdGlvbmFsIGNoaWxkIG5vZGVzKTpcbiAqXG4gKiBgQ29udGV4dDpib2R5YCAtPiBgTm9kZTowYCAtPiBgTm9kZToxYCwgd2hlcmUgYE5vZGU6MWAgaXMgdGhlIG5vZGUgdGhlXG4gKiBgZ2V0TG9jYXRpb25gIG1ldGhvZCBoYXMgYmVlbiBpbnZva2VkIG9uLlxuICpcbiAqIEBtZXRob2QgZ2V0TG9jYXRpb25cbiAqIFxuICogQHJldHVybiB7U3RyaW5nfSBsb2NhdGlvbiAocGF0aCksIGUuZy4gYGJvZHkvMC8xYFxuICovXG5Ob2RlLnByb3RvdHlwZS5nZXRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldExvY2F0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZS5sb2NhdGlvbjtcbn07XG5cbi8qKlxuICogQGFsaWFzIGdldElkXG4gKi9cbk5vZGUucHJvdG90eXBlLmdldElkID0gTm9kZS5wcm90b3R5cGUuZ2V0TG9jYXRpb247XG5cbi8qKlxuICogRGlzcGF0Y2hlcyB0aGUgZXZlbnQgb24gdGhlIG5vZGUgYnkgcmVjdXJzaXZlbHkgdHJhdmVyc2luZyB0aGUgc2NlbmUgZ3JhcGhcbiAqIHVwd2FyZHMuXG4gKlxuICogQG1ldGhvZCBlbWl0XG4gKiBcbiAqIEBwYXJhbSAge1N0cmluZ30gZXZlbnQgICBFdmVudCB0eXBlLlxuICogQHBhcmFtICB7T2JqZWN0fSBwYXlsb2FkIEV2ZW50IG9iamVjdCB0byBiZSBkaXNwYXRjaGVkLlxuICovXG5Ob2RlLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCAoZXZlbnQsIHBheWxvYWQpIHtcbiAgICB2YXIgcCA9IHRoaXMuZ2V0UGFyZW50KCk7XG4gICAgLy8gdGhlIGNvbnRleHQgaXMgaXRzIG93biBhbmNlc3RvclxuICAgIHdoaWxlIChwICE9PSAocCA9IHAuZ2V0UGFyZW50KCkpKTtcbiAgICBwLmdldERpc3BhdGNoKCkuZGlzcGF0Y2goZXZlbnQsIHBheWxvYWQpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLy8gVEhJUyBXSUxMIEJFIERFUFJJQ0FURURcbk5vZGUucHJvdG90eXBlLnNlbmREcmF3Q29tbWFuZCA9IGZ1bmN0aW9uIHNlbmREcmF3Q29tbWFuZCAobWVzc2FnZSkge1xuICAgIHRoaXMuX2dsb2JhbFVwZGF0ZXIubWVzc2FnZShtZXNzYWdlKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgc2VyaWFsaXplcyB0aGUgTm9kZSwgaW5jbHVkaW5nIGFsbCBwcmV2aW91c2x5IGFkZGVkIGNvbXBvbmVudHMuXG4gKlxuICogQG1ldGhvZCBnZXRWYWx1ZVxuICogXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICBTZXJpYWxpemVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBub2RlLCBpbmNsdWRpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuXG4gKi9cbk5vZGUucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gZ2V0VmFsdWUgKCkge1xuICAgIHZhciBudW1iZXJPZkNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoO1xuICAgIHZhciBudW1iZXJPZkNvbXBvbmVudHMgPSB0aGlzLl9jb21wb25lbnRzLmxlbmd0aDtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICB2YXIgdmFsdWUgPSB7XG4gICAgICAgIGxvY2F0aW9uOiB0aGlzLnZhbHVlLmxvY2F0aW9uLFxuICAgICAgICBzcGVjOiB0aGlzLnZhbHVlLFxuICAgICAgICBjb21wb25lbnRzOiBuZXcgQXJyYXkobnVtYmVyT2ZDb21wb25lbnRzKSxcbiAgICAgICAgY2hpbGRyZW46IG5ldyBBcnJheShudW1iZXJPZkNoaWxkcmVuKVxuICAgIH07XG5cbiAgICBmb3IgKDsgaSA8IG51bWJlck9mQ2hpbGRyZW4gOyBpKyspXG4gICAgICAgIHZhbHVlLmNoaWxkcmVuW2ldID0gdGhpcy5fY2hpbGRyZW5baV0uZ2V0VmFsdWUoKTtcblxuICAgIGZvciAoaSA9IDAgOyBpIDwgbnVtYmVyT2ZDb21wb25lbnRzIDsgaSsrKVxuICAgICAgICBpZiAodGhpcy5fY29tcG9uZW50c1tpXS5nZXRWYWx1ZSlcbiAgICAgICAgICAgIHZhbHVlLmNvbXBvbmVudHNbaV0gPSB0aGlzLl9jb21wb25lbnRzW2ldLmdldFZhbHVlKCk7XG5cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG4vKipcbiAqIFNpbWlsYXIgdG8gQHtAbGluayBnZXRWYWx1ZX0sIGJ1dCByZXR1cm5zIHRoZSBhY3R1YWwgXCJjb21wdXRlZFwiIHZhbHVlLiBFLmcuXG4gKiBhIHByb3BvcnRpb25hbCBzaXplIG9mIDAuNSBtaWdodCByZXNvbHZlIGludG8gYSBcImNvbXB1dGVkXCIgc2l6ZSBvZiAyMDBweFxuICogKGFzc3VtaW5nIHRoZSBwYXJlbnQgaGFzIGEgd2lkdGggb2YgNDAwcHgpLlxuICpcbiAqIEBtZXRob2QgZ2V0Q29tcHV0ZWRWYWx1ZVxuICogXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICBTZXJpYWxpemVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBub2RlLCBpbmNsdWRpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLCBleGNsdWRpbmcgY29tcG9uZW50cy5cbiAqL1xuTm9kZS5wcm90b3R5cGUuZ2V0Q29tcHV0ZWRWYWx1ZSA9IGZ1bmN0aW9uIGdldENvbXB1dGVkVmFsdWUgKCkge1xuICAgIHZhciBudW1iZXJPZkNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoO1xuXG4gICAgdmFyIHZhbHVlID0ge1xuICAgICAgICBsb2NhdGlvbjogdGhpcy52YWx1ZS5sb2NhdGlvbixcbiAgICAgICAgY29tcHV0ZWRWYWx1ZXM6IHRoaXMuX2NhbGN1bGF0ZWRWYWx1ZXMsXG4gICAgICAgIGNoaWxkcmVuOiBuZXcgQXJyYXkobnVtYmVyT2ZDaGlsZHJlbilcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgbnVtYmVyT2ZDaGlsZHJlbiA7IGkrKylcbiAgICAgICAgdmFsdWUuY2hpbGRyZW5baV0gPSB0aGlzLl9jaGlsZHJlbltpXS5nZXRDb21wdXRlZFZhbHVlKCk7XG5cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlcyBhbGwgY2hpbGRyZW4gb2YgdGhlIGN1cnJlbnQgbm9kZS5cbiAqXG4gKiBAbWV0aG9kIGdldENoaWxkcmVuXG4gKiBcbiAqIEByZXR1cm4ge0FycmF5LjxOb2RlPn0gICBBbiBhcnJheSBvZiBjaGlsZHJlbi5cbiAqL1xuTm9kZS5wcm90b3R5cGUuZ2V0Q2hpbGRyZW4gPSBmdW5jdGlvbiBnZXRDaGlsZHJlbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIHBhcmVudCBvZiB0aGUgY3VycmVudCBub2RlLiBVbm1vdW50ZWQgbm9kZXMgZG8gbm90IGhhdmUgYVxuICogcGFyZW50IG5vZGUuXG4gKlxuICogQG1ldGhvZCBnZXRQYXJlbnRcbiAqIFxuICogQHJldHVybiB7Tm9kZX0gICAgICAgUGFyZW50IG5vZGUuXG4gKi9cbk5vZGUucHJvdG90eXBlLmdldFBhcmVudCA9IGZ1bmN0aW9uIGdldFBhcmVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudDtcbn07XG5cbi8qKlxuICogU2NoZWR1bGVzIHRoZSBAe0BsaW5rIHVwZGF0ZX0gZnVuY3Rpb24gb2YgdGhlIG5vZGUgdG8gYmUgaW52b2tlZCBvbiB0aGUgbmV4dFxuICogZnJhbWUgKGlmIG5vIHVwZGF0ZSBkdXJpbmcgdGhpcyBmcmFtZSBoYXMgYmVlbiBzY2hlZHVsZWQgYWxyZWFkeSkuXG4gKiBJZiB0aGUgbm9kZSBpcyBjdXJyZW50bHkgYmVpbmcgdXBkYXRlZCAod2hpY2ggbWVhbnMgb25lIG9mIHRoZSByZXF1ZXN0ZXJzXG4gKiBpbnZva2VkIHJlcXVlc3RzVXBkYXRlIHdoaWxlIGJlaW5nIHVwZGF0ZWQgaXRzZWxmKSwgYW4gdXBkYXRlIHdpbGwgYmVcbiAqIHNjaGVkdWxlZCBvbiB0aGUgbmV4dCBmcmFtZS5cbiAqXG4gKiBAbWV0aG9kIHJlcXVlc3RVcGRhdGVcbiAqIFxuICogQHBhcmFtICB7T2JqZWN0fSByZXF1ZXN0ZXIgICBJZiB0aGUgcmVxdWVzdGVyIGhhcyBhbiBgb25VcGRhdGVgIG1ldGhvZCwgaXRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBiZSBpbnZva2VkIGR1cmluZyB0aGUgbmV4dCB1cGRhdGUgcGhhc2Ugb2ZcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG5vZGUuXG4gKi9cbk5vZGUucHJvdG90eXBlLnJlcXVlc3RVcGRhdGUgPSBmdW5jdGlvbiByZXF1ZXN0VXBkYXRlIChyZXF1ZXN0ZXIpIHtcbiAgICBpZiAodGhpcy5faW5VcGRhdGUpIHJldHVybiB0aGlzLnJlcXVlc3RVcGRhdGVPbk5leHRUaWNrKHJlcXVlc3Rlcik7XG4gICAgdGhpcy5fdXBkYXRlUXVldWUucHVzaChyZXF1ZXN0ZXIpO1xuICAgIGlmICghdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSkgdGhpcy5fcmVxdWVzdFVwZGF0ZSgpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTY2hlZHVsZXMgYW4gdXBkYXRlIG9uIHRoZSBuZXh0IHRpY2suIFNpbWlsYXJpbHkgdG8gQHtAbGluayByZXF1ZXN0VXBkYXRlfSxcbiAqIGByZXF1ZXN0VXBkYXRlT25OZXh0VGlja2Agc2NoZWR1bGVzIHRoZSBub2RlJ3MgYG9uVXBkYXRlYCBmdW5jdGlvbiB0byBiZVxuICogaW52b2tlZCBvbiB0aGUgZnJhbWUgYWZ0ZXIgdGhlIG5leHQgaW52b2NhdGlvbiBvbiB0aGUgbm9kZSdzIG9uVXBkYXRlIGZ1bmN0aW9uLlxuICpcbiAqIEBtZXRob2QgcmVxdWVzdFVwZGF0ZU9uTmV4dFRpY2tcbiAqIFxuICogQHBhcmFtICB7T2JqZWN0fSByZXF1ZXN0ZXIgICBJZiB0aGUgcmVxdWVzdGVyIGhhcyBhbiBgb25VcGRhdGVgIG1ldGhvZCwgaXRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBiZSBpbnZva2VkIGR1cmluZyB0aGUgbmV4dCB1cGRhdGUgcGhhc2Ugb2ZcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG5vZGUuXG4gKi9cbk5vZGUucHJvdG90eXBlLnJlcXVlc3RVcGRhdGVPbk5leHRUaWNrID0gZnVuY3Rpb24gcmVxdWVzdFVwZGF0ZU9uTmV4dFRpY2sgKHJlcXVlc3Rlcikge1xuICAgIHRoaXMuX25leHRVcGRhdGVRdWV1ZS5wdXNoKHJlcXVlc3Rlcik7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIElmIHRoZSBjb250ZXh0IGhhcyBiZWVuIGNyZWF0ZWQgdXNpbmcgQHtAbGluayBGYW1vdXMuY3JlYXRlQ29udGV4dH0sIHRoZVxuICogQHtAbGluayBGYW1vdXN9IHNpbmdsZXRvbiB3aWxsIGJlIHRoZSBnbG9iYWwgdXBkYXRlci5cbiAqXG4gKiBAbWV0aG9kIGdldFVwZGF0ZXJcbiAqIFxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZ2xvYmFsIHVwZGF0ZXIuXG4gKi9cbk5vZGUucHJvdG90eXBlLmdldFVwZGF0ZXIgPSBmdW5jdGlvbiBnZXRVcGRhdGVyICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2xvYmFsVXBkYXRlcjtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBub2RlIGlzIG1vdW50ZWQuIFVubW91bnRlZCBub2RlcyBhcmUgZGV0YWNoZWQgZnJvbSB0aGUgc2NlbmVcbiAqIGdyYXBoLlxuICpcbiAqIEBtZXRob2QgaXNNb3VudGVkXG4gKiBcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgIEJvb2xlYW4gaW5kaWNhdGluZyB3ZWF0aGVyIHRoZSBub2RlIGlzIG1vdW50ZWQgb3Igbm90LlxuICovXG5Ob2RlLnByb3RvdHlwZS5pc01vdW50ZWQgPSBmdW5jdGlvbiBpc01vdW50ZWQgKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlLnNob3dTdGF0ZS5tb3VudGVkO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIG5vZGUgaXMgdmlzaWJsZSAoXCJzaG93blwiKS5cbiAqXG4gKiBAbWV0aG9kIGlzU2hvd25cbiAqIFxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgQm9vbGVhbiBpbmRpY2F0aW5nIHdlYXRoZXIgdGhlIG5vZGUgaXMgdmlzaWJsZVxuICogICAgICAgICAgICAgICAgICAgICAgKFwic2hvd25cIikgb3Igbm90LlxuICovXG5Ob2RlLnByb3RvdHlwZS5pc1Nob3duID0gZnVuY3Rpb24gaXNTaG93biAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUuc2hvd1N0YXRlLnNob3duO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBub2RlJ3MgcmVsYXRpdmUgb3BhY2l0eS5cbiAqIFRoZSBvcGFjaXR5IG5lZWRzIHRvIGJlIHdpdGhpbiBbMCwgMV0sIHdoZXJlIDAgaW5kaWNhdGVzIGEgY29tcGxldGVseVxuICogdHJhbnNwYXJlbnQsIHRoZXJlZm9yZSBpbnZpc2libGUgbm9kZSwgd2hlcmVhcyBhbiBvcGFjaXR5IG9mIDEgbWVhbnMgdGhlXG4gKiBub2RlIGlzIGNvbXBsZXRlbHkgc29saWQuXG4gKlxuICogQG1ldGhvZCBnZXRPcGFjaXR5XG4gKiBcbiAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICBSZWxhdGl2ZSBvcGFjaXR5IG9mIHRoZSBub2RlLlxuICovXG5Ob2RlLnByb3RvdHlwZS5nZXRPcGFjaXR5ID0gZnVuY3Rpb24gZ2V0T3BhY2l0eSAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUuc2hvd1N0YXRlLm9wYWNpdHk7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgdGhlIG5vZGUncyBwcmV2aW91c2x5IHNldCBtb3VudCBwb2ludC5cbiAqIFxuICogQG1ldGhvZCBnZXRNb3VudFBvaW50XG4gKiBcbiAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheX0gICBBbiBhcnJheSByZXByZXNlbnRpbmcgdGhlIG1vdW50IHBvaW50LlxuICovXG5Ob2RlLnByb3RvdHlwZS5nZXRNb3VudFBvaW50ID0gZnVuY3Rpb24gZ2V0TW91bnRQb2ludCAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUub2Zmc2V0cy5tb3VudFBvaW50O1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBub2RlJ3MgcHJldmlvdXNseSBzZXQgYWxpZ24uXG4gKiBcbiAqIEBtZXRob2QgZ2V0QWxpZ25cbiAqIFxuICogQHJldHVybiB7RmxvYXQzMkFycmF5fSAgIEFuIGFycmF5IHJlcHJlc2VudGluZyB0aGUgYWxpZ24uXG4gKi9cbk5vZGUucHJvdG90eXBlLmdldEFsaWduID0gZnVuY3Rpb24gZ2V0QWxpZ24gKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlLm9mZnNldHMuYWxpZ247XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgdGhlIG5vZGUncyBwcmV2aW91c2x5IHNldCBvcmlnaW4uXG4gKiBcbiAqIEBtZXRob2QgZ2V0T3JpZ2luXG4gKiBcbiAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheX0gICBBbiBhcnJheSByZXByZXNlbnRpbmcgdGhlIG9yaWdpbi5cbiAqL1xuTm9kZS5wcm90b3R5cGUuZ2V0T3JpZ2luID0gZnVuY3Rpb24gZ2V0T3JpZ2luICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZS5vZmZzZXRzLm9yaWdpbjtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgbm9kZSdzIHByZXZpb3VzbHkgc2V0IHBvc2l0aW9uLlxuICpcbiAqIEBtZXRob2QgZ2V0UG9zaXRpb25cbiAqIFxuICogQHJldHVybiB7RmxvYXQzMkFycmF5fSAgIEFuIGFycmF5IHJlcHJlc2VudGluZyB0aGUgcG9zaXRpb24uXG4gKi9cbk5vZGUucHJvdG90eXBlLmdldFBvc2l0aW9uID0gZnVuY3Rpb24gZ2V0UG9zaXRpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlLnZlY3RvcnMucG9zaXRpb247XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5nZXRSb3RhdGlvbiA9IGZ1bmN0aW9uIGdldFJvdGF0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZS52ZWN0b3JzLnJvdGF0aW9uO1xufTtcblxuTm9kZS5wcm90b3R5cGUuZ2V0U2NhbGUgPSBmdW5jdGlvbiBnZXRTY2FsZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUudmVjdG9ycy5zY2FsZTtcbn07XG5cbk5vZGUucHJvdG90eXBlLmdldFNpemVNb2RlID0gZnVuY3Rpb24gZ2V0U2l6ZU1vZGUgKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlLnNpemUuc2l6ZU1vZGU7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5nZXRQcm9wb3J0aW9uYWxTaXplID0gZnVuY3Rpb24gZ2V0UHJvcG9ydGlvbmFsU2l6ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUuc2l6ZS5wcm9wb3J0aW9uYWw7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5nZXREaWZmZXJlbnRpYWxTaXplID0gZnVuY3Rpb24gZ2V0RGlmZmVyZW50aWFsU2l6ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUuc2l6ZS5kaWZmZXJlbnRpYWw7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5nZXRBYnNvbHV0ZVNpemUgPSBmdW5jdGlvbiBnZXRBYnNvbHV0ZVNpemUgKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlLnNpemUuYWJzb2x1dGU7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5nZXRSZW5kZXJTaXplID0gZnVuY3Rpb24gZ2V0UmVuZGVyU2l6ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUuc2l6ZS5yZW5kZXI7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5nZXRTaXplID0gZnVuY3Rpb24gZ2V0U2l6ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGN1bGF0ZWRWYWx1ZXMuc2l6ZTtcbn07XG5cbk5vZGUucHJvdG90eXBlLmdldFRyYW5zZm9ybSA9IGZ1bmN0aW9uIGdldFRyYW5zZm9ybSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGN1bGF0ZWRWYWx1ZXMudHJhbnNmb3JtO1xufTtcblxuTm9kZS5wcm90b3R5cGUuZ2V0VUlFdmVudHMgPSBmdW5jdGlvbiBnZXRVSUV2ZW50cyAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUuVUlFdmVudHM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5hZGRDaGlsZCA9IGZ1bmN0aW9uIGFkZENoaWxkIChjaGlsZCkge1xuICAgIHZhciBpbmRleCA9IGNoaWxkID8gdGhpcy5fY2hpbGRyZW4uaW5kZXhPZihjaGlsZCkgOiAtMTtcbiAgICBjaGlsZCA9IGNoaWxkID8gY2hpbGQgOiBuZXcgTm9kZSgpO1xuXG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICBpbmRleCA9IHRoaXMuX2ZyZWVkQ2hpbGRJbmRpY2llcy5sZW5ndGggPyB0aGlzLl9mcmVlZENoaWxkSW5kaWNpZXMucG9wKCkgOiB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuW2luZGV4XSA9IGNoaWxkO1xuXG4gICAgICAgIGlmICh0aGlzLmlzTW91bnRlZCgpICYmIGNoaWxkLm9uTW91bnQpIHtcbiAgICAgICAgICAgIHZhciBteUlkID0gdGhpcy5nZXRJZCgpO1xuICAgICAgICAgICAgdmFyIGNoaWxkSWQgPSBteUlkICsgJy8nICsgaW5kZXg7XG4gICAgICAgICAgICBjaGlsZC5vbk1vdW50KHRoaXMsIGNoaWxkSWQpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gY2hpbGQ7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIHJlbW92ZUNoaWxkIChjaGlsZCkge1xuICAgIHZhciBpbmRleCA9IHRoaXMuX2NoaWxkcmVuLmluZGV4T2YoY2hpbGQpO1xuICAgIHZhciBhZGRlZCA9IGluZGV4ICE9PSAtMTtcbiAgICBpZiAoYWRkZWQpIHtcbiAgICAgICAgdGhpcy5fZnJlZWRDaGlsZEluZGljaWVzLnB1c2goaW5kZXgpO1xuXG4gICAgICAgIGlmICh0aGlzLmlzTW91bnRlZCgpICYmIGNoaWxkLm9uRGlzbW91bnQpXG4gICAgICAgICAgICBjaGlsZC5vbkRpc21vdW50KCk7XG5cbiAgICAgICAgdGhpcy5fY2hpbGRyZW5baW5kZXhdID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGFkZGVkO1xufTtcblxuLyoqXG4gKiBFYWNoIGNvbXBvbmVudCBjYW4gb25seSBiZSBhZGRlZCBvbmNlIHBlciBub2RlLlxuICpcbiAqIEBtZXRob2QgYWRkQ29tcG9uZW50XG4gKiBcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb21wb25lbnQgICAgQW4gY29tcG9uZW50IHRvIGJlIGFkZGVkLlxuICovXG5Ob2RlLnByb3RvdHlwZS5hZGRDb21wb25lbnQgPSBmdW5jdGlvbiBhZGRDb21wb25lbnQgKGNvbXBvbmVudCkge1xuICAgIHZhciBpbmRleCA9IHRoaXMuX2NvbXBvbmVudHMuaW5kZXhPZihjb21wb25lbnQpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgaW5kZXggPSB0aGlzLl9mcmVlZENvbXBvbmVudEluZGljaWVzLmxlbmd0aCA/IHRoaXMuX2ZyZWVkQ29tcG9uZW50SW5kaWNpZXMucG9wKCkgOiB0aGlzLl9jb21wb25lbnRzLmxlbmd0aDtcbiAgICAgICAgdGhpcy5fY29tcG9uZW50c1tpbmRleF0gPSBjb21wb25lbnQ7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNNb3VudGVkKCkgJiYgY29tcG9uZW50Lm9uTW91bnQpXG4gICAgICAgICAgICBjb21wb25lbnQub25Nb3VudCh0aGlzLCBpbmRleCk7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNTaG93bigpICYmIGNvbXBvbmVudC5vblNob3cpXG4gICAgICAgICAgICBjb21wb25lbnQub25TaG93KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZGV4O1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgcHJldmlvdXNseSB2aWEgQHtAbGluayBhZGRDb21wb25lbnR9IGFkZGVkIGNvbXBvbmVudC5cbiAqXG4gKiBAbWV0aG9kIHJlbW92ZUNvbXBvbmVudFxuICogXG4gKiBAcGFyYW0gIHtPYmplY3R9IGNvbXBvbmVudCAgIEFuIGNvbXBvbmVudCB0aGF0IGhhcyBwcmV2aW91c2x5IGJlZW4gYWRkZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNpbmcgQHtAbGluayBhZGRDb21wb25lbnR9LlxuICovXG5Ob2RlLnByb3RvdHlwZS5yZW1vdmVDb21wb25lbnQgPSBmdW5jdGlvbiByZW1vdmVDb21wb25lbnQgKGNvbXBvbmVudCkge1xuICAgIHZhciBpbmRleCA9IHRoaXMuX2NvbXBvbmVudHMuaW5kZXhPZihjb21wb25lbnQpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5fZnJlZWRDb21wb25lbnRJbmRpY2llcy5wdXNoKGluZGV4KTtcbiAgICAgICAgaWYgKHRoaXMuaXNTaG93bigpICYmIGNvbXBvbmVudC5vbkhpZGUpXG4gICAgICAgICAgICBjb21wb25lbnQub25IaWRlKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNNb3VudGVkKCkgJiYgY29tcG9uZW50Lm9uRGlzbW91bnQpXG4gICAgICAgICAgICBjb21wb25lbnQub25EaXNtb3VudCgpO1xuXG4gICAgICAgIHRoaXMuX2NvbXBvbmVudHNbaW5kZXhdID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbn07XG5cbk5vZGUucHJvdG90eXBlLmFkZFVJRXZlbnQgPSBmdW5jdGlvbiBhZGRVSUV2ZW50IChldmVudE5hbWUpIHtcbiAgICB2YXIgVUlFdmVudHMgPSB0aGlzLmdldFVJRXZlbnRzKCk7XG4gICAgdmFyIGNvbXBvbmVudHMgPSB0aGlzLl9jb21wb25lbnRzO1xuICAgIHZhciBjb21wb25lbnQ7XG5cbiAgICB2YXIgYWRkZWQgPSBVSUV2ZW50cy5pbmRleE9mKGV2ZW50TmFtZSkgIT09IC0xO1xuICAgIGlmICghYWRkZWQpIHtcbiAgICAgICAgVUlFdmVudHMucHVzaChldmVudE5hbWUpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29tcG9uZW50cy5sZW5ndGggOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgICAgICBjb21wb25lbnQgPSBjb21wb25lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5vbkFkZFVJRXZlbnQpIGNvbXBvbmVudC5vbkFkZFVJRXZlbnQoZXZlbnROYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYWRkZWQ7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5fcmVxdWVzdFVwZGF0ZSA9IGZ1bmN0aW9uIF9yZXF1ZXN0VXBkYXRlIChmb3JjZSkge1xuICAgIGlmIChmb3JjZSB8fCAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgJiYgdGhpcy5fZ2xvYmFsVXBkYXRlcikpIHtcbiAgICAgICAgdGhpcy5fZ2xvYmFsVXBkYXRlci5yZXF1ZXN0VXBkYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5fdmVjT3B0aW9uYWxTZXQgPSBmdW5jdGlvbiBfdmVjT3B0aW9uYWxTZXQgKHZlYywgaW5kZXgsIHZhbCkge1xuICAgIGlmICh2YWwgIT0gbnVsbCAmJiB2ZWNbaW5kZXhdICE9PSB2YWwpIHtcbiAgICAgICAgdmVjW2luZGV4XSA9IHZhbDtcbiAgICAgICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyAoKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBpdGVtcyA9IHRoaXMuX2NvbXBvbmVudHM7XG4gICAgdmFyIGxlbiA9IGl0ZW1zLmxlbmd0aDtcbiAgICB2YXIgaXRlbTtcblxuICAgIHRoaXMudmFsdWUuc2hvd1N0YXRlLnNob3duID0gdHJ1ZTtcblxuICAgIGZvciAoOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5vblNob3cpIGl0ZW0ub25TaG93KCk7XG4gICAgfVxuXG4gICAgaSA9IDA7XG4gICAgaXRlbXMgPSB0aGlzLl9jaGlsZHJlbjtcbiAgICBsZW4gPSBpdGVtcy5sZW5ndGg7XG5cbiAgICBmb3IgKDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgIGlmIChpdGVtICYmIGl0ZW0ub25QYXJlbnRTaG93KSBpdGVtLm9uUGFyZW50U2hvdygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiBoaWRlICgpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGl0ZW1zID0gdGhpcy5fY29tcG9uZW50cztcbiAgICB2YXIgbGVuID0gaXRlbXMubGVuZ3RoO1xuICAgIHZhciBpdGVtO1xuXG4gICAgdGhpcy52YWx1ZS5zaG93U3RhdGUuc2hvd24gPSBmYWxzZTtcblxuICAgIGZvciAoOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5vbkhpZGUpIGl0ZW0ub25IaWRlKCk7XG4gICAgfVxuXG4gICAgaSA9IDA7XG4gICAgaXRlbXMgPSB0aGlzLl9jaGlsZHJlbjtcbiAgICBsZW4gPSBpdGVtcy5sZW5ndGg7XG5cbiAgICBmb3IgKDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgIGlmIChpdGVtICYmIGl0ZW0ub25QYXJlbnRIaWRlKSBpdGVtLm9uUGFyZW50SGlkZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLnNldEFsaWduID0gZnVuY3Rpb24gc2V0QWxpZ24gKHgsIHksIHopIHtcbiAgICB2YXIgdmVjMyA9IHRoaXMudmFsdWUub2Zmc2V0cy5hbGlnbjtcbiAgICB2YXIgcHJvcG9nYXRlID0gZmFsc2U7XG5cbiAgICBwcm9wb2dhdGUgPSB0aGlzLl92ZWNPcHRpb25hbFNldCh2ZWMzLCAwLCB4KSB8fCBwcm9wb2dhdGU7XG4gICAgcHJvcG9nYXRlID0gdGhpcy5fdmVjT3B0aW9uYWxTZXQodmVjMywgMSwgeSkgfHwgcHJvcG9nYXRlO1xuICAgIGlmICh6ICE9IG51bGwpIHByb3BvZ2F0ZSA9IHRoaXMuX3ZlY09wdGlvbmFsU2V0KHZlYzMsIDIsICh6IC0gMC41KSkgfHwgcHJvcG9nYXRlO1xuXG4gICAgaWYgKHByb3BvZ2F0ZSkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5fY29tcG9uZW50cztcbiAgICAgICAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgICAgICB2YXIgaXRlbTtcbiAgICAgICAgeCA9IHZlYzNbMF07XG4gICAgICAgIHkgPSB2ZWMzWzFdO1xuICAgICAgICB6ID0gdmVjM1syXTtcbiAgICAgICAgZm9yICg7IGkgPCBsZW4gOyBpKyspIHtcbiAgICAgICAgICAgIGl0ZW0gPSBsaXN0W2ldO1xuICAgICAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5vbkFsaWduQ2hhbmdlKSBpdGVtLm9uQWxpZ25DaGFuZ2UoeCwgeSwgeik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5zZXRNb3VudFBvaW50ID0gZnVuY3Rpb24gc2V0TW91bnRQb2ludCAoeCwgeSwgeikge1xuICAgIHZhciB2ZWMzID0gdGhpcy52YWx1ZS5vZmZzZXRzLm1vdW50UG9pbnQ7XG4gICAgdmFyIHByb3BvZ2F0ZSA9IGZhbHNlO1xuXG4gICAgcHJvcG9nYXRlID0gdGhpcy5fdmVjT3B0aW9uYWxTZXQodmVjMywgMCwgeCkgfHwgcHJvcG9nYXRlO1xuICAgIHByb3BvZ2F0ZSA9IHRoaXMuX3ZlY09wdGlvbmFsU2V0KHZlYzMsIDEsIHkpIHx8IHByb3BvZ2F0ZTtcbiAgICBpZiAoeiAhPSBudWxsKSBwcm9wb2dhdGUgPSB0aGlzLl92ZWNPcHRpb25hbFNldCh2ZWMzLCAyLCAoeiAtIDAuNSkpIHx8IHByb3BvZ2F0ZTtcblxuICAgIGlmIChwcm9wb2dhdGUpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGlzdCA9IHRoaXMuX2NvbXBvbmVudHM7XG4gICAgICAgIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgdmFyIGl0ZW07XG4gICAgICAgIHggPSB2ZWMzWzBdO1xuICAgICAgICB5ID0gdmVjM1sxXTtcbiAgICAgICAgeiA9IHZlYzNbMl07XG4gICAgICAgIGZvciAoOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgICAgICBpdGVtID0gbGlzdFtpXTtcbiAgICAgICAgICAgIGlmIChpdGVtICYmIGl0ZW0ub25Nb3VudFBvaW50Q2hhbmdlKSBpdGVtLm9uTW91bnRQb2ludENoYW5nZSh4LCB5LCB6KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLnNldE9yaWdpbiA9IGZ1bmN0aW9uIHNldE9yaWdpbiAoeCwgeSwgeikge1xuICAgIHZhciB2ZWMzID0gdGhpcy52YWx1ZS5vZmZzZXRzLm9yaWdpbjtcbiAgICB2YXIgcHJvcG9nYXRlID0gZmFsc2U7XG5cbiAgICBwcm9wb2dhdGUgPSB0aGlzLl92ZWNPcHRpb25hbFNldCh2ZWMzLCAwLCB4KSB8fCBwcm9wb2dhdGU7XG4gICAgcHJvcG9nYXRlID0gdGhpcy5fdmVjT3B0aW9uYWxTZXQodmVjMywgMSwgeSkgfHwgcHJvcG9nYXRlO1xuICAgIGlmICh6ICE9IG51bGwpIHByb3BvZ2F0ZSA9IHRoaXMuX3ZlY09wdGlvbmFsU2V0KHZlYzMsIDIsICh6IC0gMC41KSkgfHwgcHJvcG9nYXRlO1xuXG4gICAgaWYgKHByb3BvZ2F0ZSkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5fY29tcG9uZW50cztcbiAgICAgICAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgICAgICB2YXIgaXRlbTtcbiAgICAgICAgeCA9IHZlYzNbMF07XG4gICAgICAgIHkgPSB2ZWMzWzFdO1xuICAgICAgICB6ID0gdmVjM1syXTtcbiAgICAgICAgZm9yICg7IGkgPCBsZW4gOyBpKyspIHtcbiAgICAgICAgICAgIGl0ZW0gPSBsaXN0W2ldO1xuICAgICAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5vbk9yaWdpbkNoYW5nZSkgaXRlbS5vbk9yaWdpbkNoYW5nZSh4LCB5LCB6KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cblxuTm9kZS5wcm90b3R5cGUuc2V0UG9zaXRpb24gPSBmdW5jdGlvbiBzZXRQb3NpdGlvbiAoeCwgeSwgeikge1xuICAgIHZhciB2ZWMzID0gdGhpcy52YWx1ZS52ZWN0b3JzLnBvc2l0aW9uO1xuICAgIHZhciBwcm9wb2dhdGUgPSBmYWxzZTtcblxuICAgIHByb3BvZ2F0ZSA9IHRoaXMuX3ZlY09wdGlvbmFsU2V0KHZlYzMsIDAsIHgpIHx8IHByb3BvZ2F0ZTtcbiAgICBwcm9wb2dhdGUgPSB0aGlzLl92ZWNPcHRpb25hbFNldCh2ZWMzLCAxLCB5KSB8fCBwcm9wb2dhdGU7XG4gICAgcHJvcG9nYXRlID0gdGhpcy5fdmVjT3B0aW9uYWxTZXQodmVjMywgMiwgeikgfHwgcHJvcG9nYXRlO1xuXG4gICAgaWYgKHByb3BvZ2F0ZSkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5fY29tcG9uZW50cztcbiAgICAgICAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgICAgICB2YXIgaXRlbTtcbiAgICAgICAgeCA9IHZlYzNbMF07XG4gICAgICAgIHkgPSB2ZWMzWzFdO1xuICAgICAgICB6ID0gdmVjM1syXTtcbiAgICAgICAgZm9yICg7IGkgPCBsZW4gOyBpKyspIHtcbiAgICAgICAgICAgIGl0ZW0gPSBsaXN0W2ldO1xuICAgICAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5vblBvc2l0aW9uQ2hhbmdlKSBpdGVtLm9uUG9zaXRpb25DaGFuZ2UoeCwgeSwgeik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLnNldFJvdGF0aW9uID0gZnVuY3Rpb24gc2V0Um90YXRpb24gKHgsIHksIHosIHcpIHtcbiAgICB2YXIgcXVhdCA9IHRoaXMudmFsdWUudmVjdG9ycy5yb3RhdGlvbjtcbiAgICB2YXIgcHJvcG9nYXRlID0gZmFsc2U7XG4gICAgdmFyIHF4LCBxeSwgcXosIHF3O1xuXG4gICAgaWYgKHcgIT0gbnVsbCkge1xuICAgICAgICBxeCA9IHg7XG4gICAgICAgIHF5ID0geTtcbiAgICAgICAgcXogPSB6O1xuICAgICAgICBxdyA9IHc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgaHggPSB4ICogMC41O1xuICAgICAgICB2YXIgaHkgPSB5ICogMC41O1xuICAgICAgICB2YXIgaHogPSB6ICogMC41O1xuXG4gICAgICAgIHZhciBzeCA9IE1hdGguc2luKGh4KTtcbiAgICAgICAgdmFyIHN5ID0gTWF0aC5zaW4oaHkpO1xuICAgICAgICB2YXIgc3ogPSBNYXRoLnNpbihoeik7XG4gICAgICAgIHZhciBjeCA9IE1hdGguY29zKGh4KTtcbiAgICAgICAgdmFyIGN5ID0gTWF0aC5jb3MoaHkpO1xuICAgICAgICB2YXIgY3ogPSBNYXRoLmNvcyhoeik7XG5cbiAgICAgICAgdmFyIHN5c3ogPSBzeSAqIHN6O1xuICAgICAgICB2YXIgY3lzeiA9IGN5ICogc3o7XG4gICAgICAgIHZhciBzeWN6ID0gc3kgKiBjejtcbiAgICAgICAgdmFyIGN5Y3ogPSBjeSAqIGN6O1xuXG4gICAgICAgIHF4ID0gc3ggKiBjeWN6ICsgY3ggKiBzeXN6O1xuICAgICAgICBxeSA9IGN4ICogc3ljeiAtIHN4ICogY3lzejtcbiAgICAgICAgcXogPSBjeCAqIGN5c3ogKyBzeCAqIHN5Y3o7XG4gICAgICAgIHF3ID0gY3ggKiBjeWN6IC0gc3ggKiBzeXN6O1xuICAgIH1cblxuICAgIHByb3BvZ2F0ZSA9IHRoaXMuX3ZlY09wdGlvbmFsU2V0KHF1YXQsIDAsIHF4KSB8fCBwcm9wb2dhdGU7XG4gICAgcHJvcG9nYXRlID0gdGhpcy5fdmVjT3B0aW9uYWxTZXQocXVhdCwgMSwgcXkpIHx8IHByb3BvZ2F0ZTtcbiAgICBwcm9wb2dhdGUgPSB0aGlzLl92ZWNPcHRpb25hbFNldChxdWF0LCAyLCBxeikgfHwgcHJvcG9nYXRlO1xuICAgIHByb3BvZ2F0ZSA9IHRoaXMuX3ZlY09wdGlvbmFsU2V0KHF1YXQsIDMsIHF3KSB8fCBwcm9wb2dhdGU7XG5cbiAgICBpZiAocHJvcG9nYXRlKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxpc3QgPSB0aGlzLl9jb21wb25lbnRzO1xuICAgICAgICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gICAgICAgIHZhciBpdGVtO1xuICAgICAgICB4ID0gcXVhdFswXTtcbiAgICAgICAgeSA9IHF1YXRbMV07XG4gICAgICAgIHogPSBxdWF0WzJdO1xuICAgICAgICB3ID0gcXVhdFszXTtcbiAgICAgICAgZm9yICg7IGkgPCBsZW4gOyBpKyspIHtcbiAgICAgICAgICAgIGl0ZW0gPSBsaXN0W2ldO1xuICAgICAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5vblJvdGF0aW9uQ2hhbmdlKSBpdGVtLm9uUm90YXRpb25DaGFuZ2UoeCwgeSwgeiwgdyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5zZXRTY2FsZSA9IGZ1bmN0aW9uIHNldFNjYWxlICh4LCB5LCB6KSB7XG4gICAgdmFyIHZlYzMgPSB0aGlzLnZhbHVlLnZlY3RvcnMuc2NhbGU7XG4gICAgdmFyIHByb3BvZ2F0ZSA9IGZhbHNlO1xuXG4gICAgcHJvcG9nYXRlID0gdGhpcy5fdmVjT3B0aW9uYWxTZXQodmVjMywgMCwgeCkgfHwgcHJvcG9nYXRlO1xuICAgIHByb3BvZ2F0ZSA9IHRoaXMuX3ZlY09wdGlvbmFsU2V0KHZlYzMsIDEsIHkpIHx8IHByb3BvZ2F0ZTtcbiAgICBwcm9wb2dhdGUgPSB0aGlzLl92ZWNPcHRpb25hbFNldCh2ZWMzLCAyLCB6KSB8fCBwcm9wb2dhdGU7XG5cbiAgICBpZiAocHJvcG9nYXRlKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxpc3QgPSB0aGlzLl9jb21wb25lbnRzO1xuICAgICAgICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gICAgICAgIHZhciBpdGVtO1xuICAgICAgICB4ID0gdmVjM1swXTtcbiAgICAgICAgeSA9IHZlYzNbMV07XG4gICAgICAgIHogPSB2ZWMzWzJdO1xuICAgICAgICBmb3IgKDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICAgICAgaXRlbSA9IGxpc3RbaV07XG4gICAgICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLm9uU2NhbGVDaGFuZ2UpIGl0ZW0ub25TY2FsZUNoYW5nZSh4LCB5LCB6KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLnNldE9wYWNpdHkgPSBmdW5jdGlvbiBzZXRPcGFjaXR5ICh2YWwpIHtcbiAgICBpZiAodmFsICE9IHRoaXMudmFsdWUuc2hvd1N0YXRlLm9wYWNpdHkpIHtcbiAgICAgICAgdGhpcy52YWx1ZS5zaG93U3RhdGUub3BhY2l0eSA9IHZhbDtcbiAgICAgICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGlzdCA9IHRoaXMuX2NvbXBvbmVudHM7XG4gICAgICAgIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgdmFyIGl0ZW07XG4gICAgICAgIGZvciAoOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgICAgICBpdGVtID0gbGlzdFtpXTtcbiAgICAgICAgICAgIGlmIChpdGVtICYmIGl0ZW0ub25PcGFjaXR5Q2hhbmdlKSBpdGVtLm9uT3BhY2l0eUNoYW5nZSh2YWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBzaXplIG1vZGUgYmVpbmcgdXNlZCBmb3IgZGV0ZXJtaW5pbmcgdGhlIG5vZGVzIGZpbmFsIHdpZHRoLCBoZWlnaHRcbiAqIGFuZCBkZXB0aC5cbiAqIFNpemUgbW9kZXMgYXJlIGEgd2F5IHRvIGRlZmluZSB0aGUgd2F5IHRoZSBub2RlJ3Mgc2l6ZSBpcyBiZWluZyBjYWxjdWxhdGVkLlxuICogU2l6ZSBtb2RlcyBhcmUgZW51bXMgc2V0IG9uIHRoZSBAe0BsaW5rIFNpemV9IGNvbnN0cnVjdG9yIChhbmQgYWxpYXNlZCBvblxuICogdGhlIE5vZGUpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBub2RlLnNldFNpemVNb2RlKE5vZGUuUkVMQVRJVkVfU0laRSwgTm9kZS5BQlNPTFVURV9TSVpFLCBOb2RlLkFCU09MVVRFX1NJWkUpO1xuICogLy8gSW5zdGVhZCBvZiBudWxsLCBhbnkgcHJvcG9yaW9uYWwgaGVpZ2h0IG9yIGRlcHRoIGNhbiBiZSBwYXNzZWQgaW4sIHNpbmNlXG4gKiAvLyBpdCB3b3VsZCBiZSBpZ25vcmVkIGluIGFueSBjYXNlLlxuICogbm9kZS5zZXRQcm9wb3J0aW9uYWxTaXplKDAuNSwgbnVsbCwgbnVsbCk7XG4gKiBub2RlLnNldEFic29sdXRlU2l6ZShudWxsLCAxMDAsIDIwMCk7XG4gKlxuICogQG1ldGhvZCBzZXRTaXplTW9kZVxuICogXG4gKiBAcGFyYW0ge1NpemVNb2RlfSB4ICAgIFRoZSBzaXplIG1vZGUgYmVpbmcgdXNlZCBmb3IgZGV0ZXJtaW5pbmcgdGhlIHNpemUgaW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgeCBkaXJlY3Rpb24gKFwid2lkdGhcIikuXG4gKiBAcGFyYW0ge1NpemVNb2RlfSB5ICAgIFRoZSBzaXplIG1vZGUgYmVpbmcgdXNlZCBmb3IgZGV0ZXJtaW5pbmcgdGhlIHNpemUgaW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgeSBkaXJlY3Rpb24gKFwiaGVpZ2h0XCIpLlxuICogQHBhcmFtIHtTaXplTW9kZX0geiAgICBUaGUgc2l6ZSBtb2RlIGJlaW5nIHVzZWQgZm9yIGRldGVybWluaW5nIHRoZSBzaXplIGluXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIHogZGlyZWN0aW9uIChcImRlcHRoXCIpLlxuICovXG5Ob2RlLnByb3RvdHlwZS5zZXRTaXplTW9kZSA9IGZ1bmN0aW9uIHNldFNpemVNb2RlICh4LCB5LCB6KSB7XG4gICAgdmFyIHZlYzMgPSB0aGlzLnZhbHVlLnNpemUuc2l6ZU1vZGU7XG4gICAgdmFyIHByb3BvZ2F0ZSA9IGZhbHNlO1xuXG4gICAgcHJvcG9nYXRlID0gdGhpcy5fdmVjT3B0aW9uYWxTZXQodmVjMywgMCwgeCkgfHwgcHJvcG9nYXRlO1xuICAgIHByb3BvZ2F0ZSA9IHRoaXMuX3ZlY09wdGlvbmFsU2V0KHZlYzMsIDEsIHkpIHx8IHByb3BvZ2F0ZTtcbiAgICBwcm9wb2dhdGUgPSB0aGlzLl92ZWNPcHRpb25hbFNldCh2ZWMzLCAyLCB6KSB8fCBwcm9wb2dhdGU7XG5cbiAgICBpZiAocHJvcG9nYXRlKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxpc3QgPSB0aGlzLl9jb21wb25lbnRzO1xuICAgICAgICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gICAgICAgIHZhciBpdGVtO1xuICAgICAgICB4ID0gdmVjM1swXTtcbiAgICAgICAgeSA9IHZlYzNbMV07XG4gICAgICAgIHogPSB2ZWMzWzJdO1xuICAgICAgICBmb3IgKDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICAgICAgaXRlbSA9IGxpc3RbaV07XG4gICAgICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLm9uU2l6ZU1vZGVDaGFuZ2UpIGl0ZW0ub25TaXplTW9kZUNoYW5nZSh4LCB5LCB6KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQSBwcm9wb3J0aW9uYWwgc2l6ZSBkZWZpbmVzIHRoZSBub2RlJ3MgZGltZW5zaW9ucyByZWxhdGl2ZSB0byBpdHMgcGFyZW50c1xuICogZmluYWwgc2l6ZS5cbiAqIFByb3BvcnRpb25hbCBzaXplcyBuZWVkIHRvIGJlIHdpdGhpbiB0aGUgcmFuZ2Ugb2YgWzAsIDFdLlxuICpcbiAqIEBtZXRob2Qgc2V0UHJvcG9ydGlvbmFsU2l6ZVxuICogXG4gKiBAcGFyYW0ge051bWJlcn0geCAgICB4LVNpemUgaW4gcGl4ZWxzIChcIndpZHRoXCIpLlxuICogQHBhcmFtIHtOdW1iZXJ9IHkgICAgeS1TaXplIGluIHBpeGVscyAoXCJoZWlnaHRcIikuXG4gKiBAcGFyYW0ge051bWJlcn0geiAgICB6LVNpemUgaW4gcGl4ZWxzIChcImRlcHRoXCIpLlxuICovXG5Ob2RlLnByb3RvdHlwZS5zZXRQcm9wb3J0aW9uYWxTaXplID0gZnVuY3Rpb24gc2V0UHJvcG9ydGlvbmFsU2l6ZSAoeCwgeSwgeikge1xuICAgIHZhciB2ZWMzID0gdGhpcy52YWx1ZS5zaXplLnByb3BvcnRpb25hbDtcbiAgICB2YXIgcHJvcG9nYXRlID0gZmFsc2U7XG5cbiAgICBwcm9wb2dhdGUgPSB0aGlzLl92ZWNPcHRpb25hbFNldCh2ZWMzLCAwLCB4KSB8fCBwcm9wb2dhdGU7XG4gICAgcHJvcG9nYXRlID0gdGhpcy5fdmVjT3B0aW9uYWxTZXQodmVjMywgMSwgeSkgfHwgcHJvcG9nYXRlO1xuICAgIHByb3BvZ2F0ZSA9IHRoaXMuX3ZlY09wdGlvbmFsU2V0KHZlYzMsIDIsIHopIHx8IHByb3BvZ2F0ZTtcblxuICAgIGlmIChwcm9wb2dhdGUpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGlzdCA9IHRoaXMuX2NvbXBvbmVudHM7XG4gICAgICAgIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgdmFyIGl0ZW07XG4gICAgICAgIHggPSB2ZWMzWzBdO1xuICAgICAgICB5ID0gdmVjM1sxXTtcbiAgICAgICAgeiA9IHZlYzNbMl07XG4gICAgICAgIGZvciAoOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgICAgICBpdGVtID0gbGlzdFtpXTtcbiAgICAgICAgICAgIGlmIChpdGVtICYmIGl0ZW0ub25Qcm9wb3J0aW9uYWxTaXplQ2hhbmdlKSBpdGVtLm9uUHJvcG9ydGlvbmFsU2l6ZUNoYW5nZSh4LCB5LCB6KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRGlmZmVyZW50aWFsIHNpemluZyBjYW4gYmUgdXNlZCB0byBhZGQgb3Igc3VidHJhY3QgYW4gYWJzb2x1dGUgc2l6ZSBmcm9tIGFcbiAqIG90aGVyd2lzZSBwcm9wb3J0aW9uYWxseSBzaXplZCBub2RlLlxuICogRS5nLiBhIGRpZmZlcmVudGlhbCB3aWR0aCBvZiBgLTEwYCBhbmQgYSBwcm9wb3J0aW9uYWwgd2lkdGggb2YgYDAuNWAgaXNcbiAqIGJlaW5nIGludGVycHJldGVkIGFzIHNldHRpbmcgdGhlIG5vZGUncyBzaXplIHRvIDUwJSBvZiBpdHMgcGFyZW50J3Mgd2lkdGhcbiAqICptaW51cyogMTAgcGl4ZWxzLlxuICpcbiAqIEBtZXRob2Qgc2V0RGlmZmVyZW50aWFsU2l6ZVxuICogXG4gKiBAcGFyYW0ge051bWJlcn0geCAgICB4LVNpemUgdG8gYmUgYWRkZWQgdG8gdGhlIHJlbGF0aXZlbHkgc2l6ZWQgbm9kZSBpblxuICogICAgICAgICAgICAgICAgICAgICAgcGl4ZWxzIChcIndpZHRoXCIpLlxuICogQHBhcmFtIHtOdW1iZXJ9IHkgICAgeS1TaXplIHRvIGJlIGFkZGVkIHRvIHRoZSByZWxhdGl2ZWx5IHNpemVkIG5vZGUgaW5cbiAqICAgICAgICAgICAgICAgICAgICAgIHBpeGVscyAoXCJoZWlnaHRcIikuXG4gKiBAcGFyYW0ge051bWJlcn0geiAgICB6LVNpemUgdG8gYmUgYWRkZWQgdG8gdGhlIHJlbGF0aXZlbHkgc2l6ZWQgbm9kZSBpblxuICogICAgICAgICAgICAgICAgICAgICAgcGl4ZWxzIChcImRlcHRoXCIpLlxuICovXG5Ob2RlLnByb3RvdHlwZS5zZXREaWZmZXJlbnRpYWxTaXplID0gZnVuY3Rpb24gc2V0RGlmZmVyZW50aWFsU2l6ZSAoeCwgeSwgeikge1xuICAgIHZhciB2ZWMzID0gdGhpcy52YWx1ZS5zaXplLmRpZmZlcmVudGlhbDtcbiAgICB2YXIgcHJvcG9nYXRlID0gZmFsc2U7XG5cbiAgICBwcm9wb2dhdGUgPSB0aGlzLl92ZWNPcHRpb25hbFNldCh2ZWMzLCAwLCB4KSB8fCBwcm9wb2dhdGU7XG4gICAgcHJvcG9nYXRlID0gdGhpcy5fdmVjT3B0aW9uYWxTZXQodmVjMywgMSwgeSkgfHwgcHJvcG9nYXRlO1xuICAgIHByb3BvZ2F0ZSA9IHRoaXMuX3ZlY09wdGlvbmFsU2V0KHZlYzMsIDIsIHopIHx8IHByb3BvZ2F0ZTtcblxuICAgIGlmIChwcm9wb2dhdGUpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGlzdCA9IHRoaXMuX2NvbXBvbmVudHM7XG4gICAgICAgIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgdmFyIGl0ZW07XG4gICAgICAgIHggPSB2ZWMzWzBdO1xuICAgICAgICB5ID0gdmVjM1sxXTtcbiAgICAgICAgeiA9IHZlYzNbMl07XG4gICAgICAgIGZvciAoOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgICAgICBpdGVtID0gbGlzdFtpXTtcbiAgICAgICAgICAgIGlmIChpdGVtICYmIGl0ZW0ub25EaWZmZXJlbnRpYWxTaXplQ2hhbmdlKSBpdGVtLm9uRGlmZmVyZW50aWFsU2l6ZUNoYW5nZSh4LCB5LCB6KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgbm9kZXMgc2l6ZSBpbiBwaXhlbHMsIGluZGVwZW5kZW50IG9mIGl0cyBwYXJlbnQuXG4gKlxuICogQG1ldGhvZCBzZXRBYnNvbHV0ZVNpemVcbiAqIFxuICogQHBhcmFtIHtOdW1iZXJ9IHggICAgeC1TaXplIGluIHBpeGVscyAoXCJ3aWR0aFwiKS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5ICAgIHktU2l6ZSBpbiBwaXhlbHMgKFwiaGVpZ2h0XCIpLlxuICogQHBhcmFtIHtOdW1iZXJ9IHogICAgei1TaXplIGluIHBpeGVscyAoXCJkZXB0aFwiKS5cbiAqL1xuTm9kZS5wcm90b3R5cGUuc2V0QWJzb2x1dGVTaXplID0gZnVuY3Rpb24gc2V0QWJzb2x1dGVTaXplICh4LCB5LCB6KSB7XG4gICAgdmFyIHZlYzMgPSB0aGlzLnZhbHVlLnNpemUuYWJzb2x1dGU7XG4gICAgdmFyIHByb3BvZ2F0ZSA9IGZhbHNlO1xuXG4gICAgcHJvcG9nYXRlID0gdGhpcy5fdmVjT3B0aW9uYWxTZXQodmVjMywgMCwgeCkgfHwgcHJvcG9nYXRlO1xuICAgIHByb3BvZ2F0ZSA9IHRoaXMuX3ZlY09wdGlvbmFsU2V0KHZlYzMsIDEsIHkpIHx8IHByb3BvZ2F0ZTtcbiAgICBwcm9wb2dhdGUgPSB0aGlzLl92ZWNPcHRpb25hbFNldCh2ZWMzLCAyLCB6KSB8fCBwcm9wb2dhdGU7XG5cbiAgICBpZiAocHJvcG9nYXRlKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxpc3QgPSB0aGlzLl9jb21wb25lbnRzO1xuICAgICAgICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gICAgICAgIHZhciBpdGVtO1xuICAgICAgICB4ID0gdmVjM1swXTtcbiAgICAgICAgeSA9IHZlYzNbMV07XG4gICAgICAgIHogPSB2ZWMzWzJdO1xuICAgICAgICBmb3IgKDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICAgICAgaXRlbSA9IGxpc3RbaV07XG4gICAgICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLm9uQWJzb2x1dGVTaXplQ2hhbmdlKSBpdGVtLm9uQWJzb2x1dGVTaXplQ2hhbmdlKHgsIHksIHopO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuTm9kZS5wcm90b3R5cGUuX3RyYW5zZm9ybUNoYW5nZWQgPSBmdW5jdGlvbiBfdHJhbnNmb3JtQ2hhbmdlZCAodHJhbnNmb3JtKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBpdGVtcyA9IHRoaXMuX2NvbXBvbmVudHM7XG4gICAgdmFyIGxlbiA9IGl0ZW1zLmxlbmd0aDtcbiAgICB2YXIgaXRlbTtcblxuICAgIGZvciAoOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5vblRyYW5zZm9ybUNoYW5nZSkgaXRlbS5vblRyYW5zZm9ybUNoYW5nZSh0cmFuc2Zvcm0pO1xuICAgIH1cblxuICAgIGkgPSAwO1xuICAgIGl0ZW1zID0gdGhpcy5fY2hpbGRyZW47XG4gICAgbGVuID0gaXRlbXMubGVuZ3RoO1xuXG4gICAgZm9yICg7IGkgPCBsZW4gOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLm9uUGFyZW50VHJhbnNmb3JtQ2hhbmdlKSBpdGVtLm9uUGFyZW50VHJhbnNmb3JtQ2hhbmdlKHRyYW5zZm9ybSk7XG4gICAgfVxufTtcblxuTm9kZS5wcm90b3R5cGUuX3NpemVDaGFuZ2VkID0gZnVuY3Rpb24gX3NpemVDaGFuZ2VkIChzaXplKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBpdGVtcyA9IHRoaXMuX2NvbXBvbmVudHM7XG4gICAgdmFyIGxlbiA9IGl0ZW1zLmxlbmd0aDtcbiAgICB2YXIgaXRlbTtcblxuICAgIGZvciAoOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5vblNpemVDaGFuZ2UpIGl0ZW0ub25TaXplQ2hhbmdlKHNpemUpO1xuICAgIH1cblxuICAgIGkgPSAwO1xuICAgIGl0ZW1zID0gdGhpcy5fY2hpbGRyZW47XG4gICAgbGVuID0gaXRlbXMubGVuZ3RoO1xuXG4gICAgZm9yICg7IGkgPCBsZW4gOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLm9uUGFyZW50U2l6ZUNoYW5nZSkgaXRlbS5vblBhcmVudFNpemVDaGFuZ2Uoc2l6ZSk7XG4gICAgfVxufTtcblxuLy8gREVQUklDQVRFXG5Ob2RlLnByb3RvdHlwZS5nZXRGcmFtZSA9IGZ1bmN0aW9uIGdldEZyYW1lICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2xvYmFsVXBkYXRlci5nZXRGcmFtZSgpO1xufTtcblxuLyoqXG4gKiBFbnRlcnMgdGhlIG5vZGUncyB1cGRhdGUgcGhhc2Ugd2hpbGUgdXBkYXRpbmcgaXRzIG93biBzcGVjIGFuZCB1cGRhdGluZyBpdHMgY29tcG9uZW50cy5cbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICogXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHRpbWUgICAgaGlnaC1yZXNvbHV0aW9uIHRpbXN0YW1wLCB1c3VhbGx5IHJldHJpZXZlZCB1c2luZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZVxuICovXG5Ob2RlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKHRpbWUpe1xuICAgIHRoaXMuX2luVXBkYXRlID0gdHJ1ZTtcbiAgICB2YXIgbmV4dFF1ZXVlID0gdGhpcy5fbmV4dFVwZGF0ZVF1ZXVlO1xuICAgIHZhciBxdWV1ZSA9IHRoaXMuX3VwZGF0ZVF1ZXVlO1xuICAgIHZhciBpdGVtO1xuXG4gICAgd2hpbGUgKG5leHRRdWV1ZS5sZW5ndGgpIHF1ZXVlLnVuc2hpZnQobmV4dFF1ZXVlLnBvcCgpKTtcblxuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgaXRlbSA9IHRoaXMuX2NvbXBvbmVudHNbcXVldWUuc2hpZnQoKV07XG4gICAgICAgIGlmIChpdGVtICYmIGl0ZW0ub25VcGRhdGUpIGl0ZW0ub25VcGRhdGUodGltZSk7XG4gICAgfVxuXG4gICAgdmFyIG15U2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpO1xuICAgIHZhciBteVRyYW5zZm9ybSA9IHRoaXMuZ2V0VHJhbnNmb3JtKCk7XG4gICAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KCk7XG4gICAgdmFyIHBhcmVudFNpemUgPSBwYXJlbnQuZ2V0U2l6ZSgpO1xuICAgIHZhciBwYXJlbnRUcmFuc2Zvcm0gPSBwYXJlbnQuZ2V0VHJhbnNmb3JtKCk7XG4gICAgdmFyIHNpemVDaGFuZ2VkID0gU0laRV9QUk9DRVNTT1IuZnJvbVNwZWNXaXRoUGFyZW50KHBhcmVudFNpemUsIHRoaXMudmFsdWUsIG15U2l6ZSk7XG5cbiAgICB2YXIgdHJhbnNmb3JtQ2hhbmdlZCA9IFRSQU5TRk9STV9QUk9DRVNTT1IuZnJvbVNwZWNXaXRoUGFyZW50KHBhcmVudFRyYW5zZm9ybSwgdGhpcy52YWx1ZSwgbXlTaXplLCBwYXJlbnRTaXplLCBteVRyYW5zZm9ybSk7XG4gICAgaWYgKHRyYW5zZm9ybUNoYW5nZWQpIHRoaXMuX3RyYW5zZm9ybUNoYW5nZWQobXlUcmFuc2Zvcm0pO1xuICAgIGlmIChzaXplQ2hhbmdlZCkgdGhpcy5fc2l6ZUNoYW5nZWQobXlTaXplKTtcblxuICAgIHRoaXMuX2luVXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgaWYgKHRoaXMuX25leHRVcGRhdGVRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fZ2xvYmFsVXBkYXRlci5yZXF1ZXN0VXBkYXRlT25OZXh0VGljayh0aGlzKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIGlmICghdGhpcy5pc01vdW50ZWQoKSkge1xuICAgICAgICAvLyBsYXN0IHVwZGF0ZVxuICAgICAgICB0aGlzLl9wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLnZhbHVlLmxvY2F0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZ2xvYmFsVXBkYXRlciA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBNb3VudHMgdGhlIG5vZGUgYW5kIHRoZXJlZm9yZSBpdHMgc3VidHJlZSBieSBzZXR0aW5nIGl0IGFzIGEgY2hpbGQgb2YgdGhlXG4gKiBwYXNzZWQgaW4gcGFyZW50LlxuICpcbiAqIEBtZXRob2QgbW91bnRcbiAqIFxuICogQHBhcmFtICB7Tm9kZX0gcGFyZW50ICAgIHBhcmVudCBub2RlXG4gKiBAcGFyYW0gIHtTdHJpbmd9IG15SWQgICAgcGF0aCB0byBub2RlIChlLmcuIGBib2R5LzAvMWApXG4gKi9cbk5vZGUucHJvdG90eXBlLm1vdW50ID0gZnVuY3Rpb24gbW91bnQgKHBhcmVudCwgbXlJZCkge1xuICAgIGlmICh0aGlzLmlzTW91bnRlZCgpKSByZXR1cm47XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsaXN0ID0gdGhpcy5fY29tcG9uZW50cztcbiAgICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gICAgdmFyIGl0ZW07XG5cbiAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5fZ2xvYmFsVXBkYXRlciA9IHBhcmVudC5nZXRVcGRhdGVyKCk7XG4gICAgdGhpcy52YWx1ZS5sb2NhdGlvbiA9IG15SWQ7XG4gICAgdGhpcy52YWx1ZS5zaG93U3RhdGUubW91bnRlZCA9IHRydWU7XG5cbiAgICBmb3IgKDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICBpdGVtID0gbGlzdFtpXTtcbiAgICAgICAgaWYgKGl0ZW0ub25Nb3VudCkgaXRlbS5vbk1vdW50KHRoaXMsIGkpO1xuICAgIH1cblxuICAgIGkgPSAwO1xuICAgIGxpc3QgPSB0aGlzLl9jaGlsZHJlbjtcbiAgICBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICBmb3IgKDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICBpdGVtID0gbGlzdFtpXTtcbiAgICAgICAgaWYgKGl0ZW0ub25QYXJlbnRNb3VudCkgaXRlbS5vblBhcmVudE1vdW50KHRoaXMsIG15SWQsIGkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB0aGlzLl9yZXF1ZXN0VXBkYXRlKHRydWUpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEaXNtb3VudHMgKGRldGFjaGVzKSB0aGUgbm9kZSBmcm9tIHRoZSBzY2VuZSBncmFwaCBieSByZW1vdmluZyBpdCBhcyBhXG4gKiBjaGlsZCBvZiBpdHMgcGFyZW50LlxuICpcbiAqIEBtZXRob2QgZGlzbW91bnRcbiAqL1xuTm9kZS5wcm90b3R5cGUuZGlzbW91bnQgPSBmdW5jdGlvbiBkaXNtb3VudCAoKSB7XG4gICAgaWYgKCF0aGlzLmlzTW91bnRlZCgpKSByZXR1cm47XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsaXN0ID0gdGhpcy5fY29tcG9uZW50cztcbiAgICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gICAgdmFyIGl0ZW07XG5cbiAgICB0aGlzLnZhbHVlLnNob3dTdGF0ZS5tb3VudGVkID0gZmFsc2U7XG5cbiAgICB0aGlzLl9wYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG5cbiAgICBmb3IgKDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICBpdGVtID0gbGlzdFtpXTtcbiAgICAgICAgaWYgKGl0ZW0ub25EaXNtb3VudCkgaXRlbS5vbkRpc21vdW50KCk7XG4gICAgfVxuXG4gICAgaSA9IDA7XG4gICAgbGlzdCA9IHRoaXMuX2NoaWxkcmVuO1xuICAgIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgIGZvciAoOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBsaXN0W2ldO1xuICAgICAgICBpZiAoaXRlbS5vblBhcmVudERpc21vdW50KSBpdGVtLm9uUGFyZW50RGlzbW91bnQoKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHRoaXMuX3JlcXVlc3RVcGRhdGUoKTtcbiAgICB0aGlzLl9nbG9iYWxVcGRhdGVyID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRnVuY3Rpb24gdG8gYmUgaW52b2tlZCBieSB0aGUgcGFyZW50IGFzIHNvb24gYXMgdGhlIHBhcmVudCBpc1xuICogYmVpbmcgbW91bnRlZC5cbiAqXG4gKiBAbWV0aG9kIG9uUGFyZW50TW91bnRcbiAqIFxuICogQHBhcmFtICB7Tm9kZX0gcGFyZW50ICAgICAgICBUaGUgcGFyZW50IG5vZGUuXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHBhcmVudElkICAgIFRoZSBwYXJlbnQgaWQgKHBhdGggdG8gcGFyZW50KS5cbiAqIEBwYXJhbSAge051bWJlcn0gaW5kZXggICAgICAgSWQgdGhlIG5vZGUgc2hvdWxkIGJlIG1vdW50ZWQgdG8uXG4gKi9cbk5vZGUucHJvdG90eXBlLm9uUGFyZW50TW91bnQgPSBmdW5jdGlvbiBvblBhcmVudE1vdW50IChwYXJlbnQsIHBhcmVudElkLCBpbmRleCkge1xuICAgIHJldHVybiB0aGlzLm1vdW50KHBhcmVudCwgcGFyZW50SWQgKyAnLycgKyBpbmRleCk7XG59O1xuXG4vKipcbiAqIEZ1bmN0aW9uIHRvIGJlIGludm9rZWQgYnkgdGhlIHBhcmVudCBhcyBzb29uIGFzIHRoZSBwYXJlbnQgaXMgYmVpbmdcbiAqIHVubW91bnRlZC5cbiAqXG4gKiBAbWV0aG9kIG9uUGFyZW50RGlzbW91bnRcbiAqL1xuTm9kZS5wcm90b3R5cGUub25QYXJlbnREaXNtb3VudCA9IGZ1bmN0aW9uIG9uUGFyZW50RGlzbW91bnQgKCkge1xuICAgIHJldHVybiB0aGlzLmRpc21vdW50KCk7XG59O1xuXG4vKipcbiAqIE1ldGhvZCB0byBiZSBjYWxsZWQgaW4gb3JkZXIgdG8gZGlzcGF0Y2ggYW4gZXZlbnQgdG8gdGhlIG5vZGUgYW5kIGFsbCBpdHNcbiAqIGNvbXBvbmVudHMuIE5vdGUgdGhhdCB0aGlzIGRvZXNuJ3QgcmVjdXJzZSB0aGUgc3VidHJlZS5cbiAqXG4gKiBAbWV0aG9kIHJlY2VpdmVcbiAqIFxuICogQHBhcmFtICB7U3RyaW5nfSB0eXBlICAgVGhlIGV2ZW50IHR5cGUgKGUuZy4gXCJjbGlja1wiKS5cbiAqIEBwYXJhbSAge09iamVjdH0gZXYgICAgIFRoZSBldmVudCBwYXlsb2FkIG9iamVjdCB0byBiZSBkaXNwYXRjaGVkLlxuICovXG5Ob2RlLnByb3RvdHlwZS5yZWNlaXZlID0gZnVuY3Rpb24gcmVjZWl2ZSAodHlwZSwgZXYpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxpc3QgPSB0aGlzLl9jb21wb25lbnRzO1xuICAgIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICB2YXIgaXRlbTtcbiAgICBmb3IgKDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICBpdGVtID0gbGlzdFtpXTtcbiAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5vblJlY2VpdmUpIGl0ZW0ub25SZWNlaXZlKHR5cGUsIGV2KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbk5vZGUucHJvdG90eXBlLl9yZXF1ZXN0VXBkYXRlV2l0aG91dEFyZ3MgPSBmdW5jdGlvbiBfcmVxdWVzdFVwZGF0ZVdpdGhvdXRBcmdzICgpIHtcbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHRoaXMuX3JlcXVlc3RVcGRhdGUoKTtcbn07XG5cbk5vZGUucHJvdG90eXBlLm9uVXBkYXRlID0gTm9kZS5wcm90b3R5cGUudXBkYXRlO1xuXG5Ob2RlLnByb3RvdHlwZS5vblBhcmVudFNob3cgPSBOb2RlLnByb3RvdHlwZS5zaG93O1xuXG5Ob2RlLnByb3RvdHlwZS5vblBhcmVudEhpZGUgPSBOb2RlLnByb3RvdHlwZS5oaWRlO1xuXG5Ob2RlLnByb3RvdHlwZS5vblBhcmVudFRyYW5zZm9ybUNoYW5nZSA9IE5vZGUucHJvdG90eXBlLl9yZXF1ZXN0VXBkYXRlV2l0aG91dEFyZ3M7XG5cbk5vZGUucHJvdG90eXBlLm9uUGFyZW50U2l6ZUNoYW5nZSA9IE5vZGUucHJvdG90eXBlLl9yZXF1ZXN0VXBkYXRlV2l0aG91dEFyZ3M7XG5cbk5vZGUucHJvdG90eXBlLm9uU2hvdyA9IE5vZGUucHJvdG90eXBlLnNob3c7XG5cbk5vZGUucHJvdG90eXBlLm9uSGlkZSA9IE5vZGUucHJvdG90eXBlLmhpZGU7XG5cbk5vZGUucHJvdG90eXBlLm9uTW91bnQgPSBOb2RlLnByb3RvdHlwZS5tb3VudDtcblxuTm9kZS5wcm90b3R5cGUub25EaXNtb3VudCA9IE5vZGUucHJvdG90eXBlLmRpc21vdW50O1xuXG5Ob2RlLnByb3RvdHlwZS5vblJlY2VpdmUgPSBOb2RlLnByb3RvdHlwZS5yZWNlaXZlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5vZGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVGhlIFNpemUgY2xhc3MgaXMgcmVzcG9uc2libGUgZm9yIHByb2Nlc3NpbmcgU2l6ZSBmcm9tIGEgbm9kZVxuICogQGNvbnN0cnVjdG9yIHtTaXplfVxuICovXG5mdW5jdGlvbiBTaXplICgpIHtcbiAgICB0aGlzLl9zaXplID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbn1cblxuLy8gYW4gZW51bWVyYXRpb24gb2YgdGhlIGRpZmZlcmVudCB0eXBlcyBvZiBzaXplIG1vZGVzXG5TaXplLlJFTEFUSVZFID0gMDtcblNpemUuQUJTT0xVVEUgPSAxO1xuU2l6ZS5SRU5ERVIgPSAyO1xuU2l6ZS5ERUZBVUxUID0gU2l6ZS5SRUxBVElWRTtcblxuLyoqXG4gKiBmcm9tU3BlY1dpdGhQYXJlbnQgdGFrZXMgdGhlIHBhcmVudCBub2RlJ3Mgc2l6ZSwgdGhlIHRhcmdldCBub2RlcyBzcGVjLFxuICogYW5kIGEgdGFyZ2V0IGFycmF5IHRvIHdyaXRlIHRvLiBVc2luZyB0aGUgbm9kZSdzIHNpemUgbW9kZSBpdCBjYWxjdWxhdGVzIFxuICogYSBmaW5hbCBzaXplIGZvciB0aGUgbm9kZSBmcm9tIHRoZSBub2RlJ3Mgc3BlYy4gUmV0dXJucyB3aGV0aGVyIG9yIG5vdFxuICogdGhlIGZpbmFsIHNpemUgaGFzIGNoYW5nZWQgZnJvbSBpdHMgbGFzdCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJlbnQgbm9kZSdzIGNhbGN1bGF0ZWQgc2l6ZVxuICogQHBhcmFtIHtOb2RlLlNwZWN9IHRoZSB0YXJnZXQgbm9kZSdzIHNwZWNcbiAqIEBwYXJhbSB7QXJyYXl9IGFuIGFycmF5IHRvIHdyaXRlIHRoZSByZXN1bHQgdG9cbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBzaXplIG9mIHRoZSBub2RlIGhhcyBjaGFuZ2VkLlxuICovXG5TaXplLnByb3RvdHlwZS5mcm9tU3BlY1dpdGhQYXJlbnQgPSBmdW5jdGlvbiBmcm9tU3BlY1dpdGhQYXJlbnQgKHBhcmVudFNpemUsIHNwZWMsIHRhcmdldCkge1xuICAgIHZhciBtb2RlID0gc3BlYy5zaXplLnNpemVNb2RlO1xuICAgIHZhciBwcmV2O1xuICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgMyA7IGkrKykge1xuICAgICAgICBzd2l0Y2ggKG1vZGVbaV0pIHtcbiAgICAgICAgICAgIGNhc2UgU2l6ZS5SRUxBVElWRTpcbiAgICAgICAgICAgICAgICBwcmV2ID0gdGFyZ2V0W2ldO1xuICAgICAgICAgICAgICAgIHRhcmdldFtpXSA9IHBhcmVudFNpemVbaV0gKiBzcGVjLnNpemUucHJvcG9ydGlvbmFsW2ldICsgc3BlYy5zaXplLmRpZmZlcmVudGlhbFtpXTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gY2hhbmdlZCB8fCBwcmV2ICE9PSB0YXJnZXRbaV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFNpemUuQUJTT0xVVEU6XG4gICAgICAgICAgICAgICAgcHJldiA9IHRhcmdldFtpXTtcbiAgICAgICAgICAgICAgICB0YXJnZXRbaV0gPSBzcGVjLnNpemUuYWJzb2x1dGVbaV07XG4gICAgICAgICAgICAgICAgY2hhbmdlZCA9IGNoYW5nZWQgfHwgcHJldiAhPT0gdGFyZ2V0W2ldO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTaXplLlJFTkRFUjpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2l6ZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBUaGUgdHJhbnNmb3JtIGNsYXNzIGlzIHJlc3BvbnNpYmxlIGZvciBjYWxjdWxhdGluZyB0aGUgdHJhbnNmb3JtIG9mIGEgcGFydGljdWxhclxuICogbm9kZSBmcm9tIHRoZSBkYXRhIG9uIHRoZSBub2RlIGFuZCBpdHMgcGFyZW50XG4gKlxuICogQGNvbnN0cnVjdG9yIHtUcmFuc2Zvcm19XG4gKi9cbmZ1bmN0aW9uIFRyYW5zZm9ybSAoKSB7XG4gICAgdGhpcy5fbWF0cml4ID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbGFzdCBjYWxjdWxhdGVkIHRyYW5zZm9ybVxuICpcbiAqIEByZXR1cm4ge0FycmF5fSBhIHRyYW5zZm9ybVxuICovXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hdHJpeDtcbn07XG5cbi8qKlxuICogVXNlcyB0aGUgcGFyZW50IHRyYW5zZm9ybSwgdGhlIG5vZGUncyBzcGVjLCB0aGUgbm9kZSdzIHNpemUsIGFuZCB0aGUgcGFyZW50J3Mgc2l6ZVxuICogdG8gY2FsY3VsYXRlIGEgZmluYWwgdHJhbnNmb3JtIGZvciB0aGUgbm9kZS4gUmV0dXJucyB0cnVlIGlmIHRoZSB0cmFuc2Zvcm0gaGFzIGNoYW5nZWQuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gdGhlIHBhcmVudCBtYXRyaXhcbiAqIEBwYXJhbSB7Tm9kZS5TcGVjfSB0aGUgdGFyZ2V0IG5vZGUncyBzcGVjXG4gKiBAcGFyYW0ge0FycmF5fSB0aGUgc2l6ZSBvZiB0aGUgbm9kZVxuICogQHBhcmFtIHtBcnJheX0gdGhlIHNpemUgb2YgdGhlIHBhcmVudFxuICogQHBhcmFtIHtBcnJheX0gdGhlIHRhcmdldCBhcnJheSB0byB3cml0ZSB0aGUgcmVzdWx0aW5nIHRyYW5zZm9ybSB0b1xuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHdoZXRoZXIgb3Igbm90IHRoZSB0cmFuc2Zvcm0gY2hhbmdlZFxuICovXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmZyb21TcGVjV2l0aFBhcmVudCA9IGZ1bmN0aW9uIGZyb21TcGVjV2l0aFBhcmVudCAocGFyZW50TWF0cml4LCBzcGVjLCBteVNpemUsIHBhcmVudFNpemUsIHRhcmdldCkge1xuICAgIHRhcmdldCA9IHRhcmdldCA/IHRhcmdldCA6IHRoaXMuX21hdHJpeDtcblxuICAgIC8vIGxvY2FsIGNhY2hlIG9mIGV2ZXJ5dGhpbmdcbiAgICB2YXIgdDAwICAgICAgICAgPSB0YXJnZXRbMF07XG4gICAgdmFyIHQwMSAgICAgICAgID0gdGFyZ2V0WzFdO1xuICAgIHZhciB0MDIgICAgICAgICA9IHRhcmdldFsyXTtcbiAgICB2YXIgdDEwICAgICAgICAgPSB0YXJnZXRbNF07XG4gICAgdmFyIHQxMSAgICAgICAgID0gdGFyZ2V0WzVdO1xuICAgIHZhciB0MTIgICAgICAgICA9IHRhcmdldFs2XTtcbiAgICB2YXIgdDIwICAgICAgICAgPSB0YXJnZXRbOF07XG4gICAgdmFyIHQyMSAgICAgICAgID0gdGFyZ2V0WzldO1xuICAgIHZhciB0MjIgICAgICAgICA9IHRhcmdldFsxMF07XG4gICAgdmFyIHQzMCAgICAgICAgID0gdGFyZ2V0WzEyXTtcbiAgICB2YXIgdDMxICAgICAgICAgPSB0YXJnZXRbMTNdO1xuICAgIHZhciB0MzIgICAgICAgICA9IHRhcmdldFsxNF07XG4gICAgdmFyIHAwMCAgICAgICAgID0gcGFyZW50TWF0cml4WzBdO1xuICAgIHZhciBwMDEgICAgICAgICA9IHBhcmVudE1hdHJpeFsxXTtcbiAgICB2YXIgcDAyICAgICAgICAgPSBwYXJlbnRNYXRyaXhbMl07XG4gICAgdmFyIHAxMCAgICAgICAgID0gcGFyZW50TWF0cml4WzRdO1xuICAgIHZhciBwMTEgICAgICAgICA9IHBhcmVudE1hdHJpeFs1XTtcbiAgICB2YXIgcDEyICAgICAgICAgPSBwYXJlbnRNYXRyaXhbNl07XG4gICAgdmFyIHAyMCAgICAgICAgID0gcGFyZW50TWF0cml4WzhdO1xuICAgIHZhciBwMjEgICAgICAgICA9IHBhcmVudE1hdHJpeFs5XTtcbiAgICB2YXIgcDIyICAgICAgICAgPSBwYXJlbnRNYXRyaXhbMTBdO1xuICAgIHZhciBwMzAgICAgICAgICA9IHBhcmVudE1hdHJpeFsxMl07XG4gICAgdmFyIHAzMSAgICAgICAgID0gcGFyZW50TWF0cml4WzEzXTtcbiAgICB2YXIgcDMyICAgICAgICAgPSBwYXJlbnRNYXRyaXhbMTRdO1xuICAgIHZhciBwb3NYICAgICAgICA9IHNwZWMudmVjdG9ycy5wb3NpdGlvblswXTtcbiAgICB2YXIgcG9zWSAgICAgICAgPSBzcGVjLnZlY3RvcnMucG9zaXRpb25bMV07XG4gICAgdmFyIHBvc1ogICAgICAgID0gc3BlYy52ZWN0b3JzLnBvc2l0aW9uWzJdO1xuICAgIHZhciByb3RYICAgICAgICA9IHNwZWMudmVjdG9ycy5yb3RhdGlvblswXTtcbiAgICB2YXIgcm90WSAgICAgICAgPSBzcGVjLnZlY3RvcnMucm90YXRpb25bMV07XG4gICAgdmFyIHJvdFogICAgICAgID0gc3BlYy52ZWN0b3JzLnJvdGF0aW9uWzJdO1xuICAgIHZhciByb3RXICAgICAgICA9IHNwZWMudmVjdG9ycy5yb3RhdGlvblszXTtcbiAgICB2YXIgc2NhbGVYICAgICAgPSBzcGVjLnZlY3RvcnMuc2NhbGVbMF07XG4gICAgdmFyIHNjYWxlWSAgICAgID0gc3BlYy52ZWN0b3JzLnNjYWxlWzFdO1xuICAgIHZhciBzY2FsZVogICAgICA9IHNwZWMudmVjdG9ycy5zY2FsZVsyXTtcbiAgICB2YXIgYWxpZ25YICAgICAgPSBzcGVjLm9mZnNldHMuYWxpZ25bMF0gKiBwYXJlbnRTaXplWzBdO1xuICAgIHZhciBhbGlnblkgICAgICA9IHNwZWMub2Zmc2V0cy5hbGlnblsxXSAqIHBhcmVudFNpemVbMV07XG4gICAgdmFyIGFsaWduWiAgICAgID0gc3BlYy5vZmZzZXRzLmFsaWduWzJdICogcGFyZW50U2l6ZVsyXTtcbiAgICB2YXIgbW91bnRQb2ludFggPSBzcGVjLm9mZnNldHMubW91bnRQb2ludFswXSAqIG15U2l6ZVswXTtcbiAgICB2YXIgbW91bnRQb2ludFkgPSBzcGVjLm9mZnNldHMubW91bnRQb2ludFsxXSAqIG15U2l6ZVsxXTtcbiAgICB2YXIgbW91bnRQb2ludFogPSBzcGVjLm9mZnNldHMubW91bnRQb2ludFsyXSAqIG15U2l6ZVsyXTtcbiAgICB2YXIgb3JpZ2luWCAgICAgPSBzcGVjLm9mZnNldHMub3JpZ2luWzBdICogbXlTaXplWzBdO1xuICAgIHZhciBvcmlnaW5ZICAgICA9IHNwZWMub2Zmc2V0cy5vcmlnaW5bMV0gKiBteVNpemVbMV07XG4gICAgdmFyIG9yaWdpblogICAgID0gc3BlYy5vZmZzZXRzLm9yaWdpblsyXSAqIG15U2l6ZVsyXTtcblxuICAgIHZhciB3eCA9IHJvdFcgKiByb3RYO1xuICAgIHZhciB3eSA9IHJvdFcgKiByb3RZO1xuICAgIHZhciB3eiA9IHJvdFcgKiByb3RaO1xuICAgIHZhciB4eCA9IHJvdFggKiByb3RYO1xuICAgIHZhciB5eSA9IHJvdFkgKiByb3RZO1xuICAgIHZhciB6eiA9IHJvdFogKiByb3RaO1xuICAgIHZhciB4eSA9IHJvdFggKiByb3RZO1xuICAgIHZhciB4eiA9IHJvdFggKiByb3RaO1xuICAgIHZhciB5eiA9IHJvdFkgKiByb3RaO1xuXG4gICAgdmFyIHJzMCA9ICgxIC0gMiAqICh5eSArIHp6KSkgKiBzY2FsZVg7XG4gICAgdmFyIHJzMSA9ICgyICogKHh5ICsgd3opKSAqIHNjYWxlWDtcbiAgICB2YXIgcnMyID0gKDIgKiAoeHogLSB3eSkpICogc2NhbGVYO1xuICAgIHZhciByczMgPSAoMiAqICh4eSAtIHd6KSkgKiBzY2FsZVk7XG4gICAgdmFyIHJzNCA9ICgxIC0gMiAqICh4eCArIHp6KSkgKiBzY2FsZVk7XG4gICAgdmFyIHJzNSA9ICgyICogKHl6ICsgd3gpKSAqIHNjYWxlWTtcbiAgICB2YXIgcnM2ID0gKDIgKiAoeHogKyB3eSkpICogc2NhbGVaO1xuICAgIHZhciByczcgPSAoMiAqICh5eiAtIHd4KSkgKiBzY2FsZVo7XG4gICAgdmFyIHJzOCA9ICgxIC0gMiAqICh4eCArIHl5KSkgKiBzY2FsZVo7XG5cbiAgICB2YXIgdHggPSBhbGlnblggKyBwb3NYIC0gbW91bnRQb2ludFggKyBvcmlnaW5YIC0gKHJzMCAqIG9yaWdpblggKyByczMgKiBvcmlnaW5ZICsgcnM2ICogb3JpZ2luWik7XG4gICAgdmFyIHR5ID0gYWxpZ25ZICsgcG9zWSAtIG1vdW50UG9pbnRZICsgb3JpZ2luWSAtIChyczEgKiBvcmlnaW5YICsgcnM0ICogb3JpZ2luWSArIHJzNyAqIG9yaWdpblopO1xuICAgIHZhciB0eiA9IGFsaWduWiArIHBvc1ogLSBtb3VudFBvaW50WiArIG9yaWdpblogLSAocnMyICogb3JpZ2luWCArIHJzNSAqIG9yaWdpblkgKyByczggKiBvcmlnaW5aKTtcblxuICAgIHRhcmdldFswXSA9IHAwMCAqIHJzMCArIHAxMCAqIHJzMSArIHAyMCAqIHJzMjtcbiAgICB0YXJnZXRbMV0gPSBwMDEgKiByczAgKyBwMTEgKiByczEgKyBwMjEgKiByczI7XG4gICAgdGFyZ2V0WzJdID0gcDAyICogcnMwICsgcDEyICogcnMxICsgcDIyICogcnMyO1xuICAgIHRhcmdldFszXSA9IDA7XG4gICAgdGFyZ2V0WzRdID0gcDAwICogcnMzICsgcDEwICogcnM0ICsgcDIwICogcnM1O1xuICAgIHRhcmdldFs1XSA9IHAwMSAqIHJzMyArIHAxMSAqIHJzNCArIHAyMSAqIHJzNTtcbiAgICB0YXJnZXRbNl0gPSBwMDIgKiByczMgKyBwMTIgKiByczQgKyBwMjIgKiByczU7XG4gICAgdGFyZ2V0WzddID0gMDtcbiAgICB0YXJnZXRbOF0gPSBwMDAgKiByczYgKyBwMTAgKiByczcgKyBwMjAgKiByczg7XG4gICAgdGFyZ2V0WzldID0gcDAxICogcnM2ICsgcDExICogcnM3ICsgcDIxICogcnM4O1xuICAgIHRhcmdldFsxMF0gPSBwMDIgKiByczYgKyBwMTIgKiByczcgKyBwMjIgKiByczg7XG4gICAgdGFyZ2V0WzExXSA9IDA7XG4gICAgdGFyZ2V0WzEyXSA9IHAwMCAqIHR4ICsgcDEwICogdHkgKyBwMjAgKiB0eiArIHAzMDtcbiAgICB0YXJnZXRbMTNdID0gcDAxICogdHggKyBwMTEgKiB0eSArIHAyMSAqIHR6ICsgcDMxO1xuICAgIHRhcmdldFsxNF0gPSBwMDIgKiB0eCArIHAxMiAqIHR5ICsgcDIyICogdHogKyBwMzI7XG4gICAgdGFyZ2V0WzE1XSA9IDE7XG5cbiAgICByZXR1cm4gdDAwICE9PSB0YXJnZXRbMF0gfHxcbiAgICAgICAgdDAxICE9PSB0YXJnZXRbMV0gfHxcbiAgICAgICAgdDAyICE9PSB0YXJnZXRbMl0gfHxcbiAgICAgICAgdDEwICE9PSB0YXJnZXRbNF0gfHxcbiAgICAgICAgdDExICE9PSB0YXJnZXRbNV0gfHxcbiAgICAgICAgdDEyICE9PSB0YXJnZXRbNl0gfHxcbiAgICAgICAgdDIwICE9PSB0YXJnZXRbOF0gfHxcbiAgICAgICAgdDIxICE9PSB0YXJnZXRbOV0gfHxcbiAgICAgICAgdDIyICE9PSB0YXJnZXRbMTBdIHx8XG4gICAgICAgIHQzMCAhPT0gdGFyZ2V0WzEyXSB8fFxuICAgICAgICB0MzEgIT09IHRhcmdldFsxM10gfHxcbiAgICAgICAgdDMyICE9PSB0YXJnZXRbMTRdO1xuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgQ2xvY2s6IHJlcXVpcmUoJy4vQ2xvY2snKSxcbiAgICBFdmVudDogcmVxdWlyZSgnLi9FdmVudCcpLFxuICAgIENvbnRleHQ6IHJlcXVpcmUoJy4vQ29udGV4dCcpLFxuICAgIEZhbW91czogcmVxdWlyZSgnLi9GYW1vdXMnKSxcbiAgICBEaXNwYXRjaDogcmVxdWlyZSgnLi9EaXNwYXRjaCcpLFxuICAgIERpc3BhdGNoZXI6IHJlcXVpcmUoJy4vRGlzcGF0Y2gnKSxcbiAgICBOb2RlOiByZXF1aXJlKCcuL05vZGUnKSxcbiAgICBTaXplOiByZXF1aXJlKCcuL1NpemUnKSxcbiAgICBUcmFuc2Zvcm06IHJlcXVpcmUoJy4vVHJhbnNmb3JtJylcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQSAzeDMgbnVtZXJpY2FsIG1hdHJpeCwgcmVwcmVzZW50ZWQgYXMgYW4gYXJyYXkuXG4gKlxuICogQGNsYXNzIE1hdDMzXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge051bWJlcltdfSB2YWx1ZXNcbiAqL1xuZnVuY3Rpb24gTWF0MzModmFsdWVzKSB7XG4gICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXMgfHwgWzEsMCwwLDAsMSwwLDAsMCwxXTtcblxuICAgIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgdmFsdWVzIGluIHRoZSBNYXQzMyBhcyBhbiBhcnJheS5cbiAqXG4gKiBAbWV0aG9kIGdldFxuICogQHJldHVybiB7TnVtYmVyW119IG1hdHJpeCB2YWx1ZXMgYXMgYXJyYXkgb2Ygcm93cy5cbiAqL1xuTWF0MzMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZXM7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgdmFsdWVzIG9mIHRoZSBjdXJyZW50IE1hdDMzLlxuICpcbiAqIEBtZXRob2Qgc2V0XG4gKiBAcGFyYW0ge051bWJlcltdfSB2YWx1ZXMgQXJyYXkgb2YgbmluZSBudW1iZXJzIHRvIHNldCBpbiB0aGUgTWF0MzMuXG4gKiBAY2hhaW5hYmxlXG4gKi9cbk1hdDMzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQodmFsdWVzKSB7XG4gICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBvZiB0aGUgaW5wdXQgTWF0MzMuXG4gKlxuICogQG1ldGhvZCBjb3B5XG4gKiBAcGFyYW0ge01hdDMzfSBtYXRyaXggVGhlIE1hdDMzIHRvIGNvcHkuXG4gKiBAY2hhaW5hYmxlXG4gKi9cbk1hdDMzLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weShtYXRyaXgpIHtcbiAgICB2YXIgQSA9IHRoaXMudmFsdWVzO1xuICAgIHZhciBCID0gbWF0cml4LnZhbHVlcztcblxuICAgIEFbMF0gPSBCWzBdO1xuICAgIEFbMV0gPSBCWzFdO1xuICAgIEFbMl0gPSBCWzJdO1xuICAgIEFbM10gPSBCWzNdO1xuICAgIEFbNF0gPSBCWzRdO1xuICAgIEFbNV0gPSBCWzVdO1xuICAgIEFbNl0gPSBCWzZdO1xuICAgIEFbN10gPSBCWzddO1xuICAgIEFbOF0gPSBCWzhdO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFRha2UgdGhpcyBNYXQzMyBhcyBBLCBpbnB1dCB2ZWN0b3IgViBhcyBhIGNvbHVtbiB2ZWN0b3IsIGFuZCByZXR1cm4gTWF0MzMgcHJvZHVjdCAoQSkoVikuXG4gKlxuICogQG1ldGhvZCB2ZWN0b3JNdWx0aXBseVxuICogQHBhcmFtIHtWZWMzfSB2IFZlY3RvciB0byByb3RhdGUuXG4gKiBAcGFyYW0ge1ZlYzN9IG91dHB1dCBWZWMzIGluIHdoaWNoIHRvIHBsYWNlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJuIHtWZWMzfSBUaGUgaW5wdXQgdmVjdG9yIGFmdGVyIG11bHRpcGxpY2F0aW9uLlxuICovXG5NYXQzMy5wcm90b3R5cGUudmVjdG9yTXVsdGlwbHkgPSBmdW5jdGlvbiB2ZWN0b3JNdWx0aXBseSh2LCBvdXRwdXQpIHtcbiAgICB2YXIgTSA9IHRoaXMudmFsdWVzO1xuICAgIHZhciB2MCA9IHYueDtcbiAgICB2YXIgdjEgPSB2Lnk7XG4gICAgdmFyIHYyID0gdi56O1xuXG4gICAgb3V0cHV0LnggPSBNWzBdKnYwICsgTVsxXSp2MSArIE1bMl0qdjI7XG4gICAgb3V0cHV0LnkgPSBNWzNdKnYwICsgTVs0XSp2MSArIE1bNV0qdjI7XG4gICAgb3V0cHV0LnogPSBNWzZdKnYwICsgTVs3XSp2MSArIE1bOF0qdjI7XG5cbiAgICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqXG4gKiBNdWx0aXBseSB0aGUgcHJvdmlkZWQgTWF0MzMgd2l0aCB0aGUgY3VycmVudCBNYXQzMy4gIFJlc3VsdCBpcyAodGhpcykgKiAobWF0cml4KS5cbiAqXG4gKiBAbWV0aG9kIG11bHRpcGx5XG4gKiBAcGFyYW0ge01hdDMzfSBtYXRyaXggSW5wdXQgTWF0MzMgdG8gbXVsdGlwbHkgb24gdGhlIHJpZ2h0LlxuICogQGNoYWluYWJsZVxuICovXG5NYXQzMy5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiBtdWx0aXBseShtYXRyaXgpIHtcbiAgICB2YXIgQSA9IHRoaXMudmFsdWVzO1xuICAgIHZhciBCID0gbWF0cml4LnZhbHVlcztcblxuICAgIHZhciBBMCA9IEFbMF07XG4gICAgdmFyIEExID0gQVsxXTtcbiAgICB2YXIgQTIgPSBBWzJdO1xuICAgIHZhciBBMyA9IEFbM107XG4gICAgdmFyIEE0ID0gQVs0XTtcbiAgICB2YXIgQTUgPSBBWzVdO1xuICAgIHZhciBBNiA9IEFbNl07XG4gICAgdmFyIEE3ID0gQVs3XTtcbiAgICB2YXIgQTggPSBBWzhdO1xuXG4gICAgdmFyIEIwID0gQlswXTtcbiAgICB2YXIgQjEgPSBCWzFdO1xuICAgIHZhciBCMiA9IEJbMl07XG4gICAgdmFyIEIzID0gQlszXTtcbiAgICB2YXIgQjQgPSBCWzRdO1xuICAgIHZhciBCNSA9IEJbNV07XG4gICAgdmFyIEI2ID0gQls2XTtcbiAgICB2YXIgQjcgPSBCWzddO1xuICAgIHZhciBCOCA9IEJbOF07XG5cbiAgICBBWzBdID0gQTAqQjAgKyBBMSpCMyArIEEyKkI2O1xuICAgIEFbMV0gPSBBMCpCMSArIEExKkI0ICsgQTIqQjc7XG4gICAgQVsyXSA9IEEwKkIyICsgQTEqQjUgKyBBMipCODtcbiAgICBBWzNdID0gQTMqQjAgKyBBNCpCMyArIEE1KkI2O1xuICAgIEFbNF0gPSBBMypCMSArIEE0KkI0ICsgQTUqQjc7XG4gICAgQVs1XSA9IEEzKkIyICsgQTQqQjUgKyBBNSpCODtcbiAgICBBWzZdID0gQTYqQjAgKyBBNypCMyArIEE4KkI2O1xuICAgIEFbN10gPSBBNipCMSArIEE3KkI0ICsgQTgqQjc7XG4gICAgQVs4XSA9IEE2KkIyICsgQTcqQjUgKyBBOCpCODtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBUcmFuc3Bvc2VzIHRoZSBNYXQzMy5cbiAqXG4gKiBAbWV0aG9kIHRyYW5zcG9zZVxuICogQGNoYWluYWJsZVxuICovXG5NYXQzMy5wcm90b3R5cGUudHJhbnNwb3NlID0gZnVuY3Rpb24gdHJhbnNwb3NlKCkge1xuICAgIHZhciBNID0gdGhpcy52YWx1ZXM7XG5cbiAgICB2YXIgTTEgPSBNWzFdO1xuICAgIHZhciBNMiA9IE1bMl07XG4gICAgdmFyIE0zID0gTVszXTtcbiAgICB2YXIgTTUgPSBNWzVdO1xuICAgIHZhciBNNiA9IE1bNl07XG4gICAgdmFyIE03ID0gTVs3XTtcblxuICAgIE1bMV0gPSBNMztcbiAgICBNWzJdID0gTTY7XG4gICAgTVszXSA9IE0xO1xuICAgIE1bNV0gPSBNNztcbiAgICBNWzZdID0gTTI7XG4gICAgTVs3XSA9IE01O1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFRoZSBkZXRlcm1pbmFudCBvZiB0aGUgTWF0MzMuXG4gKlxuICogQG1ldGhvZCBnZXREZXRlcm1pbmFudFxuICogQHJldHVybiB7TnVtYmVyfSBUaGUgZGV0ZXJtaW5hbnQuXG4gKi9cbk1hdDMzLnByb3RvdHlwZS5nZXREZXRlcm1pbmFudCA9IGZ1bmN0aW9uIGdldERldGVybWluYW50KCkge1xuICAgIHZhciBNID0gdGhpcy52YWx1ZXM7XG5cbiAgICB2YXIgTTMgPSBNWzNdO1xuICAgIHZhciBNNCA9IE1bNF07XG4gICAgdmFyIE01ID0gTVs1XTtcbiAgICB2YXIgTTYgPSBNWzZdO1xuICAgIHZhciBNNyA9IE1bN107XG4gICAgdmFyIE04ID0gTVs4XTtcblxuICAgIHZhciBkZXQgPSBNWzBdKihNNCpNOCAtIE01Kk03KVxuICAgICAgICAgICAgLSBNWzFdKihNMypNOCAtIE01Kk02KVxuICAgICAgICAgICAgKyBNWzJdKihNMypNNyAtIE00Kk02KTtcblxuICAgIHJldHVybiBkZXQ7XG59O1xuXG4vKipcbiAqIFRoZSBpbnZlcnNlIG9mIHRoZSBNYXQzMy5cbiAqXG4gKiBAbWV0aG9kIGludmVyc2VcbiAqIEBjaGFpbmFibGVcbiAqL1xuTWF0MzMucHJvdG90eXBlLmludmVyc2UgPSBmdW5jdGlvbiBpbnZlcnNlKCkge1xuICAgIHZhciBNID0gdGhpcy52YWx1ZXM7XG5cbiAgICB2YXIgTTAgPSBNWzBdO1xuICAgIHZhciBNMSA9IE1bMV07XG4gICAgdmFyIE0yID0gTVsyXTtcbiAgICB2YXIgTTMgPSBNWzNdO1xuICAgIHZhciBNNCA9IE1bNF07XG4gICAgdmFyIE01ID0gTVs1XTtcbiAgICB2YXIgTTYgPSBNWzZdO1xuICAgIHZhciBNNyA9IE1bN107XG4gICAgdmFyIE04ID0gTVs4XTtcblxuICAgIHZhciBkZXQgPSBNMCooTTQqTTggLSBNNSpNNylcbiAgICAgICAgICAgIC0gTTEqKE0zKk04IC0gTTUqTTYpXG4gICAgICAgICAgICArIE0yKihNMypNNyAtIE00Kk02KTtcblxuICAgIGlmIChNYXRoLmFicyhkZXQpIDwgMWUtNDApIHJldHVybiBudWxsO1xuXG4gICAgZGV0ID0gMSAvIGRldDtcblxuICAgIE1bMF0gPSAoTTQqTTggLSBNNSpNNykgKiBkZXQ7XG4gICAgTVszXSA9ICgtTTMqTTggKyBNNSpNNikgKiBkZXQ7XG4gICAgTVs2XSA9IChNMypNNyAtIE00Kk02KSAqIGRldDtcbiAgICBNWzFdID0gKC1NMSpNOCArIE0yKk03KSAqIGRldDtcbiAgICBNWzRdID0gKE0wKk04IC0gTTIqTTYpICogZGV0O1xuICAgIE1bN10gPSAoLU0wKk03ICsgTTEqTTYpICogZGV0O1xuICAgIE1bMl0gPSAoTTEqTTUgLSBNMipNNCkgKiBkZXQ7XG4gICAgTVs1XSA9ICgtTTAqTTUgKyBNMipNMykgKiBkZXQ7XG4gICAgTVs4XSA9IChNMCpNNCAtIE0xKk0zKSAqIGRldDtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDbG9uZXMgdGhlIGlucHV0IE1hdDMzLlxuICpcbiAqIEBtZXRob2QgY2xvbmVcbiAqIEBwYXJhbSB7TWF0MzN9IG0gTWF0MzMgdG8gY2xvbmUuXG4gKiBAcmV0dXJuIHtNYXQzM30gTmV3IGNvcHkgb2YgdGhlIG9yaWdpbmFsIE1hdDMzLlxuICovXG5NYXQzMy5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lKG0pIHtcbiAgICByZXR1cm4gbmV3IE1hdDMzKG0udmFsdWVzLnNsaWNlKCkpO1xufTtcblxuLyoqXG4gKiBUaGUgaW52ZXJzZSBvZiB0aGUgTWF0MzMuXG4gKlxuICogQG1ldGhvZCBpbnZlcnNlXG4gKiBAcGFyYW0ge01hdDMzfSBtYXRyaXggTWF0MzMgdG8gaW52ZXJ0LlxuICogQHBhcmFtIHtNYXQzM30gb3V0cHV0IE1hdDMzIGluIHdoaWNoIHRvIHBsYWNlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJuIHtNYXQzM30gVGhlIE1hdDMzIGFmdGVyIHRoZSBpbnZlcnQuXG4gKi9cbk1hdDMzLmludmVyc2UgPSBmdW5jdGlvbiBpbnZlcnNlKG1hdHJpeCwgb3V0cHV0KSB7XG4gICAgdmFyIE0gPSBtYXRyaXgudmFsdWVzO1xuICAgIHZhciByZXN1bHQgPSBvdXRwdXQudmFsdWVzO1xuXG4gICAgdmFyIE0wID0gTVswXTtcbiAgICB2YXIgTTEgPSBNWzFdO1xuICAgIHZhciBNMiA9IE1bMl07XG4gICAgdmFyIE0zID0gTVszXTtcbiAgICB2YXIgTTQgPSBNWzRdO1xuICAgIHZhciBNNSA9IE1bNV07XG4gICAgdmFyIE02ID0gTVs2XTtcbiAgICB2YXIgTTcgPSBNWzddO1xuICAgIHZhciBNOCA9IE1bOF07XG5cbiAgICB2YXIgZGV0ID0gTTAqKE00Kk04IC0gTTUqTTcpXG4gICAgICAgICAgICAtIE0xKihNMypNOCAtIE01Kk02KVxuICAgICAgICAgICAgKyBNMiooTTMqTTcgLSBNNCpNNik7XG5cbiAgICBpZiAoTWF0aC5hYnMoZGV0KSA8IDFlLTQwKSByZXR1cm4gbnVsbDtcblxuICAgIGRldCA9IDEgLyBkZXQ7XG5cbiAgICByZXN1bHRbMF0gPSAoTTQqTTggLSBNNSpNNykgKiBkZXQ7XG4gICAgcmVzdWx0WzNdID0gKC1NMypNOCArIE01Kk02KSAqIGRldDtcbiAgICByZXN1bHRbNl0gPSAoTTMqTTcgLSBNNCpNNikgKiBkZXQ7XG4gICAgcmVzdWx0WzFdID0gKC1NMSpNOCArIE0yKk03KSAqIGRldDtcbiAgICByZXN1bHRbNF0gPSAoTTAqTTggLSBNMipNNikgKiBkZXQ7XG4gICAgcmVzdWx0WzddID0gKC1NMCpNNyArIE0xKk02KSAqIGRldDtcbiAgICByZXN1bHRbMl0gPSAoTTEqTTUgLSBNMipNNCkgKiBkZXQ7XG4gICAgcmVzdWx0WzVdID0gKC1NMCpNNSArIE0yKk0zKSAqIGRldDtcbiAgICByZXN1bHRbOF0gPSAoTTAqTTQgLSBNMSpNMykgKiBkZXQ7XG5cbiAgICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqXG4gKiBUcmFuc3Bvc2VzIHRoZSBNYXQzMy5cbiAqXG4gKiBAbWV0aG9kIHRyYW5zcG9zZVxuICogQHBhcmFtIHtNYXQzM30gbWF0cml4IE1hdDMzIHRvIHRyYW5zcG9zZS5cbiAqIEBwYXJhbSB7TWF0MzN9IG91dHB1dCBNYXQzMyBpbiB3aGljaCB0byBwbGFjZSB0aGUgcmVzdWx0LlxuICogQHJldHVybiB7TWF0MzN9IFRoZSBNYXQzMyBhZnRlciB0aGUgdHJhbnNwb3NlLlxuICovXG5NYXQzMy50cmFuc3Bvc2UgPSBmdW5jdGlvbiB0cmFuc3Bvc2UobWF0cml4LCBvdXRwdXQpIHtcbiAgICB2YXIgTSA9IG1hdHJpeC52YWx1ZXM7XG4gICAgdmFyIHJlc3VsdCA9IG91dHB1dC52YWx1ZXM7XG5cbiAgICB2YXIgTTAgPSBNWzBdO1xuICAgIHZhciBNMSA9IE1bMV07XG4gICAgdmFyIE0yID0gTVsyXTtcbiAgICB2YXIgTTMgPSBNWzNdO1xuICAgIHZhciBNNCA9IE1bNF07XG4gICAgdmFyIE01ID0gTVs1XTtcbiAgICB2YXIgTTYgPSBNWzZdO1xuICAgIHZhciBNNyA9IE1bN107XG4gICAgdmFyIE04ID0gTVs4XTtcblxuICAgIHJlc3VsdFswXSA9IE0wO1xuICAgIHJlc3VsdFsxXSA9IE0zO1xuICAgIHJlc3VsdFsyXSA9IE02O1xuICAgIHJlc3VsdFszXSA9IE0xO1xuICAgIHJlc3VsdFs0XSA9IE00O1xuICAgIHJlc3VsdFs1XSA9IE03O1xuICAgIHJlc3VsdFs2XSA9IE0yO1xuICAgIHJlc3VsdFs3XSA9IE01O1xuICAgIHJlc3VsdFs4XSA9IE04O1xuXG4gICAgcmV0dXJuIG91dHB1dDtcbn07XG5cbi8qKlxuICogQWRkIHRoZSBwcm92aWRlZCBNYXQzMydzLlxuICpcbiAqIEBtZXRob2QgYWRkXG4gKiBAcGFyYW0ge01hdDMzfSBtYXRyaXgxIFRoZSBsZWZ0IE1hdDMzLlxuICogQHBhcmFtIHtNYXQzM30gbWF0cml4MiBUaGUgcmlnaHQgTWF0MzMuXG4gKiBAcGFyYW0ge01hdDMzfSBvdXRwdXQgTWF0MzMgaW4gd2hpY2ggdG8gcGxhY2UgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm4ge01hdDMzfSBUaGUgcmVzdWx0IG9mIHRoZSBhZGRpdGlvbi5cbiAqL1xuTWF0MzMuYWRkID0gZnVuY3Rpb24gYWRkKG1hdHJpeDEsIG1hdHJpeDIsIG91dHB1dCkge1xuICAgIHZhciBBID0gbWF0cml4MS52YWx1ZXM7XG4gICAgdmFyIEIgPSBtYXRyaXgyLnZhbHVlcztcbiAgICB2YXIgcmVzdWx0ID0gb3V0cHV0LnZhbHVlcztcblxuICAgIHZhciBBMCA9IEFbMF07XG4gICAgdmFyIEExID0gQVsxXTtcbiAgICB2YXIgQTIgPSBBWzJdO1xuICAgIHZhciBBMyA9IEFbM107XG4gICAgdmFyIEE0ID0gQVs0XTtcbiAgICB2YXIgQTUgPSBBWzVdO1xuICAgIHZhciBBNiA9IEFbNl07XG4gICAgdmFyIEE3ID0gQVs3XTtcbiAgICB2YXIgQTggPSBBWzhdO1xuXG4gICAgdmFyIEIwID0gQlswXTtcbiAgICB2YXIgQjEgPSBCWzFdO1xuICAgIHZhciBCMiA9IEJbMl07XG4gICAgdmFyIEIzID0gQlszXTtcbiAgICB2YXIgQjQgPSBCWzRdO1xuICAgIHZhciBCNSA9IEJbNV07XG4gICAgdmFyIEI2ID0gQls2XTtcbiAgICB2YXIgQjcgPSBCWzddO1xuICAgIHZhciBCOCA9IEJbOF07XG5cbiAgICByZXN1bHRbMF0gPSBBMCArIEIwO1xuICAgIHJlc3VsdFsxXSA9IEExICsgQjE7XG4gICAgcmVzdWx0WzJdID0gQTIgKyBCMjtcbiAgICByZXN1bHRbM10gPSBBMyArIEIzO1xuICAgIHJlc3VsdFs0XSA9IEE0ICsgQjQ7XG4gICAgcmVzdWx0WzVdID0gQTUgKyBCNTtcbiAgICByZXN1bHRbNl0gPSBBNiArIEI2O1xuICAgIHJlc3VsdFs3XSA9IEE3ICsgQjc7XG4gICAgcmVzdWx0WzhdID0gQTggKyBCODtcblxuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIFN1YnRyYWN0IHRoZSBwcm92aWRlZCBNYXQzMydzLlxuICpcbiAqIEBtZXRob2Qgc3VidHJhY3RcbiAqIEBwYXJhbSB7TWF0MzN9IG1hdHJpeDEgVGhlIGxlZnQgTWF0MzMuXG4gKiBAcGFyYW0ge01hdDMzfSBtYXRyaXgyIFRoZSByaWdodCBNYXQzMy5cbiAqIEBwYXJhbSB7TWF0MzN9IG91dHB1dCBNYXQzMyBpbiB3aGljaCB0byBwbGFjZSB0aGUgcmVzdWx0LlxuICogQHJldHVybiB7TWF0MzN9IFRoZSByZXN1bHQgb2YgdGhlIHN1YnRyYWN0aW9uLlxuICovXG5NYXQzMy5zdWJ0cmFjdCA9IGZ1bmN0aW9uIHN1YnRyYWN0KG1hdHJpeDEsIG1hdHJpeDIsIG91dHB1dCkge1xuICAgIHZhciBBID0gbWF0cml4MS52YWx1ZXM7XG4gICAgdmFyIEIgPSBtYXRyaXgyLnZhbHVlcztcbiAgICB2YXIgcmVzdWx0ID0gb3V0cHV0LnZhbHVlcztcblxuICAgIHZhciBBMCA9IEFbMF07XG4gICAgdmFyIEExID0gQVsxXTtcbiAgICB2YXIgQTIgPSBBWzJdO1xuICAgIHZhciBBMyA9IEFbM107XG4gICAgdmFyIEE0ID0gQVs0XTtcbiAgICB2YXIgQTUgPSBBWzVdO1xuICAgIHZhciBBNiA9IEFbNl07XG4gICAgdmFyIEE3ID0gQVs3XTtcbiAgICB2YXIgQTggPSBBWzhdO1xuXG4gICAgdmFyIEIwID0gQlswXTtcbiAgICB2YXIgQjEgPSBCWzFdO1xuICAgIHZhciBCMiA9IEJbMl07XG4gICAgdmFyIEIzID0gQlszXTtcbiAgICB2YXIgQjQgPSBCWzRdO1xuICAgIHZhciBCNSA9IEJbNV07XG4gICAgdmFyIEI2ID0gQls2XTtcbiAgICB2YXIgQjcgPSBCWzddO1xuICAgIHZhciBCOCA9IEJbOF07XG5cbiAgICByZXN1bHRbMF0gPSBBMCAtIEIwO1xuICAgIHJlc3VsdFsxXSA9IEExIC0gQjE7XG4gICAgcmVzdWx0WzJdID0gQTIgLSBCMjtcbiAgICByZXN1bHRbM10gPSBBMyAtIEIzO1xuICAgIHJlc3VsdFs0XSA9IEE0IC0gQjQ7XG4gICAgcmVzdWx0WzVdID0gQTUgLSBCNTtcbiAgICByZXN1bHRbNl0gPSBBNiAtIEI2O1xuICAgIHJlc3VsdFs3XSA9IEE3IC0gQjc7XG4gICAgcmVzdWx0WzhdID0gQTggLSBCODtcblxuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuLyoqXG4gKiBNdWx0aXBseSB0aGUgcHJvdmlkZWQgTWF0MzMgTTIgd2l0aCB0aGlzIE1hdDMzLiAgUmVzdWx0IGlzICh0aGlzKSAqIChNMikuXG4gKlxuICogQG1ldGhvZCBtdWx0aXBseVxuICogQHBhcmFtIHtNYXQzM30gbWF0cml4MSBUaGUgbGVmdCBNYXQzMy5cbiAqIEBwYXJhbSB7TWF0MzN9IG1hdHJpeDIgVGhlIHJpZ2h0IE1hdDMzLlxuICogQHBhcmFtIHtNYXQzM30gb3V0cHV0IE1hdDMzIGluIHdoaWNoIHRvIHBsYWNlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJuIHtNYXQzM30gdGhlIHJlc3VsdCBvZiB0aGUgbXVsdGlwbGljYXRpb24uXG4gKi9cbk1hdDMzLm11bHRpcGx5ID0gZnVuY3Rpb24gbXVsdGlwbHkobWF0cml4MSwgbWF0cml4Miwgb3V0cHV0KSB7XG4gICAgdmFyIEEgPSBtYXRyaXgxLnZhbHVlcztcbiAgICB2YXIgQiA9IG1hdHJpeDIudmFsdWVzO1xuICAgIHZhciByZXN1bHQgPSBvdXRwdXQudmFsdWVzO1xuXG4gICAgdmFyIEEwID0gQVswXTtcbiAgICB2YXIgQTEgPSBBWzFdO1xuICAgIHZhciBBMiA9IEFbMl07XG4gICAgdmFyIEEzID0gQVszXTtcbiAgICB2YXIgQTQgPSBBWzRdO1xuICAgIHZhciBBNSA9IEFbNV07XG4gICAgdmFyIEE2ID0gQVs2XTtcbiAgICB2YXIgQTcgPSBBWzddO1xuICAgIHZhciBBOCA9IEFbOF07XG5cbiAgICB2YXIgQjAgPSBCWzBdO1xuICAgIHZhciBCMSA9IEJbMV07XG4gICAgdmFyIEIyID0gQlsyXTtcbiAgICB2YXIgQjMgPSBCWzNdO1xuICAgIHZhciBCNCA9IEJbNF07XG4gICAgdmFyIEI1ID0gQls1XTtcbiAgICB2YXIgQjYgPSBCWzZdO1xuICAgIHZhciBCNyA9IEJbN107XG4gICAgdmFyIEI4ID0gQls4XTtcblxuICAgIHJlc3VsdFswXSA9IEEwKkIwICsgQTEqQjMgKyBBMipCNjtcbiAgICByZXN1bHRbMV0gPSBBMCpCMSArIEExKkI0ICsgQTIqQjc7XG4gICAgcmVzdWx0WzJdID0gQTAqQjIgKyBBMSpCNSArIEEyKkI4O1xuICAgIHJlc3VsdFszXSA9IEEzKkIwICsgQTQqQjMgKyBBNSpCNjtcbiAgICByZXN1bHRbNF0gPSBBMypCMSArIEE0KkI0ICsgQTUqQjc7XG4gICAgcmVzdWx0WzVdID0gQTMqQjIgKyBBNCpCNSArIEE1KkI4O1xuICAgIHJlc3VsdFs2XSA9IEE2KkIwICsgQTcqQjMgKyBBOCpCNjtcbiAgICByZXN1bHRbN10gPSBBNipCMSArIEE3KkI0ICsgQTgqQjc7XG4gICAgcmVzdWx0WzhdID0gQTYqQjIgKyBBNypCNSArIEE4KkI4O1xuXG4gICAgcmV0dXJuIG91dHB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTWF0MzM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBNYXRyaXggPSByZXF1aXJlKCcuL01hdDMzJyk7XG5cbnZhciBzaW4gPSBNYXRoLnNpbjtcbnZhciBjb3MgPSBNYXRoLmNvcztcbnZhciBhc2luID0gTWF0aC5hc2luO1xudmFyIGFjb3MgPSBNYXRoLmFjb3M7XG52YXIgYXRhbjIgPSBNYXRoLmF0YW4yO1xudmFyIHNxcnQgPSBNYXRoLnNxcnQ7XG5cbi8qKlxuICogQSB2ZWN0b3ItbGlrZSBvYmplY3QgdXNlZCB0byByZXByZXNlbnQgcm90YXRpb25zLiBJZiB0aGV0YSBpcyB0aGUgYW5nbGUgb2ZcbiAqIHJvdGF0aW9uLCBhbmQgKHgnLCB5JywgeicpIGlzIGEgbm9ybWFsaXplZCB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBheGlzIG9mXG4gKiByb3RhdGlvbiwgdGhlbiB3ID0gY29zKHRoZXRhLzIpLCB4ID0gc2luKHRoZXRhLzIpKngnLCB5ID0gc2luKHRoZXRhLzIpKnknLFxuICogYW5kIHogPSBzaW4odGhldGEvMikqeicuXG4gKlxuICogQGNsYXNzIFF1YXRlcm5pb25cbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFRoZSB3IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFRoZSB6IGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gUXVhdGVybmlvbih3LCB4LCB5LCB6KSB7XG4gICAgdGhpcy53ID0gdyB8fCAxO1xuICAgIHRoaXMueCA9IHggfHwgMDtcbiAgICB0aGlzLnkgPSB5IHx8IDA7XG4gICAgdGhpcy56ID0geiB8fCAwO1xufVxuXG4vKipcbiAqIE11bHRpcGx5IHRoZSBjdXJyZW50IFF1YXRlcm5pb24gYnkgaW5wdXQgUXVhdGVybmlvbiBxLlxuICogTGVmdC1oYW5kZWQgbXVsdGlwbGljYXRpb24uXG4gKlxuICogQG1ldGhvZCBtdWx0aXBseVxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxIFRoZSBRdWF0ZXJuaW9uIHRvIG11bHRpcGx5IGJ5IG9uIHRoZSByaWdodC5cbiAqL1xuUXVhdGVybmlvbi5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiBtdWx0aXBseShxKSB7XG4gICAgdmFyIHgxID0gdGhpcy54O1xuICAgIHZhciB5MSA9IHRoaXMueTtcbiAgICB2YXIgejEgPSB0aGlzLno7XG4gICAgdmFyIHcxID0gdGhpcy53O1xuICAgIHZhciB4MiA9IHEueDtcbiAgICB2YXIgeTIgPSBxLnk7XG4gICAgdmFyIHoyID0gcS56O1xuICAgIHZhciB3MiA9IHEudyB8fCAwO1xuXG4gICAgdGhpcy53ID0gdzEgKiB3MiAtIHgxICogeDIgLSB5MSAqIHkyIC0gejEgKiB6MjtcbiAgICB0aGlzLnggPSB4MSAqIHcyICsgeDIgKiB3MSArIHkyICogejEgLSB5MSAqIHoyO1xuICAgIHRoaXMueSA9IHkxICogdzIgKyB5MiAqIHcxICsgeDEgKiB6MiAtIHgyICogejE7XG4gICAgdGhpcy56ID0gejEgKiB3MiArIHoyICogdzEgKyB4MiAqIHkxIC0geDEgKiB5MjtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTXVsdGlwbHkgdGhlIGN1cnJlbnQgUXVhdGVybmlvbiBieSBpbnB1dCBRdWF0ZXJuaW9uIHEgb24gdGhlIGxlZnQsIGkuZS4gcSAqIHRoaXMuXG4gKiBMZWZ0LWhhbmRlZCBtdWx0aXBsaWNhdGlvbi5cbiAqXG4gKiBAbWV0aG9kIGxlZnRNdWx0aXBseVxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxIFRoZSBRdWF0ZXJuaW9uIHRvIG11bHRpcGx5IGJ5IG9uIHRoZSBsZWZ0LlxuICovXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5sZWZ0TXVsdGlwbHkgPSBmdW5jdGlvbiBsZWZ0TXVsdGlwbHkocSkge1xuICAgIHZhciB4MSA9IHEueDtcbiAgICB2YXIgeTEgPSBxLnk7XG4gICAgdmFyIHoxID0gcS56O1xuICAgIHZhciB3MSA9IHEudyB8fCAwO1xuICAgIHZhciB4MiA9IHRoaXMueDtcbiAgICB2YXIgeTIgPSB0aGlzLnk7XG4gICAgdmFyIHoyID0gdGhpcy56O1xuICAgIHZhciB3MiA9IHRoaXMudztcblxuICAgIHRoaXMudyA9IHcxKncyIC0geDEqeDIgLSB5MSp5MiAtIHoxKnoyO1xuICAgIHRoaXMueCA9IHgxKncyICsgeDIqdzEgKyB5Mip6MSAtIHkxKnoyO1xuICAgIHRoaXMueSA9IHkxKncyICsgeTIqdzEgKyB4MSp6MiAtIHgyKnoxO1xuICAgIHRoaXMueiA9IHoxKncyICsgejIqdzEgKyB4Mip5MSAtIHgxKnkyO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBcHBseSB0aGUgY3VycmVudCBRdWF0ZXJuaW9uIHRvIGlucHV0IFZlYzMgdiwgYWNjb3JkaW5nIHRvXG4gKiB2JyA9IH5xICogdiAqIHEuXG4gKlxuICogQG1ldGhvZCByb3RhdGVWZWN0b3JcbiAqIEBwYXJhbSB7VmVjM30gdiBUaGUgcmVmZXJlbmNlIFZlYzMuXG4gKiBAcGFyYW0ge1ZlYzN9IG91dHB1dCBWZWMzIGluIHdoaWNoIHRvIHBsYWNlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJuIHtWZWMzfSBUaGUgcm90YXRlZCB2ZXJzaW9uIG9mIHRoZSBWZWMzLlxuICovXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5yb3RhdGVWZWN0b3IgPSBmdW5jdGlvbiByb3RhdGVWZWN0b3Iodiwgb3V0cHV0KSB7XG4gICAgdmFyIGN3ID0gdGhpcy53O1xuICAgIHZhciBjeCA9IC10aGlzLng7XG4gICAgdmFyIGN5ID0gLXRoaXMueTtcbiAgICB2YXIgY3ogPSAtdGhpcy56O1xuXG4gICAgdmFyIHZ4ID0gdi54O1xuICAgIHZhciB2eSA9IHYueTtcbiAgICB2YXIgdnogPSB2Lno7XG5cbiAgICB2YXIgdHcgPSAtY3ggKiB2eCAtIGN5ICogdnkgLSBjeiAqIHZ6O1xuICAgIHZhciB0eCA9IHZ4ICogY3cgKyB2eSAqIGN6IC0gY3kgKiB2ejtcbiAgICB2YXIgdHkgPSB2eSAqIGN3ICsgY3ggKiB2eiAtIHZ4ICogY3o7XG4gICAgdmFyIHR6ID0gdnogKiBjdyArIHZ4ICogY3kgLSBjeCAqIHZ5O1xuXG4gICAgdmFyIHcgPSBjdztcbiAgICB2YXIgeCA9IC1jeDtcbiAgICB2YXIgeSA9IC1jeTtcbiAgICB2YXIgeiA9IC1jejtcblxuICAgIG91dHB1dC54ID0gdHggKiB3ICsgeCAqIHR3ICsgeSAqIHR6IC0gdHkgKiB6O1xuICAgIG91dHB1dC55ID0gdHkgKiB3ICsgeSAqIHR3ICsgdHggKiB6IC0geCAqIHR6O1xuICAgIG91dHB1dC56ID0gdHogKiB3ICsgeiAqIHR3ICsgeCAqIHR5IC0gdHggKiB5O1xuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIEludmVydCB0aGUgY3VycmVudCBRdWF0ZXJuaW9uLlxuICpcbiAqIEBtZXRob2QgaW52ZXJ0XG4gKiBAY2hhaW5hYmxlXG4gKi9cblF1YXRlcm5pb24ucHJvdG90eXBlLmludmVydCA9IGZ1bmN0aW9uIGludmVydCgpIHtcbiAgICB0aGlzLncgPSAtdGhpcy53O1xuICAgIHRoaXMueCA9IC10aGlzLng7XG4gICAgdGhpcy55ID0gLXRoaXMueTtcbiAgICB0aGlzLnogPSAtdGhpcy56O1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDb25qdWdhdGUgdGhlIGN1cnJlbnQgUXVhdGVybmlvbi5cbiAqXG4gKiBAbWV0aG9kIGNvbmp1Z2F0ZVxuICogQGNoYWluYWJsZVxuICovXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5jb25qdWdhdGUgPSBmdW5jdGlvbiBjb25qdWdhdGUoKSB7XG4gICAgdGhpcy54ID0gLXRoaXMueDtcbiAgICB0aGlzLnkgPSAtdGhpcy55O1xuICAgIHRoaXMueiA9IC10aGlzLno7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIGxlbmd0aCAobm9ybSkgb2YgdGhlIGN1cnJlbnQgUXVhdGVybmlvbi5cbiAqXG4gKiBAbWV0aG9kIGxlbmd0aFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiBsZW5ndGgoKSB7XG4gICAgdmFyIHcgPSB0aGlzLnc7XG4gICAgdmFyIHggPSB0aGlzLng7XG4gICAgdmFyIHkgPSB0aGlzLnk7XG4gICAgdmFyIHogPSB0aGlzLno7XG4gICAgcmV0dXJuIHNxcnQodyAqIHcgKyB4ICogeCArIHkgKiB5ICsgeiAqIHopO1xufTtcblxuLyoqXG4gKiBBbHRlciB0aGUgY3VycmVudCBRdWF0ZXJuaW9uIHRvIGJlIG9mIHVuaXQgbGVuZ3RoO1xuICpcbiAqIEBtZXRob2Qgbm9ybWFsaXplXG4gKiBAY2hhaW5hYmxlXG4gKi9cblF1YXRlcm5pb24ucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZSgpIHtcbiAgICB2YXIgdyA9IHRoaXMudztcbiAgICB2YXIgeCA9IHRoaXMueDtcbiAgICB2YXIgeSA9IHRoaXMueTtcbiAgICB2YXIgeiA9IHRoaXMuejtcbiAgICB2YXIgbGVuZ3RoID0gc3FydCh3ICogdyArIHggKiB4ICsgeSAqIHkgKyB6ICogeik7XG4gICAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIGxlbmd0aCA9IDEgLyBsZW5ndGg7XG4gICAgdGhpcy53ICo9IGxlbmd0aDtcbiAgICB0aGlzLnggKj0gbGVuZ3RoO1xuICAgIHRoaXMueSAqPSBsZW5ndGg7XG4gICAgdGhpcy56ICo9IGxlbmd0aDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRoZSB3LCB4LCB5LCB6IGNvbXBvbmVudHMgb2YgdGhlIGN1cnJlbnQgUXVhdGVybmlvbi5cbiAqXG4gKiBAbWV0aG9kIHNldFxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVGhlIHcgY29tcG9uZW50LlxuICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggY29tcG9uZW50LlxuICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgY29tcG9uZW50LlxuICogQHBhcmFtIHtOdW1iZXJ9IHogVGhlIHogY29tcG9uZW50LlxuICogQGNoYWluYWJsZVxuICovXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQodywgeCAseSwgeikge1xuICAgIGlmICh3ICE9IG51bGwpIHRoaXMudyA9IHc7XG4gICAgaWYgKHggIT0gbnVsbCkgdGhpcy54ID0geDtcbiAgICBpZiAoeSAhPSBudWxsKSB0aGlzLnkgPSB5O1xuICAgIGlmICh6ICE9IG51bGwpIHRoaXMueiA9IHo7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENvcHkgaW5wdXQgUXVhdGVybmlvbiBxIG9udG8gdGhlIGN1cnJlbnQgUXVhdGVybmlvbi5cbiAqXG4gKiBAbWV0aG9kIGNvcHlcbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcSBUaGUgcmVmZXJlbmNlIFF1YXRlcm5pb24uXG4gKiBAY2hhaW5hYmxlXG4gKi9cblF1YXRlcm5pb24ucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5KHEpIHtcbiAgICB0aGlzLncgPSBxLnc7XG4gICAgdGhpcy54ID0gcS54O1xuICAgIHRoaXMueSA9IHEueTtcbiAgICB0aGlzLnogPSBxLno7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlc2V0IHRoZSBjdXJyZW50IFF1YXRlcm5pb24uXG4gKlxuICogQG1ldGhvZCBjbGVhclxuICogQGNoYWluYWJsZVxuICovXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHRoaXMudyA9IDE7XG4gICAgdGhpcy54ID0gMDtcbiAgICB0aGlzLnkgPSAwO1xuICAgIHRoaXMueiA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFRoZSBkb3QgcHJvZHVjdC4gQ2FuIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBjb3NpbmUgb2YgdGhlIGFuZ2xlIGJldHdlZW5cbiAqIHRoZSB0d28gcm90YXRpb25zLCBhc3N1bWluZyBib3RoIFF1YXRlcm5pb25zIGFyZSBvZiB1bml0IGxlbmd0aC5cbiAqXG4gKiBAbWV0aG9kIGRvdFxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxIFRoZSBvdGhlciBRdWF0ZXJuaW9uLlxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5kb3QgPSBmdW5jdGlvbiBkb3QocSkge1xuICAgIHJldHVybiB0aGlzLncgKiBxLncgKyB0aGlzLnggKiBxLnggKyB0aGlzLnkgKiBxLnkgKyB0aGlzLnogKiBxLno7XG59O1xuXG4vKipcbiAqIFNwaGVyaWNhbCBsaW5lYXIgaW50ZXJwb2xhdGlvbi5cbiAqXG4gKiBAbWV0aG9kIHNsZXJwXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHEgVGhlIGZpbmFsIG9yaWVudGF0aW9uLlxuICogQHBhcmFtIHtOdW1iZXJ9IHQgVGhlIHR3ZWVuIHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7VmVjM30gb3V0cHV0IFZlYzMgaW4gd2hpY2ggdG8gcHV0IHRoZSByZXN1bHQuXG4gKiBAcmV0dXJuIHtRdWF0ZXJuaW9ufVxuICovXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5zbGVycCA9IGZ1bmN0aW9uIHNsZXJwKHEsIHQsIG91dHB1dCkge1xuICAgIHZhciB3ID0gdGhpcy53O1xuICAgIHZhciB4ID0gdGhpcy54O1xuICAgIHZhciB5ID0gdGhpcy55O1xuICAgIHZhciB6ID0gdGhpcy56O1xuXG4gICAgdmFyIHF3ID0gcS53O1xuICAgIHZhciBxeCA9IHEueDtcbiAgICB2YXIgcXkgPSBxLnk7XG4gICAgdmFyIHF6ID0gcS56O1xuXG4gICAgdmFyIG9tZWdhO1xuICAgIHZhciBjb3NvbWVnYTtcbiAgICB2YXIgc2lub21lZ2E7XG4gICAgdmFyIHNjYWxlRnJvbTtcbiAgICB2YXIgc2NhbGVUbztcblxuICAgIGNvc29tZWdhID0gdyAqIHF3ICsgeCAqIHF4ICsgeSAqIHF5ICsgeiAqIHF6O1xuICAgIGlmICgoMS4wIC0gY29zb21lZ2EpID4gMWUtNSkge1xuICAgICAgICBvbWVnYSA9IGFjb3MoY29zb21lZ2EpO1xuICAgICAgICBzaW5vbWVnYSA9IHNpbihvbWVnYSk7XG4gICAgICAgIHNjYWxlRnJvbSA9IHNpbigoMS4wIC0gdCkgKiBvbWVnYSkgLyBzaW5vbWVnYTtcbiAgICAgICAgc2NhbGVUbyA9IHNpbih0ICogb21lZ2EpIC8gc2lub21lZ2E7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzY2FsZUZyb20gPSAxLjAgLSB0O1xuICAgICAgICBzY2FsZVRvID0gdDtcbiAgICB9XG5cbiAgICBvdXRwdXQudyA9IHcgKiBzY2FsZUZyb20gKyBxdyAqIHNjYWxlVG87XG4gICAgb3V0cHV0LnggPSB4ICogc2NhbGVGcm9tICsgcXggKiBzY2FsZVRvO1xuICAgIG91dHB1dC55ID0geSAqIHNjYWxlRnJvbSArIHF5ICogc2NhbGVUbztcbiAgICBvdXRwdXQueiA9IHogKiBzY2FsZUZyb20gKyBxeiAqIHNjYWxlVG87XG5cbiAgICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIE1hdDMzIG1hdHJpeCBjb3JyZXNwb25kaW5nIHRvIHRoZSBjdXJyZW50IFF1YXRlcm5pb24uXG4gKlxuICogQG1ldGhvZCB0b01hdHJpeFxuICogQHJldHVybiB7VHJhbnNmb3JtfVxuICovXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS50b01hdHJpeCA9IGZ1bmN0aW9uIHRvTWF0cml4KG91dHB1dCkge1xuICAgIHZhciB3ID0gdGhpcy53O1xuICAgIHZhciB4ID0gdGhpcy54O1xuICAgIHZhciB5ID0gdGhpcy55O1xuICAgIHZhciB6ID0gdGhpcy56O1xuXG4gICAgdmFyIHh4ID0geCp4O1xuICAgIHZhciB5eSA9IHkqeTtcbiAgICB2YXIgenogPSB6Kno7XG4gICAgdmFyIHh5ID0geCp5O1xuICAgIHZhciB4eiA9IHgqejtcbiAgICB2YXIgeXogPSB5Kno7XG5cbiAgICByZXR1cm4gb3V0cHV0LnNldChbXG4gICAgICAgIDEgLSAyICogKHl5ICsgenopLCAyICogKHh5IC0gdyp6KSwgMiAqICh4eiArIHcqeSksXG4gICAgICAgIDIgKiAoeHkgKyB3KnopLCAxIC0gMiAqICh4eCArIHp6KSwgMiAqICh5eiAtIHcqeCksXG4gICAgICAgIDIgKiAoeHogLSB3KnkpLCAyICogKHl6ICsgdyp4KSwgMSAtIDIgKiAoeHggKyB5eSlcbiAgICBdKTtcbn07XG5cbi8qKlxuICogVGhlIHJvdGF0aW9uIGFuZ2xlcyBhYm91dCB0aGUgeCwgeSwgYW5kIHogYXhlcyBjb3JyZXNwb25kaW5nIHRvIHRoZVxuICogY3VycmVudCBRdWF0ZXJuaW9uLCB3aGVuIGFwcGxpZWQgaW4gdGhlIFpZWCBvcmRlci5cbiAqXG4gKiBAbWV0aG9kIHRvRXVsZXJcbiAqIEBwYXJhbSB7VmVjM30gb3V0cHV0IFZlYzMgaW4gd2hpY2ggdG8gcHV0IHRoZSByZXN1bHQuXG4gKiBAcmV0dXJuIHtWZWMzfVxuICovXG5cblF1YXRlcm5pb24ucHJvdG90eXBlLnRvRXVsZXIgPSBmdW5jdGlvbiB0b0V1bGVyKG91dHB1dCkge1xuICAgIHZhciB3ID0gdGhpcy53O1xuICAgIHZhciB4ID0gdGhpcy54O1xuICAgIHZhciB5ID0gdGhpcy55O1xuICAgIHZhciB6ID0gdGhpcy56O1xuXG4gICAgdmFyIHh4ID0geCAqIHg7XG4gICAgdmFyIHl5ID0geSAqIHk7XG4gICAgdmFyIHp6ID0geiAqIHo7XG4gICAgdmFyIHd3ID0gdyAqIHc7XG5cbiAgICB2YXIgdHkgPSAyICogKHggKiB6ICsgeSAqIHcpO1xuICAgIHR5ID0gdHkgPCAtMSA/IC0xIDogdHkgPiAxID8gMSA6IHR5O1xuXG4gICAgb3V0cHV0LnggPSBhdGFuMigyICogKHggKiB3IC0geSAqIHopLCAxIC0gMiAqICh4eCArIHl5KSk7XG4gICAgb3V0cHV0LnkgPSBhc2luKHR5KTtcbiAgICBvdXRwdXQueiA9IGF0YW4yKDIgKiAoeiAqIHcgLSB4ICogeSksIDEgLSAyICogKHl5ICsgenopKTtcblxuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIFRoZSBRdWF0ZXJuaW9uIGNvcnJlc3BvbmRpbmcgdG8gdGhlIEV1bGVyIGFuZ2xlcyB4LCB5LCBhbmQgeixcbiAqIGFwcGxpZWQgaW4gdGhlIFpZWCBvcmRlci5cbiAqXG4gKiBAbWV0aG9kIGZyb21FdWxlclxuICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIGFuZ2xlIG9mIHJvdGF0aW9uIGFib3V0IHRoZSB4IGF4aXMuXG4gKiBAcGFyYW0ge051bWJlcn0geSBUaGUgYW5nbGUgb2Ygcm90YXRpb24gYWJvdXQgdGhlIHkgYXhpcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFRoZSBhbmdsZSBvZiByb3RhdGlvbiBhYm91dCB0aGUgeiBheGlzLlxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBvdXRwdXQgUXVhdGVybmlvbiBpbiB3aGljaCB0byBwdXQgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm4ge1F1YXRlcm5pb259IFRoZSBlcXVpdmFsZW50IFF1YXRlcm5pb24uXG4gKi9cblF1YXRlcm5pb24ucHJvdG90eXBlLmZyb21FdWxlciA9IGZ1bmN0aW9uIGZyb21FdWxlcih4LCB5LCB6KSB7XG4gICAgdmFyIGh4ID0geCAqIDAuNTtcbiAgICB2YXIgaHkgPSB5ICogMC41O1xuICAgIHZhciBoeiA9IHogKiAwLjU7XG5cbiAgICB2YXIgc3ggPSBzaW4oaHgpO1xuICAgIHZhciBzeSA9IHNpbihoeSk7XG4gICAgdmFyIHN6ID0gc2luKGh6KTtcbiAgICB2YXIgY3ggPSBjb3MoaHgpO1xuICAgIHZhciBjeSA9IGNvcyhoeSk7XG4gICAgdmFyIGN6ID0gY29zKGh6KTtcblxuICAgIHRoaXMudyA9IGN4ICogY3kgKiBjeiAtIHN4ICogc3kgKiBzejtcbiAgICB0aGlzLnggPSBzeCAqIGN5ICogY3ogKyBjeCAqIHN5ICogc3o7XG4gICAgdGhpcy55ID0gY3ggKiBzeSAqIGN6IC0gc3ggKiBjeSAqIHN6O1xuICAgIHRoaXMueiA9IGN4ICogY3kgKiBzeiArIHN4ICogc3kgKiBjejtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBbHRlciB0aGUgY3VycmVudCBRdWF0ZXJuaW9uIHRvIHJlZmxlY3QgYSByb3RhdGlvbiBvZiBpbnB1dCBhbmdsZSBhYm91dFxuICogaW5wdXQgYXhpcyB2LlxuICpcbiAqIEBtZXRob2QgbWFrZUZyb21BbmdsZUFuZEF4aXNcbiAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZSBUaGUgYW5nbGUgb2Ygcm90YXRpb24uXG4gKiBAcGFyYW0ge1ZlYzN9IHYgVGhlIGF4aXMgb2Ygcm90YXRpb24uXG4gKiBAY2hhaW5hYmxlXG4gKi9cblF1YXRlcm5pb24ucHJvdG90eXBlLmZyb21BbmdsZUF4aXMgPSBmdW5jdGlvbiBmcm9tQW5nbGVBeGlzKGFuZ2xlLCB4LCB5LCB6KSB7XG4gICAgdmFyIGxlbiA9IHNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KTtcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgIHRoaXMudyA9IDE7XG4gICAgICAgIHRoaXMueCA9IHRoaXMueSA9IHRoaXMueiA9IDA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZW4gPSAxIC8gbGVuO1xuICAgICAgICB2YXIgaGFsZlRoZXRhID0gYW5nbGUgKiAwLjU7XG4gICAgICAgIHZhciBzID0gc2luKGhhbGZUaGV0YSk7XG4gICAgICAgIHRoaXMudyA9IGNvcyhoYWxmVGhldGEpO1xuICAgICAgICB0aGlzLnggPSBzICogeCAqIGxlbjtcbiAgICAgICAgdGhpcy55ID0gcyAqIHkgKiBsZW47XG4gICAgICAgIHRoaXMueiA9IHMgKiB6ICogbGVuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTXVsdGlwbHkgdGhlIGlucHV0IFF1YXRlcm5pb25zLlxuICogTGVmdC1oYW5kZWQgY29vcmRpbmF0ZSBzeXN0ZW0gbXVsdGlwbGljYXRpb24uXG4gKlxuICogQG1ldGhvZCBtdWx0aXBseVxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxMSBUaGUgbGVmdCBRdWF0ZXJuaW9uLlxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxMiBUaGUgcmlnaHQgUXVhdGVybmlvbi5cbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gb3V0cHV0IFF1YXRlcm5pb24gaW4gd2hpY2ggdG8gcGxhY2UgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm4ge1F1YXRlcm5pb259IFRoZSBwcm9kdWN0IG9mIG11bHRpcGxpY2F0aW9uLlxuICovXG5RdWF0ZXJuaW9uLm11bHRpcGx5ID0gZnVuY3Rpb24gbXVsdGlwbHkocTEsIHEyLCBvdXRwdXQpIHtcbiAgICB2YXIgdzEgPSBxMS53IHx8IDA7XG4gICAgdmFyIHgxID0gcTEueDtcbiAgICB2YXIgeTEgPSBxMS55O1xuICAgIHZhciB6MSA9IHExLno7XG5cbiAgICB2YXIgdzIgPSBxMi53IHx8IDA7XG4gICAgdmFyIHgyID0gcTIueDtcbiAgICB2YXIgeTIgPSBxMi55O1xuICAgIHZhciB6MiA9IHEyLno7XG5cbiAgICBvdXRwdXQudyA9IHcxICogdzIgLSB4MSAqIHgyIC0geTEgKiB5MiAtIHoxICogejI7XG4gICAgb3V0cHV0LnggPSB4MSAqIHcyICsgeDIgKiB3MSArIHkyICogejEgLSB5MSAqIHoyO1xuICAgIG91dHB1dC55ID0geTEgKiB3MiArIHkyICogdzEgKyB4MSAqIHoyIC0geDIgKiB6MTtcbiAgICBvdXRwdXQueiA9IHoxICogdzIgKyB6MiAqIHcxICsgeDIgKiB5MSAtIHgxICogeTI7XG4gICAgcmV0dXJuIG91dHB1dDtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIHRoZSBpbnB1dCBxdWF0ZXJuaW9uLlxuICpcbiAqIEBtZXRob2Qgbm9ybWFsaXplXG4gKiBAcmV0dXJuIHtRdWF0ZXJuaW9ufSBUaGUgbm9ybWFsaXplZCBxdWF0ZXJuaW9uLlxuICovXG5RdWF0ZXJuaW9uLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZShxLCBvdXRwdXQpIHtcbiAgICB2YXIgdyA9IHEudztcbiAgICB2YXIgeCA9IHEueDtcbiAgICB2YXIgeSA9IHEueTtcbiAgICB2YXIgeiA9IHEuejtcbiAgICB2YXIgbGVuZ3RoID0gc3FydCh3ICogdyArIHggKiB4ICsgeSAqIHkgKyB6ICogeik7XG4gICAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIGxlbmd0aCA9IDEgLyBsZW5ndGg7XG4gICAgb3V0cHV0LncgKj0gbGVuZ3RoO1xuICAgIG91dHB1dC54ICo9IGxlbmd0aDtcbiAgICBvdXRwdXQueSAqPSBsZW5ndGg7XG4gICAgb3V0cHV0LnogKj0gbGVuZ3RoO1xuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIFRoZSBjb25qdWdhdGUgb2YgdGhlIGlucHV0IFF1YXRlcm5pb24uXG4gKlxuICogQG1ldGhvZCBjb25qdWdhdGVcbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcSBUaGUgcmVmZXJlbmNlIFF1YXRlcm5pb24uXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IG91dHB1dCBRdWF0ZXJuaW9uIGluIHdoaWNoIHRvIHBsYWNlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJuIHtRdWF0ZXJuaW9ufSBUaGUgY29uanVnYXRlIFF1YXRlcm5pb24uXG4gKi9cblF1YXRlcm5pb24uY29uanVnYXRlID0gZnVuY3Rpb24gY29uanVnYXRlKHEsIG91dHB1dCkge1xuICAgIG91dHB1dC53ID0gcS53O1xuICAgIG91dHB1dC54ID0gLXEueDtcbiAgICBvdXRwdXQueSA9IC1xLnk7XG4gICAgb3V0cHV0LnogPSAtcS56O1xuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIENsb25lIHRoZSBpbnB1dCBRdWF0ZXJuaW9uLlxuICpcbiAqIEBtZXRob2QgY2xvbmVcbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcSB0aGUgcmVmZXJlbmNlIFF1YXRlcm5pb24uXG4gKiBAcmV0dXJuIHtRdWF0ZXJuaW9ufSBUaGUgY2xvbmVkIFF1YXRlcm5pb24uXG4gKi9cblF1YXRlcm5pb24uY2xvbmUgPSBmdW5jdGlvbiBjbG9uZShxKSB7XG4gICAgcmV0dXJuIG5ldyBRdWF0ZXJuaW9uKHEudywgcS54LCBxLnksIHEueik7XG59O1xuXG4vKipcbiAqIFRoZSBkb3QgcHJvZHVjdCBvZiB0aGUgdHdvIGlucHV0IFF1YXRlcm5pb25zLlxuICpcbiAqIEBtZXRob2QgZG90UHJvZHVjdFxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxMSBUaGUgbGVmdCBRdWF0ZXJuaW9uLlxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxMiBUaGUgcmlnaHQgUXVhdGVybmlvbi5cbiAqIEByZXR1cm4ge051bWJlcn0gVGhlIGRvdCBwcm9kdWN0IG9mIHRoZSB0d28gUXVhdGVybmlvbnMuXG4gKi9cblF1YXRlcm5pb24uZG90ID0gZnVuY3Rpb24gZG90KHExLCBxMikge1xuICAgIHJldHVybiBxMS53ICogcTIudyArIHExLnggKiBxMi54ICsgcTEueSAqIHEyLnkgKyBxMS56ICogcTIuejtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUXVhdGVybmlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHNpbiA9IE1hdGguc2luO1xudmFyIGNvcyA9IE1hdGguY29zO1xudmFyIHNxcnQgPSBNYXRoLnNxcnQ7XG5cbi8qKlxuICogQSB0d28tZGltZW5zaW9uYWwgdmVjdG9yLlxuICpcbiAqIEBjbGFzcyBWZWMyXG4gKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBjb21wb25lbnQuXG4gKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBjb21wb25lbnQuXG4gKi9cbnZhciBWZWMyID0gZnVuY3Rpb24oeCwgeSl7XG4gICAgaWYgKHggaW5zdGFuY2VvZiBBcnJheSB8fCB4IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSB7XG4gICAgICAgIHRoaXMueCA9IHhbMF0gfHwgMDtcbiAgICAgICAgdGhpcy55ID0geFsxXSB8fCAwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy54ID0geCB8fCAwO1xuICAgICAgICB0aGlzLnkgPSB5IHx8IDA7XG4gICAgfVxufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgdGhlIGN1cnJlbnQgVmVjMi5cbiAqXG4gKiBAbWV0aG9kIHNldFxuICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggY29tcG9uZW50LlxuICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgY29tcG9uZW50LlxuICogQGNoYWluYWJsZVxuICovXG5WZWMyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQoeCwgeSkge1xuICAgIGlmICh4ICE9IG51bGwpIHRoaXMueCA9IHg7XG4gICAgaWYgKHkgIT0gbnVsbCkgdGhpcy55ID0geTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkIHRoZSBpbnB1dCB2IHRvIHRoZSBjdXJyZW50IFZlYzIuXG4gKlxuICogQG1ldGhvZCBhZGRcbiAqIEBwYXJhbSB7VmVjMn0gdiBUaGUgVmVjMiB0byBhZGQuXG4gKiBAY2hhaW5hYmxlXG4gKi9cblZlYzIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCh2KSB7XG4gICAgdGhpcy54ICs9IHYueDtcbiAgICB0aGlzLnkgKz0gdi55O1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdCB0aGUgaW5wdXQgdiBmcm9tIHRoZSBjdXJyZW50IFZlYzIuXG4gKlxuICogQG1ldGhvZCBzdWJ0cmFjdFxuICogQHBhcmFtIHtWZWMyfSB2IFRoZSBWZWMyIHRvIHN1YnRyYWN0LlxuICogQGNoYWluYWJsZVxuICovXG5WZWMyLnByb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uIHN1YnRyYWN0KHYpIHtcbiAgICB0aGlzLnggLT0gdi54O1xuICAgIHRoaXMueSAtPSB2Lnk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNjYWxlIHRoZSBjdXJyZW50IFZlYzIgYnkgYSBzY2FsYXIgb3IgVmVjMi5cbiAqXG4gKiBAbWV0aG9kIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcnxWZWMyfSBzIFRoZSBOdW1iZXIgb3IgdmVjMiBieSB3aGljaCB0byBzY2FsZS5cbiAqIEBjaGFpbmFibGVcbiAqL1xuVmVjMi5wcm90b3R5cGUuc2NhbGUgPSBmdW5jdGlvbiBzY2FsZShzKSB7XG4gICAgaWYgKHMgaW5zdGFuY2VvZiBWZWMyKSB7XG4gICAgICAgIHRoaXMueCAqPSBzLng7XG4gICAgICAgIHRoaXMueSAqPSBzLnk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy54ICo9IHM7XG4gICAgICAgIHRoaXMueSAqPSBzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUm90YXRlIHRoZSBWZWMyIGNvdW50ZXItY2xvY2t3aXNlIGJ5IHRoZXRhIGFib3V0IHRoZSB6LWF4aXMuXG4gKlxuICogQG1ldGhvZCByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aGV0YSBBbmdsZSBieSB3aGljaCB0byByb3RhdGUuXG4gKiBAY2hhaW5hYmxlXG4gKi9cblZlYzIucHJvdG90eXBlLnJvdGF0ZSA9IGZ1bmN0aW9uKHRoZXRhKSB7XG4gICAgdmFyIHggPSB0aGlzLng7XG4gICAgdmFyIHkgPSB0aGlzLnk7XG5cbiAgICB2YXIgY29zVGhldGEgPSBjb3ModGhldGEpO1xuICAgIHZhciBzaW5UaGV0YSA9IHNpbih0aGV0YSk7XG5cbiAgICB0aGlzLnggPSB4ICogY29zVGhldGEgLSB5ICogc2luVGhldGE7XG4gICAgdGhpcy55ID0geCAqIHNpblRoZXRhICsgeSAqIGNvc1RoZXRhO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFRoZSBkb3QgcHJvZHVjdCBvZiBvZiB0aGUgY3VycmVudCBWZWMyIHdpdGggdGhlIGlucHV0IFZlYzIuXG4gKlxuICogQG1ldGhvZCBkb3RcbiAqIEBwYXJhbSB7TnVtYmVyfSB2IFRoZSBvdGhlciBWZWMyLlxuICogQGNoYWluYWJsZVxuICovXG5WZWMyLnByb3RvdHlwZS5kb3QgPSBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueTtcbn07XG5cbi8qKlxuICogVGhlIGNyb3NzIHByb2R1Y3Qgb2Ygb2YgdGhlIGN1cnJlbnQgVmVjMiB3aXRoIHRoZSBpbnB1dCBWZWMyLlxuICpcbiAqIEBtZXRob2QgY3Jvc3NcbiAqIEBwYXJhbSB7TnVtYmVyfSB2IFRoZSBvdGhlciBWZWMyLlxuICogQGNoYWluYWJsZVxuICovXG5WZWMyLnByb3RvdHlwZS5jcm9zcyA9IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gdGhpcy54ICogdi55IC0gdGhpcy55ICogdi54O1xufTtcblxuLyoqXG4gKiBQcmVzZXJ2ZSB0aGUgbWFnbml0dWRlIGJ1dCBpbnZlcnQgdGhlIG9yaWVudGF0aW9uIG9mIHRoZSBjdXJyZW50IFZlYzIuXG4gKlxuICogQG1ldGhvZCBpbnZlcnRcbiAqIEBjaGFpbmFibGVcbiAqL1xuVmVjMi5wcm90b3R5cGUuaW52ZXJ0ID0gZnVuY3Rpb24gaW52ZXJ0KCkge1xuICAgIHRoaXMueCAqPSAtMTtcbiAgICB0aGlzLnkgKj0gLTE7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFwcGx5IGEgZnVuY3Rpb24gY29tcG9uZW50LXdpc2UgdG8gdGhlIGN1cnJlbnQgVmVjMi5cbiAqXG4gKiBAbWV0aG9kIG1hcFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gYXBwbHkuXG4gKiBAY2hhaW5hYmxlXG4gKi9cblZlYzIucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIG1hcChmbikge1xuICAgIHRoaXMueCA9IGZuKHRoaXMueCk7XG4gICAgdGhpcy55ID0gZm4odGhpcy55KTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVGhlIG1hZ25pdHVkZSBvZiB0aGUgY3VycmVudCBWZWMyLlxuICpcbiAqIEBtZXRob2QgbGVuZ3RoXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cblZlYzIucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uIGxlbmd0aCgpIHtcbiAgICB2YXIgeCA9IHRoaXMueDtcbiAgICB2YXIgeSA9IHRoaXMueTtcblxuICAgIHJldHVybiBzcXJ0KHggKiB4ICsgeSAqIHkpO1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSBpbnB1dCBvbnRvIHRoZSBjdXJyZW50IFZlYzIuXG4gKlxuICogQG1ldGhvZCBjb3B5XG4gKiBAcGFyYW0ge1ZlYzJ9IHYgVmVjMiB0byBjb3B5LlxuICogQGNoYWluYWJsZVxuICovXG5WZWMyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSh2KSB7XG4gICAgdGhpcy54ID0gdi54O1xuICAgIHRoaXMueSA9IHYueTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVzZXQgdGhlIGN1cnJlbnQgVmVjMi5cbiAqXG4gKiBAbWV0aG9kIGNsZWFyXG4gKiBAY2hhaW5hYmxlXG4gKi9cblZlYzIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgdGhpcy54ID0gMDtcbiAgICB0aGlzLnkgPSAwO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBtYWduaXR1ZGUgb2YgdGhlIGN1cnJlbnQgVmVjMiBpcyBleGFjdGx5IDAuXG4gKlxuICogQG1ldGhvZCBpc1plcm9cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblZlYzIucHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uIGlzWmVybygpIHtcbiAgICBpZiAodGhpcy54ICE9PSAwIHx8IHRoaXMueSAhPT0gMCkgcmV0dXJuIGZhbHNlO1xuICAgIGVsc2UgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIFRoZSBhcnJheSBmb3JtIG9mIHRoZSBjdXJyZW50IFZlYzIuXG4gKlxuICogQG1ldGhvZCB0b0FycmF5XG4gKiBAcmV0dXJuIHtOdW1iZXJbXX1cbiAqL1xuVmVjMi5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIFt0aGlzLngsIHRoaXMueV07XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSB0aGUgaW5wdXQgVmVjMi5cbiAqXG4gKiBAbWV0aG9kIG5vcm1hbGl6ZVxuICogQHBhcmFtIHtWZWMyfSB2IFRoZSByZWZlcmVuY2UgVmVjMi5cbiAqIEBwYXJhbSB7VmVjMn0gb3V0cHV0IFZlYzIgaW4gd2hpY2ggdG8gcGxhY2UgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm4ge1ZlYzJ9IFRoZSBub3JtYWxpemUgVmVjMi5cbiAqL1xuVmVjMi5ub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUodiwgb3V0cHV0KSB7XG4gICAgdmFyIHggPSB2Lng7XG4gICAgdmFyIHkgPSB2Lnk7XG5cbiAgICB2YXIgbGVuZ3RoID0gc3FydCh4ICogeCArIHkgKiB5KSB8fCAxO1xuICAgIGxlbmd0aCA9IDEgLyBsZW5ndGg7XG4gICAgb3V0cHV0LnggPSB2LnggKiBsZW5ndGg7XG4gICAgb3V0cHV0LnkgPSB2LnkgKiBsZW5ndGg7XG5cbiAgICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqXG4gKiBDbG9uZSB0aGUgaW5wdXQgVmVjMi5cbiAqXG4gKiBAbWV0aG9kIGNsb25lXG4gKiBAcGFyYW0ge1ZlYzJ9IHYgVGhlIFZlYzIgdG8gY2xvbmUuXG4gKiBAcmV0dXJuIHtWZWMyfSBUaGUgY2xvbmVkIFZlYzIuXG4gKi9cblZlYzIuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSh2KSB7XG4gICAgcmV0dXJuIG5ldyBWZWMyKHYueCwgdi55KTtcbn07XG5cbi8qKlxuICogQWRkIHRoZSBpbnB1dCBWZWMyJ3MuXG4gKlxuICogQG1ldGhvZCBhZGRcbiAqIEBwYXJhbSB7VmVjMn0gdjEgVGhlIGxlZnQgVmVjMi5cbiAqIEBwYXJhbSB7VmVjMn0gdjIgVGhlIHJpZ2h0IFZlYzIuXG4gKiBAcGFyYW0ge1ZlYzJ9IG91dHB1dCBWZWMyIGluIHdoaWNoIHRvIHBsYWNlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJuIHtWZWMyfSBUaGUgcmVzdWx0IG9mIHRoZSBhZGRpdGlvbi5cbiAqL1xuVmVjMi5hZGQgPSBmdW5jdGlvbiBhZGQodjEsIHYyLCBvdXRwdXQpIHtcbiAgICBvdXRwdXQueCA9IHYxLnggKyB2Mi54O1xuICAgIG91dHB1dC55ID0gdjEueSArIHYyLnk7XG5cbiAgICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdCB0aGUgc2Vjb25kIFZlYzIgZnJvbSB0aGUgZmlyc3QuXG4gKlxuICogQG1ldGhvZCBzdWJ0cmFjdFxuICogQHBhcmFtIHtWZWMyfSB2MSBUaGUgbGVmdCBWZWMyLlxuICogQHBhcmFtIHtWZWMyfSB2MiBUaGUgcmlnaHQgVmVjMi5cbiAqIEBwYXJhbSB7VmVjMn0gb3V0cHV0IFZlYzIgaW4gd2hpY2ggdG8gcGxhY2UgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm4ge1ZlYzJ9IFRoZSByZXN1bHQgb2YgdGhlIHN1YnRyYWN0aW9uLlxuICovXG5WZWMyLnN1YnRyYWN0ID0gZnVuY3Rpb24gc3VidHJhY3QodjEsIHYyLCBvdXRwdXQpIHtcbiAgICBvdXRwdXQueCA9IHYxLnggLSB2Mi54O1xuICAgIG91dHB1dC55ID0gdjEueSAtIHYyLnk7XG4gICAgcmV0dXJuIG91dHB1dDtcbn07XG5cbi8qKlxuICogU2NhbGUgdGhlIGlucHV0IFZlYzIuXG4gKlxuICogQG1ldGhvZCBzY2FsZVxuICogQHBhcmFtIHtWZWMyfSB2IFRoZSByZWZlcmVuY2UgVmVjMi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBzIE51bWJlciB0byBzY2FsZSBieS5cbiAqIEBwYXJhbSB7VmVjMn0gb3V0cHV0IFZlYzIgaW4gd2hpY2ggdG8gcGxhY2UgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm4ge1ZlYzJ9IFRoZSByZXN1bHQgb2YgdGhlIHNjYWxpbmcuXG4gKi9cblZlYzIuc2NhbGUgPSBmdW5jdGlvbiBzY2FsZSh2LCBzLCBvdXRwdXQpIHtcbiAgICBvdXRwdXQueCA9IHYueCAqIHM7XG4gICAgb3V0cHV0LnkgPSB2LnkgKiBzO1xuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIFRoZSBkb3QgcHJvZHVjdCBvZiB0aGUgaW5wdXQgVmVjMidzLlxuICpcbiAqIEBtZXRob2QgZG90XG4gKiBAcGFyYW0ge1ZlYzJ9IHYxIFRoZSBsZWZ0IFZlYzIuXG4gKiBAcGFyYW0ge1ZlYzJ9IHYyIFRoZSByaWdodCBWZWMyLlxuICogQHJldHVybiB7TnVtYmVyfSBUaGUgZG90IHByb2R1Y3QuXG4gKi9cblZlYzIuZG90ID0gZnVuY3Rpb24gZG90KHYxLCB2Mikge1xuICAgIHJldHVybiB2MS54ICogdjIueCArIHYxLnkgKiB2Mi55O1xufTtcblxuLyoqXG4gKiBUaGUgY3Jvc3MgcHJvZHVjdCBvZiB0aGUgaW5wdXQgVmVjMidzLlxuICpcbiAqIEBtZXRob2QgY3Jvc3NcbiAqIEBwYXJhbSB7TnVtYmVyfSB2IFRoZSBsZWZ0IFZlYzIuXG4gKiBAcGFyYW0ge051bWJlcn0gdiBUaGUgcmlnaHQgVmVjMi5cbiAqIEByZXR1cm4ge051bWJlcn0gVGhlIHotY29tcG9uZW50IG9mIHRoZSBjcm9zcyBwcm9kdWN0LlxuICovXG5WZWMyLmNyb3NzID0gZnVuY3Rpb24odjEsdjIpIHtcbiAgICByZXR1cm4gdjEueCAqIHYyLnkgLSB2MS55ICogdjIueDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVmVjMjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHNpbiA9IE1hdGguc2luO1xudmFyIGNvcyA9IE1hdGguY29zO1xudmFyIHNxcnQgPSBNYXRoLnNxcnQ7XG5cbi8qKlxuICogQSB0aHJlZS1kaW1lbnNpb25hbCB2ZWN0b3IuXG4gKlxuICogQGNsYXNzIFZlYzNcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFRoZSB6IGNvbXBvbmVudC5cbiAqL1xudmFyIFZlYzMgPSBmdW5jdGlvbih4ICx5LCB6KXtcbiAgICB0aGlzLnggPSB4IHx8IDA7XG4gICAgdGhpcy55ID0geSB8fCAwO1xuICAgIHRoaXMueiA9IHogfHwgMDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIHRoZSBjdXJyZW50IFZlYzMuXG4gKlxuICogQG1ldGhvZCBzZXRcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFRoZSB6IGNvbXBvbmVudC5cbiAqIEBjaGFpbmFibGVcbiAqL1xuVmVjMy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0KHgsIHksIHopIHtcbiAgICBpZiAoeCAhPSBudWxsKSB0aGlzLnggPSB4O1xuICAgIGlmICh5ICE9IG51bGwpIHRoaXMueSA9IHk7XG4gICAgaWYgKHogIT0gbnVsbCkgdGhpcy56ID0gejtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGQgdGhlIGlucHV0IHYgdG8gdGhlIGN1cnJlbnQgVmVjMy5cbiAqXG4gKiBAbWV0aG9kIGFkZFxuICogQHBhcmFtIHtWZWMzfSB2IFRoZSBWZWMzIHRvIGFkZC5cbiAqIEBjaGFpbmFibGVcbiAqL1xuVmVjMy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKHYpIHtcbiAgICB0aGlzLnggKz0gdi54O1xuICAgIHRoaXMueSArPSB2Lnk7XG4gICAgdGhpcy56ICs9IHYuejtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdCB0aGUgaW5wdXQgdiBmcm9tIHRoZSBjdXJyZW50IFZlYzMuXG4gKlxuICogQG1ldGhvZCBzdWJ0cmFjdFxuICogQHBhcmFtIHtWZWMzfSB2IFRoZSBWZWMzIHRvIHN1YnRyYWN0LlxuICogQGNoYWluYWJsZVxuICovXG5WZWMzLnByb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uIHN1YnRyYWN0KHYpIHtcbiAgICB0aGlzLnggLT0gdi54O1xuICAgIHRoaXMueSAtPSB2Lnk7XG4gICAgdGhpcy56IC09IHYuejtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSb3RhdGUgdGhlIGN1cnJlbnQgVmVjMyBieSB0aGV0YSBjbG9ja3dpc2UgYWJvdXQgdGhlIHggYXhpcy5cbiAqXG4gKiBAbWV0aG9kIHJvdGF0ZVhcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aGV0YSBBbmdsZSBieSB3aGljaCB0byByb3RhdGUuXG4gKiBAY2hhaW5hYmxlXG4gKi9cblZlYzMucHJvdG90eXBlLnJvdGF0ZVggPSBmdW5jdGlvbiByb3RhdGVYKHRoZXRhKSB7XG4gICAgdmFyIHggPSB0aGlzLng7XG4gICAgdmFyIHkgPSB0aGlzLnk7XG4gICAgdmFyIHogPSB0aGlzLno7XG5cbiAgICB2YXIgY29zVGhldGEgPSBjb3ModGhldGEpO1xuICAgIHZhciBzaW5UaGV0YSA9IHNpbih0aGV0YSk7XG5cbiAgICB0aGlzLnkgPSB5ICogY29zVGhldGEgLSB6ICogc2luVGhldGE7XG4gICAgdGhpcy56ID0geSAqIHNpblRoZXRhICsgeiAqIGNvc1RoZXRhO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJvdGF0ZSB0aGUgY3VycmVudCBWZWMzIGJ5IHRoZXRhIGNsb2Nrd2lzZSBhYm91dCB0aGUgeSBheGlzLlxuICpcbiAqIEBtZXRob2Qgcm90YXRlWVxuICogQHBhcmFtIHtOdW1iZXJ9IHRoZXRhIEFuZ2xlIGJ5IHdoaWNoIHRvIHJvdGF0ZS5cbiAqIEBjaGFpbmFibGVcbiAqL1xuVmVjMy5wcm90b3R5cGUucm90YXRlWSA9IGZ1bmN0aW9uIHJvdGF0ZVkodGhldGEpIHtcbiAgICB2YXIgeCA9IHRoaXMueDtcbiAgICB2YXIgeSA9IHRoaXMueTtcbiAgICB2YXIgeiA9IHRoaXMuejtcblxuICAgIHZhciBjb3NUaGV0YSA9IGNvcyh0aGV0YSk7XG4gICAgdmFyIHNpblRoZXRhID0gc2luKHRoZXRhKTtcblxuICAgIHRoaXMueCA9IHogKiBzaW5UaGV0YSArIHggKiBjb3NUaGV0YTtcbiAgICB0aGlzLnogPSB6ICogY29zVGhldGEgLSB4ICogc2luVGhldGE7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUm90YXRlIHRoZSBjdXJyZW50IFZlYzMgYnkgdGhldGEgY2xvY2t3aXNlIGFib3V0IHRoZSB6IGF4aXMuXG4gKlxuICogQG1ldGhvZCByb3RhdGVaXG4gKiBAcGFyYW0ge051bWJlcn0gdGhldGEgQW5nbGUgYnkgd2hpY2ggdG8gcm90YXRlLlxuICogQGNoYWluYWJsZVxuICovXG5WZWMzLnByb3RvdHlwZS5yb3RhdGVaID0gZnVuY3Rpb24gcm90YXRlWih0aGV0YSkge1xuICAgIHZhciB4ID0gdGhpcy54O1xuICAgIHZhciB5ID0gdGhpcy55O1xuICAgIHZhciB6ID0gdGhpcy56O1xuXG4gICAgdmFyIGNvc1RoZXRhID0gY29zKHRoZXRhKTtcbiAgICB2YXIgc2luVGhldGEgPSBzaW4odGhldGEpO1xuXG4gICAgdGhpcy54ID0geCAqIGNvc1RoZXRhIC0geSAqIHNpblRoZXRhO1xuICAgIHRoaXMueSA9IHggKiBzaW5UaGV0YSArIHkgKiBjb3NUaGV0YTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBUaGUgZG90IHByb2R1Y3Qgb2YgdGhlIGN1cnJlbnQgVmVjMyB3aXRoIGlucHV0IFZlYzMgdi5cbiAqXG4gKiBAbWV0aG9kIGRvdFxuICogQHBhcmFtIHtWZWMzfSB2IFRoZSBvdGhlciBWZWMzLlxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5WZWMzLnByb3RvdHlwZS5kb3QgPSBmdW5jdGlvbiBkb3Qodikge1xuICAgIHJldHVybiB0aGlzLngqdi54ICsgdGhpcy55KnYueSArIHRoaXMueip2Lno7XG59O1xuXG4vKipcbiAqIFRoZSBkb3QgcHJvZHVjdCBvZiB0aGUgY3VycmVudCBWZWMzIHdpdGggaW5wdXQgVmVjMyB2LlxuICogU3RvcmVzIHRoZSByZXN1bHQgaW4gdGhlIGN1cnJlbnQgVmVjMy5cbiAqXG4gKiBAbWV0aG9kIGNyb3NzXG4gKiBAcGFyYW0ge1ZlYzN9IHYgVGhlIG90aGVyIFZlYzMuXG4gKiBAY2hhaW5hYmxlXG4gKi9cblZlYzMucHJvdG90eXBlLmNyb3NzID0gZnVuY3Rpb24gY3Jvc3Modikge1xuICAgIHZhciB4ID0gdGhpcy54O1xuICAgIHZhciB5ID0gdGhpcy55O1xuICAgIHZhciB6ID0gdGhpcy56O1xuXG4gICAgdmFyIHZ4ID0gdi54O1xuICAgIHZhciB2eSA9IHYueTtcbiAgICB2YXIgdnogPSB2Lno7XG5cbiAgICB0aGlzLnggPSB5ICogdnogLSB6ICogdnk7XG4gICAgdGhpcy55ID0geiAqIHZ4IC0geCAqIHZ6O1xuICAgIHRoaXMueiA9IHggKiB2eSAtIHkgKiB2eDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2NhbGUgdGhlIGN1cnJlbnQgVmVjMyBieSBhIHNjYWxhci5cbiAqXG4gKiBAbWV0aG9kIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gcyBUaGUgTnVtYmVyIGJ5IHdoaWNoIHRvIHNjYWxlLlxuICogQGNoYWluYWJsZVxuICovXG5WZWMzLnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uIHNjYWxlKHMpIHtcbiAgICB0aGlzLnggKj0gcztcbiAgICB0aGlzLnkgKj0gcztcbiAgICB0aGlzLnogKj0gcztcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQcmVzZXJ2ZSB0aGUgbWFnbml0dWRlIGJ1dCBpbnZlcnQgdGhlIG9yaWVudGF0aW9uIG9mIHRoZSBjdXJyZW50IFZlYzMuXG4gKlxuICogQG1ldGhvZCBpbnZlcnRcbiAqIEBjaGFpbmFibGVcbiAqL1xuVmVjMy5wcm90b3R5cGUuaW52ZXJ0ID0gZnVuY3Rpb24gaW52ZXJ0KCkge1xuICAgIHRoaXMueCA9IC10aGlzLng7XG4gICAgdGhpcy55ID0gLXRoaXMueTtcbiAgICB0aGlzLnogPSAtdGhpcy56O1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFwcGx5IGEgZnVuY3Rpb24gY29tcG9uZW50LXdpc2UgdG8gdGhlIGN1cnJlbnQgVmVjMy5cbiAqXG4gKiBAbWV0aG9kIG1hcFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gYXBwbHkuXG4gKiBAY2hhaW5hYmxlXG4gKi9cblZlYzMucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIG1hcChmbikge1xuICAgIHRoaXMueCA9IGZuKHRoaXMueCk7XG4gICAgdGhpcy55ID0gZm4odGhpcy55KTtcbiAgICB0aGlzLnogPSBmbih0aGlzLnopO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFRoZSBtYWduaXR1ZGUgb2YgdGhlIGN1cnJlbnQgVmVjMy5cbiAqXG4gKiBAbWV0aG9kIGxlbmd0aFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5WZWMzLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiBsZW5ndGgoKSB7XG4gICAgdmFyIHggPSB0aGlzLng7XG4gICAgdmFyIHkgPSB0aGlzLnk7XG4gICAgdmFyIHogPSB0aGlzLno7XG5cbiAgICByZXR1cm4gc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopO1xufTtcblxuLyoqXG4gKiBUaGUgbWFnbml0dWRlIHNxdWFyZWQgb2YgdGhlIGN1cnJlbnQgVmVjMy5cbiAqXG4gKiBAbWV0aG9kIGxlbmd0aFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5WZWMzLnByb3RvdHlwZS5sZW5ndGhTcSA9IGZ1bmN0aW9uIGxlbmd0aFNxKCkge1xuICAgIHZhciB4ID0gdGhpcy54O1xuICAgIHZhciB5ID0gdGhpcy55O1xuICAgIHZhciB6ID0gdGhpcy56O1xuXG4gICAgcmV0dXJuIHggKiB4ICsgeSAqIHkgKyB6ICogejtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgaW5wdXQgb250byB0aGUgY3VycmVudCBWZWMzLlxuICpcbiAqIEBtZXRob2QgY29weVxuICogQHBhcmFtIHtWZWMzfSB2IFZlYzMgdG8gY29weS5cbiAqIEBjaGFpbmFibGVcbiAqL1xuVmVjMy5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkodikge1xuICAgIHRoaXMueCA9IHYueDtcbiAgICB0aGlzLnkgPSB2Lnk7XG4gICAgdGhpcy56ID0gdi56O1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXNldCB0aGUgY3VycmVudCBWZWMzLlxuICpcbiAqIEBtZXRob2QgY2xlYXJcbiAqIEBjaGFpbmFibGVcbiAqL1xuVmVjMy5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy56ID0gMDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgbWFnbml0dWRlIG9mIHRoZSBjdXJyZW50IFZlYzMgaXMgZXhhY3RseSAwLlxuICpcbiAqIEBtZXRob2QgaXNaZXJvXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5WZWMzLnByb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiBpc1plcm8oKSB7XG4gICAgcmV0dXJuIHRoaXMueCA9PT0gMCAmJiB0aGlzLnkgPT09IDAgJiYgdGhpcy56ID09PSAwO1xufTtcblxuLyoqXG4gKiBUaGUgYXJyYXkgZm9ybSBvZiB0aGUgY3VycmVudCBWZWMzLlxuICpcbiAqIEBtZXRob2QgdG9BcnJheVxuICogQHJldHVybiB7TnVtYmVyW119XG4gKi9cblZlYzMucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiB0b0FycmF5KCkge1xuICAgIHJldHVybiBbdGhpcy54LCB0aGlzLnksIHRoaXMuel07XG59O1xuXG4vKipcbiAqIFByZXNlcnZlIHRoZSBvcmllbnRhdGlvbiBidXQgY2hhbmdlIHRoZSBsZW5ndGggb2YgdGhlIGN1cnJlbnQgVmVjMyB0byAxLlxuICpcbiAqIEBtZXRob2Qgbm9ybWFsaXplXG4gKiBAY2hhaW5hYmxlXG4gKi9cblZlYzMucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZSgpIHtcbiAgICB2YXIgeCA9IHRoaXMueDtcbiAgICB2YXIgeSA9IHRoaXMueTtcbiAgICB2YXIgeiA9IHRoaXMuejtcblxuICAgIHZhciBsZW4gPSBzcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeikgfHwgMTtcbiAgICBsZW4gPSAxIC8gbGVuO1xuXG4gICAgdGhpcy54ICo9IGxlbjtcbiAgICB0aGlzLnkgKj0gbGVuO1xuICAgIHRoaXMueiAqPSBsZW47XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFwcGx5IHRoZSByb3RhdGlvbiBjb3JyZXNwb25kaW5nIHRvIHRoZSBpbnB1dCAodW5pdCkgUXVhdGVybmlvblxuICogdG8gdGhlIGN1cnJlbnQgVmVjMy5cbiAqXG4gKiBAbWV0aG9kIGFwcGx5Um90YXRpb25cbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcSBVbml0IFF1YXRlcm5pb24gcmVwcmVzZW50aW5nIHRoZSByb3RhdGlvbiB0byBhcHBseS5cbiAqIEBjaGFpbmFibGVcbiAqL1xuVmVjMy5wcm90b3R5cGUuYXBwbHlSb3RhdGlvbiA9IGZ1bmN0aW9uIGFwcGx5Um90YXRpb24ocSkge1xuICAgIHZhciBjdyA9IHEudztcbiAgICB2YXIgY3ggPSAtcS54O1xuICAgIHZhciBjeSA9IC1xLnk7XG4gICAgdmFyIGN6ID0gLXEuejtcblxuICAgIHZhciB2eCA9IHRoaXMueDtcbiAgICB2YXIgdnkgPSB0aGlzLnk7XG4gICAgdmFyIHZ6ID0gdGhpcy56O1xuXG4gICAgdmFyIHR3ID0gLWN4ICogdnggLSBjeSAqIHZ5IC0gY3ogKiB2ejtcbiAgICB2YXIgdHggPSB2eCAqIGN3ICsgdnkgKiBjeiAtIGN5ICogdno7XG4gICAgdmFyIHR5ID0gdnkgKiBjdyArIGN4ICogdnogLSB2eCAqIGN6O1xuICAgIHZhciB0eiA9IHZ6ICogY3cgKyB2eCAqIGN5IC0gY3ggKiB2eTtcblxuICAgIHZhciB3ID0gY3c7XG4gICAgdmFyIHggPSAtY3g7XG4gICAgdmFyIHkgPSAtY3k7XG4gICAgdmFyIHogPSAtY3o7XG5cbiAgICB0aGlzLnggPSB0eCAqIHcgKyB4ICogdHcgKyB5ICogdHogLSB0eSAqIHo7XG4gICAgdGhpcy55ID0gdHkgKiB3ICsgeSAqIHR3ICsgdHggKiB6IC0geCAqIHR6O1xuICAgIHRoaXMueiA9IHR6ICogdyArIHogKiB0dyArIHggKiB0eSAtIHR4ICogeTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQXBwbHkgdGhlIGlucHV0IE1hdDMzIHRoZSB0aGUgY3VycmVudCBWZWMzLlxuICpcbiAqIEBtZXRob2QgYXBwbHlNYXRyaXhcbiAqIEBwYXJhbSB7TWF0MzN9IG1hdHJpeCBNYXQzMyB0byBhcHBseS5cbiAqIEBjaGFpbmFibGVcbiAqL1xuVmVjMy5wcm90b3R5cGUuYXBwbHlNYXRyaXggPSBmdW5jdGlvbiBhcHBseU1hdHJpeChtYXRyaXgpIHtcbiAgICB2YXIgTSA9IG1hdHJpeC5nZXQoKTtcblxuICAgIHZhciB4ID0gdGhpcy54O1xuICAgIHZhciB5ID0gdGhpcy55O1xuICAgIHZhciB6ID0gdGhpcy56O1xuXG4gICAgdGhpcy54ID0gTVswXSp4ICsgTVsxXSp5ICsgTVsyXSp6O1xuICAgIHRoaXMueSA9IE1bM10qeCArIE1bNF0qeSArIE1bNV0qejtcbiAgICB0aGlzLnogPSBNWzZdKnggKyBNWzddKnkgKyBNWzhdKno7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSB0aGUgaW5wdXQgVmVjMy5cbiAqXG4gKiBAbWV0aG9kIG5vcm1hbGl6ZVxuICogQHBhcmFtIHtWZWMzfSB2IFRoZSByZWZlcmVuY2UgVmVjMy5cbiAqIEBwYXJhbSB7VmVjM30gb3V0cHV0IFZlYzMgaW4gd2hpY2ggdG8gcGxhY2UgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm4ge1ZlYzN9IFRoZSBub3JtYWxpemUgVmVjMy5cbiAqL1xuVmVjMy5ub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUodiwgb3V0cHV0KSB7XG4gICAgdmFyIHggPSB2Lng7XG4gICAgdmFyIHkgPSB2Lnk7XG4gICAgdmFyIHogPSB2Lno7XG5cbiAgICB2YXIgbGVuZ3RoID0gc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopIHx8IDE7XG4gICAgbGVuZ3RoID0gMSAvIGxlbmd0aDtcblxuICAgIG91dHB1dC54ID0geCAqIGxlbmd0aDtcbiAgICBvdXRwdXQueSA9IHkgKiBsZW5ndGg7XG4gICAgb3V0cHV0LnogPSB6ICogbGVuZ3RoO1xuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIEFwcGx5IGEgcm90YXRpb24gdG8gdGhlIGlucHV0IFZlYzMuXG4gKlxuICogQG1ldGhvZCBhcHBseVJvdGF0aW9uXG4gKiBAcGFyYW0ge1ZlYzN9IHYgVGhlIHJlZmVyZW5jZSBWZWMzLlxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxIFVuaXQgUXVhdGVybmlvbiByZXByZXNlbnRpbmcgdGhlIHJvdGF0aW9uIHRvIGFwcGx5LlxuICogQHBhcmFtIHtWZWMzfSBvdXRwdXQgVmVjMyBpbiB3aGljaCB0byBwbGFjZSB0aGUgcmVzdWx0LlxuICogQHJldHVybiB7VmVjM30gVGhlIHJvdGF0ZWQgdmVyc2lvbiBvZiB0aGUgaW5wdXQgVmVjMy5cbiAqL1xuVmVjMy5hcHBseVJvdGF0aW9uID0gZnVuY3Rpb24gYXBwbHlSb3RhdGlvbih2LCBxLCBvdXRwdXQpIHtcbiAgICB2YXIgY3cgPSBxLnc7XG4gICAgdmFyIGN4ID0gLXEueDtcbiAgICB2YXIgY3kgPSAtcS55O1xuICAgIHZhciBjeiA9IC1xLno7XG5cbiAgICB2YXIgdnggPSB2Lng7XG4gICAgdmFyIHZ5ID0gdi55O1xuICAgIHZhciB2eiA9IHYuejtcblxuICAgIHZhciB0dyA9IC1jeCAqIHZ4IC0gY3kgKiB2eSAtIGN6ICogdno7XG4gICAgdmFyIHR4ID0gdnggKiBjdyArIHZ5ICogY3ogLSBjeSAqIHZ6O1xuICAgIHZhciB0eSA9IHZ5ICogY3cgKyBjeCAqIHZ6IC0gdnggKiBjejtcbiAgICB2YXIgdHogPSB2eiAqIGN3ICsgdnggKiBjeSAtIGN4ICogdnk7XG5cbiAgICB2YXIgdyA9IGN3O1xuICAgIHZhciB4ID0gLWN4O1xuICAgIHZhciB5ID0gLWN5O1xuICAgIHZhciB6ID0gLWN6O1xuXG4gICAgb3V0cHV0LnggPSB0eCAqIHcgKyB4ICogdHcgKyB5ICogdHogLSB0eSAqIHo7XG4gICAgb3V0cHV0LnkgPSB0eSAqIHcgKyB5ICogdHcgKyB0eCAqIHogLSB4ICogdHo7XG4gICAgb3V0cHV0LnogPSB0eiAqIHcgKyB6ICogdHcgKyB4ICogdHkgLSB0eCAqIHk7XG4gICAgcmV0dXJuIG91dHB1dDtcbn07XG5cbi8qKlxuICogQ2xvbmUgdGhlIGlucHV0IFZlYzMuXG4gKlxuICogQG1ldGhvZCBjbG9uZVxuICogQHBhcmFtIHtWZWMzfSB2IFRoZSBWZWMzIHRvIGNsb25lLlxuICogQHJldHVybiB7VmVjM30gVGhlIGNsb25lZCBWZWMzLlxuICovXG5WZWMzLmNsb25lID0gZnVuY3Rpb24gY2xvbmUodikge1xuICAgIHJldHVybiBuZXcgVmVjMyh2LngsIHYueSwgdi56KTtcbn07XG5cbi8qKlxuICogQWRkIHRoZSBpbnB1dCBWZWMzJ3MuXG4gKlxuICogQG1ldGhvZCBhZGRcbiAqIEBwYXJhbSB7VmVjM30gdjEgVGhlIGxlZnQgVmVjMy5cbiAqIEBwYXJhbSB7VmVjM30gdjIgVGhlIHJpZ2h0IFZlYzMuXG4gKiBAcGFyYW0ge1ZlYzN9IG91dHB1dCBWZWMzIGluIHdoaWNoIHRvIHBsYWNlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJuIHtWZWMzfSBUaGUgcmVzdWx0IG9mIHRoZSBhZGRpdGlvbi5cbiAqL1xuVmVjMy5hZGQgPSBmdW5jdGlvbiBhZGQodjEsIHYyLCBvdXRwdXQpIHtcbiAgICBvdXRwdXQueCA9IHYxLnggKyB2Mi54O1xuICAgIG91dHB1dC55ID0gdjEueSArIHYyLnk7XG4gICAgb3V0cHV0LnogPSB2MS56ICsgdjIuejtcbiAgICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdCB0aGUgc2Vjb25kIFZlYzMgZnJvbSB0aGUgZmlyc3QuXG4gKlxuICogQG1ldGhvZCBzdWJ0cmFjdFxuICogQHBhcmFtIHtWZWMzfSB2MSBUaGUgbGVmdCBWZWMzLlxuICogQHBhcmFtIHtWZWMzfSB2MiBUaGUgcmlnaHQgVmVjMy5cbiAqIEBwYXJhbSB7VmVjM30gb3V0cHV0IFZlYzMgaW4gd2hpY2ggdG8gcGxhY2UgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm4ge1ZlYzN9IFRoZSByZXN1bHQgb2YgdGhlIHN1YnRyYWN0aW9uLlxuICovXG5WZWMzLnN1YnRyYWN0ID0gZnVuY3Rpb24gc3VidHJhY3QodjEsIHYyLCBvdXRwdXQpIHtcbiAgICBvdXRwdXQueCA9IHYxLnggLSB2Mi54O1xuICAgIG91dHB1dC55ID0gdjEueSAtIHYyLnk7XG4gICAgb3V0cHV0LnogPSB2MS56IC0gdjIuejtcbiAgICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqXG4gKiBTY2FsZSB0aGUgaW5wdXQgVmVjMy5cbiAqXG4gKiBAbWV0aG9kIHNjYWxlXG4gKiBAcGFyYW0ge1ZlYzN9IHYgVGhlIHJlZmVyZW5jZSBWZWMzLlxuICogQHBhcmFtIHtOdW1iZXJ9IHMgTnVtYmVyIHRvIHNjYWxlIGJ5LlxuICogQHBhcmFtIHtWZWMzfSBvdXRwdXQgVmVjMyBpbiB3aGljaCB0byBwbGFjZSB0aGUgcmVzdWx0LlxuICogQHJldHVybiB7VmVjM30gVGhlIHJlc3VsdCBvZiB0aGUgc2NhbGluZy5cbiAqL1xuVmVjMy5zY2FsZSA9IGZ1bmN0aW9uIHNjYWxlKHYsIHMsIG91dHB1dCkge1xuICAgIG91dHB1dC54ID0gdi54ICogcztcbiAgICBvdXRwdXQueSA9IHYueSAqIHM7XG4gICAgb3V0cHV0LnogPSB2LnogKiBzO1xuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIFRoZSBkb3QgcHJvZHVjdCBvZiB0aGUgaW5wdXQgVmVjMydzLlxuICpcbiAqIEBtZXRob2QgZG90UHJvZHVjdFxuICogQHBhcmFtIHtWZWMzfSB2MSBUaGUgbGVmdCBWZWMzLlxuICogQHBhcmFtIHtWZWMzfSB2MiBUaGUgcmlnaHQgVmVjMy5cbiAqIEByZXR1cm4ge051bWJlcn0gVGhlIGRvdCBwcm9kdWN0LlxuICovXG5WZWMzLmRvdCA9IGZ1bmN0aW9uIGRvdCh2MSwgdjIpIHtcbiAgICByZXR1cm4gdjEueCAqIHYyLnggKyB2MS55ICogdjIueSArIHYxLnogKiB2Mi56O1xufTtcblxuLyoqXG4gKiBUaGUgKHJpZ2h0LWhhbmRlZCkgY3Jvc3MgcHJvZHVjdCBvZiB0aGUgaW5wdXQgVmVjMydzLlxuICogdjEgeCB2Mi5cbiAqXG4gKiBAbWV0aG9kIGNyb3NzUHJvZHVjdFxuICogQHBhcmFtIHtWZWMzfSB2MSBUaGUgbGVmdCBWZWMzLlxuICogQHBhcmFtIHtWZWMzfSB2MiBUaGUgcmlnaHQgVmVjMy5cbiAqIEBwYXJhbSB7VmVjM30gb3V0cHV0IFZlYzMgaW4gd2hpY2ggdG8gcGxhY2UgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm4ge1ZlYzN9XG4gKi9cblZlYzMuY3Jvc3MgPSBmdW5jdGlvbiBjcm9zcyh2MSwgdjIsIG91dHB1dCkge1xuICAgIHZhciB4MSA9IHYxLng7XG4gICAgdmFyIHkxID0gdjEueTtcbiAgICB2YXIgejEgPSB2MS56O1xuICAgIHZhciB4MiA9IHYyLng7XG4gICAgdmFyIHkyID0gdjIueTtcbiAgICB2YXIgejIgPSB2Mi56O1xuXG4gICAgb3V0cHV0LnggPSB5MSAqIHoyIC0gejEgKiB5MjtcbiAgICBvdXRwdXQueSA9IHoxICogeDIgLSB4MSAqIHoyO1xuICAgIG91dHB1dC56ID0geDEgKiB5MiAtIHkxICogeDI7XG4gICAgcmV0dXJuIG91dHB1dDtcbn07XG5cbi8qKlxuICogVGhlIHByb2plY3Rpb24gb2YgdjEgb250byB2Mi5cbiAqXG4gKiBAbWV0aG9kIHByb2plY3RcbiAqIEBwYXJhbSB7VmVjM30gdjEgVGhlIGxlZnQgVmVjMy5cbiAqIEBwYXJhbSB7VmVjM30gdjIgVGhlIHJpZ2h0IFZlYzMuXG4gKiBAcGFyYW0ge1ZlYzN9IG91dHB1dCBWZWMzIGluIHdoaWNoIHRvIHBsYWNlIHRoZSByZXN1bHQuXG4gKiBAcmV0dXJuIHtWZWMzfVxuICovXG5WZWMzLnByb2plY3QgPSBmdW5jdGlvbiBwcm9qZWN0KHYxLCB2Miwgb3V0cHV0KSB7XG4gICAgdmFyIHgxID0gdjEueDtcbiAgICB2YXIgeTEgPSB2MS55O1xuICAgIHZhciB6MSA9IHYxLno7XG4gICAgdmFyIHgyID0gdjIueDtcbiAgICB2YXIgeTIgPSB2Mi55O1xuICAgIHZhciB6MiA9IHYyLno7XG5cbiAgICB2YXIgc2NhbGUgPSB4MSAqIHgyICsgeTEgKiB5MiArIHoxICogejI7XG4gICAgc2NhbGUgLz0geDIgKiB4MiArIHkyICogeTIgKyB6MiAqIHoyO1xuXG4gICAgb3V0cHV0LnggPSB4MiAqIHNjYWxlO1xuICAgIG91dHB1dC55ID0geTIgKiBzY2FsZTtcbiAgICBvdXRwdXQueiA9IHoyICogc2NhbGU7XG5cbiAgICByZXR1cm4gb3V0cHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBWZWMzO1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgTWF0MzM6IHJlcXVpcmUoJy4vTWF0MzMnKSxcbiAgICBRdWF0ZXJuaW9uOiByZXF1aXJlKCcuL1F1YXRlcm5pb24nKSxcbiAgICBWZWMyOiByZXF1aXJlKCcuL1ZlYzInKSxcbiAgICBWZWMzOiByZXF1aXJlKCcuL1ZlYzMnKVxufTtcblxuIiwiLypqc2hpbnQgLVcwMDggKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ3VydmVzID0ge1xuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBsaW5lYXJcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGxpbmVhcjogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGVhc2VJblxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgZWFzZUluOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0KnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBlYXNlT3V0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBlYXNlT3V0OiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0KigyLXQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgZWFzZUluT3V0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBlYXNlSW5PdXQ6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgaWYgKHQgPD0gMC41KSByZXR1cm4gMip0KnQ7XG4gICAgICAgIGVsc2UgcmV0dXJuIC0yKnQqdCArIDQqdCAtIDE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBlYXNlT3V0Qm91bmNlXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBlYXNlT3V0Qm91bmNlOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0KigzIC0gMip0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHNwcmluZ1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgc3ByaW5nOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiAoMSAtIHQpICogTWF0aC5zaW4oNiAqIE1hdGguUEkgKiB0KSArIHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpblF1YWRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGluUXVhZDogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gdCp0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgb3V0UXVhZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgb3V0UXVhZDogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gLSh0LT0xKSp0KzE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpbk91dFF1YWRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGluT3V0UXVhZDogZnVuY3Rpb24odCkge1xuICAgICAgICBpZiAoKHQvPS41KSA8IDEpIHJldHVybiAuNSp0KnQ7XG4gICAgICAgIHJldHVybiAtLjUqKCgtLXQpKih0LTIpIC0gMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpbkN1YmljXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBpbkN1YmljOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0KnQqdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IG91dEN1YmljXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBvdXRDdWJpYzogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gKCgtLXQpKnQqdCArIDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5PdXRDdWJpY1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgaW5PdXRDdWJpYzogZnVuY3Rpb24odCkge1xuICAgICAgICBpZiAoKHQvPS41KSA8IDEpIHJldHVybiAuNSp0KnQqdDtcbiAgICAgICAgcmV0dXJuIC41KigodC09MikqdCp0ICsgMik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpblF1YXJ0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBpblF1YXJ0OiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0KnQqdCp0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgb3V0UXVhcnRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIG91dFF1YXJ0OiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiAtKCgtLXQpKnQqdCp0IC0gMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpbk91dFF1YXJ0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBpbk91dFF1YXJ0OiBmdW5jdGlvbih0KSB7XG4gICAgICAgIGlmICgodC89LjUpIDwgMSkgcmV0dXJuIC41KnQqdCp0KnQ7XG4gICAgICAgIHJldHVybiAtLjUgKiAoKHQtPTIpKnQqdCp0IC0gMik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpblF1aW50XG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBpblF1aW50OiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0KnQqdCp0KnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBvdXRRdWludFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgb3V0UXVpbnQ6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuICgoLS10KSp0KnQqdCp0ICsgMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpbk91dFF1aW50XG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBpbk91dFF1aW50OiBmdW5jdGlvbih0KSB7XG4gICAgICAgIGlmICgodC89LjUpIDwgMSkgcmV0dXJuIC41KnQqdCp0KnQqdDtcbiAgICAgICAgcmV0dXJuIC41KigodC09MikqdCp0KnQqdCArIDIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5TaW5lXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBpblNpbmU6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIC0xLjAqTWF0aC5jb3ModCAqIChNYXRoLlBJLzIpKSArIDEuMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IG91dFNpbmVcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIG91dFNpbmU6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc2luKHQgKiAoTWF0aC5QSS8yKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpbk91dFNpbmVcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGluT3V0U2luZTogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gLS41KihNYXRoLmNvcyhNYXRoLlBJKnQpIC0gMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpbkV4cG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGluRXhwbzogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gKHQ9PT0wKSA/IDAuMCA6IE1hdGgucG93KDIsIDEwICogKHQgLSAxKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBvdXRFeHBvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBvdXRFeHBvOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiAodD09PTEuMCkgPyAxLjAgOiAoLU1hdGgucG93KDIsIC0xMCAqIHQpICsgMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpbk91dEV4cG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGluT3V0RXhwbzogZnVuY3Rpb24odCkge1xuICAgICAgICBpZiAodD09PTApIHJldHVybiAwLjA7XG4gICAgICAgIGlmICh0PT09MS4wKSByZXR1cm4gMS4wO1xuICAgICAgICBpZiAoKHQvPS41KSA8IDEpIHJldHVybiAuNSAqIE1hdGgucG93KDIsIDEwICogKHQgLSAxKSk7XG4gICAgICAgIHJldHVybiAuNSAqICgtTWF0aC5wb3coMiwgLTEwICogLS10KSArIDIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5DaXJjXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBpbkNpcmM6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIC0oTWF0aC5zcXJ0KDEgLSB0KnQpIC0gMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBvdXRDaXJjXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBvdXRDaXJjOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoMSAtICgtLXQpKnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5PdXRDaXJjXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBpbk91dENpcmM6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgaWYgKCh0Lz0uNSkgPCAxKSByZXR1cm4gLS41ICogKE1hdGguc3FydCgxIC0gdCp0KSAtIDEpO1xuICAgICAgICByZXR1cm4gLjUgKiAoTWF0aC5zcXJ0KDEgLSAodC09MikqdCkgKyAxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGluRWxhc3RpY1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgaW5FbGFzdGljOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHZhciBzPTEuNzAxNTg7dmFyIHA9MDt2YXIgYT0xLjA7XG4gICAgICAgIGlmICh0PT09MCkgcmV0dXJuIDAuMDsgIGlmICh0PT09MSkgcmV0dXJuIDEuMDsgIGlmICghcCkgcD0uMztcbiAgICAgICAgcyA9IHAvKDIqTWF0aC5QSSkgKiBNYXRoLmFzaW4oMS4wL2EpO1xuICAgICAgICByZXR1cm4gLShhKk1hdGgucG93KDIsMTAqKHQtPTEpKSAqIE1hdGguc2luKCh0LXMpKigyKk1hdGguUEkpLyBwKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBvdXRFbGFzdGljXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBvdXRFbGFzdGljOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHZhciBzPTEuNzAxNTg7dmFyIHA9MDt2YXIgYT0xLjA7XG4gICAgICAgIGlmICh0PT09MCkgcmV0dXJuIDAuMDsgIGlmICh0PT09MSkgcmV0dXJuIDEuMDsgIGlmICghcCkgcD0uMztcbiAgICAgICAgcyA9IHAvKDIqTWF0aC5QSSkgKiBNYXRoLmFzaW4oMS4wL2EpO1xuICAgICAgICByZXR1cm4gYSpNYXRoLnBvdygyLC0xMCp0KSAqIE1hdGguc2luKCh0LXMpKigyKk1hdGguUEkpL3ApICsgMS4wO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5PdXRFbGFzdGljXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBpbk91dEVsYXN0aWM6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdmFyIHM9MS43MDE1ODt2YXIgcD0wO3ZhciBhPTEuMDtcbiAgICAgICAgaWYgKHQ9PT0wKSByZXR1cm4gMC4wOyAgaWYgKCh0Lz0uNSk9PT0yKSByZXR1cm4gMS4wOyAgaWYgKCFwKSBwPSguMyoxLjUpO1xuICAgICAgICBzID0gcC8oMipNYXRoLlBJKSAqIE1hdGguYXNpbigxLjAvYSk7XG4gICAgICAgIGlmICh0IDwgMSkgcmV0dXJuIC0uNSooYSpNYXRoLnBvdygyLDEwKih0LT0xKSkgKiBNYXRoLnNpbigodC1zKSooMipNYXRoLlBJKS9wKSk7XG4gICAgICAgIHJldHVybiBhKk1hdGgucG93KDIsLTEwKih0LT0xKSkgKiBNYXRoLnNpbigodC1zKSooMipNYXRoLlBJKS9wKSouNSArIDEuMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGluQmFja1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgaW5CYWNrOiBmdW5jdGlvbih0LCBzKSB7XG4gICAgICAgIGlmIChzID09PSB1bmRlZmluZWQpIHMgPSAxLjcwMTU4O1xuICAgICAgICByZXR1cm4gdCp0KigocysxKSp0IC0gcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBvdXRCYWNrXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBvdXRCYWNrOiBmdW5jdGlvbih0LCBzKSB7XG4gICAgICAgIGlmIChzID09PSB1bmRlZmluZWQpIHMgPSAxLjcwMTU4O1xuICAgICAgICByZXR1cm4gKCgtLXQpKnQqKChzKzEpKnQgKyBzKSArIDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5PdXRCYWNrXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBpbk91dEJhY2s6IGZ1bmN0aW9uKHQsIHMpIHtcbiAgICAgICAgaWYgKHMgPT09IHVuZGVmaW5lZCkgcyA9IDEuNzAxNTg7XG4gICAgICAgIGlmICgodC89LjUpIDwgMSkgcmV0dXJuIC41Kih0KnQqKCgocyo9KDEuNTI1KSkrMSkqdCAtIHMpKTtcbiAgICAgICAgcmV0dXJuIC41KigodC09MikqdCooKChzKj0oMS41MjUpKSsxKSp0ICsgcykgKyAyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGluQm91bmNlXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBpbkJvdW5jZTogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gMS4wIC0gQ3VydmVzLm91dEJvdW5jZSgxLjAtdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBvdXRCb3VuY2VcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIG91dEJvdW5jZTogZnVuY3Rpb24odCkge1xuICAgICAgICBpZiAodCA8ICgxLzIuNzUpKSB7XG4gICAgICAgICAgICByZXR1cm4gKDcuNTYyNSp0KnQpO1xuICAgICAgICB9IGVsc2UgaWYgKHQgPCAoMi8yLjc1KSkge1xuICAgICAgICAgICAgcmV0dXJuICg3LjU2MjUqKHQtPSgxLjUvMi43NSkpKnQgKyAuNzUpO1xuICAgICAgICB9IGVsc2UgaWYgKHQgPCAoMi41LzIuNzUpKSB7XG4gICAgICAgICAgICByZXR1cm4gKDcuNTYyNSoodC09KDIuMjUvMi43NSkpKnQgKyAuOTM3NSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKDcuNTYyNSoodC09KDIuNjI1LzIuNzUpKSp0ICsgLjk4NDM3NSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGluT3V0Qm91bmNlXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBpbk91dEJvdW5jZTogZnVuY3Rpb24odCkge1xuICAgICAgICBpZiAodCA8IC41KSByZXR1cm4gQ3VydmVzLmluQm91bmNlKHQqMikgKiAuNTtcbiAgICAgICAgcmV0dXJuIEN1cnZlcy5vdXRCb3VuY2UodCoyLTEuMCkgKiAuNSArIC41O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgZmxhdFxuICAgICAqXG4gICAgICogVXNlZnVsIGZvciBkZWxheWluZyB0aGUgZXhlY3V0aW9uIG9mIGEgc3Vic2VxdWVudCB0cmFuc2l0aW9uLlxuICAgICAqIFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgZmxhdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ3VydmVzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ3VydmVzID0gcmVxdWlyZSgnLi9DdXJ2ZXMnKTtcblxuLyoqXG4gKiBBIHN0YXRlIG1haW50YWluZXIgZm9yIGEgc21vb3RoIHRyYW5zaXRpb24gYmV0d2VlblxuICogICAgbnVtZXJpY2FsbHktc3BlY2lmaWVkIHN0YXRlcy4gRXhhbXBsZSBudW1lcmljIHN0YXRlcyBpbmNsdWRlIGZsb2F0cyBhbmRcbiAqICAgIGFycmF5cyBvZiBmbG9hdHMgb2JqZWN0cy5cbiAqXG4gKiBBbiBpbml0aWFsIHN0YXRlIGlzIHNldCB3aXRoIHRoZSBjb25zdHJ1Y3RvciBvciB1c2luZ1xuICogICAgIHtAbGluayBUcmFuc2l0aW9uYWJsZSNmcm9tfS4gU3Vic2VxdWVudCB0cmFuc2l0aW9ucyBjb25zaXN0IG9mIGFuXG4gKiAgICAgaW50ZXJtZWRpYXRlIHN0YXRlLCBlYXNpbmcgY3VydmUsIGR1cmF0aW9uIGFuZCBjYWxsYmFjay4gVGhlIGZpbmFsIHN0YXRlXG4gKiAgICAgb2YgZWFjaCB0cmFuc2l0aW9uIGlzIHRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSBzdWJzZXF1ZW50IG9uZS4gQ2FsbHMgdG9cbiAqICAgICB7QGxpbmsgVHJhbnNpdGlvbmFibGUjZ2V0fSBwcm92aWRlIHRoZSBpbnRlcnBvbGF0ZWQgc3RhdGUgYWxvbmcgdGhlIHdheS5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlcmUgaXMgbm8gZXZlbnQgbG9vcCBoZXJlIC0gY2FsbHMgdG8ge0BsaW5rIFRyYW5zaXRpb25hYmxlI2dldH1cbiAqICAgIGFyZSB0aGUgb25seSB3YXkgdG8gZmluZCBzdGF0ZSBwcm9qZWN0ZWQgdG8gdGhlIGN1cnJlbnQgKG9yIHByb3ZpZGVkKVxuICogICAgdGltZSBhbmQgYXJlIHRoZSBvbmx5IHdheSB0byB0cmlnZ2VyIGNhbGxiYWNrcyBhbmQgbXV0YXRlIHRoZSBpbnRlcm5hbFxuICogICAgdHJhbnNpdGlvbiBxdWV1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIHQgPSBuZXcgVHJhbnNpdGlvbmFibGUoWzAsIDBdKTtcbiAqIHRcbiAqICAgICAudG8oWzEwMCwgMF0sICdsaW5lYXInLCAxMDAwKVxuICogICAgIC5kZWxheSgxMDAwKVxuICogICAgIC50byhbMjAwLCAwXSwgJ291dEJvdW5jZScsIDEwMDApO1xuICpcbiAqIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAqIGRpdi5zdHlsZS5iYWNrZ3JvdW5kID0gJ2JsdWUnO1xuICogZGl2LnN0eWxlLndpZHRoID0gJzEwMHB4JztcbiAqIGRpdi5zdHlsZS5oZWlnaHQgPSAnMTAwcHgnO1xuICogZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuICpcbiAqIGRpdi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuICogICAgIHQuaXNQYXVzZWQoKSA/IHQucmVzdW1lKCkgOiB0LnBhdXNlKCk7XG4gKiB9KTtcbiAqXG4gKiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gbG9vcCgpIHtcbiAqICAgICBkaXYuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVgoJyArIHQuZ2V0KClbMF0gKyAncHgpJyArICcgdHJhbnNsYXRlWSgnICsgdC5nZXQoKVsxXSArICdweCknO1xuICogICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKTtcbiAqIH0pO1xuICpcbiAqIEBjbGFzcyBUcmFuc2l0aW9uYWJsZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge051bWJlcnxBcnJheS5OdW1iZXJ9IGluaXRpYWxTdGF0ZSAgICBpbml0aWFsIHN0YXRlIHRvIHRyYW5zaXRpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gLSBlcXVpdmFsZW50IHRvIGEgcHVyc3VhbnRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludm9jYXRpb24gb2ZcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtAbGluayBUcmFuc2l0aW9uYWJsZSNmcm9tfVxuICovXG5mdW5jdGlvbiBUcmFuc2l0aW9uYWJsZShpbml0aWFsU3RhdGUpIHtcbiAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuICAgIHRoaXMuX211bHRpID0gbnVsbDtcbiAgICB0aGlzLl9tZXRob2QgPSBudWxsO1xuICAgIHRoaXMuX2VuZCA9IG51bGw7XG4gICAgdGhpcy5fc3RhcnRlZEF0ID0gbnVsbDtcbiAgICB0aGlzLl9wYXVzZWRBdCA9IG51bGw7XG4gICAgaWYgKGluaXRpYWxTdGF0ZSAhPSBudWxsKSB0aGlzLmZyb20oaW5pdGlhbFN0YXRlKTtcbn1cblxuLyoqXG4gKiBJbnRlcm5hbCBDbG9jayB1c2VkIGZvciBkZXRlcm1pbmluZyB0aGUgY3VycmVudCB0aW1lIGZvciB0aGUgb25nb2luZ1xuICogdHJhbnNpdGlvbnMuXG4gKlxuICogQHR5cGUge1BlcmZvcm1hbmNlfERhdGV8T2JqZWN0fVxuICovXG5UcmFuc2l0aW9uYWJsZS5DbG9jayA9IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCcgPyBwZXJmb3JtYW5jZSA6IERhdGU7XG5cbi8qKlxuICogUmVnaXN0ZXJzIGEgdHJhbnNpdGlvbiB0byBiZSBwdXNoZWQgb250byB0aGUgaW50ZXJuYWwgcXVldWUuXG4gKlxuICogQG1ldGhvZCB0b1xuICogQGNoYWluYWJsZVxuICpcbiAqIEBwYXJhbSAge051bWJlcnxBcnJheS5OdW1iZXJ9ICAgIGZpbmFsU3RhdGUgICAgICAgICAgICAgIGZpbmFsIHN0YXRlIHRvXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0b24gdG9cbiAqIEBwYXJhbSAge1N0cmluZ3xGdW5jdGlvbn0gICAgICAgIFtjdXJ2ZT1DdXJ2ZXMubGluZWFyXSAgIGVhc2luZyBmdW5jdGlvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlZCBmb3JcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVycG9sYXRpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFswLCAxXVxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgICAgICAgICAgICAgW2R1cmF0aW9uPTEwMF0gICAgICAgICAgZHVyYXRpb24gb2ZcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSAgICAgICAgICAgICAgIFtjYWxsYmFja10gICAgICAgICAgICAgIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBiZSBjYWxsZWQgYWZ0ZXJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSB0cmFuc2l0aW9uIGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZVxuICogQHJldHVybiB7VHJhbnNpdGlvbmFibGV9ICAgICAgICAgdGhpc1xuICovXG5UcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUudG8gPSBmdW5jdGlvbiB0byhmaW5hbFN0YXRlLCBjdXJ2ZSwgZHVyYXRpb24sIGNhbGxiYWNrLCBtZXRob2QpIHtcbiAgICBjdXJ2ZSA9IGN1cnZlICE9IG51bGwgJiYgY3VydmUuY29uc3RydWN0b3IgPT09IFN0cmluZyA/IEN1cnZlc1tjdXJ2ZV0gOiBjdXJ2ZTtcbiAgICB0aGlzLl9tZXRob2QgPSBtZXRob2Q7XG4gICAgaWYgKHRoaXMuX3F1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9zdGFydGVkQXQgPSB0aGlzLmNvbnN0cnVjdG9yLkNsb2NrLm5vdygpO1xuICAgICAgICB0aGlzLl9wYXVzZWRBdCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuX3F1ZXVlLnB1c2goXG4gICAgICAgIGZpbmFsU3RhdGUsXG4gICAgICAgIGN1cnZlICE9IG51bGwgPyBjdXJ2ZSA6IEN1cnZlcy5saW5lYXIsXG4gICAgICAgIGR1cmF0aW9uICE9IG51bGwgPyBkdXJhdGlvbiA6IDEwMCxcbiAgICAgICAgY2FsbGJhY2tcbiAgICApO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXNldHMgdGhlIHRyYW5zaXRpb24gcXVldWUgdG8gYSBzdGFibGUgaW5pdGlhbCBzdGF0ZS5cbiAqXG4gKiBAbWV0aG9kIGZyb21cbiAqIEBjaGFpbmFibGVcbiAqXG4gKiBAcGFyYW0gIHtOdW1iZXJ8QXJyYXkuTnVtYmVyfSAgICBpbml0aWFsU3RhdGUgICAgaW5pdGlhbCBzdGF0ZSB0b1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24gZnJvbVxuICogQHJldHVybiB7VHJhbnNpdGlvbmFibGV9ICAgICAgICAgdGhpc1xuICovXG5UcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUuZnJvbSA9IGZ1bmN0aW9uIGZyb20oaW5pdGlhbFN0YXRlKSB7XG4gICAgdGhpcy5fZW5kID0gaW5pdGlhbFN0YXRlO1xuICAgIGlmIChpbml0aWFsU3RhdGUuY29uc3RydWN0b3IgPT09IEFycmF5ICYmIHRoaXMuX211bHRpICE9IG51bGwgJiYgdGhpcy5fbXVsdGkuY29uc3RydWN0b3IgPT09IEFycmF5KSB7XG4gICAgICAgIHRoaXMuX211bHRpLmxlbmd0aCA9IGluaXRpYWxTdGF0ZS5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbXVsdGkgPSBpbml0aWFsU3RhdGUuY29uc3RydWN0b3IgPT09IEFycmF5ID8gW10gOiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5fcXVldWUubGVuZ3RoID0gMDtcbiAgICB0aGlzLl9zdGFydGVkQXQgPSB0aGlzLmNvbnN0cnVjdG9yLkNsb2NrLm5vdygpO1xuICAgIHRoaXMuX3BhdXNlZEF0ID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRGVsYXlzIHRoZSBleGVjdXRpb24gb2YgdGhlIHN1YnNlcXVlbnQgdHJhbnNpdGlvbiBmb3IgYSBjZXJ0YWluIHBlcmlvZCBvZlxuICogdGltZS5cbiAqXG4gKiBAbWV0aG9kIGRlbGF5XG4gKiBAY2hhaW5hYmxlXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgZHVyYXRpb24gICAgZGVsYXkgdGltZSBpbiBtc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gICAgW2NhbGxiYWNrXSAgWmVyby1hcmd1bWVudCBmdW5jdGlvbiB0byBjYWxsIG9uIG9ic2VydmVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0aW9uICh0PTEpXG4gKiBAcmV0dXJuIHtUcmFuc2l0aW9uYWJsZX0gICAgICAgICB0aGlzXG4gKi9cblRyYW5zaXRpb25hYmxlLnByb3RvdHlwZS5kZWxheSA9IGZ1bmN0aW9uIGRlbGF5KGR1cmF0aW9uLCBjYWxsYmFjaykge1xuICAgIHZhciBlbmRTdGF0ZSA9IHRoaXMuX3F1ZXVlLmxlbmd0aCA+IDAgPyB0aGlzLl9xdWV1ZVt0aGlzLl9xdWV1ZS5sZW5ndGggLSA0XSA6IHRoaXMuX2VuZDtcbiAgICByZXR1cm4gdGhpcy50byhlbmRTdGF0ZSwgQ3VydmVzLmZsYXQsIGR1cmF0aW9uLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIE92ZXJyaWRlcyBjdXJyZW50IHRyYW5zaXRpb24uXG4gKlxuICogQG1ldGhvZCBvdmVycmlkZVxuICogQGNoYWluYWJsZVxuICpcbiAqIEBwYXJhbSAge051bWJlcnxBcnJheS5OdW1iZXJ9ICAgIFtmaW5hbFN0YXRlXSAgICBmaW5hbCBzdGF0ZSB0byB0cmFuc2l0b24gdG9cbiAqIEBwYXJhbSAge1N0cmluZ3xGdW5jdGlvbn0gICAgICAgIFtjdXJ2ZV0gICAgICAgICBlYXNpbmcgZnVuY3Rpb24gdXNlZCBmb3JcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnBvbGF0aW5nIFswLCAxXVxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgICAgICAgICAgICAgW2R1cmF0aW9uXSAgICAgIGR1cmF0aW9uIG9mIHRyYW5zaXRpb25cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSAgICAgICAgICAgICAgIFtjYWxsYmFja10gICAgICBjYWxsYmFjayBmdW5jdGlvbiB0byBiZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxlZCBhZnRlciB0aGUgdHJhbnNpdGlvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIGNvbXBsZXRlXG4gKiBAcmV0dXJuIHtUcmFuc2l0aW9uYWJsZX0gICAgICAgICB0aGlzXG4gKi9cblRyYW5zaXRpb25hYmxlLnByb3RvdHlwZS5vdmVycmlkZSA9IGZ1bmN0aW9uIG92ZXJyaWRlKGZpbmFsU3RhdGUsIGN1cnZlLCBkdXJhdGlvbiwgY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5fcXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoZmluYWxTdGF0ZSAhPSBudWxsKSB0aGlzLl9xdWV1ZVswXSA9IGZpbmFsU3RhdGU7XG4gICAgICAgIGlmIChjdXJ2ZSAhPSBudWxsKSAgICAgIHRoaXMuX3F1ZXVlWzFdID0gY3VydmUuY29uc3RydWN0b3IgPT09IFN0cmluZyA/IEN1cnZlc1tjdXJ2ZV0gOiBjdXJ2ZTtcbiAgICAgICAgaWYgKGR1cmF0aW9uICE9IG51bGwpICAgdGhpcy5fcXVldWVbMl0gPSBkdXJhdGlvbjtcbiAgICAgICAgaWYgKGNhbGxiYWNrICE9IG51bGwpICAgdGhpcy5fcXVldWVbM10gPSBjYWxsYmFjaztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5UcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUuX2ludGVycG9sYXRlID0gZnVuY3Rpb24gX2ludGVycG9sYXRlKGZyb20sIHRvLCBwcm9ncmVzcykge1xuICAgIGlmICh0aGlzLl9tdWx0aSkge1xuICAgICAgICBpZiAodGhpcy5fbWV0aG9kID09PSAnc2xlcnAnKSB7XG4gICAgICAgICAgICB2YXIgeCwgeSwgeiwgdztcbiAgICAgICAgICAgIHZhciBxeCwgcXksIHF6LCBxdztcbiAgICAgICAgICAgIHZhciBvbWVnYSwgY29zb21lZ2EsIHNpbm9tZWdhLCBzY2FsZUZyb20sIHNjYWxlVG87XG4gICAgICAgICAgICB2YXIgcmVzeCwgcmVzeSwgcmVzeiwgcmVzdztcblxuICAgICAgICAgICAgeCA9IGZyb21bMF07XG4gICAgICAgICAgICB5ID0gZnJvbVsxXTtcbiAgICAgICAgICAgIHogPSBmcm9tWzJdO1xuICAgICAgICAgICAgdyA9IGZyb21bM107XG5cbiAgICAgICAgICAgIHF4ID0gdG9bMF07XG4gICAgICAgICAgICBxeSA9IHRvWzFdO1xuICAgICAgICAgICAgcXogPSB0b1syXTtcbiAgICAgICAgICAgIHF3ID0gdG9bM107XG5cbiAgICAgICAgICAgIGNvc29tZWdhID0gdyAqIHF3ICsgeCAqIHF4ICsgeSAqIHF5ICsgeiAqIHF6O1xuICAgICAgICAgICAgaWYgKCgxLjAgLSBjb3NvbWVnYSkgPiAxZS01KSB7XG4gICAgICAgICAgICAgICAgb21lZ2EgPSBNYXRoLmFjb3MoY29zb21lZ2EpO1xuICAgICAgICAgICAgICAgIHNpbm9tZWdhID0gTWF0aC5zaW4ob21lZ2EpO1xuICAgICAgICAgICAgICAgIHNjYWxlRnJvbSA9IE1hdGguc2luKCgxLjAgLSBwcm9ncmVzcykgKiBvbWVnYSkgLyBzaW5vbWVnYTtcbiAgICAgICAgICAgICAgICBzY2FsZVRvID0gTWF0aC5zaW4ocHJvZ3Jlc3MgKiBvbWVnYSkgLyBzaW5vbWVnYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjYWxlRnJvbSA9IDEuMCAtIHByb2dyZXNzO1xuICAgICAgICAgICAgICAgIHNjYWxlVG8gPSBwcm9ncmVzcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fbXVsdGlbMF0gPSB4ICogc2NhbGVGcm9tICsgcXggKiBzY2FsZVRvO1xuICAgICAgICAgICAgdGhpcy5fbXVsdGlbMV0gPSB5ICogc2NhbGVGcm9tICsgcXkgKiBzY2FsZVRvO1xuICAgICAgICAgICAgdGhpcy5fbXVsdGlbMl0gPSB6ICogc2NhbGVGcm9tICsgcXogKiBzY2FsZVRvO1xuICAgICAgICAgICAgdGhpcy5fbXVsdGlbM10gPSB3ICogc2NhbGVGcm9tICsgcXcgKiBzY2FsZVRvO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0by5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuX211bHRpW2ldID0gZnJvbVtpXSArIHByb2dyZXNzICogKHRvW2ldIC0gZnJvbVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX211bHRpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmcm9tICsgcHJvZ3Jlc3MgKiAodG8gLSBmcm9tKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEdldCBpbnRlcnBvbGF0ZWQgc3RhdGUgb2YgY3VycmVudCBhY3Rpb24gYXQgcHJvdmlkZWQgdGltZS4gSWYgdGhlIGxhc3RcbiAqICAgIGFjdGlvbiBoYXMgY29tcGxldGVkLCBpbnZva2UgaXRzIGNhbGxiYWNrLlxuICpcbiAqIEBtZXRob2QgZ2V0XG4gKlxuICogQHBhcmFtIHtOdW1iZXI9fSB0aW1lc3RhbXAgRXZhbHVhdGUgdGhlIGN1cnZlIGF0IGEgbm9ybWFsaXplZCB2ZXJzaW9uIG9mIHRoaXNcbiAqICAgIHRpbWUuIElmIG9taXR0ZWQsIHVzZSBjdXJyZW50IHRpbWUuIChVbml4IGVwb2NoIHRpbWUpXG4gKiBAcmV0dXJuIHtOdW1iZXJ8QXJyYXkuTnVtYmVyfSBiZWdpbm5pbmcgc3RhdGVcbiAqICAgIGludGVycG9sYXRlZCB0byB0aGlzIHBvaW50IGluIHRpbWUuXG4gKi9cblRyYW5zaXRpb25hYmxlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQodCkge1xuICAgIHQgPSB0aGlzLl9wYXVzZWRBdCA/IHRoaXMuX3BhdXNlZEF0IDogdDtcbiAgICB0ID0gdCA/IHQgOiB0aGlzLmNvbnN0cnVjdG9yLkNsb2NrLm5vdygpO1xuICAgIGlmICh0aGlzLl9xdWV1ZS5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9lbmQ7XG5cbiAgICB2YXIgcHJvZ3Jlc3MgPSAodCAtIHRoaXMuX3N0YXJ0ZWRBdCkgLyB0aGlzLl9xdWV1ZVsyXTtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9pbnRlcnBvbGF0ZSh0aGlzLl9lbmQsIHRoaXMuX3F1ZXVlWzBdLCB0aGlzLl9xdWV1ZVsxXShwcm9ncmVzcyA+IDEgPyAxIDogcHJvZ3Jlc3MpLCB0aGlzLl9tZXRob2QpO1xuICAgIGlmIChwcm9ncmVzcyA+PSAxKSB7XG4gICAgICAgIHRoaXMuX3N0YXJ0ZWRBdCA9IHRoaXMuX3N0YXJ0ZWRBdCArIHRoaXMuX3F1ZXVlWzJdO1xuICAgICAgICB0aGlzLl9lbmQgPSB0aGlzLl9xdWV1ZS5zaGlmdCgpO1xuICAgICAgICB0aGlzLl9xdWV1ZS5zaGlmdCgpO1xuICAgICAgICB0aGlzLl9xdWV1ZS5zaGlmdCgpO1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLl9xdWV1ZS5zaGlmdCgpO1xuICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIHJldHVybiBwcm9ncmVzcyA+IDEgPyB0aGlzLmdldCgpIDogc3RhdGU7XG59O1xuXG4vKipcbiAqIElzIHRoZXJlIGF0IGxlYXN0IG9uZSB0cmFuc2l0aW9uIHBlbmRpbmcgY29tcGxldGlvbj9cbiAqXG4gKiBAbWV0aG9kIGlzQWN0aXZlXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuVHJhbnNpdGlvbmFibGUucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3F1ZXVlLmxlbmd0aCA+IDA7XG59O1xuXG4vKipcbiAqIEhhbHQgdHJhbnNpdGlvbiBhdCBjdXJyZW50IHN0YXRlIGFuZCBlcmFzZSBhbGwgcGVuZGluZyBhY3Rpb25zLlxuICpcbiAqIEBtZXRob2QgaGFsdFxuICogQGNoYWluYWJsZVxuICpcbiAqIEByZXR1cm4ge1RyYW5zaXRpb25hYmxlfSB0aGlzXG4gKi9cblRyYW5zaXRpb25hYmxlLnByb3RvdHlwZS5oYWx0ID0gZnVuY3Rpb24gaGFsdCgpIHtcbiAgICByZXR1cm4gdGhpcy5mcm9tKHRoaXMuZ2V0KCkpO1xufTtcblxuLyoqXG4gKiBQYXVzZSB0cmFuc2l0aW9uLiBUaGlzIHdpbGwgbm90IGVyYXNlIGFueSBhY3Rpb25zLlxuICpcbiAqIEBtZXRob2QgcGF1c2VcbiAqIEBjaGFpbmFibGVcbiAqXG4gKiBAcmV0dXJuIHtUcmFuc2l0aW9uYWJsZX0gdGhpc1xuICovXG5UcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICB0aGlzLl9wYXVzZWRBdCA9IHRoaXMuY29uc3RydWN0b3IuQ2xvY2subm93KCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEhhcyB0aGUgY3VycmVudCBhY3Rpb24gYmVlbiBwYXVzZWQ/XG4gKlxuICogQG1ldGhvZCBpc1BhdXNlZFxuICogQGNoYWluYWJsZVxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGlmIHRoZSBjdXJyZW50IGFjdGlvbiBoYXMgYmVlbiBwYXVzZWRcbiAqL1xuVHJhbnNpdGlvbmFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gaXNQYXVzZWQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fcGF1c2VkQXQ7XG59O1xuXG4vKipcbiAqIFJlc3VtZSB0cmFuc2l0aW9uLlxuICpcbiAqIEBtZXRob2QgcmVzdW1lXG4gKiBAY2hhaW5hYmxlXG4gKlxuICogQHJldHVybiB7VHJhbnNpdGlvbmFibGV9IHRoaXNcbiAqL1xuVHJhbnNpdGlvbmFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uIHJlc3VtZSgpIHtcbiAgICB2YXIgZGlmZiA9IHRoaXMuX3BhdXNlZEF0IC0gdGhpcy5fc3RhcnRlZEF0O1xuICAgIHRoaXMuX3N0YXJ0ZWRBdCA9IHRoaXMuY29uc3RydWN0b3IuQ2xvY2subm93KCkgLSBkaWZmO1xuICAgIHRoaXMuX3BhdXNlZEF0ID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FuY2VsIGFsbCB0cmFuc2l0aW9ucyBhbmQgcmVzZXQgdG8gYSBzdGFibGUgc3RhdGVcbiAqXG4gKiBAbWV0aG9kIHJlc2V0XG4gKiBAY2hhaW5hYmxlXG4gKiBAZGVwcmVjYXRlZCBVc2UgYC5mcm9tYCBpbnN0ZWFkIVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfEFycmF5Lk51bWJlcnxPYmplY3QuPG51bWJlciwgbnVtYmVyPn0gc3RhcnRTdGF0ZVxuICogICAgc3RhYmxlIHN0YXRlIHRvIHNldCB0b1xuICovXG5UcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbihzdGFydCkge1xuICAgIHJldHVybiB0aGlzLmZyb20oc3RhcnQpO1xufTtcblxuLyoqXG4gKiBBZGQgdHJhbnNpdGlvbiB0byBlbmQgc3RhdGUgdG8gdGhlIHF1ZXVlIG9mIHBlbmRpbmcgdHJhbnNpdGlvbnMuIFNwZWNpYWxcbiAqICAgIFVzZTogY2FsbGluZyB3aXRob3V0IGEgdHJhbnNpdGlvbiByZXNldHMgdGhlIG9iamVjdCB0byB0aGF0IHN0YXRlIHdpdGhcbiAqICAgIG5vIHBlbmRpbmcgYWN0aW9uc1xuICpcbiAqIEBtZXRob2Qgc2V0XG4gKiBAY2hhaW5hYmxlXG4gKiBAZGVwcmVjYXRlZCBVc2UgYC50b2AgaW5zdGVhZCFcbiAqXG4gKiBAcGFyYW0ge051bWJlcnxGYW1vdXNNYXRyaXh8QXJyYXkuTnVtYmVyfE9iamVjdC48bnVtYmVyLCBudW1iZXI+fSBlbmRTdGF0ZVxuICogICAgZW5kIHN0YXRlIHRvIHdoaWNoIHdlIGludGVycG9sYXRlXG4gKiBAcGFyYW0ge3RyYW5zaXRpb249fSB0cmFuc2l0aW9uIG9iamVjdCBvZiB0eXBlIHtkdXJhdGlvbjogbnVtYmVyLCBjdXJ2ZTpcbiAqICAgIGZbMCwxXSAtPiBbMCwxXSBvciBuYW1lfS4gSWYgdHJhbnNpdGlvbiBpcyBvbWl0dGVkLCBjaGFuZ2Ugd2lsbCBiZVxuICogICAgaW5zdGFudGFuZW91cy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKT19IGNhbGxiYWNrIFplcm8tYXJndW1lbnQgZnVuY3Rpb24gdG8gY2FsbCBvbiBvYnNlcnZlZFxuICogICAgY29tcGxldGlvbiAodD0xKVxuICovXG5UcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oc3RhdGUsIHRyYW5zaXRpb24sIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRyYW5zaXRpb24gPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmZyb20oc3RhdGUpO1xuICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50byhzdGF0ZSwgdHJhbnNpdGlvbi5jdXJ2ZSwgdHJhbnNpdGlvbi5kdXJhdGlvbiwgY2FsbGJhY2ssIHRyYW5zaXRpb24ubWV0aG9kKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zaXRpb25hYmxlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBDdXJ2ZXM6IHJlcXVpcmUoJy4vQ3VydmVzJyksXG4gICAgVHJhbnNpdGlvbmFibGU6IHJlcXVpcmUoJy4vVHJhbnNpdGlvbmFibGUnKVxufTtcbiIsIi8qanNoaW50IC1XMDA4ICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEN1cnZlcyA9IHtcbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgbGluZWFyXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBsaW5lYXI6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBlYXNlSW5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGVhc2VJbjogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gdCp0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgZWFzZU91dFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgZWFzZU91dDogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gdCooMi10KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGVhc2VJbk91dFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgZWFzZUluT3V0OiBmdW5jdGlvbih0KSB7XG4gICAgICAgIGlmICh0IDw9IDAuNSkgcmV0dXJuIDIqdCp0O1xuICAgICAgICBlbHNlIHJldHVybiAtMip0KnQgKyA0KnQgLSAxO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgZWFzZU91dEJvdW5jZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgZWFzZU91dEJvdW5jZTogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gdCooMyAtIDIqdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBzcHJpbmdcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIHNwcmluZzogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gKDEgLSB0KSAqIE1hdGguc2luKDYgKiBNYXRoLlBJICogdCkgKyB0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5RdWFkXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBpblF1YWQ6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIHQqdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IG91dFF1YWRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIG91dFF1YWQ6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIC0odC09MSkqdCsxO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5PdXRRdWFkXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBpbk91dFF1YWQ6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgaWYgKCh0Lz0uNSkgPCAxKSByZXR1cm4gLjUqdCp0O1xuICAgICAgICByZXR1cm4gLS41KigoLS10KSoodC0yKSAtIDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5DdWJpY1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgaW5DdWJpYzogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gdCp0KnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBvdXRDdWJpY1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgb3V0Q3ViaWM6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuICgoLS10KSp0KnQgKyAxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGluT3V0Q3ViaWNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGluT3V0Q3ViaWM6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgaWYgKCh0Lz0uNSkgPCAxKSByZXR1cm4gLjUqdCp0KnQ7XG4gICAgICAgIHJldHVybiAuNSooKHQtPTIpKnQqdCArIDIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5RdWFydFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgaW5RdWFydDogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gdCp0KnQqdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IG91dFF1YXJ0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBvdXRRdWFydDogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gLSgoLS10KSp0KnQqdCAtIDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5PdXRRdWFydFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgaW5PdXRRdWFydDogZnVuY3Rpb24odCkge1xuICAgICAgICBpZiAoKHQvPS41KSA8IDEpIHJldHVybiAuNSp0KnQqdCp0O1xuICAgICAgICByZXR1cm4gLS41ICogKCh0LT0yKSp0KnQqdCAtIDIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5RdWludFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgaW5RdWludDogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gdCp0KnQqdCp0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgb3V0UXVpbnRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIG91dFF1aW50OiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiAoKC0tdCkqdCp0KnQqdCArIDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5PdXRRdWludFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgaW5PdXRRdWludDogZnVuY3Rpb24odCkge1xuICAgICAgICBpZiAoKHQvPS41KSA8IDEpIHJldHVybiAuNSp0KnQqdCp0KnQ7XG4gICAgICAgIHJldHVybiAuNSooKHQtPTIpKnQqdCp0KnQgKyAyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGluU2luZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgaW5TaW5lOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiAtMS4wKk1hdGguY29zKHQgKiAoTWF0aC5QSS8yKSkgKyAxLjA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBvdXRTaW5lXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBvdXRTaW5lOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNpbih0ICogKE1hdGguUEkvMikpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5PdXRTaW5lXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBpbk91dFNpbmU6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIC0uNSooTWF0aC5jb3MoTWF0aC5QSSp0KSAtIDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5FeHBvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBpbkV4cG86IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuICh0PT09MCkgPyAwLjAgOiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgb3V0RXhwb1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgb3V0RXhwbzogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gKHQ9PT0xLjApID8gMS4wIDogKC1NYXRoLnBvdygyLCAtMTAgKiB0KSArIDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5PdXRFeHBvXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBpbk91dEV4cG86IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgaWYgKHQ9PT0wKSByZXR1cm4gMC4wO1xuICAgICAgICBpZiAodD09PTEuMCkgcmV0dXJuIDEuMDtcbiAgICAgICAgaWYgKCh0Lz0uNSkgPCAxKSByZXR1cm4gLjUgKiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpO1xuICAgICAgICByZXR1cm4gLjUgKiAoLU1hdGgucG93KDIsIC0xMCAqIC0tdCkgKyAyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGluQ2lyY1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgaW5DaXJjOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiAtKE1hdGguc3FydCgxIC0gdCp0KSAtIDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgb3V0Q2lyY1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgb3V0Q2lyYzogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KDEgLSAoLS10KSp0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGluT3V0Q2lyY1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgaW5PdXRDaXJjOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIGlmICgodC89LjUpIDwgMSkgcmV0dXJuIC0uNSAqIChNYXRoLnNxcnQoMSAtIHQqdCkgLSAxKTtcbiAgICAgICAgcmV0dXJuIC41ICogKE1hdGguc3FydCgxIC0gKHQtPTIpKnQpICsgMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpbkVsYXN0aWNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGluRWxhc3RpYzogZnVuY3Rpb24odCkge1xuICAgICAgICB2YXIgcz0xLjcwMTU4O3ZhciBwPTA7dmFyIGE9MS4wO1xuICAgICAgICBpZiAodD09PTApIHJldHVybiAwLjA7ICBpZiAodD09PTEpIHJldHVybiAxLjA7ICBpZiAoIXApIHA9LjM7XG4gICAgICAgIHMgPSBwLygyKk1hdGguUEkpICogTWF0aC5hc2luKDEuMC9hKTtcbiAgICAgICAgcmV0dXJuIC0oYSpNYXRoLnBvdygyLDEwKih0LT0xKSkgKiBNYXRoLnNpbigodC1zKSooMipNYXRoLlBJKS8gcCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgb3V0RWxhc3RpY1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgb3V0RWxhc3RpYzogZnVuY3Rpb24odCkge1xuICAgICAgICB2YXIgcz0xLjcwMTU4O3ZhciBwPTA7dmFyIGE9MS4wO1xuICAgICAgICBpZiAodD09PTApIHJldHVybiAwLjA7ICBpZiAodD09PTEpIHJldHVybiAxLjA7ICBpZiAoIXApIHA9LjM7XG4gICAgICAgIHMgPSBwLygyKk1hdGguUEkpICogTWF0aC5hc2luKDEuMC9hKTtcbiAgICAgICAgcmV0dXJuIGEqTWF0aC5wb3coMiwtMTAqdCkgKiBNYXRoLnNpbigodC1zKSooMipNYXRoLlBJKS9wKSArIDEuMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGluT3V0RWxhc3RpY1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgaW5PdXRFbGFzdGljOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHZhciBzPTEuNzAxNTg7dmFyIHA9MDt2YXIgYT0xLjA7XG4gICAgICAgIGlmICh0PT09MCkgcmV0dXJuIDAuMDsgIGlmICgodC89LjUpPT09MikgcmV0dXJuIDEuMDsgIGlmICghcCkgcD0oLjMqMS41KTtcbiAgICAgICAgcyA9IHAvKDIqTWF0aC5QSSkgKiBNYXRoLmFzaW4oMS4wL2EpO1xuICAgICAgICBpZiAodCA8IDEpIHJldHVybiAtLjUqKGEqTWF0aC5wb3coMiwxMCoodC09MSkpICogTWF0aC5zaW4oKHQtcykqKDIqTWF0aC5QSSkvcCkpO1xuICAgICAgICByZXR1cm4gYSpNYXRoLnBvdygyLC0xMCoodC09MSkpICogTWF0aC5zaW4oKHQtcykqKDIqTWF0aC5QSSkvcCkqLjUgKyAxLjA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpbkJhY2tcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGluQmFjazogZnVuY3Rpb24odCwgcykge1xuICAgICAgICBpZiAocyA9PT0gdW5kZWZpbmVkKSBzID0gMS43MDE1ODtcbiAgICAgICAgcmV0dXJuIHQqdCooKHMrMSkqdCAtIHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgb3V0QmFja1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgb3V0QmFjazogZnVuY3Rpb24odCwgcykge1xuICAgICAgICBpZiAocyA9PT0gdW5kZWZpbmVkKSBzID0gMS43MDE1ODtcbiAgICAgICAgcmV0dXJuICgoLS10KSp0KigocysxKSp0ICsgcykgKyAxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGluT3V0QmFja1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgaW5PdXRCYWNrOiBmdW5jdGlvbih0LCBzKSB7XG4gICAgICAgIGlmIChzID09PSB1bmRlZmluZWQpIHMgPSAxLjcwMTU4O1xuICAgICAgICBpZiAoKHQvPS41KSA8IDEpIHJldHVybiAuNSoodCp0KigoKHMqPSgxLjUyNSkpKzEpKnQgLSBzKSk7XG4gICAgICAgIHJldHVybiAuNSooKHQtPTIpKnQqKCgocyo9KDEuNTI1KSkrMSkqdCArIHMpICsgMik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpbkJvdW5jZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgaW5Cb3VuY2U6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIDEuMCAtIEN1cnZlcy5vdXRCb3VuY2UoMS4wLXQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgb3V0Qm91bmNlXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBvdXRCb3VuY2U6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgaWYgKHQgPCAoMS8yLjc1KSkge1xuICAgICAgICAgICAgcmV0dXJuICg3LjU2MjUqdCp0KTtcbiAgICAgICAgfSBlbHNlIGlmICh0IDwgKDIvMi43NSkpIHtcbiAgICAgICAgICAgIHJldHVybiAoNy41NjI1Kih0LT0oMS41LzIuNzUpKSp0ICsgLjc1KTtcbiAgICAgICAgfSBlbHNlIGlmICh0IDwgKDIuNS8yLjc1KSkge1xuICAgICAgICAgICAgcmV0dXJuICg3LjU2MjUqKHQtPSgyLjI1LzIuNzUpKSp0ICsgLjkzNzUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICg3LjU2MjUqKHQtPSgyLjYyNS8yLjc1KSkqdCArIC45ODQzNzUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpbk91dEJvdW5jZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgaW5PdXRCb3VuY2U6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgaWYgKHQgPCAuNSkgcmV0dXJuIEN1cnZlcy5pbkJvdW5jZSh0KjIpICogLjU7XG4gICAgICAgIHJldHVybiBDdXJ2ZXMub3V0Qm91bmNlKHQqMi0xLjApICogLjUgKyAuNTtcbiAgICB9LFxuXG4gICAgZmxhdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ3VydmVzO1xuIiwiLypqc2hpbnQgLVcwMDggKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2RlZmF1bHRDdXJ2ZXMgPSB7XG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGxpbmVhclxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgbGluZWFyOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgZWFzZUluXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBlYXNlSW46IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIHQqdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGVhc2VPdXRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGVhc2VPdXQ6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIHQqKDItdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBlYXNlSW5PdXRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGVhc2VJbk91dDogZnVuY3Rpb24odCkge1xuICAgICAgICBpZiAodCA8PSAwLjUpIHJldHVybiAyKnQqdDtcbiAgICAgICAgZWxzZSByZXR1cm4gLTIqdCp0ICsgNCp0IC0gMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGVhc2VPdXRCb3VuY2VcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGVhc2VPdXRCb3VuY2U6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIHQqKDMgLSAyKnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgc3ByaW5nXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBzcHJpbmc6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuICgxIC0gdCkgKiBNYXRoLnNpbig2ICogTWF0aC5QSSAqIHQpICsgdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGluUXVhZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgaW5RdWFkOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0KnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBvdXRRdWFkXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBvdXRRdWFkOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiAtKHQtPTEpKnQrMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGluT3V0UXVhZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgaW5PdXRRdWFkOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIGlmICgodC89LjUpIDwgMSkgcmV0dXJuIC41KnQqdDtcbiAgICAgICAgcmV0dXJuIC0uNSooKC0tdCkqKHQtMikgLSAxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGluQ3ViaWNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGluQ3ViaWM6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIHQqdCp0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgb3V0Q3ViaWNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIG91dEN1YmljOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiAoKC0tdCkqdCp0ICsgMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpbk91dEN1YmljXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBpbk91dEN1YmljOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIGlmICgodC89LjUpIDwgMSkgcmV0dXJuIC41KnQqdCp0O1xuICAgICAgICByZXR1cm4gLjUqKCh0LT0yKSp0KnQgKyAyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGluUXVhcnRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGluUXVhcnQ6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIHQqdCp0KnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBvdXRRdWFydFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgb3V0UXVhcnQ6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIC0oKC0tdCkqdCp0KnQgLSAxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGluT3V0UXVhcnRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGluT3V0UXVhcnQ6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgaWYgKCh0Lz0uNSkgPCAxKSByZXR1cm4gLjUqdCp0KnQqdDtcbiAgICAgICAgcmV0dXJuIC0uNSAqICgodC09MikqdCp0KnQgLSAyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGluUXVpbnRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGluUXVpbnQ6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIHQqdCp0KnQqdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IG91dFF1aW50XG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBvdXRRdWludDogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gKCgtLXQpKnQqdCp0KnQgKyAxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGluT3V0UXVpbnRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGluT3V0UXVpbnQ6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgaWYgKCh0Lz0uNSkgPCAxKSByZXR1cm4gLjUqdCp0KnQqdCp0O1xuICAgICAgICByZXR1cm4gLjUqKCh0LT0yKSp0KnQqdCp0ICsgMik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpblNpbmVcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGluU2luZTogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gLTEuMCpNYXRoLmNvcyh0ICogKE1hdGguUEkvMikpICsgMS4wO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgb3V0U2luZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgb3V0U2luZTogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gTWF0aC5zaW4odCAqIChNYXRoLlBJLzIpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGluT3V0U2luZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgaW5PdXRTaW5lOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiAtLjUqKE1hdGguY29zKE1hdGguUEkqdCkgLSAxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGluRXhwb1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgaW5FeHBvOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiAodD09PTApID8gMC4wIDogTWF0aC5wb3coMiwgMTAgKiAodCAtIDEpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IG91dEV4cG9cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIG91dEV4cG86IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuICh0PT09MS4wKSA/IDEuMCA6ICgtTWF0aC5wb3coMiwgLTEwICogdCkgKyAxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGluT3V0RXhwb1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgaW5PdXRFeHBvOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIGlmICh0PT09MCkgcmV0dXJuIDAuMDtcbiAgICAgICAgaWYgKHQ9PT0xLjApIHJldHVybiAxLjA7XG4gICAgICAgIGlmICgodC89LjUpIDwgMSkgcmV0dXJuIC41ICogTWF0aC5wb3coMiwgMTAgKiAodCAtIDEpKTtcbiAgICAgICAgcmV0dXJuIC41ICogKC1NYXRoLnBvdygyLCAtMTAgKiAtLXQpICsgMik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpbkNpcmNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGluQ2lyYzogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gLShNYXRoLnNxcnQoMSAtIHQqdCkgLSAxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IG91dENpcmNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIG91dENpcmM6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCgxIC0gKC0tdCkqdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpbk91dENpcmNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGluT3V0Q2lyYzogZnVuY3Rpb24odCkge1xuICAgICAgICBpZiAoKHQvPS41KSA8IDEpIHJldHVybiAtLjUgKiAoTWF0aC5zcXJ0KDEgLSB0KnQpIC0gMSk7XG4gICAgICAgIHJldHVybiAuNSAqIChNYXRoLnNxcnQoMSAtICh0LT0yKSp0KSArIDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5FbGFzdGljXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBpbkVsYXN0aWM6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdmFyIHM9MS43MDE1ODt2YXIgcD0wO3ZhciBhPTEuMDtcbiAgICAgICAgaWYgKHQ9PT0wKSByZXR1cm4gMC4wOyAgaWYgKHQ9PT0xKSByZXR1cm4gMS4wOyAgaWYgKCFwKSBwPS4zO1xuICAgICAgICBzID0gcC8oMipNYXRoLlBJKSAqIE1hdGguYXNpbigxLjAvYSk7XG4gICAgICAgIHJldHVybiAtKGEqTWF0aC5wb3coMiwxMCoodC09MSkpICogTWF0aC5zaW4oKHQtcykqKDIqTWF0aC5QSSkvIHApKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IG91dEVsYXN0aWNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIG91dEVsYXN0aWM6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdmFyIHM9MS43MDE1ODt2YXIgcD0wO3ZhciBhPTEuMDtcbiAgICAgICAgaWYgKHQ9PT0wKSByZXR1cm4gMC4wOyAgaWYgKHQ9PT0xKSByZXR1cm4gMS4wOyAgaWYgKCFwKSBwPS4zO1xuICAgICAgICBzID0gcC8oMipNYXRoLlBJKSAqIE1hdGguYXNpbigxLjAvYSk7XG4gICAgICAgIHJldHVybiBhKk1hdGgucG93KDIsLTEwKnQpICogTWF0aC5zaW4oKHQtcykqKDIqTWF0aC5QSSkvcCkgKyAxLjA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpbk91dEVsYXN0aWNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGluT3V0RWxhc3RpYzogZnVuY3Rpb24odCkge1xuICAgICAgICB2YXIgcz0xLjcwMTU4O3ZhciBwPTA7dmFyIGE9MS4wO1xuICAgICAgICBpZiAodD09PTApIHJldHVybiAwLjA7ICBpZiAoKHQvPS41KT09PTIpIHJldHVybiAxLjA7ICBpZiAoIXApIHA9KC4zKjEuNSk7XG4gICAgICAgIHMgPSBwLygyKk1hdGguUEkpICogTWF0aC5hc2luKDEuMC9hKTtcbiAgICAgICAgaWYgKHQgPCAxKSByZXR1cm4gLS41KihhKk1hdGgucG93KDIsMTAqKHQtPTEpKSAqIE1hdGguc2luKCh0LXMpKigyKk1hdGguUEkpL3ApKTtcbiAgICAgICAgcmV0dXJuIGEqTWF0aC5wb3coMiwtMTAqKHQtPTEpKSAqIE1hdGguc2luKCh0LXMpKigyKk1hdGguUEkpL3ApKi41ICsgMS4wO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5CYWNrXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBpbkJhY2s6IGZ1bmN0aW9uKHQsIHMpIHtcbiAgICAgICAgaWYgKHMgPT09IHVuZGVmaW5lZCkgcyA9IDEuNzAxNTg7XG4gICAgICAgIHJldHVybiB0KnQqKChzKzEpKnQgLSBzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IG91dEJhY2tcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIG91dEJhY2s6IGZ1bmN0aW9uKHQsIHMpIHtcbiAgICAgICAgaWYgKHMgPT09IHVuZGVmaW5lZCkgcyA9IDEuNzAxNTg7XG4gICAgICAgIHJldHVybiAoKC0tdCkqdCooKHMrMSkqdCArIHMpICsgMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpbk91dEJhY2tcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGluT3V0QmFjazogZnVuY3Rpb24odCwgcykge1xuICAgICAgICBpZiAocyA9PT0gdW5kZWZpbmVkKSBzID0gMS43MDE1ODtcbiAgICAgICAgaWYgKCh0Lz0uNSkgPCAxKSByZXR1cm4gLjUqKHQqdCooKChzKj0oMS41MjUpKSsxKSp0IC0gcykpO1xuICAgICAgICByZXR1cm4gLjUqKCh0LT0yKSp0KigoKHMqPSgxLjUyNSkpKzEpKnQgKyBzKSArIDIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5Cb3VuY2VcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGluQm91bmNlOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiAxLjAgLSBfZGVmYXVsdEN1cnZlcy5vdXRCb3VuY2UoMS4wLXQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgb3V0Qm91bmNlXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBvdXRCb3VuY2U6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgaWYgKHQgPCAoMS8yLjc1KSkge1xuICAgICAgICAgICAgcmV0dXJuICg3LjU2MjUqdCp0KTtcbiAgICAgICAgfSBlbHNlIGlmICh0IDwgKDIvMi43NSkpIHtcbiAgICAgICAgICAgIHJldHVybiAoNy41NjI1Kih0LT0oMS41LzIuNzUpKSp0ICsgLjc1KTtcbiAgICAgICAgfSBlbHNlIGlmICh0IDwgKDIuNS8yLjc1KSkge1xuICAgICAgICAgICAgcmV0dXJuICg3LjU2MjUqKHQtPSgyLjI1LzIuNzUpKSp0ICsgLjkzNzUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICg3LjU2MjUqKHQtPSgyLjYyNS8yLjc1KSkqdCArIC45ODQzNzUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpbk91dEJvdW5jZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgaW5PdXRCb3VuY2U6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgaWYgKHQgPCAuNSkgcmV0dXJuIF9kZWZhdWx0Q3VydmVzLmluQm91bmNlKHQqMikgKiAuNTtcbiAgICAgICAgcmV0dXJuIF9kZWZhdWx0Q3VydmVzLm91dEJvdW5jZSh0KjItMS4wKSAqIC41ICsgLjU7XG4gICAgfVxufTtcblxudmFyIF9jdXJ2ZXMgPSBPYmplY3QuY3JlYXRlKF9kZWZhdWx0Q3VydmVzKTtcblxuLypcbiAqIEEgbGlicmFyeSBvZiBjdXJ2ZXMgd2hpY2ggbWFwIGFuIGFuaW1hdGlvbiBleHBsaWNpdGx5IGFzIGEgZnVuY3Rpb24gb2YgdGltZS5cbiAqICAgIFRoZSBmb2xsb3dpbmcgZWFzaW5nIGN1cnZlcyBhcmUgYXZhaWxhYmxlIGJ5IGRlZmF1bHQgYW5kIGNhbiBub3QgYmVcbiAqICAgIHVucmVnaXN0ZXJlZCBvciBvdmVyd3JpdHRlbjpcbiAqXG4gKiAgICBsaW5lYXIsXG4gKiAgICBlYXNlSW4sIGVhc2VPdXQsIGVhc2VJbk91dCxcbiAqICAgIGVhc2VPdXRCb3VuY2UsXG4gKiAgICBzcHJpbmcsXG4gKiAgICBpblF1YWQsIG91dFF1YWQsIGluT3V0UXVhZCxcbiAqICAgIGluQ3ViaWMsIG91dEN1YmljLCBpbk91dEN1YmljLFxuICogICAgaW5RdWFydCwgb3V0UXVhcnQsIGluT3V0UXVhcnQsXG4gKiAgICBpblF1aW50LCBvdXRRdWludCwgaW5PdXRRdWludCxcbiAqICAgIGluU2luZSwgb3V0U2luZSwgaW5PdXRTaW5lLFxuICogICAgaW5FeHBvLCBvdXRFeHBvLCBpbk91dEV4cG8sXG4gKiAgICBpbkNpcmMsIG91dENpcmMsIGluT3V0Q2lyYyxcbiAqICAgIGluRWxhc3RpYywgb3V0RWxhc3RpYywgaW5PdXRFbGFzdGljLFxuICogICAgaW5CYWNrLCBvdXRCYWNrLCBpbk91dEJhY2ssXG4gKiAgICBpbkJvdW5jZSwgb3V0Qm91bmNlLCBpbk91dEJvdW5jZVxuICpcbiAqIEBjbGFzcyBFYXNpbmdcbiAqIEBkZXByZWNhdGVkIFVzZSBjdXJ2ZXMgaW5zdGVhZFxuICovXG52YXIgRWFzaW5nID0ge1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGdpdmVuIGN1cnZlIHRvIGJlIGF2YWlsYWJsZSBpbiBzdWJzZXF1ZW50IHRyYW5zaXRpb25zIGJ5XG4gICAgICogICAgYWRkaW5nIGl0IHRvIHRoZSBpbnRlcmFsIGRpY3Rpb25hcnkgb2YgcmVnaXN0ZXJlZCBjdXJ2ZXMuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHJlZ2lzdGVyQ3VydmVcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICogQHN0YXRpY1xuICAgICAqXG4gICAgICogQHRocm93cyB7RXJyb3J9IFdpbGwgdGhyb3cgYW4gZXJyb3Igd2hlbiBhdHRlbXB0aW5nIHRvIG92ZXJ3cml0ZSBkZWZhdWx0XG4gICAgICogICAgY3VydmUuXG4gICAgICogQHRocm93cyB7RXJyb3J9IFdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgY3VydmUgaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgdW5pcXVlIG5hbWUgZm9yIGxhdGVyIGFjY2Vzc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1cnZlIGZ1bmN0aW9uIG9mIG9uZSBudW1lcmljIHZhcmlhYmxlIG1hcHBpbmcgWzAsMV1cbiAgICAgKiAgICB0byByYW5nZSBpbnNpZGUgWzAsMV1cbiAgICAgKiBAcmV0dXJuIHtFYXNpbmd9IHRoaXNcbiAgICAgKi9cbiAgICByZWdpc3RlckN1cnZlOiBmdW5jdGlvbihuYW1lLCBjdXJ2ZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0Vhc2luZyBpcyBkZXByZWNhdGVkISBVc2UgdHJhbnNpdGlvbnMuQ3VydmVzIGluc3RlYWQhJyk7XG4gICAgICAgIGlmIChfZGVmYXVsdEN1cnZlc1tuYW1lXSkgdGhyb3cgbmV3IEVycm9yKCdEZWZhdWx0IGN1cnZlcyBjYW4gbm90IGJlIG92ZXJ3cml0dGVuJyk7XG4gICAgICAgIGlmIChfY3VydmVzW25hbWVdKSB0aHJvdyBuZXcgRXJyb3IoJ0N1cnZlIGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZCcpO1xuICAgICAgICBfY3VydmVzW25hbWVdID0gY3VydmU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbnJlZ2lzdGVycyB0aGUgY3VydmUgcmVnaXN0ZXJlZCB1bmRlciB0aGUgZ2l2ZW4gbmFtZSBieSByZW1vdmluZyBpdCBmcm9tXG4gICAgICogICAgdGhlIGludGVybmFsIGRpY3Rpb25hcnkgb2YgcmVnaXN0ZXJlZCBjdXJ2ZXMuIFRoaXMgd29uJ3QgZWZmZWN0XG4gICAgICogICAgY3VycmVudGx5IGFjdGl2ZSB0cmFuc2l0aW9ucy5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgdW5yZWdpc3RlckN1cnZlXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBXaWxsIHRocm93IGFuIGVycm9yIGlmIGN1cnZlIGRvZXMgbm90IGV4aXN0LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG5hbWUgb2YgY3VydmVcbiAgICAgKiBAcmV0dXJuIHtFYXNpbmd9IHRoaXNcbiAgICAgKi9cbiAgICB1bnJlZ2lzdGVyQ3VydmU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdFYXNpbmcgaXMgZGVwcmVjYXRlZCEgVXNlIHRyYW5zaXRpb25zLkN1cnZlcyBpbnN0ZWFkIScpO1xuICAgICAgICBpZiAoX2RlZmF1bHRDdXJ2ZXNbbmFtZV0pIHRocm93IG5ldyBFcnJvcignRGVmYXVsdCBjdXJ2ZXMgY2FuIG5vdCBiZSB1bnJlZ2lzdGVyZWQnKTtcbiAgICAgICAgaWYgKCFfY3VydmVzW25hbWVdKSB0aHJvdyBuZXcgRXJyb3IoJ0N1cnZlIGhhcyBub3QgYmVlbiByZWdpc3RlcmVkJyk7XG4gICAgICAgIGRlbGV0ZSBfY3VydmVzW25hbWVdO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZWFzaW5nIGN1cnZlIHdpdGggdGhlIGdpdmVuIG5hbWUuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldEN1cnZlXG4gICAgICogQHN0YXRpY1xuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgbmFtZSBvZiBjdXJ2ZVxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBjdXJ2ZSBmdW5jdGlvbiBvZiBvbmUgbnVtZXJpYyB2YXJpYWJsZSBtYXBwaW5nIFswLDFdXG4gICAgICogICAgdG8gcmFuZ2UgaW5zaWRlIFswLDFdXG4gICAgICovXG4gICAgZ2V0Q3VydmU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdFYXNpbmcgaXMgZGVwcmVjYXRlZCEgVXNlIHRyYW5zaXRpb25zLkN1cnZlcyBpbnN0ZWFkIScpO1xuICAgICAgICByZXR1cm4gX2N1cnZlc1tuYW1lXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBuYW1lcyBvZiBhbGwgcHJldmlvdXNseSByZWdpc3RlcmVkIGVhc2luZyBjdXJ2ZXMuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldEN1cnZlc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ1tdfSBhcnJheSBvZiByZWdpc3RlcmVkIGVhc2luZyBjdXJ2ZXNcbiAgICAgKi9cbiAgICBnZXRDdXJ2ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0Vhc2luZyBpcyBkZXByZWNhdGVkISBVc2UgdHJhbnNpdGlvbnMuQ3VydmVzIGluc3RlYWQhJyk7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhfZGVmYXVsdEN1cnZlcykuY29uY2F0KE9iamVjdC5rZXlzKF9jdXJ2ZXMpKTtcbiAgICB9LFxuXG4gICAgY3JlYXRlQmV6aWVyQ3VydmU6IGZ1bmN0aW9uKHYxLCB2Mikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0Vhc2luZyBpcyBkZXByZWNhdGVkISBVc2UgdHJhbnNpdGlvbnMuQ3VydmVzIGluc3RlYWQhJyk7XG4gICAgICAgIHYxID0gdjEgfHwgMDsgdjIgPSB2MiB8fCAwO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgcmV0dXJuIHYxKnQgKyAoLTIqdjEgLSB2MiArIDMpKnQqdCArICh2MSArIHYyIC0gMikqdCp0KnQ7XG4gICAgICAgIH07XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFYXNpbmc7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDdXJ2ZXMgPSByZXF1aXJlKCcuL0N1cnZlcycpO1xuXG4vKipcbiAqIEEgc3RhdGUgbWFpbnRhaW5lciBmb3IgYSBzbW9vdGggdHJhbnNpdGlvbiBiZXR3ZWVuXG4gKiAgICBudW1lcmljYWxseS1zcGVjaWZpZWQgc3RhdGVzLiBFeGFtcGxlIG51bWVyaWMgc3RhdGVzIGluY2x1ZGUgZmxvYXRzIGFuZFxuICogICAgYXJyYXlzIG9mIGZsb2F0cyBvYmplY3RzLlxuICpcbiAqIEFuIGluaXRpYWwgc3RhdGUgaXMgc2V0IHdpdGggdGhlIGNvbnN0cnVjdG9yIG9yIHVzaW5nXG4gKiAgICAge0BsaW5rIFRyYW5zaXRpb25hYmxlI2Zyb219LiBTdWJzZXF1ZW50IHRyYW5zaXRpb25zIGNvbnNpc3Qgb2YgYW5cbiAqICAgICBpbnRlcm1lZGlhdGUgc3RhdGUsIGVhc2luZyBjdXJ2ZSwgZHVyYXRpb24gYW5kIGNhbGxiYWNrLiBUaGUgZmluYWwgc3RhdGVcbiAqICAgICBvZiBlYWNoIHRyYW5zaXRpb24gaXMgdGhlIGluaXRpYWwgc3RhdGUgb2YgdGhlIHN1YnNlcXVlbnQgb25lLiBDYWxscyB0b1xuICogICAgIHtAbGluayBUcmFuc2l0aW9uYWJsZSNnZXR9IHByb3ZpZGUgdGhlIGludGVycG9sYXRlZCBzdGF0ZSBhbG9uZyB0aGUgd2F5LlxuICpcbiAqIE5vdGUgdGhhdCB0aGVyZSBpcyBubyBldmVudCBsb29wIGhlcmUgLSBjYWxscyB0byB7QGxpbmsgVHJhbnNpdGlvbmFibGUjZ2V0fVxuICogICAgYXJlIHRoZSBvbmx5IHdheSB0byBmaW5kIHN0YXRlIHByb2plY3RlZCB0byB0aGUgY3VycmVudCAob3IgcHJvdmlkZWQpXG4gKiAgICB0aW1lIGFuZCBhcmUgdGhlIG9ubHkgd2F5IHRvIHRyaWdnZXIgY2FsbGJhY2tzIGFuZCBtdXRhdGUgdGhlIGludGVybmFsXG4gKiAgICB0cmFuc2l0aW9uIHF1ZXVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgdCA9IG5ldyBUcmFuc2l0aW9uYWJsZShbMCwgMF0pO1xuICogdFxuICogICAgIC50byhbMTAwLCAwXSwgJ2xpbmVhcicsIDEwMDApXG4gKiAgICAgLmRlbGF5KDEwMDApXG4gKiAgICAgLnRvKFsyMDAsIDBdLCAnb3V0Qm91bmNlJywgMTAwMCk7XG4gKlxuICogdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICogZGl2LnN0eWxlLmJhY2tncm91bmQgPSAnYmx1ZSc7XG4gKiBkaXYuc3R5bGUud2lkdGggPSAnMTAwcHgnO1xuICogZGl2LnN0eWxlLmhlaWdodCA9ICcxMDBweCc7XG4gKiBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG4gKlxuICogZGl2LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gKiAgICAgdC5pc1BhdXNlZCgpID8gdC5yZXN1bWUoKSA6IHQucGF1c2UoKTtcbiAqIH0pO1xuICpcbiAqIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiBsb29wKCkge1xuICogICAgIGRpdi5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlWCgnICsgdC5nZXQoKVswXSArICdweCknICsgJyB0cmFuc2xhdGVZKCcgKyB0LmdldCgpWzFdICsgJ3B4KSc7XG4gKiAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApO1xuICogfSk7XG4gKlxuICogQGNsYXNzIFRyYW5zaXRpb25hYmxlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfEFycmF5Lk51bWJlcn0gaW5pdGlhbFN0YXRlICAgIGluaXRpYWwgc3RhdGUgdG8gdHJhbnNpdGlvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSAtIGVxdWl2YWxlbnQgdG8gYSBwdXJzdWFudFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW52b2NhdGlvbiBvZlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge0BsaW5rIFRyYW5zaXRpb25hYmxlI2Zyb219XG4gKi9cbmZ1bmN0aW9uIFRyYW5zaXRpb25hYmxlKGluaXRpYWxTdGF0ZSkge1xuICAgIHRoaXMuX3F1ZXVlID0gW107XG4gICAgdGhpcy5fbXVsdGkgPSBudWxsO1xuICAgIHRoaXMuX2VuZCA9IG51bGw7XG4gICAgdGhpcy5fc3RhcnRlZEF0ID0gbnVsbDtcbiAgICB0aGlzLl9wYXVzZWRBdCA9IG51bGw7XG4gICAgaWYgKGluaXRpYWxTdGF0ZSAhPSBudWxsKSB0aGlzLmZyb20oaW5pdGlhbFN0YXRlKTtcbn1cblxuLyoqXG4gKiBJbnRlcm5hbCBDbG9jayB1c2VkIGZvciBkZXRlcm1pbmluZyB0aGUgY3VycmVudCB0aW1lIGZvciB0aGUgb25nb2luZ1xuICogdHJhbnNpdGlvbnMuXG4gKlxuICogQHR5cGUge1BlcmZvcm1hbmNlfERhdGV8T2JqZWN0fVxuICovXG5UcmFuc2l0aW9uYWJsZS5DbG9jayA9IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCcgPyBwZXJmb3JtYW5jZSA6IERhdGU7XG5cbi8qKlxuICogUmVnaXN0ZXJzIGEgdHJhbnNpdGlvbiB0byBiZSBwdXNoZWQgb250byB0aGUgaW50ZXJuYWwgcXVldWUuXG4gKlxuICogQG1ldGhvZCB0b1xuICogQGNoYWluYWJsZVxuICpcbiAqIEBwYXJhbSAge051bWJlcnxBcnJheS5OdW1iZXJ9ICAgIGZpbmFsU3RhdGUgICAgICAgICAgICAgIGZpbmFsIHN0YXRlIHRvXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0b24gdG9cbiAqIEBwYXJhbSAge1N0cmluZ3xGdW5jdGlvbn0gICAgICAgIFtjdXJ2ZT1DdXJ2ZXMubGluZWFyXSAgIGVhc2luZyBmdW5jdGlvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlZCBmb3JcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVycG9sYXRpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFswLCAxXVxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgICAgICAgICAgICAgW2R1cmF0aW9uPTEwMF0gICAgICAgICAgZHVyYXRpb24gb2ZcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSAgICAgICAgICAgICAgIFtjYWxsYmFja10gICAgICAgICAgICAgIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBiZSBjYWxsZWQgYWZ0ZXJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSB0cmFuc2l0aW9uIGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZVxuICogQHJldHVybiB7VHJhbnNpdGlvbmFibGV9ICAgICAgICAgdGhpc1xuICovXG5UcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUudG8gPSBmdW5jdGlvbiB0byhmaW5hbFN0YXRlLCBjdXJ2ZSwgZHVyYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgY3VydmUgPSBjdXJ2ZSAhPSBudWxsICYmIGN1cnZlLmNvbnN0cnVjdG9yID09PSBTdHJpbmcgPyBDdXJ2ZXNbY3VydmVdIDogY3VydmU7XG4gICAgaWYgKHRoaXMuX3F1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9zdGFydGVkQXQgPSB0aGlzLmNvbnN0cnVjdG9yLkNsb2NrLm5vdygpO1xuICAgICAgICB0aGlzLl9wYXVzZWRBdCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuX3F1ZXVlLnB1c2goXG4gICAgICAgIGZpbmFsU3RhdGUsXG4gICAgICAgIGN1cnZlICE9IG51bGwgPyBjdXJ2ZSA6IEN1cnZlcy5saW5lYXIsXG4gICAgICAgIGR1cmF0aW9uICE9IG51bGwgPyBkdXJhdGlvbiA6IDEwMCxcbiAgICAgICAgY2FsbGJhY2tcbiAgICApO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXNldHMgdGhlIHRyYW5zaXRpb24gcXVldWUgdG8gYSBzdGFibGUgaW5pdGlhbCBzdGF0ZS5cbiAqXG4gKiBAbWV0aG9kIGZyb21cbiAqIEBjaGFpbmFibGVcbiAqXG4gKiBAcGFyYW0gIHtOdW1iZXJ8QXJyYXkuTnVtYmVyfSAgICBpbml0aWFsU3RhdGUgICAgaW5pdGlhbCBzdGF0ZSB0b1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24gZnJvbVxuICogQHJldHVybiB7VHJhbnNpdGlvbmFibGV9ICAgICAgICAgdGhpc1xuICovXG5UcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUuZnJvbSA9IGZ1bmN0aW9uIGZyb20oaW5pdGlhbFN0YXRlKSB7XG4gICAgdGhpcy5fZW5kID0gaW5pdGlhbFN0YXRlO1xuICAgIGlmIChpbml0aWFsU3RhdGUuY29uc3RydWN0b3IgPT09IEFycmF5ICYmIHRoaXMuX211bHRpICE9IG51bGwgJiYgdGhpcy5fbXVsdGkuY29uc3RydWN0b3IgPT09IEFycmF5KSB7XG4gICAgICAgIHRoaXMuX211bHRpLmxlbmd0aCA9IGluaXRpYWxTdGF0ZS5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbXVsdGkgPSBpbml0aWFsU3RhdGUuY29uc3RydWN0b3IgPT09IEFycmF5ID8gW10gOiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5fcXVldWUubGVuZ3RoID0gMDtcbiAgICB0aGlzLl9zdGFydGVkQXQgPSB0aGlzLmNvbnN0cnVjdG9yLkNsb2NrLm5vdygpO1xuICAgIHRoaXMuX3BhdXNlZEF0ID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRGVsYXlzIHRoZSBleGVjdXRpb24gb2YgdGhlIHN1YnNlcXVlbnQgdHJhbnNpdGlvbiBmb3IgYSBjZXJ0YWluIHBlcmlvZCBvZlxuICogdGltZS5cbiAqXG4gKiBAbWV0aG9kIGRlbGF5XG4gKiBAY2hhaW5hYmxlXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9ICAgICAgZHVyYXRpb24gICAgZGVsYXkgdGltZSBpbiBtc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gICAgW2NhbGxiYWNrXSAgWmVyby1hcmd1bWVudCBmdW5jdGlvbiB0byBjYWxsIG9uIG9ic2VydmVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0aW9uICh0PTEpXG4gKiBAcmV0dXJuIHtUcmFuc2l0aW9uYWJsZX0gICAgICAgICB0aGlzXG4gKi9cblRyYW5zaXRpb25hYmxlLnByb3RvdHlwZS5kZWxheSA9IGZ1bmN0aW9uIGRlbGF5KGR1cmF0aW9uLCBjYWxsYmFjaykge1xuICAgIHZhciBlbmRTdGF0ZSA9IHRoaXMuX3F1ZXVlLmxlbmd0aCA+IDAgPyB0aGlzLl9xdWV1ZVt0aGlzLl9xdWV1ZS5sZW5ndGggLSA0XSA6IHRoaXMuX2VuZDtcbiAgICByZXR1cm4gdGhpcy50byhlbmRTdGF0ZSwgQ3VydmVzLmZsYXQsIGR1cmF0aW9uLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIE92ZXJyaWRlcyBjdXJyZW50IHRyYW5zaXRpb24uXG4gKlxuICogQG1ldGhvZCBvdmVycmlkZVxuICogQGNoYWluYWJsZVxuICpcbiAqIEBwYXJhbSAge051bWJlcnxBcnJheS5OdW1iZXJ9ICAgIFtmaW5hbFN0YXRlXSAgICBmaW5hbCBzdGF0ZSB0byB0cmFuc2l0b24gdG9cbiAqIEBwYXJhbSAge1N0cmluZ3xGdW5jdGlvbn0gICAgICAgIFtjdXJ2ZV0gICAgICAgICBlYXNpbmcgZnVuY3Rpb24gdXNlZCBmb3JcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnBvbGF0aW5nIFswLCAxXVxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgICAgICAgICAgICAgW2R1cmF0aW9uXSAgICAgIGR1cmF0aW9uIG9mIHRyYW5zaXRpb25cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSAgICAgICAgICAgICAgIFtjYWxsYmFja10gICAgICBjYWxsYmFjayBmdW5jdGlvbiB0byBiZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxlZCBhZnRlciB0aGUgdHJhbnNpdGlvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIGNvbXBsZXRlXG4gKiBAcmV0dXJuIHtUcmFuc2l0aW9uYWJsZX0gICAgICAgICB0aGlzXG4gKi9cblRyYW5zaXRpb25hYmxlLnByb3RvdHlwZS5vdmVycmlkZSA9IGZ1bmN0aW9uIG92ZXJyaWRlKGZpbmFsU3RhdGUsIGN1cnZlLCBkdXJhdGlvbiwgY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5fcXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoZmluYWxTdGF0ZSAhPSBudWxsKSB0aGlzLl9xdWV1ZVswXSA9IGZpbmFsU3RhdGU7XG4gICAgICAgIGlmIChjdXJ2ZSAhPSBudWxsKSAgICAgIHRoaXMuX3F1ZXVlWzFdID0gY3VydmUuY29uc3RydWN0b3IgPT09IFN0cmluZyA/IEN1cnZlc1tjdXJ2ZV0gOiBjdXJ2ZTtcbiAgICAgICAgaWYgKGR1cmF0aW9uICE9IG51bGwpICAgdGhpcy5fcXVldWVbMl0gPSBkdXJhdGlvbjtcbiAgICAgICAgaWYgKGNhbGxiYWNrICE9IG51bGwpICAgdGhpcy5fcXVldWVbM10gPSBjYWxsYmFjaztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5UcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUuX2ludGVycG9sYXRlID0gZnVuY3Rpb24gX2ludGVycG9sYXRlKGZyb20sIHRvLCBwcm9ncmVzcykge1xuICAgIGlmICh0aGlzLl9tdWx0aSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9tdWx0aVtpXSA9IGZyb21baV0gKyBwcm9ncmVzcyAqICh0b1tpXSAtIGZyb21baV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9tdWx0aTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZnJvbSArIHByb2dyZXNzICogKHRvIC0gZnJvbSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBHZXQgaW50ZXJwb2xhdGVkIHN0YXRlIG9mIGN1cnJlbnQgYWN0aW9uIGF0IHByb3ZpZGVkIHRpbWUuIElmIHRoZSBsYXN0XG4gKiAgICBhY3Rpb24gaGFzIGNvbXBsZXRlZCwgaW52b2tlIGl0cyBjYWxsYmFjay5cbiAqXG4gKiBAbWV0aG9kIGdldFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyPX0gdGltZXN0YW1wIEV2YWx1YXRlIHRoZSBjdXJ2ZSBhdCBhIG5vcm1hbGl6ZWQgdmVyc2lvbiBvZiB0aGlzXG4gKiAgICB0aW1lLiBJZiBvbWl0dGVkLCB1c2UgY3VycmVudCB0aW1lLiAoVW5peCBlcG9jaCB0aW1lKVxuICogQHJldHVybiB7TnVtYmVyfEFycmF5Lk51bWJlcn0gYmVnaW5uaW5nIHN0YXRlXG4gKiAgICBpbnRlcnBvbGF0ZWQgdG8gdGhpcyBwb2ludCBpbiB0aW1lLlxuICovXG5UcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0KHQpIHtcbiAgICB0ID0gdGhpcy5fcGF1c2VkQXQgPyB0aGlzLl9wYXVzZWRBdCA6IHQ7XG4gICAgdCA9IHQgPyB0IDogdGhpcy5jb25zdHJ1Y3Rvci5DbG9jay5ub3coKTtcbiAgICBpZiAodGhpcy5fcXVldWUubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fZW5kO1xuXG4gICAgdmFyIHByb2dyZXNzID0gKHQgLSB0aGlzLl9zdGFydGVkQXQpIC8gdGhpcy5fcXVldWVbMl07XG4gICAgdmFyIHN0YXRlID0gdGhpcy5faW50ZXJwb2xhdGUodGhpcy5fZW5kLCB0aGlzLl9xdWV1ZVswXSwgdGhpcy5fcXVldWVbMV0ocHJvZ3Jlc3MgPiAxID8gMSA6IHByb2dyZXNzKSk7XG4gICAgaWYgKHByb2dyZXNzID49IDEpIHtcbiAgICAgICAgdGhpcy5fc3RhcnRlZEF0ID0gdGhpcy5fc3RhcnRlZEF0ICsgdGhpcy5fcXVldWVbMl07XG4gICAgICAgIHRoaXMuX2VuZCA9IHRoaXMuX3F1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIHRoaXMuX3F1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIHRoaXMuX3F1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRoaXMuX3F1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2dyZXNzID4gMSA/IHRoaXMuZ2V0KCkgOiBzdGF0ZTtcbn07XG5cbi8qKlxuICogSXMgdGhlcmUgYXQgbGVhc3Qgb25lIHRyYW5zaXRpb24gcGVuZGluZyBjb21wbGV0aW9uP1xuICpcbiAqIEBtZXRob2QgaXNBY3RpdmVcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5UcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiBpc0FjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcXVldWUubGVuZ3RoID4gMDtcbn07XG5cbi8qKlxuICogSGFsdCB0cmFuc2l0aW9uIGF0IGN1cnJlbnQgc3RhdGUgYW5kIGVyYXNlIGFsbCBwZW5kaW5nIGFjdGlvbnMuXG4gKlxuICogQG1ldGhvZCBoYWx0XG4gKiBAY2hhaW5hYmxlXG4gKlxuICogQHJldHVybiB7VHJhbnNpdGlvbmFibGV9IHRoaXNcbiAqL1xuVHJhbnNpdGlvbmFibGUucHJvdG90eXBlLmhhbHQgPSBmdW5jdGlvbiBoYWx0KCkge1xuICAgIHJldHVybiB0aGlzLmZyb20odGhpcy5nZXQoKSk7XG59O1xuXG4vKipcbiAqIFBhdXNlIHRyYW5zaXRpb24uIFRoaXMgd2lsbCBub3QgZXJhc2UgYW55IGFjdGlvbnMuXG4gKlxuICogQG1ldGhvZCBwYXVzZVxuICogQGNoYWluYWJsZVxuICpcbiAqIEByZXR1cm4ge1RyYW5zaXRpb25hYmxlfSB0aGlzXG4gKi9cblRyYW5zaXRpb25hYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgIHRoaXMuX3BhdXNlZEF0ID0gdGhpcy5jb25zdHJ1Y3Rvci5DbG9jay5ub3coKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogSGFzIHRoZSBjdXJyZW50IGFjdGlvbiBiZWVuIHBhdXNlZD9cbiAqXG4gKiBAbWV0aG9kIGlzUGF1c2VkXG4gKiBAY2hhaW5hYmxlXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn0gaWYgdGhlIGN1cnJlbnQgYWN0aW9uIGhhcyBiZWVuIHBhdXNlZFxuICovXG5UcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiBpc1BhdXNlZCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9wYXVzZWRBdDtcbn07XG5cbi8qKlxuICogUmVzdW1lIHRyYW5zaXRpb24uXG4gKlxuICogQG1ldGhvZCByZXN1bWVcbiAqIEBjaGFpbmFibGVcbiAqXG4gKiBAcmV0dXJuIHtUcmFuc2l0aW9uYWJsZX0gdGhpc1xuICovXG5UcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gcmVzdW1lKCkge1xuICAgIHZhciBkaWZmID0gdGhpcy5fcGF1c2VkQXQgLSB0aGlzLl9zdGFydGVkQXQ7XG4gICAgdGhpcy5fc3RhcnRlZEF0ID0gdGhpcy5jb25zdHJ1Y3Rvci5DbG9jay5ub3coKSAtIGRpZmY7XG4gICAgdGhpcy5fcGF1c2VkQXQgPSBudWxsO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYW5jZWwgYWxsIHRyYW5zaXRpb25zIGFuZCByZXNldCB0byBhIHN0YWJsZSBzdGF0ZVxuICpcbiAqIEBtZXRob2QgcmVzZXRcbiAqIEBjaGFpbmFibGVcbiAqIEBkZXByZWNhdGVkIFVzZSBgLmZyb21gIGluc3RlYWQhXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ8QXJyYXkuTnVtYmVyfE9iamVjdC48bnVtYmVyLCBudW1iZXI+fSBzdGFydFN0YXRlXG4gKiAgICBzdGFibGUgc3RhdGUgdG8gc2V0IHRvXG4gKi9cblRyYW5zaXRpb25hYmxlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXMuZnJvbShzdGFydCk7XG59O1xuXG4vKipcbiAqIEFkZCB0cmFuc2l0aW9uIHRvIGVuZCBzdGF0ZSB0byB0aGUgcXVldWUgb2YgcGVuZGluZyB0cmFuc2l0aW9ucy4gU3BlY2lhbFxuICogICAgVXNlOiBjYWxsaW5nIHdpdGhvdXQgYSB0cmFuc2l0aW9uIHJlc2V0cyB0aGUgb2JqZWN0IHRvIHRoYXQgc3RhdGUgd2l0aFxuICogICAgbm8gcGVuZGluZyBhY3Rpb25zXG4gKlxuICogQG1ldGhvZCBzZXRcbiAqIEBjaGFpbmFibGVcbiAqIEBkZXByZWNhdGVkIFVzZSBgLnRvYCBpbnN0ZWFkIVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfEZhbW91c01hdHJpeHxBcnJheS5OdW1iZXJ8T2JqZWN0LjxudW1iZXIsIG51bWJlcj59IGVuZFN0YXRlXG4gKiAgICBlbmQgc3RhdGUgdG8gd2hpY2ggd2UgaW50ZXJwb2xhdGVcbiAqIEBwYXJhbSB7dHJhbnNpdGlvbj19IHRyYW5zaXRpb24gb2JqZWN0IG9mIHR5cGUge2R1cmF0aW9uOiBudW1iZXIsIGN1cnZlOlxuICogICAgZlswLDFdIC0+IFswLDFdIG9yIG5hbWV9LiBJZiB0cmFuc2l0aW9uIGlzIG9taXR0ZWQsIGNoYW5nZSB3aWxsIGJlXG4gKiAgICBpbnN0YW50YW5lb3VzLlxuICogQHBhcmFtIHtmdW5jdGlvbigpPX0gY2FsbGJhY2sgWmVyby1hcmd1bWVudCBmdW5jdGlvbiB0byBjYWxsIG9uIG9ic2VydmVkXG4gKiAgICBjb21wbGV0aW9uICh0PTEpXG4gKi9cblRyYW5zaXRpb25hYmxlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihzdGF0ZSwgdHJhbnNpdGlvbiwgY2FsbGJhY2spIHtcbiAgICBpZiAodHJhbnNpdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuZnJvbShzdGF0ZSk7XG4gICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRvKHN0YXRlLCB0cmFuc2l0aW9uLmN1cnZlLCB0cmFuc2l0aW9uLmR1cmF0aW9uLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2l0aW9uYWJsZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBSZXR1cm4gd3JhcHBlciBhcm91bmQgY2FsbGJhY2sgZnVuY3Rpb24uIE9uY2UgdGhlIHdyYXBwZXIgaXMgY2FsbGVkIE5cbiAqICAgdGltZXMsIGludm9rZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uIEFyZ3VtZW50cyBhbmQgc2NvcGUgcHJlc2VydmVkLlxuICpcbiAqIEBtZXRob2QgYWZ0ZXJcbiAqIEBkZXByZWNhdGVkXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IG51bWJlciBvZiBjYWxscyBiZWZvcmUgY2FsbGJhY2sgZnVuY3Rpb24gaW52b2tlZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgd3JhcHBlZCBjYWxsYmFjayBmdW5jdGlvblxuICpcbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSB3cmFwcGVkIGNhbGxiYWNrIHdpdGggY291bmRvd24gZmVhdHVyZVxuICovXG52YXIgYWZ0ZXIgPSBmdW5jdGlvbiBhZnRlcihjb3VudCwgY2FsbGJhY2spIHtcbiAgICBjb25zb2xlLndhcm4oJ3RyYW5zaXRpb25zLmFmdGVyIGlzIGRlcHJlY2F0ZWQhJyk7XG4gICAgdmFyIGNvdW50ZXIgPSBjb3VudDtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvdW50ZXItLTtcbiAgICAgICAgaWYgKGNvdW50ZXIgPT09IDApIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYWZ0ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGFmdGVyOiByZXF1aXJlKCcuL2FmdGVyJyksXG4gICAgRWFzaW5nOiByZXF1aXJlKCcuL0Vhc2luZycpLFxuICAgIEN1cnZlczogcmVxdWlyZSgnLi9DdXJ2ZXMnKSxcbiAgICBUcmFuc2l0aW9uYWJsZTogcmVxdWlyZSgnLi9UcmFuc2l0aW9uYWJsZScpXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEEgbGlnaHR3ZWlnaHQsIGZlYXR1cmVsZXNzIEV2ZW50RW1pdHRlci5cbiAqIFxuICogQGNsYXNzIENhbGxiYWNrU3RvcmVcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBDYWxsYmFja1N0b3JlICgpIHtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbn1cblxuLyoqXG4gKiBBZGRzIGEgbGlzdGVuZXIgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQgKD0ga2V5KS5cbiAqXG4gKiBAbWV0aG9kIG9uXG4gKiBAY2hhaW5hYmxlXG4gKiBcbiAqIEBwYXJhbSAge1N0cmluZ30gICBrZXlcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdG8gY2FsbCBpZiB5b3Ugd2FudCB0byByZW1vdmUgdGhlIGNhbGxiYWNrXG4gKi9cbkNhbGxiYWNrU3RvcmUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24gKGtleSwgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50c1trZXldKSB0aGlzLl9ldmVudHNba2V5XSA9IFtdO1xuICAgIHZhciBjYWxsYmFja0xpc3QgPSB0aGlzLl9ldmVudHNba2V5XTtcbiAgICBjYWxsYmFja0xpc3QucHVzaChjYWxsYmFjayk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FsbGJhY2tMaXN0LnNwbGljZShjYWxsYmFja0xpc3QuaW5kZXhPZihjYWxsYmFjayksIDEpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIHByZXZpb3VzbHkgYWRkZWQgZXZlbnQgbGlzdGVuZXIuXG4gKlxuICogQG1ldGhvZCBvZmZcbiAqIEBjaGFpbmFibGVcbiAqIFxuICogQHBhcmFtICB7U3RyaW5nfSAgICAgICAgICBrZXlcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSAgICAgICAgY2FsbGJhY2tcbiAqIEByZXR1cm4ge0NhbGxiYWNrU3RvcmV9ICAgdGhpc1xuICovXG5DYWxsYmFja1N0b3JlLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiBvZmYgKGtleSwgY2FsbGJhY2spIHtcbiAgICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzW2tleV07XG4gICAgaWYgKGV2ZW50cykgZXZlbnRzLnNwbGljZShldmVudHMuaW5kZXhPZihjYWxsYmFjayksIDEpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBJbnZva2VzIGFsbCB0aGUgcHJldmlvdXNseSBmb3IgdGhpcyBrZXkgcmVnaXN0ZXJlZCBjYWxsYmFja3MuXG4gKlxuICogQG1ldGhvZCB0cmlnZ2VyXG4gKiBAY2hhaW5hYmxlXG4gKiBcbiAqIEBwYXJhbSAge1N0cmluZ30gICAgICAgIGtleVxuICogQHBhcmFtICB7T2JqZWN0fSAgICAgICAgcGF5bG9hZFxuICogQHJldHVybiB7Q2FsbGJhY2tTdG9yZX0gdGhpc1xuICovXG5DYWxsYmFja1N0b3JlLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gdHJpZ2dlciAoa2V5LCBwYXlsb2FkKSB7XG4gICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50c1trZXldO1xuICAgIGlmIChldmVudHMpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGVuID0gZXZlbnRzLmxlbmd0aDtcbiAgICAgICAgZm9yICg7IGkgPCBsZW4gOyBpKyspIGV2ZW50c1tpXShwYXlsb2FkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbGxiYWNrU3RvcmU7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUcmFuc2l0aW9uYWJsZSA9IHJlcXVpcmUoJ2ZhbW91cy10cmFuc2l0aW9ucycpLlRyYW5zaXRpb25hYmxlO1xuXG4vKipcbiAqIEBjbGFzcyBDb2xvclxuICogQGNvbnN0cnVjdG9yXG4gKiBAY29tcG9uZW50XG4gKiBAcGFyYW0ge0NvbG9yfFN0cmluZ3xBcnJheX0gT3B0aW9uYWwgYXJndW1lbnQgZm9yIHNldHRpbmcgY29sb3IgdXNpbmdcbiAqIEhleCwgYSBDb2xvciBpbnN0YW5jZSwgY29sb3IgbmFtZSBvciBSR0JcbiAqIEBwYXJhbSB7T2JqZWN0fSBPcHRpb25hbCB0cmFuc2l0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBDYWxsYmFja1xuICovXG5mdW5jdGlvbiBDb2xvcihjb2xvciwgdHJhbnNpdGlvbiwgY2IpIHtcbiAgICB0aGlzLl9yID0gbmV3IFRyYW5zaXRpb25hYmxlKDApO1xuICAgIHRoaXMuX2cgPSBuZXcgVHJhbnNpdGlvbmFibGUoMCk7XG4gICAgdGhpcy5fYiA9IG5ldyBUcmFuc2l0aW9uYWJsZSgwKTtcbiAgICBpZiAoY29sb3IpIHRoaXMuc2V0KGNvbG9yLCB0cmFuc2l0aW9uLCBjYik7XG59O1xuXG4vKipcbiogUmV0dXJucyB0aGUgZGVmaW5pdGlvbiBvZiB0aGUgQ2xhc3M6ICdDb2xvcidcbiogQG1ldGhvZCB0b1N0cmluZ1xuKiBAcmV0dXJuIHtTdHJpbmd9IGRlZmluaXRpb25cbiovXG5Db2xvci50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnQ29sb3InO1xufTtcblxuLyoqXG4qIFNldHMgdGhlIGNvbG9yLiBJdCBhY2NlcHRzIGFuIG9wdGlvbmFsIHRyYW5zaXRpb24gcGFyYW1ldGVyIGFuZCBjYWxsYmFjay5cbiogc2V0KENvbG9yLCB0cmFuc2l0aW9uLCBjYWxsYmFjaylcbiogc2V0KCcjMDAwMDAwJywgdHJhbnNpdGlvbiwgY2FsbGJhY2spXG4qIHNldCgnYmxhY2snLCB0cmFuc2l0aW9uLCBjYWxsYmFjaylcbiogc2V0KFtyLCBnLCBiXSwgdHJhbnNpdGlvbiwgY2FsbGJhY2spXG4qIEBtZXRob2Qgc2V0XG4gKiBAcGFyYW0ge0NvbG9yfFN0cmluZ3xBcnJheX0gT3B0aW9uYWwgYXJndW1lbnQgZm9yIHNldHRpbmcgY29sb3IgdXNpbmdcbiAqIEhleCwgYSBDb2xvciBpbnN0YW5jZSwgY29sb3IgbmFtZSBvciBSR0JcbiAqIEBwYXJhbSB7T2JqZWN0fSBPcHRpb25hbCB0cmFuc2l0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBDYWxsYmFja1xuKiBAY2hhaW5hYmxlXG4qL1xuQ29sb3IucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldChjb2xvciwgdHJhbnNpdGlvbiwgY2IpIHtcbiAgICBzd2l0Y2ggKENvbG9yLmRldGVybWluZVR5cGUoY29sb3IpKSB7XG4gICAgICAgIGNhc2UgJ2hleCc6IHJldHVybiB0aGlzLnNldEhleChjb2xvciwgdHJhbnNpdGlvbiwgY2IpO1xuICAgICAgICBjYXNlICdjb2xvck5hbWUnOiByZXR1cm4gdGhpcy5zZXRDb2xvcihjb2xvciwgdHJhbnNpdGlvbiwgY2IpO1xuICAgICAgICBjYXNlICdpbnN0YW5jZSc6IHJldHVybiB0aGlzLmNoYW5nZVRvKGNvbG9yLCB0cmFuc2l0aW9uLCBjYik7XG4gICAgICAgIGNhc2UgJ3JnYic6IHJldHVybiB0aGlzLnNldFJHQihjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCB0cmFuc2l0aW9uLCBjYik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgQ29sb3IgaXMgc3RpbGwgaW4gYW4gYW5pbWF0aW5nICh0cmFuc2l0aW9uaW5nKSBzdGF0ZS5cbiAqXG4gKiBAbWV0aG9kIGlzQWN0aXZlXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYm9vbGVhblxuICovXG5Db2xvci5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiBpc0FjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fci5pc0FjdGl2ZSgpIHx8IHRoaXMuX2cuaXNBY3RpdmUoKSB8fCB0aGlzLl9iLmlzQWN0aXZlKCk7XG59O1xuXG4vKipcbiAqIEhhbHQgdHJhbnNpdGlvbiBhdCBjdXJyZW50IHN0YXRlIGFuZCBlcmFzZSBhbGwgcGVuZGluZyBhY3Rpb25zLlxuICpcbiAqIEBtZXRob2QgaGFsdFxuICogQGNoYWluYWJsZVxuICpcbiAqIEByZXR1cm4ge0NvbG9yfSB0aGlzXG4gKi9cbkNvbG9yLnByb3RvdHlwZS5oYWx0ID0gZnVuY3Rpb24gaGFsdCgpIHtcbiAgICB0aGlzLl9yLmhhbHQoKTtcbiAgICB0aGlzLl9nLmhhbHQoKTtcbiAgICB0aGlzLl9iLmhhbHQoKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY29sb3IgdmFsdWVzIGZyb20gYW5vdGhlciBDb2xvciBpbnN0YW5jZS5cbiAqXG4gKiBAbWV0aG9kIGNoYW5nZVRvXG4gKiBAcGFyYW0ge0NvbG9yfSBDb2xvciBpbnN0YW5jZVxuICogQHBhcmFtIHtPYmplY3R9IHRyYW5zaXRpb24gT3B0aW9uYWwgdHJhbnNpdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgT3B0aW9uYWxcbiAqIEBjaGFpbmFibGVcbiAqL1xuQ29sb3IucHJvdG90eXBlLmNoYW5nZVRvID0gZnVuY3Rpb24gY2hhbmdlVG8oY29sb3IsIHRyYW5zaXRpb24sIGNiKSB7XG4gICAgaWYgKENvbG9yLmlzQ29sb3JJbnN0YW5jZShjb2xvcikpIHtcbiAgICAgICAgdmFyIHJnYiA9IGNvbG9yLmdldFJHQigpO1xuICAgICAgICB0aGlzLnNldFJHQihyZ2JbMF0sIHJnYlsxXSwgcmdiWzJdLCB0cmFuc2l0aW9uLCBjYik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjb2xvciBiYXNlZCBvbiBzdGF0aWMgY29sb3IgbmFtZXMuXG4gKlxuICogQG1ldGhvZCBzZXRDb2xvclxuICogQHBhcmFtIHtTdHJpbmd9IENvbG9yIG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2l0aW9uIE9wdGlvbmFsIHRyYW5zaXRpb24gcGFyYW1ldGVyc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgT3B0aW9uYWxcbiAqIEBjaGFpbmFibGVcbiAqL1xuQ29sb3IucHJvdG90eXBlLnNldENvbG9yID0gZnVuY3Rpb24gc2V0Q29sb3IobmFtZSwgdHJhbnNpdGlvbiwgY2IpIHtcbiAgICBpZiAoY29sb3JOYW1lc1tuYW1lXSkge1xuICAgICAgICB0aGlzLnNldEhleChjb2xvck5hbWVzW25hbWVdLCB0cmFuc2l0aW9uLCBjYik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjb2xvciBpbiBlaXRoZXIgUkdCIG9yIHdpdGggdGhlIHJlcXVlc3RlZCBmb3JtYXQuXG4gKlxuICogQG1ldGhvZCBnZXRDb2xvclxuICogQHBhcmFtIHtTdHJpbmd9IE9wdGlvbmFsIGFyZ3VtZW50IGZvciBkZXRlcm1pbmluZyB3aGljaCB0eXBlIG9mIGNvbG9yIHRvIGdldCAoZGVmYXVsdCBpcyBSR0IpXG4gKiBAcmV0dXJucyBDb2xvciBpbiBlaXRoZXIgUkdCIG9yIHNwZWNpZmljIG9wdGlvbiB2YWx1ZVxuICovXG5Db2xvci5wcm90b3R5cGUuZ2V0Q29sb3IgPSBmdW5jdGlvbiBnZXRDb2xvcihvcHRpb24pIHtcbiAgICBpZiAoQ29sb3IuaXNTdHJpbmcob3B0aW9uKSkgb3B0aW9uID0gb3B0aW9uLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIChvcHRpb24gPT09ICdoZXgnKSA/IHRoaXMuZ2V0SGV4KCkgOiB0aGlzLmdldFJHQigpO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBSIG9mIHRoZSBDb2xvcidzIFJHQlxuICpcbiAqIEBtZXRob2Qgc2V0UlxuICogQHBhcmFtIHtJbnRlZ2VyfSBSIGNoYW5uZWwgb2YgY29sb3JcbiAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2l0aW9uIE9wdGlvbmFsIHRyYW5zaXRpb24gcGFyYW1ldGVyc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgT3B0aW9uYWxcbiAqIEBjaGFpbmFibGVcbiAqL1xuQ29sb3IucHJvdG90eXBlLnNldFIgPSBmdW5jdGlvbiBzZXRSKHIsIHRyYW5zaXRpb24sIGNiKSB7XG4gICAgdGhpcy5fci5zZXQociwgdHJhbnNpdGlvbiwgY2IpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBHIG9mIHRoZSBDb2xvcidzIFJHQlxuICpcbiAqIEBtZXRob2Qgc2V0R1xuICogQHBhcmFtIHtJbnRlZ2VyfSBHIGNoYW5uZWwgb2YgY29sb3JcbiAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2l0aW9uIE9wdGlvbmFsIHRyYW5zaXRpb24gcGFyYW1ldGVyc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgT3B0aW9uYWxcbiAqIEBjaGFpbmFibGVcbiAqL1xuQ29sb3IucHJvdG90eXBlLnNldEcgPSBmdW5jdGlvbiBzZXRHKGcsIHRyYW5zaXRpb24sIGNiKSB7XG4gICAgdGhpcy5fZy5zZXQoZywgdHJhbnNpdGlvbiwgY2IpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBCIG9mIHRoZSBDb2xvcidzIFJHQlxuICpcbiAqIEBtZXRob2Qgc2V0QlxuICogQHBhcmFtIHtJbnRlZ2VyfSBCIGNoYW5uZWwgb2YgY29sb3JcbiAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2l0aW9uIE9wdGlvbmFsIHRyYW5zaXRpb24gcGFyYW1ldGVyc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgT3B0aW9uYWxcbiAqIEBjaGFpbmFibGVcbiAqL1xuQ29sb3IucHJvdG90eXBlLnNldEIgPSBmdW5jdGlvbiBzZXRCKGIsIHRyYW5zaXRpb24sIGNiKSB7XG4gICAgdGhpcy5fYi5zZXQoYiwgdHJhbnNpdGlvbiwgY2IpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIFJHQlxuICpcbiAqIEBtZXRob2Qgc2V0UkdCXG4gKiBAcGFyYW0ge0ludGVnZXJ9IFIgY2hhbm5lbCBvZiBjb2xvclxuICogQHBhcmFtIHtJbnRlZ2VyfSBHIGNoYW5uZWwgb2YgY29sb3JcbiAqIEBwYXJhbSB7SW50ZWdlcn0gQiBjaGFubmVsIG9mIGNvbG9yXG4gKiBAcGFyYW0ge09iamVjdH0gdHJhbnNpdGlvbiBPcHRpb25hbCB0cmFuc2l0aW9uIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIE9wdGlvbmFsXG4gKiBAY2hhaW5hYmxlXG4gKi9cbkNvbG9yLnByb3RvdHlwZS5zZXRSR0IgPSBmdW5jdGlvbiBzZXRSR0IociwgZywgYiwgdHJhbnNpdGlvbiwgY2IpIHtcbiAgICB0aGlzLnNldFIociwgdHJhbnNpdGlvbik7XG4gICAgdGhpcy5zZXRHKGcsIHRyYW5zaXRpb24pO1xuICAgIHRoaXMuc2V0QihiLCB0cmFuc2l0aW9uLCBjYik7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgUiBvZiBSR0JcbiAqXG4gKiBAbWV0aG9kIGdldFJcbiAqIEByZXR1cm5zIFIgb2YgQ29sb3JcbiAqL1xuQ29sb3IucHJvdG90eXBlLmdldFIgPSBmdW5jdGlvbiBnZXRSKCkge1xuICAgIHJldHVybiB0aGlzLl9yLmdldCgpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIEcgb2YgUkdCXG4gKlxuICogQG1ldGhvZCBnZXRHXG4gKiBAcmV0dXJucyBHIG9mIENvbG9yXG4gKi9cbkNvbG9yLnByb3RvdHlwZS5nZXRHID0gZnVuY3Rpb24gZ2V0RygpIHtcbiAgICByZXR1cm4gdGhpcy5fZy5nZXQoKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBCIG9mIFJHQlxuICpcbiAqIEBtZXRob2QgZ2V0QlxuICogQHJldHVybnMgQiBvZiBDb2xvclxuICovXG5Db2xvci5wcm90b3R5cGUuZ2V0QiA9IGZ1bmN0aW9uIGdldEIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2IuZ2V0KCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgUkdCXG4gKlxuICogQG1ldGhvZCBnZXRSR0JcbiAqIEByZXR1cm5zIFJHQlxuICovXG5Db2xvci5wcm90b3R5cGUuZ2V0UkdCID0gZnVuY3Rpb24gZ2V0UkdCKCkge1xuICAgIHJldHVybiBbdGhpcy5nZXRSKCksIHRoaXMuZ2V0RygpLCB0aGlzLmdldEIoKV07XG59O1xuXG4vKipcbiAqIFJldHVybnMgTm9ybWFsaXplZCBSR0JcbiAqXG4gKiBAbWV0aG9kIGdldE5vcm1hbGl6ZWRSR0JcbiAqIEByZXR1cm5zIE5vcm1hbGl6ZWQgUkdCXG4gKi9cbkNvbG9yLnByb3RvdHlwZS5nZXROb3JtYWxpemVkUkdCID0gZnVuY3Rpb24gZ2V0Tm9ybWFsaXplZFJHQigpIHtcbiAgICB2YXIgciA9IHRoaXMuZ2V0UigpIC8gMjU1LjA7XG4gICAgdmFyIGcgPSB0aGlzLmdldEcoKSAvIDI1NS4wO1xuICAgIHZhciBiID0gdGhpcy5nZXRCKCkgLyAyNTUuMDtcbiAgICByZXR1cm4gW3IsIGcsIGJdO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IGNvbG9yIGluIEhleFxuICpcbiAqIEBtZXRob2QgZ2V0SGV4XG4gKiBAcmV0dXJucyBIZXggdmFsdWVcbiAqL1xuQ29sb3IucHJvdG90eXBlLmdldEhleCA9IGZ1bmN0aW9uIGdldEhleCgpIHtcbiAgICB2YXIgciA9IENvbG9yLnRvSGV4KHRoaXMuZ2V0UigpKTtcbiAgICB2YXIgZyA9IENvbG9yLnRvSGV4KHRoaXMuZ2V0RygpKTtcbiAgICB2YXIgYiA9IENvbG9yLnRvSGV4KHRoaXMuZ2V0QigpKTtcbiAgICByZXR1cm4gJyMnICsgciArIGcgKyBiO1xufTtcblxuLyoqXG4gKiBTZXRzIGNvbG9yIHVzaW5nIEhleFxuICpcbiAqIEBtZXRob2Qgc2V0SGV4XG4gKiBAcGFyYW0ge1N0cmluZ30gSGV4IHZhbHVlXG4gKiBAcGFyYW0ge09iamVjdH0gdHJhbnNpdGlvbiBPcHRpb25hbCB0cmFuc2l0aW9uIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIE9wdGlvbmFsXG4gKiBAY2hhaW5hYmxlXG4gKi9cbkNvbG9yLnByb3RvdHlwZS5zZXRIZXggPSBmdW5jdGlvbiBzZXRIZXgoaGV4LCB0cmFuc2l0aW9uLCBjYikge1xuICAgIGhleCA9IChoZXguY2hhckF0KDApID09PSAnIycpID8gaGV4LnN1YnN0cmluZygxLCBoZXgubGVuZ3RoKSA6IGhleDtcblxuICAgIGlmIChoZXgubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIHZhciBzaG9ydGhhbmRSZWdleCA9IC9eIz8oW2EtZlxcZF0pKFthLWZcXGRdKShbYS1mXFxkXSkkL2k7XG4gICAgICAgIGhleCA9IGhleC5yZXBsYWNlKHNob3J0aGFuZFJlZ2V4LCBmdW5jdGlvbihtLCByLCBnLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gciArIHIgKyBnICsgZyArIGIgKyBiO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgciA9IHBhcnNlSW50KGhleC5zdWJzdHJpbmcoMCwgMiksIDE2KTtcbiAgICB2YXIgZyA9IHBhcnNlSW50KGhleC5zdWJzdHJpbmcoMiwgNCksIDE2KTtcbiAgICB2YXIgYiA9IHBhcnNlSW50KGhleC5zdWJzdHJpbmcoNCwgNiksIDE2KTtcbiAgICB0aGlzLnNldFJHQihyLCBnLCBiLCB0cmFuc2l0aW9uLCBjYik7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgbnVtYmVyIHRvIGEgaGV4IHZhbHVlXG4gKlxuICogQG1ldGhvZCB0b0hleFxuICogQHBhcmFtIHtJbnRlZ2VyfSBOdW1iZXJcbiAqIEByZXR1cm5zIEhleCB2YWx1ZVxuICovXG5Db2xvci50b0hleCA9IGZ1bmN0aW9uIHRvSGV4KG51bSkge1xuICAgIHZhciBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBoZXgubGVuZ3RoID09PSAxID8gJzAnICsgaGV4IDogaGV4O1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBnaXZlbiBpbnB1dCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBjb25maWd1cmF0aW9uXG4gKlxuICogQG1ldGhvZCBkZXRlcm1pbmVUeXBlXG4gKiBAcGFyYW0ge0NvbG9yfFN0cmluZ3xBcnJheX0gQ29sb3IgdHlwZVxuICogQHJldHVybnMge1N0cmluZ30gQXBwcm9wcmlhdGUgY29sb3IgdHlwZVxuICovXG5Db2xvci5kZXRlcm1pbmVUeXBlID0gZnVuY3Rpb24gZGV0ZXJtaW5lVHlwZSh0eXBlKSB7XG4gICAgaWYgKENvbG9yLmlzQ29sb3JJbnN0YW5jZSh0eXBlKSkgcmV0dXJuICdpbnN0YW5jZSc7XG4gICAgaWYgKGNvbG9yTmFtZXNbdHlwZV0pIHJldHVybiAnY29sb3JOYW1lJztcbiAgICBpZiAoQ29sb3IuaXNIZXgodHlwZSkpIHJldHVybiAnaGV4JztcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkgcmV0dXJuICdyZ2InO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgYm9vbGVhbiBjaGVja2luZyB3aGV0aGVyIGlucHV0IGlzIGEgJ1N0cmluZydcbiAqXG4gKiBAbWV0aG9kIGlzU3RyaW5nXG4gKiBAcGFyYW0gUHJpbWl0aXZlXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gQm9vbGVhblxuICovXG5Db2xvci5pc1N0cmluZyA9IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbCkge1xuICAgIHJldHVybiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgYm9vbGVhbiBjaGVja2luZyB3aGV0aGVyIHN0cmluZyBpbnB1dCBoYXMgYSBoYXNoICgjKSBzeW1ib2xcbiAqXG4gKiBAbWV0aG9kIGlzSGV4XG4gKiBAcGFyYW0gU3RyaW5nXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gQm9vbGVhblxuICovXG5Db2xvci5pc0hleCA9IGZ1bmN0aW9uIGlzSGV4KHZhbCkge1xuICAgIGlmICghQ29sb3IuaXNTdHJpbmcodmFsKSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB2YWxbMF0gPT09ICcjJztcbn07XG5cbi8qKlxuICogUmV0dXJucyBib29sZWFuIHdoZXRoZXIgdGhlIGlucHV0IGlzIGEgQ29sb3IgaW5zdGFuY2VcbiAqXG4gKiBAbWV0aG9kIGlzQ29sb3JJbnN0YW5jZVxuICogQHBhcmFtIENvbG9yIGluc3RhbmNlXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gQm9vbGVhblxuICovXG5Db2xvci5pc0NvbG9ySW5zdGFuY2UgPSBmdW5jdGlvbiBpc0NvbG9ySW5zdGFuY2UodmFsKSB7XG4gICAgcmV0dXJuICEhdmFsLmdldENvbG9yO1xufTtcblxuLyoqXG4gKiBDb21tb24gY29sb3IgbmFtZXMgd2l0aCB0aGVpciBhc3NvY2lhdGVkIEhleCB2YWx1ZXNcbiAqL1xudmFyIGNvbG9yTmFtZXMgPSB7IGFsaWNlYmx1ZTogJyNmMGY4ZmYnLCBhbnRpcXVld2hpdGU6ICcjZmFlYmQ3JywgYXF1YTogJyMwMGZmZmYnLCBhcXVhbWFyaW5lOiAnIzdmZmZkNCcsIGF6dXJlOiAnI2YwZmZmZicsIGJlaWdlOiAnI2Y1ZjVkYycsIGJpc3F1ZTogJyNmZmU0YzQnLCBibGFjazogJyMwMDAwMDAnLCBibGFuY2hlZGFsbW9uZDogJyNmZmViY2QnLCBibHVlOiAnIzAwMDBmZicsIGJsdWV2aW9sZXQ6ICcjOGEyYmUyJywgYnJvd246ICcjYTUyYTJhJywgYnVybHl3b29kOiAnI2RlYjg4NycsIGNhZGV0Ymx1ZTogJyM1ZjllYTAnLCBjaGFydHJldXNlOiAnIzdmZmYwMCcsIGNob2NvbGF0ZTogJyNkMjY5MWUnLCBjb3JhbDogJyNmZjdmNTAnLCBjb3JuZmxvd2VyYmx1ZTogJyM2NDk1ZWQnLCBjb3Juc2lsazogJyNmZmY4ZGMnLCBjcmltc29uOiAnI2RjMTQzYycsIGN5YW46ICcjMDBmZmZmJywgZGFya2JsdWU6ICcjMDAwMDhiJywgZGFya2N5YW46ICcjMDA4YjhiJywgZGFya2dvbGRlbnJvZDogJyNiODg2MGInLCBkYXJrZ3JheTogJyNhOWE5YTknLCBkYXJrZ3JlZW46ICcjMDA2NDAwJywgZGFya2dyZXk6ICcjYTlhOWE5JywgZGFya2toYWtpOiAnI2JkYjc2YicsIGRhcmttYWdlbnRhOiAnIzhiMDA4YicsIGRhcmtvbGl2ZWdyZWVuOiAnIzU1NmIyZicsIGRhcmtvcmFuZ2U6ICcjZmY4YzAwJywgZGFya29yY2hpZDogJyM5OTMyY2MnLCBkYXJrcmVkOiAnIzhiMDAwMCcsIGRhcmtzYWxtb246ICcjZTk5NjdhJywgZGFya3NlYWdyZWVuOiAnIzhmYmM4ZicsIGRhcmtzbGF0ZWJsdWU6ICcjNDgzZDhiJywgZGFya3NsYXRlZ3JheTogJyMyZjRmNGYnLCBkYXJrc2xhdGVncmV5OiAnIzJmNGY0ZicsIGRhcmt0dXJxdW9pc2U6ICcjMDBjZWQxJywgZGFya3Zpb2xldDogJyM5NDAwZDMnLCBkZWVwcGluazogJyNmZjE0OTMnLCBkZWVwc2t5Ymx1ZTogJyMwMGJmZmYnLCBkaW1ncmF5OiAnIzY5Njk2OScsIGRpbWdyZXk6ICcjNjk2OTY5JywgZG9kZ2VyYmx1ZTogJyMxZTkwZmYnLCBmaXJlYnJpY2s6ICcjYjIyMjIyJywgZmxvcmFsd2hpdGU6ICcjZmZmYWYwJywgZm9yZXN0Z3JlZW46ICcjMjI4YjIyJywgZnVjaHNpYTogJyNmZjAwZmYnLCBnYWluc2Jvcm86ICcjZGNkY2RjJywgZ2hvc3R3aGl0ZTogJyNmOGY4ZmYnLCBnb2xkOiAnI2ZmZDcwMCcsIGdvbGRlbnJvZDogJyNkYWE1MjAnLCBncmF5OiAnIzgwODA4MCcsIGdyZWVuOiAnIzAwODAwMCcsIGdyZWVueWVsbG93OiAnI2FkZmYyZicsIGdyZXk6ICcjODA4MDgwJywgaG9uZXlkZXc6ICcjZjBmZmYwJywgaG90cGluazogJyNmZjY5YjQnLCBpbmRpYW5yZWQ6ICcjY2Q1YzVjJywgaW5kaWdvOiAnIzRiMDA4MicsIGl2b3J5OiAnI2ZmZmZmMCcsIGtoYWtpOiAnI2YwZTY4YycsIGxhdmVuZGVyOiAnI2U2ZTZmYScsIGxhdmVuZGVyYmx1c2g6ICcjZmZmMGY1JywgbGF3bmdyZWVuOiAnIzdjZmMwMCcsIGxlbW9uY2hpZmZvbjogJyNmZmZhY2QnLCBsaWdodGJsdWU6ICcjYWRkOGU2JywgbGlnaHRjb3JhbDogJyNmMDgwODAnLCBsaWdodGN5YW46ICcjZTBmZmZmJywgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6ICcjZmFmYWQyJywgbGlnaHRncmF5OiAnI2QzZDNkMycsIGxpZ2h0Z3JlZW46ICcjOTBlZTkwJywgbGlnaHRncmV5OiAnI2QzZDNkMycsIGxpZ2h0cGluazogJyNmZmI2YzEnLCBsaWdodHNhbG1vbjogJyNmZmEwN2EnLCBsaWdodHNlYWdyZWVuOiAnIzIwYjJhYScsIGxpZ2h0c2t5Ymx1ZTogJyM4N2NlZmEnLCBsaWdodHNsYXRlZ3JheTogJyM3Nzg4OTknLCBsaWdodHNsYXRlZ3JleTogJyM3Nzg4OTknLCBsaWdodHN0ZWVsYmx1ZTogJyNiMGM0ZGUnLCBsaWdodHllbGxvdzogJyNmZmZmZTAnLCBsaW1lOiAnIzAwZmYwMCcsIGxpbWVncmVlbjogJyMzMmNkMzInLCBsaW5lbjogJyNmYWYwZTYnLCBtYWdlbnRhOiAnI2ZmMDBmZicsIG1hcm9vbjogJyM4MDAwMDAnLCBtZWRpdW1hcXVhbWFyaW5lOiAnIzY2Y2RhYScsIG1lZGl1bWJsdWU6ICcjMDAwMGNkJywgbWVkaXVtb3JjaGlkOiAnI2JhNTVkMycsIG1lZGl1bXB1cnBsZTogJyM5MzcwZGInLCBtZWRpdW1zZWFncmVlbjogJyMzY2IzNzEnLCBtZWRpdW1zbGF0ZWJsdWU6ICcjN2I2OGVlJywgbWVkaXVtc3ByaW5nZ3JlZW46ICcjMDBmYTlhJywgbWVkaXVtdHVycXVvaXNlOiAnIzQ4ZDFjYycsIG1lZGl1bXZpb2xldHJlZDogJyNjNzE1ODUnLCBtaWRuaWdodGJsdWU6ICcjMTkxOTcwJywgbWludGNyZWFtOiAnI2Y1ZmZmYScsIG1pc3R5cm9zZTogJyNmZmU0ZTEnLCBtb2NjYXNpbjogJyNmZmU0YjUnLCBuYXZham93aGl0ZTogJyNmZmRlYWQnLCBuYXZ5OiAnIzAwMDA4MCcsIG9sZGxhY2U6ICcjZmRmNWU2Jywgb2xpdmU6ICcjODA4MDAwJywgb2xpdmVkcmFiOiAnIzZiOGUyMycsIG9yYW5nZTogJyNmZmE1MDAnLCBvcmFuZ2VyZWQ6ICcjZmY0NTAwJywgb3JjaGlkOiAnI2RhNzBkNicsIHBhbGVnb2xkZW5yb2Q6ICcjZWVlOGFhJywgcGFsZWdyZWVuOiAnIzk4ZmI5OCcsIHBhbGV0dXJxdW9pc2U6ICcjYWZlZWVlJywgcGFsZXZpb2xldHJlZDogJyNkYjcwOTMnLCBwYXBheWF3aGlwOiAnI2ZmZWZkNScsIHBlYWNocHVmZjogJyNmZmRhYjknLCBwZXJ1OiAnI2NkODUzZicsIHBpbms6ICcjZmZjMGNiJywgcGx1bTogJyNkZGEwZGQnLCBwb3dkZXJibHVlOiAnI2IwZTBlNicsIHB1cnBsZTogJyM4MDAwODAnLCByZWJlY2NhcHVycGxlOiAnIzY2MzM5OScsIHJlZDogJyNmZjAwMDAnLCByb3N5YnJvd246ICcjYmM4ZjhmJywgcm95YWxibHVlOiAnIzQxNjllMScsIHNhZGRsZWJyb3duOiAnIzhiNDUxMycsIHNhbG1vbjogJyNmYTgwNzInLCBzYW5keWJyb3duOiAnI2Y0YTQ2MCcsIHNlYWdyZWVuOiAnIzJlOGI1NycsIHNlYXNoZWxsOiAnI2ZmZjVlZScsIHNpZW5uYTogJyNhMDUyMmQnLCBzaWx2ZXI6ICcjYzBjMGMwJywgc2t5Ymx1ZTogJyM4N2NlZWInLCBzbGF0ZWJsdWU6ICcjNmE1YWNkJywgc2xhdGVncmF5OiAnIzcwODA5MCcsIHNsYXRlZ3JleTogJyM3MDgwOTAnLCBzbm93OiAnI2ZmZmFmYScsIHNwcmluZ2dyZWVuOiAnIzAwZmY3ZicsIHN0ZWVsYmx1ZTogJyM0NjgyYjQnLCB0YW46ICcjZDJiNDhjJywgdGVhbDogJyMwMDgwODAnLCB0aGlzdGxlOiAnI2Q4YmZkOCcsIHRvbWF0bzogJyNmZjYzNDcnLCB0dXJxdW9pc2U6ICcjNDBlMGQwJywgdmlvbGV0OiAnI2VlODJlZScsIHdoZWF0OiAnI2Y1ZGViMycsIHdoaXRlOiAnI2ZmZmZmZicsIHdoaXRlc21va2U6ICcjZjVmNWY1JywgeWVsbG93OiAnI2ZmZmYwMCcsIHllbGxvd2dyZWVuOiAnIzlhY2QzMicgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2xvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb2xsZWN0aW9uIHRvIG1hcCBrZXlib2FyZCBjb2RlcyBpbiBwbGFpbiBlbmdsaXNoXG4gKlxuICogQGNsYXNzIEtleUNvZGVzXG4gKiBAc3RhdGljXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIDA6IDQ4LFxuICAgIDE6IDQ5LFxuICAgIDI6IDUwLFxuICAgIDM6IDUxLFxuICAgIDQ6IDUyLFxuICAgIDU6IDUzLFxuICAgIDY6IDU0LFxuICAgIDc6IDU1LFxuICAgIDg6IDU2LFxuICAgIDk6IDU3LFxuICAgIGE6IDk3LFxuICAgIGI6IDk4LFxuICAgIGM6IDk5LFxuICAgIGQ6IDEwMCxcbiAgICBlOiAxMDEsXG4gICAgZjogMTAyLFxuICAgIGc6IDEwMyxcbiAgICBoOiAxMDQsXG4gICAgaTogMTA1LFxuICAgIGo6IDEwNixcbiAgICBrOiAxMDcsXG4gICAgbDogMTA4LFxuICAgIG06IDEwOSxcbiAgICBuOiAxMTAsXG4gICAgbzogMTExLFxuICAgIHA6IDExMixcbiAgICBxOiAxMTMsXG4gICAgcjogMTE0LFxuICAgIHM6IDExNSxcbiAgICB0OiAxMTYsXG4gICAgdTogMTE3LFxuICAgIHY6IDExOCxcbiAgICB3OiAxMTksXG4gICAgeDogMTIwLFxuICAgIHk6IDEyMSxcbiAgICB6OiAxMjIsXG4gICAgQTogNjUsXG4gICAgQjogNjYsXG4gICAgQzogNjcsXG4gICAgRDogNjgsXG4gICAgRTogNjksXG4gICAgRjogNzAsXG4gICAgRzogNzEsXG4gICAgSDogNzIsXG4gICAgSTogNzMsXG4gICAgSjogNzQsXG4gICAgSzogNzUsXG4gICAgTDogNzYsXG4gICAgTTogNzcsXG4gICAgTjogNzgsXG4gICAgTzogNzksXG4gICAgUDogODAsXG4gICAgUTogODEsXG4gICAgUjogODIsXG4gICAgUzogODMsXG4gICAgVDogODQsXG4gICAgVTogODUsXG4gICAgVjogODYsXG4gICAgVzogODcsXG4gICAgWDogODgsXG4gICAgWTogODksXG4gICAgWjogOTAsXG4gICAgRU5URVIgOiAxMyxcbiAgICBMRUZUX0FSUk9XOiAzNyxcbiAgICBSSUdIVF9BUlJPVzogMzksXG4gICAgVVBfQVJST1c6IDM4LFxuICAgIERPV05fQVJST1c6IDQwLFxuICAgIFNQQUNFOiAzMixcbiAgICBTSElGVDogMTYsXG4gICAgVEFCOiA5XG59O1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIE1ldGhvZFN0b3JlICgpIHtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbn1cblxuTWV0aG9kU3RvcmUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24gKGtleSwgY2JjbGFzcywgY2JuYW1lKSB7XG4gICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50c1trZXldO1xuICAgIGlmICghZXZlbnRzKSBldmVudHMgPSBbXTtcbiAgICBldmVudHMucHVzaChjYmNsYXNzLCBjYm5hbWUpO1xuICAgIHJldHVybiB0aGlzO1xufVxuXG5NZXRob2RTdG9yZS5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gb2ZmIChrZXksIGNiY2xhc3MpIHtcbiAgICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzW2tleV07XG4gICAgaWYgKGV2ZW50cykge1xuICAgICAgICB2YXIgaW5kZXggPSBldmVudHMuaW5kZXhPZihjYmNsYXNzKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIGV2ZW50cy5zcGxpY2UoaW5kZXgsIDIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn1cblxuTWV0aG9kU3RvcmUucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiB0cmlnZ2VyIChrZXksIHBheWxvYWQpIHtcbiAgICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzW2tleV07XG4gICAgaWYgKGV2ZW50cykge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBsZW4gPSBldmVudHMubGVuZ3RoO1xuICAgICAgICBmb3IgKDsgaSA8IGxlbiA7IGkgKz0gMikgZXZlbnRzW2ldW2V2ZW50c1tpICsgMV1dKHBheWxvYWQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTWV0aG9kU3RvcmU7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU2luZ2xldG9uIG9iamVjdCB0byBtYW5hZ2UgcmVjeWNsaW5nIG9mIG9iamVjdHMgd2l0aCB0eXBpY2FsbHkgc2hvcnQgbGlmZXNwYW5zLCB1c2VkIHRvIGN1dCBkb3duIG9uIHRoZVxuICogYW1vdW50IG9mIGdhcmJhZ2UgY29sbGVjdGlvbiByZXF1aXJlZC5cbiAqXG4gKiBAc2luZ2xldG9uXG4gKi9cbnZhciBPYmplY3RNYW5hZ2VyID0ge307XG5cbk9iamVjdE1hbmFnZXIucG9vbHMgPSB7fTtcblxuLyoqXG4gKiBSZWdpc3RlciByZXF1ZXN0IGFuZCBmcmVlIGZ1bmN0aW9ucyBmb3IgdGhlIGdpdmVuIHR5cGUuXG4gKlxuICogQG1ldGhvZCByZWdpc3RlclxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IENvbnN0cnVjdG9yXG4gKi9cbk9iamVjdE1hbmFnZXIucmVnaXN0ZXIgPSBmdW5jdGlvbih0eXBlLCBDb25zdHJ1Y3Rvcikge1xuICAgIHZhciBwb29sID0gdGhpcy5wb29sc1t0eXBlXSA9IFtdO1xuXG4gICAgdGhpc1sncmVxdWVzdCcgKyB0eXBlXSA9IF9yZXF1ZXN0KHBvb2wsIENvbnN0cnVjdG9yKTtcbiAgICB0aGlzWydmcmVlJyArIHR5cGVdID0gX2ZyZWUocG9vbCk7XG59O1xuXG5mdW5jdGlvbiBfcmVxdWVzdChwb29sLCBDb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiByZXF1ZXN0KCkge1xuICAgICAgICBpZiAocG9vbC5sZW5ndGggIT09IDApIHJldHVybiBwb29sLnBvcCgpO1xuICAgICAgICBlbHNlIHJldHVybiBuZXcgQ29uc3RydWN0b3IoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIF9mcmVlKHBvb2wpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gZnJlZShvYmopIHtcbiAgICAgICAgcG9vbC5wdXNoKG9iaik7XG4gICAgfVxufVxuXG4vKipcbiAqIFVudHJhY2sgYWxsIG9iamVjdCBvZiB0aGUgZ2l2ZW4gdHlwZS4gVXNlZCB0byBhbGxvdyBhbGxvY2F0ZWQgb2JqZWN0cyB0byBiZSBnYXJiYWdlIGNvbGxlY3RlZC5cbiAqXG4gKiBAbWV0aG9kIGRpc3Bvc2VPZlxuICogQHBhcmFtIHtTdHJpbmd9XG4gKi9cbk9iamVjdE1hbmFnZXIuZGlzcG9zZU9mPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgdmFyIHBvb2wgPSB0aGlzLnBvb2xzW3R5cGVdO1xuICAgIHZhciBpID0gcG9vbC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgcG9vbC5wb3AoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0TWFuYWdlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiAgRGVlcCBjbG9uZSBhbiBvYmplY3QuXG4gKiAgQG1lbWJlcm9mIFV0aWxpdGllc1xuICogIEBwYXJhbSBiIHtPYmplY3R9IE9iamVjdCB0byBjbG9uZVxuICogIEByZXR1cm4gYSB7T2JqZWN0fSBDbG9uZWQgb2JqZWN0LlxuICovXG52YXIgY2xvbmUgPSBmdW5jdGlvbiBjbG9uZShiKSB7XG4gICAgdmFyIGE7XG4gICAgaWYgKHR5cGVvZiBiID09PSAnb2JqZWN0Jykge1xuICAgICAgICBhID0gKGIgaW5zdGFuY2VvZiBBcnJheSkgPyBbXSA6IHt9O1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gYikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBiW2tleV0gPT09ICdvYmplY3QnICYmIGJba2V5XSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChiW2tleV0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBhW2tleV0gPSBuZXcgQXJyYXkoYltrZXldLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYltrZXldLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhW2tleV1baV0gPSBjbG9uZShiW2tleV1baV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgYVtrZXldID0gY2xvbmUoYltrZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhW2tleV0gPSBiW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGEgPSBiO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmU7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRmxhdCBjbG9uZSBhbiBvYmplY3QuXG4gKiBAbWVtYmVyb2YgVXRpbGl0aWVzXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gT2JqZWN0IHRvIGNsb25lXG4gKiBAcmV0dXJuIHtPYmplY3R9IENsb25lZCBvYmplY3RcbiAqL1xuZnVuY3Rpb24gZmxhdENsb25lKG9iaikge1xuICAgIHZhciBjbG9uZSA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGNsb25lW2tleV0gPSBvYmpba2V5XTtcbiAgICByZXR1cm4gY2xvbmU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmxhdENsb25lO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBDYWxsYmFja1N0b3JlOiByZXF1aXJlKCcuL0NhbGxiYWNrU3RvcmUnKSxcbiAgICBjbG9uZTogcmVxdWlyZSgnLi9jbG9uZScpLFxuICAgIGZsYXRDbG9uZTogcmVxdWlyZSgnLi9mbGF0Q2xvbmUnKSxcbiAgICBLZXlDb2RlczogcmVxdWlyZSgnLi9LZXlDb2RlcycpLFxuICAgIGxvYWRVUkw6IHJlcXVpcmUoJy4vbG9hZFVSTCcpLFxuICAgIE1ldGhvZFN0b3JlOiByZXF1aXJlKCcuL01ldGhvZFN0b3JlJyksXG4gICAgT2JqZWN0TWFuYWdlcjogcmVxdWlyZSgnLi9PYmplY3RNYW5hZ2VyJyksXG4gICAgQ29sb3I6IHJlcXVpcmUoJy4vQ29sb3InKSxcbiAgICBzdHJpcDogcmVxdWlyZSgnLi9zdHJpcCcpLFxuICAgIGtleVZhbHVlVG9BcnJheXM6IHJlcXVpcmUoJy4va2V5VmFsdWVUb0FycmF5cycpXG59O1xuXG4iLCIvKipcbiAqIFRha2VzIGFuIG9iamVjdCBjb250YWluaW5nIGtleXMgYW5kIHZhbHVlcyBhbmQgcmV0dXJucyBhbiBvYmplY3RcbiAqIGNvbXByaXNpbmcgdHdvIFwiYXNzb2NpYXRlXCIgYXJyYXlzLCBvbmUgd2l0aCB0aGUga2V5cyBhbmQgdGhlIG90aGVyXG4gKiB3aXRoIHRoZSB2YWx1ZXMuXG4gKlxuICogQG1ldGhvZCBrZXlWYWx1ZXNUb0FycmF5c1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBPYmplY3RcbiAqIEByZXR1cm5zIHtPYmplY3R9IE9iamVjdCBPYmplY3QgY29udGFpbmluZyB0d28gYXJyYXlzLCBvbmUgd2l0aCB0aGUga2V5cyBhbmQgdGhlIG90aGVyIGZvciB2YWx1ZXNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBrZXlWYWx1ZXNUb0FycmF5cyhvYmopIHtcbiAgICB2YXIga2V5c0FycmF5ID0gW10sIHZhbHVlc0FycmF5ID0gW107XG4gICAgdmFyIGkgPSAwO1xuICAgIGZvcih2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIGtleXNBcnJheVtpXSA9IGtleTtcbiAgICAgICAgICAgIHZhbHVlc0FycmF5W2ldID0gb2JqW2tleV07XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2V5czoga2V5c0FycmF5LFxuICAgICAgICB2YWx1ZXM6IHZhbHVlc0FycmF5XG4gICAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTG9hZCBhIFVSTCBhbmQgcmV0dXJuIGl0cyBjb250ZW50cyBpbiBhIGNhbGxiYWNrXG4gKlxuICogQG1ldGhvZCBsb2FkVVJMXG4gKiBAbWVtYmVyb2YgVXRpbGl0aWVzXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFVSTCBvZiBvYmplY3RcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrIHRvIGRpc3BhdGNoIHdpdGggY29udGVudFxuICovXG52YXIgbG9hZFVSTCA9IGZ1bmN0aW9uIGxvYWRVUkwodXJsLCBjYWxsYmFjaykge1xuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gb25yZWFkeXN0YXRlY2hhbmdlKCkge1xuICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKHRoaXMucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgeGhyLm9wZW4oJ0dFVCcsIHVybCk7XG4gICAgeGhyLnNlbmQoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbG9hZFVSTDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCB2YWx1ZXMgbm90IGJlaW5nIG9mIGEgcHJpbWl0aXZlIHR5cGUgZnJvbSBhbiBhcmJpdHJhcnkgb2JqZWN0XG4gKiBsaXRlcmFsLlxuICpcbiAqIEBtZXRob2Qgc3RyaXBcbiAqIEBtZW1iZXJvZiBVdGlsaXRpZXNcbiAqIEBwYXJhbSAge2FueX0gICAgICAgIHByaW1pdGl2ZSBvciAobm9uLSlzZXJpYWxpemFibGUgb2JqZWN0IHdpdGhvdXRcbiAqICAgICAgICAgICAgICAgICAgICAgIGNpcmN1bGFyIHJlZmVyZW5jZXNcbiAqIEByZXR1cm4ge2FueX0gICAgICAgIHByaW1pdGl2ZSBvciAobmVzdGVkKSBvYmplY3Qgb25seSBjb250YWluaW5nIHByaW1pdGl2ZVxuICogICAgICAgICAgICAgICAgICAgICAgdHlwZXMgKHNlcmlhbGl6YWJsZSlcbiAqL1xuZnVuY3Rpb24gc3RyaXAob2JqKSB7XG4gICAgc3dpdGNoIChvYmopIHtcbiAgICAgICAgY2FzZSBudWxsOlxuICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIHN3aXRjaCAob2JqLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGNhc2UgQm9vbGVhbjpcbiAgICAgICAgY2FzZSBOdW1iZXI6XG4gICAgICAgIGNhc2UgU3RyaW5nOlxuICAgICAgICBjYXNlIFN5bWJvbDpcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIGNhc2UgT2JqZWN0OlxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgICAgIHZhciBzdHJpcHBlZCA9IHN0cmlwKG9ialtrZXldLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHN0cmlwcGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpcDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFBvc2l0aW9uID0gcmVxdWlyZSgnLi9Qb3NpdGlvbicpO1xuXG4vKipcbiAqIEBjbGFzcyBBbGlnblxuICogQGNvbnN0cnVjdG9yXG4gKiBAY29tcG9uZW50XG4gKiBAcGFyYW0ge0xvY2FsRGlzcGF0Y2h9IG5vZGUgTG9jYWxEaXNwYXRjaCB0byBiZSByZXRyaWV2ZWQgZnJvbSBjb3JyZXNwb25kaW5nIFJlbmRlciBOb2RlIG9mIHRoZSBBbGlnbiBjb21wb25lbnRcbiAqL1xuXG5mdW5jdGlvbiBBbGlnbihub2RlKSB7XG4gICAgUG9zaXRpb24uY2FsbCh0aGlzLCBub2RlKTtcblxuICAgIHZhciBpbml0aWFsID0gbm9kZS5nZXRBbGlnbigpO1xuXG4gICAgdGhpcy5feC5zZXQoaW5pdGlhbFswXSk7XG4gICAgdGhpcy5feS5zZXQoaW5pdGlhbFsxXSk7XG4gICAgdGhpcy5fei5zZXQoaW5pdGlhbFsyXSk7XG59XG5cbi8qKlxuKlxuKiBzdHJpbmdpZmllcyBBbGlnblxuKlxuKiBAbWV0aG9kXG4qIEByZXR1cm4ge1N0cmluZ30gdGhlIG5hbWUgb2YgdGhlIENvbXBvbmVudCBDbGFzczogJ0FsaWduJ1xuKi9cbkFsaWduLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIEFsaWduLnRvU3RyaW5nO1xufTtcblxuQWxpZ24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQb3NpdGlvbi5wcm90b3R5cGUpO1xuQWxpZ24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQWxpZ247XG5cbkFsaWduLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgdGhpcy5fbm9kZS5zZXRBbGlnbih0aGlzLl94LmdldCgpLCB0aGlzLl95LmdldCgpLCB0aGlzLl96LmdldCgpKTtcbiAgICB0aGlzLl9jaGVja1VwZGF0ZSgpO1xufTtcblxuQWxpZ24ucHJvdG90eXBlLm9uVXBkYXRlID0gQWxpZ24ucHJvdG90eXBlLnVwZGF0ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBBbGlnbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAY2xhc3MgQ2FtZXJhXG4gKiBAY29uc3RydWN0b3JcbiAqIEBjb21wb25lbnRcbiAqIEBwYXJhbSB7UmVuZGVyTm9kZX0gUmVuZGVyTm9kZSB0byB3aGljaCB0aGUgaW5zdGFuY2Ugb2YgQ2FtZXJhIHdpbGwgYmUgYSBjb21wb25lbnQgb2ZcbiAqL1xuZnVuY3Rpb24gQ2FtZXJhKG5vZGUpIHtcbiAgICB0aGlzLl9ub2RlID0gbm9kZTtcbiAgICB0aGlzLl9wcm9qZWN0aW9uVHlwZSA9IENhbWVyYS5PUlRIT0dSQVBISUNfUFJPSkVDVElPTjtcbiAgICB0aGlzLl9mb2NhbERlcHRoID0gMDtcbiAgICB0aGlzLl9uZWFyID0gMDtcbiAgICB0aGlzLl9mYXIgPSAwO1xuICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9pZCA9IG5vZGUuYWRkQ29tcG9uZW50KHRoaXMpO1xuICAgIHRoaXMuX3ZpZXdUcmFuc2Zvcm0gPSBuZXcgRmxvYXQzMkFycmF5KFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxXSk7XG4gICAgdGhpcy5fdmlld0RpcnR5ID0gZmFsc2U7XG4gICAgdGhpcy5fcGVyc3BlY3RpdmVEaXJ0eSA9IGZhbHNlO1xuICAgIHRoaXMuc2V0RmxhdCgpO1xufVxuXG5DYW1lcmEuRlJVU1RVTV9QUk9KRUNUSU9OID0gMDtcbkNhbWVyYS5QSU5IT0xFX1BST0pFQ1RJT04gPSAxO1xuQ2FtZXJhLk9SVEhPR1JBUEhJQ19QUk9KRUNUSU9OID0gMjtcblxuLy8gUmV0dXJuIHRoZSBuYW1lIG9mIHRoZSBFbGVtZW50IENsYXNzOiAnQ2FtZXJhJ1xuQ2FtZXJhLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdDYW1lcmEnO1xufTtcblxuQ2FtZXJhLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uIGdldFZhbHVlKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbXBvbmVudDogdGhpcy5jb25zdHJ1Y3Rvci50b1N0cmluZygpLFxuICAgICAgICBwcm9qZWN0aW9uVHlwZTogdGhpcy5fcHJvamVjdGlvblR5cGUsXG4gICAgICAgIGZvY2FsRGVwdGg6IHRoaXMuX2ZvY2FsRGVwdGgsXG4gICAgICAgIG5lYXI6IHRoaXMuX25lYXIsXG4gICAgICAgIGZhcjogdGhpcy5fZmFyXG4gICAgfTtcbn07XG5cbkNhbWVyYS5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiBzZXRWYWx1ZShzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5jb21wb25lbnQgPT09IHRoaXMuY29uc3RydWN0b3IudG9TdHJpbmcoKSkge1xuICAgICAgICB0aGlzLnNldChzdGF0ZS5wcm9qZWN0aW9uVHlwZSwgc3RhdGUuZm9jYWxEZXB0aCwgc3RhdGUubmVhciwgc3RhdGUuZmFyKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbkNhbWVyYS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0KHR5cGUsIGRlcHRoLCBuZWFyLCBmYXIpIHtcbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5fbm9kZS5yZXF1ZXN0VXBkYXRlKHRoaXMuX2lkKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX3Byb2plY3Rpb25UeXBlID0gdHlwZTtcbiAgICB0aGlzLl9mb2NhbERlcHRoID0gZGVwdGg7XG4gICAgdGhpcy5fbmVhciA9IG5lYXI7XG4gICAgdGhpcy5fZmFyID0gZmFyO1xufTtcblxuQ2FtZXJhLnByb3RvdHlwZS5zZXREZXB0aCA9IGZ1bmN0aW9uIHNldERlcHRoKGRlcHRoKSB7XG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX25vZGUucmVxdWVzdFVwZGF0ZSh0aGlzLl9pZCk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9wZXJzcGVjdGl2ZURpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLl9wcm9qZWN0aW9uVHlwZSA9IENhbWVyYS5QSU5IT0xFX1BST0pFQ1RJT047XG4gICAgdGhpcy5fZm9jYWxEZXB0aCA9IGRlcHRoO1xuICAgIHRoaXMuX25lYXIgPSAwO1xuICAgIHRoaXMuX2ZhciA9IDA7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbkNhbWVyYS5wcm90b3R5cGUuc2V0RnJ1c3R1bSA9IGZ1bmN0aW9uIHNldEZydXN0dW0obmVhciwgZmFyKSB7XG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX25vZGUucmVxdWVzdFVwZGF0ZSh0aGlzLl9pZCk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9wZXJzcGVjdGl2ZURpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLl9wcm9qZWN0aW9uVHlwZSA9IENhbWVyYS5GUlVTVFVNX1BST0pFQ1RJT047XG4gICAgdGhpcy5fZm9jYWxEZXB0aCA9IDA7XG4gICAgdGhpcy5fbmVhciA9IG5lYXI7XG4gICAgdGhpcy5fZmFyID0gZmFyO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5DYW1lcmEucHJvdG90eXBlLnNldEZsYXQgPSBmdW5jdGlvbiBzZXRGbGF0KCkge1xuICAgIGlmICghdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSkge1xuICAgICAgICB0aGlzLl9ub2RlLnJlcXVlc3RVcGRhdGUodGhpcy5faWQpO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fcGVyc3BlY3RpdmVEaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5fcHJvamVjdGlvblR5cGUgPSBDYW1lcmEuT1JUSE9HUkFQSElDX1BST0pFQ1RJT047XG4gICAgdGhpcy5fZm9jYWxEZXB0aCA9IDA7XG4gICAgdGhpcy5fbmVhciA9IDA7XG4gICAgdGhpcy5fZmFyID0gMDtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuQ2FtZXJhLnByb3RvdHlwZS5vblVwZGF0ZSA9IGZ1bmN0aW9uIG9uVXBkYXRlKCkge1xuICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSBmYWxzZTtcblxuICAgIHZhciBwYXRoID0gdGhpcy5fbm9kZS5nZXRMb2NhdGlvbigpO1xuXG4gICAgdGhpcy5fbm9kZVxuICAgICAgICAuc2VuZERyYXdDb21tYW5kKCdXSVRIJylcbiAgICAgICAgLnNlbmREcmF3Q29tbWFuZChwYXRoKTtcblxuICAgIGlmICh0aGlzLl9wZXJzcGVjdGl2ZURpcnR5KSB7XG4gICAgICAgIHRoaXMuX3BlcnNwZWN0aXZlRGlydHkgPSBmYWxzZTtcblxuICAgICAgICBzd2l0Y2ggKHRoaXMuX3Byb2plY3Rpb25UeXBlKSB7XG4gICAgICAgICAgICBjYXNlIENhbWVyYS5GUlVTVFVNX1BST0pFQ1RJT046XG4gICAgICAgICAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQoJ0ZSVVNUVU1fUFJPSkVDVElPTicpO1xuICAgICAgICAgICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKHRoaXMuX25lYXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKHRoaXMuX2Zhcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENhbWVyYS5QSU5IT0xFX1BST0pFQ1RJT046XG4gICAgICAgICAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQoJ1BJTkhPTEVfUFJPSkVDVElPTicpO1xuICAgICAgICAgICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKHRoaXMuX2ZvY2FsRGVwdGgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDYW1lcmEuT1JUSE9HUkFQSElDX1BST0pFQ1RJT046XG4gICAgICAgICAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQoJ09SVEhPR1JBUEhJQ19QUk9KRUNUSU9OJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fdmlld0RpcnR5KSB7XG4gICAgICAgIHRoaXMuX3ZpZXdEaXJ0eSA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKCdDSEFOR0VfVklFV19UUkFOU0ZPUk0nKTtcbiAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQodGhpcy5fdmlld1RyYW5zZm9ybVswXSk7XG4gICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKHRoaXMuX3ZpZXdUcmFuc2Zvcm1bMV0pO1xuICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZCh0aGlzLl92aWV3VHJhbnNmb3JtWzJdKTtcbiAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQodGhpcy5fdmlld1RyYW5zZm9ybVszXSk7XG5cbiAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQodGhpcy5fdmlld1RyYW5zZm9ybVs0XSk7XG4gICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKHRoaXMuX3ZpZXdUcmFuc2Zvcm1bNV0pO1xuICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZCh0aGlzLl92aWV3VHJhbnNmb3JtWzZdKTtcbiAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQodGhpcy5fdmlld1RyYW5zZm9ybVs3XSk7XG5cbiAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQodGhpcy5fdmlld1RyYW5zZm9ybVs4XSk7XG4gICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKHRoaXMuX3ZpZXdUcmFuc2Zvcm1bOV0pO1xuICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZCh0aGlzLl92aWV3VHJhbnNmb3JtWzEwXSk7XG4gICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKHRoaXMuX3ZpZXdUcmFuc2Zvcm1bMTFdKTtcblxuICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZCh0aGlzLl92aWV3VHJhbnNmb3JtWzEyXSk7XG4gICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKHRoaXMuX3ZpZXdUcmFuc2Zvcm1bMTNdKTtcbiAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQodGhpcy5fdmlld1RyYW5zZm9ybVsxNF0pO1xuICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZCh0aGlzLl92aWV3VHJhbnNmb3JtWzE1XSk7XG4gICAgfVxufTtcblxuXG5DYW1lcmEucHJvdG90eXBlLm9uVHJhbnNmb3JtQ2hhbmdlID0gZnVuY3Rpb24gb25UcmFuc2Zvcm1DaGFuZ2UodHJhbnNmb3JtKSB7XG4gICAgdmFyIGEgPSB0cmFuc2Zvcm07XG4gICAgdGhpcy5fdmlld0RpcnR5ID0gdHJ1ZTtcblxuICAgIGlmICghdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSkge1xuICAgICAgICB0aGlzLl9ub2RlLnJlcXVlc3RVcGRhdGUodGhpcy5faWQpO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XSxcblxuICAgIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMCxcbiAgICBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTAsXG4gICAgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwLFxuICAgIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMSxcbiAgICBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTEsXG4gICAgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyLFxuICAgIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMCxcbiAgICBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzAsXG4gICAgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwLFxuICAgIGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMSxcbiAgICBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzEsXG4gICAgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyLFxuXG4gICAgZGV0ID0gMS8oYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2KTtcblxuICAgIHRoaXMuX3ZpZXdUcmFuc2Zvcm1bMF0gPSAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldDtcbiAgICB0aGlzLl92aWV3VHJhbnNmb3JtWzFdID0gKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQ7XG4gICAgdGhpcy5fdmlld1RyYW5zZm9ybVsyXSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xuICAgIHRoaXMuX3ZpZXdUcmFuc2Zvcm1bM10gPSAoYTIyICogYjA0IC0gYTIxICogYjA1IC0gYTIzICogYjAzKSAqIGRldDtcbiAgICB0aGlzLl92aWV3VHJhbnNmb3JtWzRdID0gKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQ7XG4gICAgdGhpcy5fdmlld1RyYW5zZm9ybVs1XSA9IChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0O1xuICAgIHRoaXMuX3ZpZXdUcmFuc2Zvcm1bNl0gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcbiAgICB0aGlzLl92aWV3VHJhbnNmb3JtWzddID0gKGEyMCAqIGIwNSAtIGEyMiAqIGIwMiArIGEyMyAqIGIwMSkgKiBkZXQ7XG4gICAgdGhpcy5fdmlld1RyYW5zZm9ybVs4XSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xuICAgIHRoaXMuX3ZpZXdUcmFuc2Zvcm1bOV0gPSAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldDtcbiAgICB0aGlzLl92aWV3VHJhbnNmb3JtWzEwXSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0O1xuICAgIHRoaXMuX3ZpZXdUcmFuc2Zvcm1bMTFdID0gKGEyMSAqIGIwMiAtIGEyMCAqIGIwNCAtIGEyMyAqIGIwMCkgKiBkZXQ7XG4gICAgdGhpcy5fdmlld1RyYW5zZm9ybVsxMl0gPSAoYTExICogYjA3IC0gYTEwICogYjA5IC0gYTEyICogYjA2KSAqIGRldDtcbiAgICB0aGlzLl92aWV3VHJhbnNmb3JtWzEzXSA9IChhMDAgKiBiMDkgLSBhMDEgKiBiMDcgKyBhMDIgKiBiMDYpICogZGV0O1xuICAgIHRoaXMuX3ZpZXdUcmFuc2Zvcm1bMTRdID0gKGEzMSAqIGIwMSAtIGEzMCAqIGIwMyAtIGEzMiAqIGIwMCkgKiBkZXQ7XG4gICAgdGhpcy5fdmlld1RyYW5zZm9ybVsxNV0gPSAoYTIwICogYjAzIC0gYTIxICogYjAxICsgYTIyICogYjAwKSAqIGRldDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FtZXJhO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvbXBvbmVudCB0byBtYW5hZ2UgZ2VuZXJhbCBldmVudCBlbWlzc2lvbi5cbiAqXG4gKiBAY2xhc3MgRXZlbnRFbWl0dGVyXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIG5vZGUgdG8gc2VuZCBldmVudHMgdGhyb3VnaC5cbiAqL1xuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKG5vZGUpIHtcbiAgICB0aGlzLm5vZGUgPSBub2RlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG5hbWUgb2YgRXZlbnRFbWl0dGVyIGFzIGEgc3RyaW5nLlxuICpcbiAqIEBtZXRob2QgdG9TdHJpbmdcbiAqIEBzdGF0aWNcbiAqIEByZXR1cm4ge1N0cmluZ30gJ0V2ZW50RW1pdHRlcidcbiAqL1xuRXZlbnRFbWl0dGVyLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdFdmVudEVtaXR0ZXInO1xufTtcblxuLyoqXG4gKiBFbWl0IGFuIGV2ZW50IHdpdGggYSBwYXlsb2FkLlxuICpcbiAqIEBtZXRob2QgZW1pdFxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWQgVGhlIGV2ZW50IHBheWxvYWQuXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZlbnQsIHBheWxvYWQpIHtcbiAgICB0aGlzLm5vZGUuZW1pdChldmVudCwgcGF5bG9hZCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENhbGxiYWNrU3RvcmUgPSByZXF1aXJlKCdmYW1vdXMtdXRpbGl0aWVzJykuQ2FsbGJhY2tTdG9yZTtcblxuLyoqXG4gKiBDb21wb25lbnQgdG8gaGFuZGxlIGdlbmVyYWwgZXZlbnRzLlxuICpcbiAqIEBjbGFzcyBFdmVudEhhbmRsZXJcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBUaGUgbm9kZSBvbiB3aGljaCB0aGlzIGNvbXBvbmVudCBpcyByZWdpc3RlcmVkLlxuICovXG5mdW5jdGlvbiBFdmVudEhhbmRsZXIgKG5vZGUpIHtcbiAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgIHRoaXMuaWQgPSBub2RlLmFkZENvbXBvbmVudCh0aGlzKTtcbiAgICB0aGlzLl9ldmVudHMgPSBuZXcgQ2FsbGJhY2tTdG9yZSgpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG5hbWUgb2YgRXZlbnRIYW5kbGVyIGFzIGEgc3RyaW5nLlxuICpcbiAqIEBtZXRob2QgdG9TdHJpbmdcbiAqIEBzdGF0aWNcbiAqIEByZXR1cm4ge1N0cmluZ30gJ0V2ZW50SGFuZGxlcidcbiAqL1xuRXZlbnRIYW5kbGVyLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdFdmVudEhhbmRsZXInO1xufTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgb24gYW4gZXZlbnQuXG4gKlxuICogQG1ldGhvZCBvblxuICogQHBhcmFtIHtTdHJpbmd9IGV2IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgVGhlIGNhbGxiYWNrLlxuICovXG5FdmVudEhhbmRsZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24gKGV2LCBjYikge1xuICAgIHRoaXMuX2V2ZW50cy5vbihldiwgY2IpO1xufTtcblxuLyoqXG4gKiBEZXJlZ2lzdGVyIGEgY2FsbGJhY2sgZnJvbSBhbiBldmVudC5cbiAqXG4gKiBAbWV0aG9kIG9uXG4gKiBAcGFyYW0ge1N0cmluZ30gZXYgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBUaGUgY2FsbGJhY2suXG4gKi9cbkV2ZW50SGFuZGxlci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gb2ZmIChldiwgY2IpIHtcbiAgICB0aGlzLl9ldmVudHMub2ZmKGV2LCBjYik7XG59O1xuXG4vKipcbiAqIFRyaWdnZXIgdGhlIGNhbGxiYWNrIGFzc29jaWF0ZWQgd2l0aCBhbiBldmVudCwgcGFzc2luZyBpbiBhIHBheWxvYWQuXG4gKlxuICogQG1ldGhvZCB0cmlnZ2VyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXYgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZCBUaGUgZXZlbnQgcGF5bG9hZC5cbiAqL1xuRXZlbnRIYW5kbGVyLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gdHJpZ2dlciAoZXYsIHBheWxvYWQpIHtcbiAgICB0aGlzLl9ldmVudHMudHJpZ2dlcihldiwgcGF5bG9hZCk7XG59O1xuXG5FdmVudEhhbmRsZXIucHJvdG90eXBlLm9uUmVjZWl2ZSA9IEV2ZW50SGFuZGxlci5wcm90b3R5cGUudHJpZ2dlcjtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEhhbmRsZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDYWxsYmFja1N0b3JlID0gcmVxdWlyZSgnZmFtb3VzLXV0aWxpdGllcycpLkNhbGxiYWNrU3RvcmU7XG52YXIgVmVjMiA9IHJlcXVpcmUoJ2ZhbW91cy1tYXRoJykuVmVjMjtcblxudmFyIFZFQ19SRUdJU1RFUiA9IG5ldyBWZWMyKCk7XG5cbnZhciBnZXN0dXJlcyA9IHtkcmFnOiB0cnVlLCB0YXA6IHRydWUsIHJvdGF0ZTogdHJ1ZSwgcGluY2g6IHRydWV9O1xuXG4vKipcbiAqIENvbXBvbmVudCB0byBtYW5hZ2UgZ2VzdHVyZSBldmVudHMuIFdpbGwgdHJhY2sgJ3BpbmNoJywgJ3JvdGF0ZScsICd0YXAnLCBhbmQgJ2RyYWcnIGV2ZW50cywgb24gYW5cbiAqIGFzLXJlcXVlc3RlZCBiYXNpcy5cbiAqXG4gKiBAY2xhc3MgR2VzdHVyZUhhbmRsZXJcbiAqIEBwYXJhbSB7TG9jYWxEaXNwYXRjaH0gbm9kZSBUaGUgbm9kZSB3aXRoIHdoaWNoIHRvIHJlZ2lzdGVyIHRoZSBoYW5kbGVyLlxuICogQHBhcmFtIHtPYmplY3RbXX0gZXZlbnRzIEFuIGFycmF5IG9mIGV2ZW50IG9iamVjdHMgc3BlY2lmeWluZyAuZXZlbnQgYW5kIC5jYWxsYmFjayBwcm9wZXJ0aWVzLlxuICovXG5cbmZ1bmN0aW9uIEdlc3R1cmVIYW5kbGVyIChub2RlLCBldmVudHMpIHtcbiAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgIHRoaXMuaWQgPSBub2RlLmFkZENvbXBvbmVudCh0aGlzKTtcblxuICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBDYWxsYmFja1N0b3JlKCk7XG5cbiAgICB0aGlzLmxhc3QxID0gbmV3IFZlYzIoKTtcbiAgICB0aGlzLmxhc3QyID0gbmV3IFZlYzIoKTtcblxuICAgIHRoaXMuZGVsdGExID0gbmV3IFZlYzIoKTtcbiAgICB0aGlzLmRlbHRhMiA9IG5ldyBWZWMyKCk7XG5cbiAgICB0aGlzLnZlbG9jaXR5MSA9IG5ldyBWZWMyKCk7XG4gICAgdGhpcy52ZWxvY2l0eTIgPSBuZXcgVmVjMigpO1xuXG4gICAgdGhpcy5kaXN0ID0gMDtcbiAgICB0aGlzLmRpZmYxMiA9IG5ldyBWZWMyKCk7XG5cbiAgICB0aGlzLmNlbnRlciA9IG5ldyBWZWMyKCk7XG4gICAgdGhpcy5jZW50ZXJEZWx0YSA9IG5ldyBWZWMyKCk7XG4gICAgdGhpcy5jZW50ZXJWZWxvY2l0eSA9IG5ldyBWZWMyKCk7XG5cbiAgICB0aGlzLnBvaW50ZXIxID0ge1xuICAgICAgICBwb3NpdGlvbjogdGhpcy5sYXN0MSxcbiAgICAgICAgZGVsdGE6IHRoaXMuZGVsdGExLFxuICAgICAgICB2ZWxvY2l0eTogdGhpcy52ZWxvY2l0eTEsXG4gICAgfTtcblxuICAgIHRoaXMucG9pbnRlcjIgPSB7XG4gICAgICAgIHBvc2l0aW9uOiB0aGlzLmxhc3QyLFxuICAgICAgICBkZWx0YTogdGhpcy5kZWx0YTIsXG4gICAgICAgIHZlbG9jaXR5OiB0aGlzLnZlbG9jaXR5MixcbiAgICB9O1xuXG4gICAgdGhpcy5ldmVudCA9IHtcbiAgICAgICAgc3RhdHVzOiBudWxsLFxuICAgICAgICB0aW1lOiAwLFxuICAgICAgICBwb2ludGVyczogW10sXG4gICAgICAgIGNlbnRlcjogdGhpcy5jZW50ZXIsXG4gICAgICAgIGNlbnRlckRlbHRhOiB0aGlzLmNlbnRlckRlbHRhLFxuICAgICAgICBjZW50ZXJWZWxvY2l0eTogdGhpcy5jZW50ZXJWZWxvY2l0eSxcbiAgICAgICAgcG9pbnRzOiAwLFxuICAgICAgICBjdXJyZW50OiAwXG4gICAgfTtcblxuICAgIHRoaXMudHJhY2tlZFBvaW50ZXJJRHMgPSBbLTEsIC0xXTtcbiAgICB0aGlzLnRpbWVPZlBvaW50ZXIgPSAwO1xuICAgIHRoaXMubXVsdGlUYXAgPSAwO1xuXG4gICAgdGhpcy5taWNlID0gW107XG5cbiAgICB0aGlzLmdlc3R1cmVzID0gW107XG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgdGhpcy50cmFja2VkR2VzdHVyZXMgPSB7fTtcblxuICAgIHZhciBpO1xuICAgIHZhciBsZW47XG5cbiAgICBpZiAoZXZlbnRzKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGV2ZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdGhpcy5vbihldmVudHNbaV0sIGV2ZW50c1tpXS5jYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBub2RlLmFkZFVJRXZlbnQoJ3RvdWNoc3RhcnQnKTtcbiAgICBub2RlLmFkZFVJRXZlbnQoJ21vdXNlZG93bicpO1xuICAgIG5vZGUuYWRkVUlFdmVudCgndG91Y2htb3ZlJyk7XG4gICAgbm9kZS5hZGRVSUV2ZW50KCdtb3VzZW1vdmUnKTtcbiAgICBub2RlLmFkZFVJRXZlbnQoJ3RvdWNoZW5kJyk7XG4gICAgbm9kZS5hZGRVSUV2ZW50KCdtb3VzZXVwJyk7XG4gICAgbm9kZS5hZGRVSUV2ZW50KCdtb3VzZWxlYXZlJyk7XG59XG5cbkdlc3R1cmVIYW5kbGVyLnByb3RvdHlwZS5vblJlY2VpdmUgPSBmdW5jdGlvbiBvblJlY2VpdmUgKGV2LCBwYXlsb2FkKSB7XG4gICAgc3dpdGNoKGV2KSB7XG4gICAgICAgIGNhc2UgJ3RvdWNoc3RhcnQnOlxuICAgICAgICBjYXNlICdtb3VzZWRvd24nOlxuICAgICAgICAgICAgX3Byb2Nlc3NQb2ludGVyU3RhcnQuY2FsbCh0aGlzLCBwYXlsb2FkKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0b3VjaG1vdmUnOlxuICAgICAgICBjYXNlICdtb3VzZW1vdmUnOlxuICAgICAgICAgICAgX3Byb2Nlc3NQb2ludGVyTW92ZS5jYWxsKHRoaXMsIHBheWxvYWQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RvdWNoZW5kJzpcbiAgICAgICAgY2FzZSAnbW91c2V1cCc6XG4gICAgICAgICAgICBfcHJvY2Vzc1BvaW50ZXJFbmQuY2FsbCh0aGlzLCBwYXlsb2FkKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtb3VzZWxlYXZlJzpcbiAgICAgICAgICAgIF9wcm9jZXNzTW91c2VMZWF2ZS5jYWxsKHRoaXMsIHBheWxvYWQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG5hbWUgb2YgR2VzdHVyZUhhbmRsZXIgYXMgYSBzdHJpbmcuXG4gKlxuICogQG1ldGhvZCB0b1N0cmluZ1xuICogQHN0YXRpY1xuICogQHJldHVybiB7U3RyaW5nfSAnR2VzdHVyZUhhbmRsZXInXG4gKi9cbkdlc3R1cmVIYW5kbGVyLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdHZXN0dXJlSGFuZGxlcic7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCBvbiBhbiBldmVudC5cbiAqXG4gKiBAbWV0aG9kIG9uXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGV2IFRoZSBldmVudCBvYmplY3Qgb3IgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIFRoZSBjYWxsYmFjay5cbiAqL1xuR2VzdHVyZUhhbmRsZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZXYsIGNiKSB7XG4gICAgdmFyIGdlc3R1cmUgPSBldi5ldmVudCB8fCBldjtcbiAgICBpZiAoZ2VzdHVyZXNbZ2VzdHVyZV0pIHtcbiAgICAgICAgdGhpcy50cmFja2VkR2VzdHVyZXNbZ2VzdHVyZV0gPSB0cnVlO1xuICAgICAgICB0aGlzLmdlc3R1cmVzLnB1c2goZ2VzdHVyZSk7XG4gICAgICAgIGlmIChldi5ldmVudCkgdGhpcy5vcHRpb25zW2dlc3R1cmVdID0gZXY7XG4gICAgICAgIHRoaXMuX2V2ZW50cy5vbihnZXN0dXJlLCBjYik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBUcmlnZ2VyIGdlc3R1cmVzIGluIHRoZSBvcmRlciB0aGV5IHdlcmUgcmVxdWVzdGVkLCBpZiB0aGV5IG9jY3VyZWQuXG4gKlxuICogQG1ldGhvZCB0cmlnZ2VyR2VzdHVyZXNcbiAqL1xuR2VzdHVyZUhhbmRsZXIucHJvdG90eXBlLnRyaWdnZXJHZXN0dXJlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwYXlsb2FkID0gdGhpcy5ldmVudDtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5nZXN0dXJlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgZ2VzdHVyZSA9IHRoaXMuZ2VzdHVyZXNbaV07XG4gICAgICAgIHN3aXRjaCAoZ2VzdHVyZSkge1xuICAgICAgICAgICAgY2FzZSAncm90YXRlJzpcbiAgICAgICAgICAgIGNhc2UgJ3BpbmNoJzpcbiAgICAgICAgICAgICAgICBpZiAocGF5bG9hZC5wb2ludHMgPT09IDIpIHRoaXMudHJpZ2dlcihnZXN0dXJlLCBwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3RhcCc6XG4gICAgICAgICAgICAgICAgaWYgKHBheWxvYWQuc3RhdHVzID09PSAnc3RhcnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudGFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHRzID0gdGhpcy5vcHRpb25zLnRhcC5wb2ludHMgfHwgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMubXVsdGlUYXAgPj0gcHRzICYmIHBheWxvYWQucG9pbnRzID49IHB0cykgdGhpcy50cmlnZ2VyKGdlc3R1cmUsIHBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgdGhpcy50cmlnZ2VyKGdlc3R1cmUsIHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKGdlc3R1cmUsIHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBUcmlnZ2VyIHRoZSBjYWxsYmFjayBhc3NvY2lhdGVkIHdpdGggYW4gZXZlbnQsIHBhc3NpbmcgaW4gYSBwYXlsb2FkLlxuICpcbiAqIEBtZXRob2QgdHJpZ2dlclxuICogQHBhcmFtIHtTdHJpbmd9IGV2IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWQgVGhlIGV2ZW50IHBheWxvYWQuXG4gKi9cbkdlc3R1cmVIYW5kbGVyLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gdHJpZ2dlciAoZXYsIHBheWxvYWQpIHtcbiAgICB0aGlzLl9ldmVudHMudHJpZ2dlcihldiwgcGF5bG9hZCk7XG59O1xuXG4vKipcbiAqIFByb2Nlc3MgdXAgdG8gdGhlIGZpcnN0IHR3byB0b3VjaC9tb3VzZSBtb3ZlIGV2ZW50cy4gRXhpdCBvdXQgaWYgdGhlIGZpcnN0IHR3byBwb2ludHMgYXJlIGFscmVhZHkgYmVpbmcgdHJhY2tlZC5cbiAqXG4gKiBAbWV0aG9kIF9wcm9jZXNzUG9pbnRlclN0YXJ0XG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGUgVGhlIGV2ZW50IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gX3Byb2Nlc3NQb2ludGVyU3RhcnQoZSkge1xuICAgIHZhciB0O1xuICAgIGlmICghZS50YXJnZXRUb3VjaGVzKSB7XG4gICAgICAgIHRoaXMubWljZVswXSA9IGU7XG4gICAgICAgIHQgPSB0aGlzLm1pY2U7XG4gICAgICAgIGUuaWRlbnRpZmllciA9IDE7XG4gICAgfVxuICAgIGVsc2UgdCA9IGUudGFyZ2V0VG91Y2hlcztcblxuICAgIGlmICh0WzBdICYmIHRbMV0gJiYgdGhpcy50cmFja2VkUG9pbnRlcklEc1swXSA9PT0gdFswXS5pZGVudGlmaWVyICYmIHRoaXMudHJhY2tlZFBvaW50ZXJJRHNbMV0gPT09IHRbMV0uaWRlbnRpZmllcikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5ldmVudC50aW1lID0gRGF0ZS5ub3coKTtcblxuICAgIHZhciB0aHJlc2hvbGQ7XG4gICAgdmFyIGlkO1xuXG4gICAgaWYgKHRoaXMudHJhY2tlZFBvaW50ZXJJRHNbMF0gIT09IHRbMF0uaWRlbnRpZmllcikge1xuICAgICAgICBpZiAodGhpcy50cmFja2VkR2VzdHVyZXMudGFwKSB7XG4gICAgICAgICAgICB0aHJlc2hvbGQgPSAodGhpcy5vcHRpb25zLnRhcCAmJiB0aGlzLm9wdGlvbnMudGFwLnRocmVzaG9sZCkgfHwgMjUwO1xuICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnQudGltZSAtIHRoaXMudGltZU9mUG9pbnRlciA8IHRocmVzaG9sZCkgdGhpcy5ldmVudC50YXBzKys7XG4gICAgICAgICAgICBlbHNlIHRoaXMuZXZlbnQudGFwcyA9IDE7XG4gICAgICAgICAgICB0aGlzLnRpbWVPZlBvaW50ZXIgPSB0aGlzLmV2ZW50LnRpbWU7XG4gICAgICAgICAgICB0aGlzLm11bHRpVGFwID0gMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV2ZW50LmN1cnJlbnQgPSAxO1xuICAgICAgICB0aGlzLmV2ZW50LnBvaW50cyA9IDE7XG4gICAgICAgIGlkID0gdFswXS5pZGVudGlmaWVyO1xuICAgICAgICB0aGlzLnRyYWNrZWRQb2ludGVySURzWzBdID0gaWQ7XG5cbiAgICAgICAgdGhpcy5sYXN0MS5zZXQodFswXS5wYWdlWCwgdFswXS5wYWdlWSk7XG4gICAgICAgIHRoaXMudmVsb2NpdHkxLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuZGVsdGExLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuZXZlbnQucG9pbnRlcnMucHVzaCh0aGlzLnBvaW50ZXIxKTtcbiAgICB9XG4gICAgaWYgKHRbMV0gJiYgdGhpcy50cmFja2VkUG9pbnRlcklEc1sxXSAhPT0gdFsxXS5pZGVudGlmaWVyKSB7XG4gICAgICAgIGlmICh0aGlzLnRyYWNrZWRHZXN0dXJlcy50YXApIHtcbiAgICAgICAgICAgIHRocmVzaG9sZCA9ICh0aGlzLm9wdGlvbnMudGFwICYmIHRoaXMub3B0aW9ucy50YXAudGhyZXNob2xkKSB8fCAyNTA7XG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudC50aW1lIC0gdGhpcy50aW1lT2ZQb2ludGVyIDwgdGhyZXNob2xkKSB0aGlzLm11bHRpVGFwID0gMjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV2ZW50LmN1cnJlbnQgPSAyO1xuICAgICAgICB0aGlzLmV2ZW50LnBvaW50cyA9IDI7XG4gICAgICAgIGlkID0gdFsxXS5pZGVudGlmaWVyO1xuICAgICAgICB0aGlzLnRyYWNrZWRQb2ludGVySURzWzFdID0gaWQ7XG5cbiAgICAgICAgdGhpcy5sYXN0Mi5zZXQodFsxXS5wYWdlWCwgdFsxXS5wYWdlWSk7XG4gICAgICAgIHRoaXMudmVsb2NpdHkyLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuZGVsdGEyLmNsZWFyKCk7XG5cbiAgICAgICAgVmVjMi5hZGQodGhpcy5sYXN0MSwgdGhpcy5sYXN0MiwgdGhpcy5jZW50ZXIpLnNjYWxlKDAuNSk7XG4gICAgICAgIHRoaXMuY2VudGVyRGVsdGEuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5jZW50ZXJWZWxvY2l0eS5jbGVhcigpO1xuXG4gICAgICAgIFZlYzIuc3VidHJhY3QodGhpcy5sYXN0MiwgdGhpcy5sYXN0MSwgdGhpcy5kaWZmMTIpO1xuICAgICAgICB0aGlzLmRpc3QgPSB0aGlzLmRpZmYxMi5sZW5ndGgoKTtcblxuICAgICAgICBpZiAodGhpcy50cmFja2VkR2VzdHVyZXMucGluY2gpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnQuc2NhbGUgPSB0aGlzLmV2ZW50LnNjYWxlIHx8IDE7XG4gICAgICAgICAgICB0aGlzLmV2ZW50LnNjYWxlRGVsdGEgPSAwO1xuICAgICAgICAgICAgdGhpcy5ldmVudC5zY2FsZVZlbG9jaXR5ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50cmFja2VkR2VzdHVyZXMucm90YXRlKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50LnJvdGF0aW9uID0gdGhpcy5ldmVudC5yb3RhdGlvbiB8fCAwO1xuICAgICAgICAgICAgdGhpcy5ldmVudC5yb3RhdGlvbkRlbHRhID0gMDtcbiAgICAgICAgICAgIHRoaXMuZXZlbnQucm90YXRpb25WZWxvY2l0eSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ldmVudC5wb2ludGVycy5wdXNoKHRoaXMucG9pbnRlcjIpO1xuICAgIH1cblxuICAgIHRoaXMuZXZlbnQuc3RhdHVzID0gJ3N0YXJ0JztcbiAgICBpZiAodGhpcy5ldmVudC5wb2ludHMgPT09IDEpIHtcbiAgICAgICAgdGhpcy5jZW50ZXIuY29weSh0aGlzLmxhc3QxKTtcbiAgICAgICAgdGhpcy5jZW50ZXJEZWx0YS5jbGVhcigpO1xuICAgICAgICB0aGlzLmNlbnRlclZlbG9jaXR5LmNsZWFyKCk7XG4gICAgICAgIGlmICh0aGlzLnRyYWNrZWRHZXN0dXJlcy5waW5jaCkge1xuICAgICAgICAgICAgdGhpcy5ldmVudC5zY2FsZSA9IDE7XG4gICAgICAgICAgICB0aGlzLmV2ZW50LnNjYWxlRGVsdGEgPSAwO1xuICAgICAgICAgICAgdGhpcy5ldmVudC5zY2FsZVZlbG9jaXR5ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50cmFja2VkR2VzdHVyZXMucm90YXRlKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50LnJvdGF0aW9uID0gMDtcbiAgICAgICAgICAgIHRoaXMuZXZlbnQucm90YXRpb25EZWx0YSA9IDA7XG4gICAgICAgICAgICB0aGlzLmV2ZW50LnJvdGF0aW9uVmVsb2NpdHkgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMudHJpZ2dlckdlc3R1cmVzKCk7XG59XG5cbi8qKlxuICogUHJvY2VzcyB1cCB0byB0aGUgZmlyc3QgdHdvIHRvdWNoL21vdXNlIG1vdmUgZXZlbnRzLlxuICpcbiAqIEBtZXRob2QgX3Byb2Nlc3NQb2ludGVyTW92ZVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBlIFRoZSBldmVudCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIF9wcm9jZXNzUG9pbnRlck1vdmUoZSkge1xuICAgIHZhciB0O1xuICAgIGlmICghZS50YXJnZXRUb3VjaGVzKSB7XG4gICAgICAgIGlmICghdGhpcy5ldmVudC5jdXJyZW50KSByZXR1cm47XG4gICAgICAgIHRoaXMubWljZVswXSA9IGU7XG4gICAgICAgIHQgPSB0aGlzLm1pY2U7XG4gICAgICAgIGUuaWRlbnRpZmllciA9IDE7XG4gICAgfVxuICAgIGVsc2UgdCA9IGUudGFyZ2V0VG91Y2hlcztcblxuICAgIHZhciB0aW1lID0gRGF0ZS5ub3coKTtcbiAgICB2YXIgZHQgPSB0aW1lIC0gdGhpcy5ldmVudC50aW1lO1xuICAgIGlmIChkdCA9PT0gMCkgcmV0dXJuO1xuICAgIHZhciBpbnZEdCA9IDEwMDAgLyBkdDtcbiAgICB0aGlzLmV2ZW50LnRpbWUgPSB0aW1lO1xuXG4gICAgdGhpcy5ldmVudC5jdXJyZW50ID0gMTtcbiAgICB0aGlzLmV2ZW50LnBvaW50cyA9IDE7XG4gICAgaWYgKHRoaXMudHJhY2tlZFBvaW50ZXJJRHNbMF0gPT09IHRbMF0uaWRlbnRpZmllcikge1xuICAgICAgICBWRUNfUkVHSVNURVIuc2V0KHRbMF0ucGFnZVgsIHRbMF0ucGFnZVkpO1xuICAgICAgICBWZWMyLnN1YnRyYWN0KFZFQ19SRUdJU1RFUiwgdGhpcy5sYXN0MSwgdGhpcy5kZWx0YTEpO1xuICAgICAgICBWZWMyLnNjYWxlKHRoaXMuZGVsdGExLCBpbnZEdCwgdGhpcy52ZWxvY2l0eTEpO1xuICAgICAgICB0aGlzLmxhc3QxLmNvcHkoVkVDX1JFR0lTVEVSKTtcblxuICAgIH1cbiAgICBpZiAodFsxXSkge1xuICAgICAgICB0aGlzLmV2ZW50LmN1cnJlbnQgPSAyO1xuICAgICAgICB0aGlzLmV2ZW50LnBvaW50cyA9IDI7XG4gICAgICAgIFZFQ19SRUdJU1RFUi5zZXQodFsxXS5wYWdlWCwgdFsxXS5wYWdlWSk7XG4gICAgICAgIFZlYzIuc3VidHJhY3QoVkVDX1JFR0lTVEVSLCB0aGlzLmxhc3QyLCB0aGlzLmRlbHRhMik7XG4gICAgICAgIFZlYzIuc2NhbGUodGhpcy5kZWx0YTIsIGludkR0LCB0aGlzLnZlbG9jaXR5Mik7XG4gICAgICAgIHRoaXMubGFzdDIuY29weShWRUNfUkVHSVNURVIpO1xuXG4gICAgICAgIFZlYzIuYWRkKHRoaXMubGFzdDEsIHRoaXMubGFzdDIsIFZFQ19SRUdJU1RFUikuc2NhbGUoMC41KTtcbiAgICAgICAgVmVjMi5zdWJ0cmFjdChWRUNfUkVHSVNURVIsIHRoaXMuY2VudGVyLCB0aGlzLmNlbnRlckRlbHRhKTtcbiAgICAgICAgVmVjMi5hZGQodGhpcy52ZWxvY2l0eTEsIHRoaXMudmVsb2NpdHkyLCB0aGlzLmNlbnRlclZlbG9jaXR5KS5zY2FsZSgwLjUpO1xuICAgICAgICB0aGlzLmNlbnRlci5jb3B5KFZFQ19SRUdJU1RFUik7XG5cbiAgICAgICAgVmVjMi5zdWJ0cmFjdCh0aGlzLmxhc3QyLCB0aGlzLmxhc3QxLCBWRUNfUkVHSVNURVIpO1xuXG4gICAgICAgIGlmICh0aGlzLnRyYWNrZWRHZXN0dXJlcy5yb3RhdGUpIHtcbiAgICAgICAgICAgIHZhciBkb3QgPSBWRUNfUkVHSVNURVIuZG90KHRoaXMuZGlmZjEyKTtcbiAgICAgICAgICAgIHZhciBjcm9zcyA9IFZFQ19SRUdJU1RFUi5jcm9zcyh0aGlzLmRpZmYxMik7XG4gICAgICAgICAgICB2YXIgdGhldGEgPSAtTWF0aC5hdGFuMihjcm9zcywgZG90KTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnQucm90YXRpb24gKz0gdGhldGE7XG4gICAgICAgICAgICB0aGlzLmV2ZW50LnJvdGF0aW9uRGVsdGEgPSB0aGV0YTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnQucm90YXRpb25WZWxvY2l0eSA9IHRoZXRhICogaW52RHQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGlzdCA9IFZFQ19SRUdJU1RFUi5sZW5ndGgoKTtcbiAgICAgICAgdmFyIHNjYWxlID0gZGlzdCAvIHRoaXMuZGlzdDtcbiAgICAgICAgdGhpcy5kaWZmMTIuY29weShWRUNfUkVHSVNURVIpO1xuICAgICAgICB0aGlzLmRpc3QgPSBkaXN0O1xuXG4gICAgICAgIGlmICh0aGlzLnRyYWNrZWRHZXN0dXJlcy5waW5jaCkge1xuICAgICAgICAgICAgdGhpcy5ldmVudC5zY2FsZSAqPSBzY2FsZTtcbiAgICAgICAgICAgIHNjYWxlIC09IDEuMDtcbiAgICAgICAgICAgIHRoaXMuZXZlbnQuc2NhbGVEZWx0YSA9IHNjYWxlO1xuICAgICAgICAgICAgdGhpcy5ldmVudC5zY2FsZVZlbG9jaXR5ID0gc2NhbGUgKiBpbnZEdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZXZlbnQuc3RhdHVzID0gJ21vdmUnO1xuICAgIGlmICh0aGlzLmV2ZW50LnBvaW50cyA9PT0gMSkge1xuICAgICAgICB0aGlzLmNlbnRlci5jb3B5KHRoaXMubGFzdDEpO1xuICAgICAgICB0aGlzLmNlbnRlckRlbHRhLmNvcHkodGhpcy5kZWx0YTEpO1xuICAgICAgICB0aGlzLmNlbnRlclZlbG9jaXR5LmNvcHkodGhpcy52ZWxvY2l0eTEpO1xuICAgICAgICBpZiAodGhpcy50cmFja2VkR2VzdHVyZXMucGluY2gpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnQuc2NhbGUgPSAxO1xuICAgICAgICAgICAgdGhpcy5ldmVudC5zY2FsZURlbHRhID0gMDtcbiAgICAgICAgICAgIHRoaXMuZXZlbnQuc2NhbGVWZWxvY2l0eSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudHJhY2tlZEdlc3R1cmVzLnJvdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5ldmVudC5yb3RhdGlvbiA9IDA7XG4gICAgICAgICAgICB0aGlzLmV2ZW50LnJvdGF0aW9uRGVsdGEgPSAwO1xuICAgICAgICAgICAgdGhpcy5ldmVudC5yb3RhdGlvblZlbG9jaXR5ID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnRyaWdnZXJHZXN0dXJlcygpO1xufVxuXG4vKipcbiAqIFByb2Nlc3MgdXAgdG8gdGhlIGZpcnN0IHR3byB0b3VjaC9tb3VzZSBlbmQgZXZlbnRzLiBFeGl0IG91dCBpZiB0aGUgdHdvIHBvaW50cyBiZWluZyB0cmFja2VkIGFyZSBzdGlsbCBhY3RpdmUuXG4gKlxuICogQG1ldGhvZCBfcHJvY2Vzc1BvaW50ZXJFbmRcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gZSBUaGUgZXZlbnQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBfcHJvY2Vzc1BvaW50ZXJFbmQoZSkge1xuICAgIHZhciB0O1xuICAgIGlmICghZS50YXJnZXRUb3VjaGVzKSB7XG4gICAgICAgIGlmICghdGhpcy5ldmVudC5jdXJyZW50KSByZXR1cm47XG4gICAgICAgIHRoaXMubWljZS5wb3AoKTtcbiAgICAgICAgdCA9IHRoaXMubWljZTtcbiAgICB9XG4gICAgZWxzZSB0ID0gZS50YXJnZXRUb3VjaGVzO1xuXG4gICAgaWYgKHRbMF0gJiYgdFsxXSAmJiB0aGlzLnRyYWNrZWRQb2ludGVySURzWzBdID09PSB0WzBdLmlkZW50aWZpZXIgJiYgdGhpcy50cmFja2VkUG9pbnRlcklEc1sxXSA9PT0gdFsxXS5pZGVudGlmaWVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGlkO1xuXG4gICAgdGhpcy5ldmVudC5zdGF0dXMgPSAnZW5kJztcbiAgICBpZiAoIXRbMF0pIHtcbiAgICAgICAgdGhpcy5ldmVudC5jdXJyZW50ID0gMDtcbiAgICAgICAgdGhpcy50cmFja2VkUG9pbnRlcklEc1swXSA9IC0xO1xuICAgICAgICB0aGlzLnRyYWNrZWRQb2ludGVySURzWzFdID0gLTE7XG4gICAgICAgIHRoaXMudHJpZ2dlckdlc3R1cmVzKCk7XG4gICAgICAgIHRoaXMuZXZlbnQucG9pbnRlcnMucG9wKCk7XG4gICAgICAgIHRoaXMuZXZlbnQucG9pbnRlcnMucG9wKCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSBpZih0aGlzLnRyYWNrZWRQb2ludGVySURzWzBdICE9PSB0WzBdLmlkZW50aWZpZXIpIHtcbiAgICAgICAgdGhpcy50cmFja2VkUG9pbnRlcklEc1swXSA9IC0xO1xuICAgICAgICBpZCA9IHRbMF0uaWRlbnRpZmllcjtcbiAgICAgICAgdGhpcy50cmFja2VkUG9pbnRlcklEc1swXSA9IGlkO1xuXG4gICAgICAgIHRoaXMubGFzdDEuc2V0KHRbMF0ucGFnZVgsIHRbMF0ucGFnZVkpO1xuICAgICAgICB0aGlzLnZlbG9jaXR5MS5jbGVhcigpO1xuICAgICAgICB0aGlzLmRlbHRhMS5jbGVhcigpO1xuICAgIH1cbiAgICBpZiAoIXRbMV0pIHtcbiAgICAgICAgdGhpcy5ldmVudC5jdXJyZW50ID0gMTtcbiAgICAgICAgdGhpcy50cmFja2VkUG9pbnRlcklEc1sxXSA9IC0xO1xuICAgICAgICB0aGlzLnRyaWdnZXJHZXN0dXJlcygpO1xuICAgICAgICB0aGlzLmV2ZW50LnBvaW50cyA9IDE7XG4gICAgICAgIHRoaXMuZXZlbnQucG9pbnRlcnMucG9wKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMudHJhY2tlZFBvaW50ZXJJRHNbMV0gIT09IHRbMV0uaWRlbnRpZmllcikge1xuICAgICAgICB0aGlzLnRyYWNrZWRQb2ludGVySURzWzFdID0gLTE7XG4gICAgICAgIHRoaXMuZXZlbnQucG9pbnRzID0gMjtcbiAgICAgICAgaWQgPSB0WzFdLmlkZW50aWZpZXI7XG4gICAgICAgIHRoaXMudHJhY2tlZFBvaW50ZXJJRHNbMV0gPSBpZDtcblxuICAgICAgICB0aGlzLmxhc3QyLnNldCh0WzFdLnBhZ2VYLCB0WzFdLnBhZ2VZKTtcbiAgICAgICAgdGhpcy52ZWxvY2l0eTIuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5kZWx0YTIuY2xlYXIoKTtcblxuICAgICAgICBWZWMyLmFkZCh0aGlzLmxhc3QxLCB0aGlzLmxhc3QyLCB0aGlzLmNlbnRlcikuc2NhbGUoMC41KTtcbiAgICAgICAgdGhpcy5jZW50ZXJEZWx0YS5jbGVhcigpO1xuICAgICAgICB0aGlzLmNlbnRlclZlbG9jaXR5LmNsZWFyKCk7XG5cbiAgICAgICAgVmVjMi5zdWJ0cmFjdCh0aGlzLmxhc3QyLCB0aGlzLmxhc3QxLCB0aGlzLmRpZmYxMik7XG4gICAgICAgIHRoaXMuZGlzdCA9IHRoaXMuZGlmZjEyLmxlbmd0aCgpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUcmVhdHMgYSBtb3VzZWxlYXZlIGV2ZW50IGFzIGEgZ2VzdHVyZSBlbmQuXG4gKlxuICogQG1ldGhvZCBfcHJvY2Vzc01vdXNlTGVhdmVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9wcm9jZXNzTW91c2VMZWF2ZSgpIHtcbiAgICBpZiAodGhpcy5ldmVudC5jdXJyZW50KSB7XG4gICAgICAgIHRoaXMuZXZlbnQuc3RhdHVzID0gJ2VuZCc7XG4gICAgICAgIHRoaXMuZXZlbnQuY3VycmVudCA9IDA7XG4gICAgICAgIHRoaXMudHJhY2tlZFBvaW50ZXJJRHNbMF0gPSAtMTtcbiAgICAgICAgdGhpcy50cmlnZ2VyR2VzdHVyZXMoKTtcbiAgICAgICAgdGhpcy5ldmVudC5wb2ludGVycy5wb3AoKTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gR2VzdHVyZUhhbmRsZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBQb3NpdGlvbiA9IHJlcXVpcmUoJy4vUG9zaXRpb24nKTtcblxuLyoqXG4gKiBAY2xhc3MgTW91bnRQb2ludFxuICogQGNvbnN0cnVjdG9yXG4gKiBAY29tcG9uZW50XG4gKiBAcGFyYW0ge0xvY2FsRGlzcGF0Y2h9IGRpc3BhdGNoIExvY2FsRGlzcGF0Y2ggdG8gYmUgcmV0cmlldmVkIGZyb20gY29ycmVzcG9uZGluZyBSZW5kZXIgTm9kZSBvZiB0aGUgTW91bnRQb2ludCBjb21wb25lbnRcbiAqL1xuZnVuY3Rpb24gTW91bnRQb2ludChub2RlKSB7XG4gICAgUG9zaXRpb24uY2FsbCh0aGlzLCBub2RlKTtcblxuICAgIHZhciBpbml0aWFsID0gbm9kZS5nZXRNb3VudFBvaW50KCk7XG5cbiAgICB0aGlzLl94LnNldChpbml0aWFsWzBdKTtcbiAgICB0aGlzLl95LnNldChpbml0aWFsWzFdKTtcbiAgICB0aGlzLl96LnNldChpbml0aWFsWzJdKTtcbn1cblxuLyoqXG4qXG4qIFN0cmluZ2lmaWVzIE1vdW50UG9pbnRcbipcbiogQG1ldGhvZFxuKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBuYW1lIG9mIHRoZSBDb21wb25lbnQgQ2xhc3M6ICdNb3VudFBvaW50J1xuKi9cbk1vdW50UG9pbnQudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ01vdW50UG9pbnQnO1xufTtcblxuTW91bnRQb2ludC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBvc2l0aW9uLnByb3RvdHlwZSk7XG5Nb3VudFBvaW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1vdW50UG9pbnQ7XG5cbk1vdW50UG9pbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICB0aGlzLl9ub2RlLnNldE1vdW50UG9pbnQodGhpcy5feC5nZXQoKSwgdGhpcy5feS5nZXQoKSwgdGhpcy5fei5nZXQoKSk7XG4gICAgdGhpcy5fY2hlY2tVcGRhdGUoKTtcbn07XG5cbk1vdW50UG9pbnQucHJvdG90eXBlLm9uVXBkYXRlID0gTW91bnRQb2ludC5wcm90b3R5cGUudXBkYXRlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1vdW50UG9pbnQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUcmFuc2l0aW9uYWJsZSA9IHJlcXVpcmUoJ2ZhbW91cy10cmFuc2l0aW9ucycpLlRyYW5zaXRpb25hYmxlO1xuXG5cbi8qKlxuICogQGNsYXNzIE9wYWNpdHlcbiAqIEBjb25zdHJ1Y3RvclxuICogQGNvbXBvbmVudFxuICogQHBhcmFtIHtMb2NhbERpc3BhdGNofSBkaXNwYXRjaCBMb2NhbERpc3BhdGNoIHRvIGJlIHJldHJpZXZlZCBmcm9tIGNvcnJlc3BvbmRpbmcgUmVuZGVyIE5vZGUgb2YgdGhlIE9wYWNpdHkgY29tcG9uZW50XG4gKi9cbmZ1bmN0aW9uIE9wYWNpdHkobm9kZSkge1xuICAgIHRoaXMuX25vZGUgPSBub2RlO1xuICAgIHRoaXMuX2lkID0gbm9kZS5hZGRDb21wb25lbnQodGhpcyk7XG4gICAgdGhpcy5fdmFsdWUgPSBuZXcgVHJhbnNpdGlvbmFibGUoMSk7XG5cbiAgICB0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlID0gZmFsc2U7XG59XG5cbi8qKlxuKlxuKiByZXR1cm5zIHN0cmluZ2lmaWVkIE9wYWNpdHlcbipcbiogQG1ldGhvZFxuKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBuYW1lIG9mIHRoZSBDb21wb25lbnQgQ2xhc3M6ICdPcGFjaXR5J1xuKi9cbk9wYWNpdHkudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ09wYWNpdHknO1xufTtcblxuLyoqXG4qXG4qIFJldHJpZXZlcyBzdGF0ZSBvZiBPcGFjaXR5XG4qXG4qIEBtZXRob2RcbiogQHJldHVybiB7T2JqZWN0fSBjb250YWlucyBjb21wb25lbnQga2V5IHdoaWNoIGhvbGRzIHRoZSBzdHJpbmdpZmllZCBjb25zdHJ1Y3RvciBcbiogYW5kIHZhbHVlIGtleSB3aGljaCBjb250YWlucyB0aGUgbnVtZXJpYyB2YWx1ZVxuKi9cbk9wYWNpdHkucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29tcG9uZW50OiB0aGlzLmNvbnN0cnVjdG9yLnRvU3RyaW5nKCksXG4gICAgICAgIHZhbHVlOiB0aGlzLl92YWx1ZS5nZXQoKVxuICAgIH07XG59O1xuXG4vKipcbipcbiogU2V0dGVyIGZvciBPcGFjaXR5IHN0YXRlXG4qXG4qIEBtZXRob2RcbiogQHBhcmFtIHtPYmplY3R9IHN0YXRlIGNvbnRhaW5zIGNvbXBvbmVudCBrZXksIHdoaWNoIGhvbGRzIHN0cmluZ2lmaWVkIGNvbnN0cnVjdG9yLCBhbmQgYSB2YWx1ZSBrZXksIHdoaWNoIGNvbnRhaW5zIGEgbnVtZXJpYyB2YWx1ZSB1c2VkIHRvIHNldCBvcGFjaXR5IGlmIHRoZSBjb25zdHJ1Y3RvciB2YWx1ZSBtYXRjaGVzXG4qIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgc2V0IGlzIHN1Y2Nlc3NmdWwsIGZhbHNlIG90aGVyd2lzZVxuKi9cbk9wYWNpdHkucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gc2V0VmFsdWUodmFsdWUpIHtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci50b1N0cmluZygpID09PSB2YWx1ZS5jb21wb25lbnQpIHtcbiAgICAgICAgdGhpcy5zZXQodmFsdWUudmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4qXG4qIFNldHRlciBmb3IgT3BhY2l0eSB3aXRoIGNhbGxiYWNrXG4qXG4qIEBtZXRob2RcbiogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIHZhbHVlIHVzZWQgdG8gc2V0IE9wYWNpdHlcbiogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgb3B0aW9ucyBoYXNoXG4qIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBmb2xsb3dpbmcgT3BhY2l0eSBzZXRcbiogQGNoYWluYWJsZVxuKi9cbk9wYWNpdHkucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCh2YWx1ZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5fbm9kZS5yZXF1ZXN0VXBkYXRlKHRoaXMuX2lkKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5fdmFsdWUuc2V0KHZhbHVlLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbipcbiogR2V0dGVyIGZvciBPcGFjaXR5XG4qXG4qIEBtZXRob2RcbiogQHJldHVybiB7TnVtYmVyfVxuKi9cbk9wYWNpdHkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWUuZ2V0KCk7XG59O1xuXG4vKipcbipcbiogU3RvcHMgT3BhY2l0eSB0cmFuc2l0aW9uXG4qXG4qIEBtZXRob2RcbiogQGNoYWluYWJsZVxuKi9cbk9wYWNpdHkucHJvdG90eXBlLmhhbHQgPSBmdW5jdGlvbiBoYWx0KCkge1xuICAgIHRoaXMuX3ZhbHVlLmhhbHQoKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbk9wYWNpdHkucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gaXNBY3RpdmUoKXtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWUuaXNBY3RpdmUoKTtcbn07XG5cbk9wYWNpdHkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gICAgdGhpcy5fbm9kZS5zZXRPcGFjaXR5KHRoaXMuX3ZhbHVlLmdldCgpKTtcbiAgICBpZiAodGhpcy5fdmFsdWUuaXNBY3RpdmUoKSkge1xuICAgICAgdGhpcy5fbm9kZS5yZXF1ZXN0VXBkYXRlT25OZXh0VGljayh0aGlzLl9pZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSBmYWxzZTtcbiAgICB9XG59O1xuXG5PcGFjaXR5LnByb3RvdHlwZS5vblVwZGF0ZSA9IE9wYWNpdHkucHJvdG90eXBlLnVwZGF0ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBPcGFjaXR5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9zaXRpb24gPSByZXF1aXJlKCcuL1Bvc2l0aW9uJyk7XG5cbi8qKlxuICogQGNsYXNzIE9yaWdpblxuICogQGNvbnN0cnVjdG9yXG4gKiBAY29tcG9uZW50XG4gKiBAcGFyYW0ge0xvY2FsRGlzcGF0Y2h9IGRpc3BhdGNoIExvY2FsRGlzcGF0Y2ggdG8gYmUgcmV0cmlldmVkIGZyb20gY29ycmVzcG9uZGluZyBSZW5kZXIgTm9kZSBvZiB0aGUgT3JpZ2luIGNvbXBvbmVudFxuICovXG5mdW5jdGlvbiBPcmlnaW4obm9kZSkge1xuICAgIFBvc2l0aW9uLmNhbGwodGhpcywgbm9kZSk7XG5cbiAgICB2YXIgaW5pdGlhbCA9IG5vZGUuZ2V0T3JpZ2luKCk7XG5cbiAgICB0aGlzLl94LnNldChpbml0aWFsWzBdKTtcbiAgICB0aGlzLl95LnNldChpbml0aWFsWzFdKTtcbiAgICB0aGlzLl96LnNldChpbml0aWFsWzJdKTtcbn1cblxuXG4vKipcbipcbiogcmV0dXJucyBzdHJpbmdpZmllZCBPcmlnaW5cbipcbiogQG1ldGhvZFxuKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBuYW1lIG9mIHRoZSBDb21wb25lbnQgQ2xhc3M6ICdPcmlnaW4nXG4qL1xuT3JpZ2luLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdPcmlnaW4nO1xufTtcblxuT3JpZ2luLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUG9zaXRpb24ucHJvdG90eXBlKTtcbk9yaWdpbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBPcmlnaW47XG5cbk9yaWdpbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIHRoaXMuX25vZGUuc2V0T3JpZ2luKHRoaXMuX3guZ2V0KCksIHRoaXMuX3kuZ2V0KCksIHRoaXMuX3ouZ2V0KCkpO1xuICAgIHRoaXMuX2NoZWNrVXBkYXRlKCk7XG59O1xuXG5PcmlnaW4ucHJvdG90eXBlLm9uVXBkYXRlID0gT3JpZ2luLnByb3RvdHlwZS51cGRhdGU7XG5cbm1vZHVsZS5leHBvcnRzID0gT3JpZ2luO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHJhbnNpdGlvbmFibGUgPSByZXF1aXJlKCdmYW1vdXMtdHJhbnNpdGlvbnMnKS5UcmFuc2l0aW9uYWJsZTtcblxuLyoqXG4gKiBAY2xhc3MgUG9zaXRpb25cbiAqIEBjb25zdHJ1Y3RvclxuICogQGNvbXBvbmVudFxuICogQHBhcmFtIHtMb2NhbERpc3BhdGNofSBkaXNwYXRjaCBMb2NhbERpc3BhdGNoIHRvIGJlIHJldHJpZXZlZCBmcm9tIGNvcnJlc3BvbmRpbmcgUmVuZGVyIE5vZGUgb2YgdGhlIFBvc2l0aW9uIGNvbXBvbmVudFxuICovXG5mdW5jdGlvbiBQb3NpdGlvbihub2RlKSB7XG4gICAgdGhpcy5fbm9kZSA9IG5vZGU7XG4gICAgdGhpcy5faWQgPSBub2RlLmFkZENvbXBvbmVudCh0aGlzKTtcbiAgXG4gICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IGZhbHNlO1xuICAgIFxuICAgIHZhciBpbml0aWFsUG9zaXRpb24gPSBub2RlLmdldFBvc2l0aW9uKCk7XG5cbiAgICB0aGlzLl94ID0gbmV3IFRyYW5zaXRpb25hYmxlKGluaXRpYWxQb3NpdGlvblswXSk7XG4gICAgdGhpcy5feSA9IG5ldyBUcmFuc2l0aW9uYWJsZShpbml0aWFsUG9zaXRpb25bMV0pO1xuICAgIHRoaXMuX3ogPSBuZXcgVHJhbnNpdGlvbmFibGUoaW5pdGlhbFBvc2l0aW9uWzJdKTtcbn1cblxuLyoqIFxuKlxuKiBzdHJpbmdpZmllcyBQb3NpdGlvbiBjb25zdHJ1Y3RvclxuKlxuKiBAbWV0aG9kXG4qIEByZXR1cm4ge1N0cmluZ30gdGhlIGRlZmluaXRpb24gb2YgdGhlIENvbXBvbmVudCBDbGFzczogJ1Bvc2l0aW9uJ1xuKi9cblBvc2l0aW9uLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdQb3NpdGlvbic7XG59O1xuXG4vKipcbipcbiogR2V0cyBvYmplY3QgY29udGFpbmluZyBzdHJpbmdpZmllZCBjb25zdHJ1Y3RvciwgeCwgeSwgeiBjb29yZGluYXRlc1xuKlxuKiBAbWV0aG9kXG4qIEByZXR1cm4ge09iamVjdH1cbiovXG5Qb3NpdGlvbi5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb21wb25lbnQ6IHRoaXMuY29uc3RydWN0b3IudG9TdHJpbmcoKSxcbiAgICAgICAgeDogdGhpcy5feC5nZXQoKSxcbiAgICAgICAgeTogdGhpcy5feS5nZXQoKSxcbiAgICAgICAgejogdGhpcy5fei5nZXQoKVxuICAgIH07XG59O1xuXG4vKipcbipcbiogU2V0dGVyIGZvciBwb3NpdGlvbiBjb29yZGluYXRlc1xuKlxuKiBAbWV0aG9kXG4qIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSBPYmplY3QgLS0gY29tcG9uZW50OiBzdHJpbmdpZmllZCBjb25zdHJ1Y3RvciwgeDogbnVtYmVyLCB5OiBudW1iZXIsIHo6IG51bWJlclxuKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIG9uIHN1Y2Nlc3NcbiovXG5Qb3NpdGlvbi5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiBzZXRWYWx1ZShzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5jb21wb25lbnQgPT09IHRoaXMuY29uc3RydWN0b3IudG9TdHJpbmcoKSkge1xuICAgICAgICB0aGlzLnNldChzdGF0ZS54LCBzdGF0ZS55LCBzdGF0ZS56KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuKlxuKiBHZXR0ZXIgZm9yIFggcG9zaXRpb25cbipcbiogQG1ldGhvZFxuKiBAcmV0dXJuIHtOdW1iZXJ9XG4qL1xuUG9zaXRpb24ucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiBnZXRYKCkge1xuICAgIHJldHVybiB0aGlzLl94LmdldCgpO1xufTtcblxuLyoqXG4qXG4qIEdldHRlciBmb3IgWSBwb3NpdGlvblxuKlxuKiBAbWV0aG9kXG4qIEByZXR1cm4ge051bWJlcn1cbiovXG5Qb3NpdGlvbi5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uIGdldFkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3kuZ2V0KCk7XG59O1xuXG4vKipcbipcbiogR2V0dGVyIGZvciBaIHBvc2l0aW9uXG4qXG4qIEBtZXRob2RcbiogQHJldHVybiB7TnVtYmVyfVxuKi9cblBvc2l0aW9uLnByb3RvdHlwZS5nZXRaID0gZnVuY3Rpb24gZ2V0WigpIHtcbiAgICByZXR1cm4gdGhpcy5fei5nZXQoKTtcbn07XG5cbi8qKlxuKlxuKiBHZXR0ZXIgZm9yIGFueSBhY3RpdmUgY29vcmRpbmF0ZXNcbipcbiogQG1ldGhvZFxuKiBAcmV0dXJuIHtCb29sZWFufVxuKi9cblBvc2l0aW9uLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uIGlzQWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLl94LmlzQWN0aXZlKCkgfHwgdGhpcy5feS5pc0FjdGl2ZSgpIHx8IHRoaXMuX3ouaXNBY3RpdmUoKTtcbn07XG5cblBvc2l0aW9uLnByb3RvdHlwZS5fY2hlY2tVcGRhdGUgPSBmdW5jdGlvbiBfY2hlY2tVcGRhdGUoKSB7XG4gICAgaWYgKHRoaXMuaXNBY3RpdmUoKSkgdGhpcy5fbm9kZS5yZXF1ZXN0VXBkYXRlT25OZXh0VGljayh0aGlzLl9pZCk7XG4gICAgZWxzZSB0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlID0gZmFsc2U7XG59O1xuXG5cblBvc2l0aW9uLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKCkge1xuICAgIHRoaXMuX25vZGUuc2V0UG9zaXRpb24odGhpcy5feC5nZXQoKSwgdGhpcy5feS5nZXQoKSwgdGhpcy5fei5nZXQoKSk7XG4gICAgdGhpcy5fY2hlY2tVcGRhdGUoKTtcbn07XG5cbi8qKiBcbipcbiogSWYgdHJ1ZSwgY29tcG9uZW50IGlzIHRvIGJlIHVwZGF0ZWQgb24gbmV4dCBlbmdpbmUgdGlja1xuKlxuKiBAbWV0aG9kXG4qL1xuUG9zaXRpb24ucHJvdG90eXBlLm9uVXBkYXRlID0gUG9zaXRpb24ucHJvdG90eXBlLnVwZGF0ZTtcblxuLyoqIFxuKlxuKiBTZXR0ZXIgZm9yIFggcG9zaXRpb25cbipcbiogQG1ldGhvZFxuKiBAcGFyYW0ge051bWJlcn0gdmFsIHVzZWQgdG8gc2V0IHggY29vcmRpbmF0ZVxuKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBvcHRpb25zIGhhc2hcbiogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdG8gZXhlY3V0ZSBhZnRlciBzZXR0aW5nIFhcbiogQGNoYWluYWJsZVxuKi9cblBvc2l0aW9uLnByb3RvdHlwZS5zZXRYID0gZnVuY3Rpb24gc2V0WCh2YWwsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX25vZGUucmVxdWVzdFVwZGF0ZSh0aGlzLl9pZCk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuX3guc2V0KHZhbCwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqIFxuKlxuKiBTZXR0ZXIgZm9yIFkgcG9zaXRpb25cbipcbiogQG1ldGhvZFxuKiBAcGFyYW0ge051bWJlcn0gdmFsIHVzZWQgdG8gc2V0IHkgY29vcmRpbmF0ZVxuKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBvcHRpb25zIGhhc2hcbiogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdG8gZXhlY3V0ZSBhZnRlciBzZXR0aW5nIFlcbiogQGNoYWluYWJsZVxuKi9cblBvc2l0aW9uLnByb3RvdHlwZS5zZXRZID0gZnVuY3Rpb24gc2V0WSh2YWwsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX25vZGUucmVxdWVzdFVwZGF0ZSh0aGlzLl9pZCk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuX3kuc2V0KHZhbCwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqIFxuKlxuKiBTZXR0ZXIgZm9yIFogcG9zaXRpb25cbipcbiogQG1ldGhvZFxuKiBAcGFyYW0ge051bWJlcn0gdmFsIHVzZWQgdG8gc2V0IHogY29vcmRpbmF0ZVxuKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBvcHRpb25zIGhhc2hcbiogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdG8gZXhlY3V0ZSBhZnRlciBzZXR0aW5nIFpcbiogQGNoYWluYWJsZVxuKi9cblBvc2l0aW9uLnByb3RvdHlwZS5zZXRaID0gZnVuY3Rpb24gc2V0Wih2YWwsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX25vZGUucmVxdWVzdFVwZGF0ZSh0aGlzLl9pZCk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuX3ouc2V0KHZhbCwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuXG4vKipcbipcbiogU2V0dGVyIGZvciBYWVogcG9zaXRpb24gd2l0aCBjYWxsYmFja1xuKlxuKiBAbWV0aG9kXG4qIEBwYXJhbSB7TnVtYmVyfSB4IHVzZWQgdG8gc2V0IHggY29vcmRpbmF0ZVxuKiBAcGFyYW0ge051bWJlcn0geSB1c2VkIHRvIHNldCB5IGNvb3JkaW5hdGVcbiogQHBhcmFtIHtOdW1iZXJ9IHogdXNlZCB0byBzZXQgeiBjb29yZGluYXRlXG4qIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIG9wdGlvbnMgaGFzaFxuKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbiB0byBleGVjdXRlIGFmdGVyIHNldHRpbmcgZWFjaCBjb29yZGluYXRlXG4qIEBjaGFpbmFibGVcbiovXG5Qb3NpdGlvbi5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0KHgsIHksIHosIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX25vZGUucmVxdWVzdFVwZGF0ZSh0aGlzLl9pZCk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciB4Q2FsbGJhY2s7XG4gICAgdmFyIHlDYWxsYmFjaztcbiAgICB2YXIgekNhbGxiYWNrO1xuXG4gICAgaWYgKHogIT0gbnVsbCkge1xuICAgICAgICB6Q2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgZWxzZSBpZiAoeSAhPSBudWxsKSB7XG4gICAgICAgIHlDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICBlbHNlIGlmICh4ICE9IG51bGwpIHtcbiAgICAgICAgeENhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgaWYgKHggIT0gbnVsbCkgdGhpcy5feC5zZXQoeCwgb3B0aW9ucywgeENhbGxiYWNrKTtcbiAgICBpZiAoeSAhPSBudWxsKSB0aGlzLl95LnNldCh5LCBvcHRpb25zLCB5Q2FsbGJhY2spO1xuICAgIGlmICh6ICE9IG51bGwpIHRoaXMuX3ouc2V0KHosIG9wdGlvbnMsIHpDYWxsYmFjayk7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuKlxuKiBTdG9wcyB0cmFuc2l0aW9uIG9mIFBvc2l0aW9uIGNvbXBvbmVudFxuKlxuKiBAbWV0aG9kXG4qIEBjaGFpbmFibGVcbiovXG5Qb3NpdGlvbi5wcm90b3R5cGUuaGFsdCA9IGZ1bmN0aW9uIGhhbHQoKSB7XG4gICAgdGhpcy5feC5oYWx0KCk7XG4gICAgdGhpcy5feS5oYWx0KCk7XG4gICAgdGhpcy5fei5oYWx0KCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvc2l0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9zaXRpb24gPSByZXF1aXJlKCcuL1Bvc2l0aW9uJyk7XG5cbi8qKlxuICogQGNsYXNzIFJvdGF0aW9uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBjb21wb25lbnRcbiAqIEBwYXJhbSB7TG9jYWxEaXNwYXRjaH0gZGlzcGF0Y2ggTG9jYWxEaXNwYXRjaCB0byBiZSByZXRyaWV2ZWQgZnJvbSBjb3JyZXNwb25kaW5nIFJlbmRlciBOb2RlIG9mIHRoZSBSb3RhdGlvbiBjb21wb25lbnRcbiAqL1xuZnVuY3Rpb24gUm90YXRpb24obm9kZSkge1xuICAgIFBvc2l0aW9uLmNhbGwodGhpcywgbm9kZSk7XG5cbiAgICB2YXIgaW5pdGlhbCA9IG5vZGUuZ2V0Um90YXRpb24oKTtcblxuICAgIHZhciB4ID0gaW5pdGlhbFswXTtcbiAgICB2YXIgeSA9IGluaXRpYWxbMV07XG4gICAgdmFyIHogPSBpbml0aWFsWzJdO1xuICAgIHZhciB3ID0gaW5pdGlhbFszXTtcblxuICAgIHZhciB4eCA9IHggKiB4O1xuICAgIHZhciB5eSA9IHkgKiB5O1xuICAgIHZhciB6eiA9IHogKiB6O1xuXG4gICAgdmFyIHR5ID0gMiAqICh4ICogeiArIHkgKiB3KTtcbiAgICB0eSA9IHR5IDwgLTEgPyAtMSA6IHR5ID4gMSA/IDEgOiB0eTtcblxuICAgIHZhciByeCA9IE1hdGguYXRhbjIoMiAqICh4ICogdyAtIHkgKiB6KSwgMSAtIDIgKiAoeHggKyB5eSkpO1xuICAgIHZhciByeSA9IE1hdGguYXNpbih0eSk7XG4gICAgdmFyIHJ6ID0gTWF0aC5hdGFuMigyICogKHogKiB3IC0geCAqIHkpLCAxIC0gMiAqICh5eSArIHp6KSk7XG5cbiAgICB0aGlzLl94LnNldChyeCk7XG4gICAgdGhpcy5feS5zZXQocnkpO1xuICAgIHRoaXMuX3ouc2V0KHJ6KTtcbn1cblxuLyoqXG4qXG4qIHN0cmluZ2lmaWVzIFJvdGF0aW9uXG4qXG4qIEBtZXRob2RcbiogQHJldHVybiB7U3RyaW5nfSB0aGUgbmFtZSBvZiB0aGUgQ29tcG9uZW50IENsYXNzOiAnUm90YXRpb24nXG4qL1xuUm90YXRpb24udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ1JvdGF0aW9uJztcbn07XG5cblJvdGF0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUG9zaXRpb24ucHJvdG90eXBlKTtcblJvdGF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJvdGF0aW9uO1xuXG5Sb3RhdGlvbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIHRoaXMuX25vZGUuc2V0Um90YXRpb24odGhpcy5feC5nZXQoKSwgdGhpcy5feS5nZXQoKSwgdGhpcy5fei5nZXQoKSk7XG4gICAgdGhpcy5fY2hlY2tVcGRhdGUoKTtcbn07XG5cblJvdGF0aW9uLnByb3RvdHlwZS5vblVwZGF0ZSA9IFJvdGF0aW9uLnByb3RvdHlwZS51cGRhdGU7XG5cbm1vZHVsZS5leHBvcnRzID0gUm90YXRpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBQb3NpdGlvbiA9IHJlcXVpcmUoJy4vUG9zaXRpb24nKTtcblxuLyoqXG4gKiBAY2xhc3MgU2NhbGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQGNvbXBvbmVudFxuICogQHBhcmFtIHtMb2NhbERpc3BhdGNofSBkaXNwYXRjaCBMb2NhbERpc3BhdGNoIHRvIGJlIHJldHJpZXZlZCBmcm9tIGNvcnJlc3BvbmRpbmcgUmVuZGVyIE5vZGUgb2YgdGhlIFNjYWxlIGNvbXBvbmVudFxuICovXG5mdW5jdGlvbiBTY2FsZShub2RlKSB7XG4gICAgUG9zaXRpb24uY2FsbCh0aGlzLCBub2RlKTtcbiAgICB0aGlzLl94LnNldCgxKTtcbiAgICB0aGlzLl95LnNldCgxKTtcbiAgICB0aGlzLl96LnNldCgxKTtcbn1cblxuLyoqXG4qXG4qIHN0cmluZ2lmaWVzIFNjYWxlXG4qXG4qIEBtZXRob2QgXG4qIEByZXR1cm4ge1N0cmluZ30gdGhlIG5hbWUgb2YgdGhlIENvbXBvbmVudCBDbGFzczogJ1NjYWxlJ1xuKi9cblNjYWxlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdTY2FsZSc7XG59O1xuXG5TY2FsZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBvc2l0aW9uLnByb3RvdHlwZSk7XG5TY2FsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTY2FsZTtcblxuU2NhbGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICB0aGlzLl9ub2RlLnNldFNjYWxlKHRoaXMuX3guZ2V0KCksIHRoaXMuX3kuZ2V0KCksIHRoaXMuX3ouZ2V0KCkpO1xuICAgIHRoaXMuX2NoZWNrVXBkYXRlKCk7XG59O1xuXG5TY2FsZS5wcm90b3R5cGUub25VcGRhdGUgPSBTY2FsZS5wcm90b3R5cGUudXBkYXRlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjYWxlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHJhbnNpdGlvbmFibGUgPSByZXF1aXJlKCdmYW1vdXMtdHJhbnNpdGlvbnMnKS5UcmFuc2l0aW9uYWJsZTtcbnZhciBDb3JlU2l6ZSA9IHJlcXVpcmUoJ2ZhbW91cy1jb3JlJykuU2l6ZTtcblxuLyoqXG4gKiBTaXplIGNvbXBvbmVudCB1c2VkIGZvciBtYW5hZ2luZyB0aGUgc2l6ZSBvZiB0aGUgdW5kZXJseWluZyBSZW5kZXJDb250ZXh0LlxuICogU3VwcG9ydHMgYWJzb2x1dGUgYW5kIHJlbGF0aXZlIChwcm9wb3J0aW9uYWwgYW5kIGRpZmZlcmVudGlhbCkgc2l6aW5nLlxuICpcbiAqIEBjbGFzcyBTaXplXG4gKiBAY29uc3RydWN0b3JcbiAqIEBjb21wb25lbnRcbiAqXG4gKiBAcGFyYW0ge0xvY2FsRGlzcGF0Y2h9IG5vZGUgTG9jYWxEaXNwYXRjaCB0byBiZSByZXRyaWV2ZWQgZnJvbVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JyZXNwb25kaW5nIFJlbmRlck5vZGUgb2YgdGhlIFNpemVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50XG4gKi9cbmZ1bmN0aW9uIFNpemUobm9kZSkge1xuICAgIHRoaXMuX25vZGUgPSBub2RlO1xuICAgIHRoaXMuX2lkID0gbm9kZS5hZGRDb21wb25lbnQodGhpcyk7XG4gICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgdmFyIGluaXRpYWxQcm9wb3J0aW9uYWxTaXplID0gbm9kZS5nZXRQcm9wb3J0aW9uYWxTaXplKCk7XG4gICAgdmFyIGluaXRpYWxEaWZmZXJlbnRpYWxTaXplID0gbm9kZS5nZXREaWZmZXJlbnRpYWxTaXplKCk7XG4gICAgdmFyIGluaXRpYWxBYnNvbHV0ZVNpemUgPSBub2RlLmdldEFic29sdXRlU2l6ZSgpO1xuXG4gICAgdGhpcy5fcHJvcG9ydGlvbmFsID0ge1xuICAgICAgICB4OiBuZXcgVHJhbnNpdGlvbmFibGUoaW5pdGlhbFByb3BvcnRpb25hbFNpemVbMF0pLFxuICAgICAgICB5OiBuZXcgVHJhbnNpdGlvbmFibGUoaW5pdGlhbFByb3BvcnRpb25hbFNpemVbMV0pLFxuICAgICAgICB6OiBuZXcgVHJhbnNpdGlvbmFibGUoaW5pdGlhbFByb3BvcnRpb25hbFNpemVbMl0pXG4gICAgfTtcbiAgICB0aGlzLl9kaWZmZXJlbnRpYWwgPSB7XG4gICAgICAgIHg6IG5ldyBUcmFuc2l0aW9uYWJsZShpbml0aWFsRGlmZmVyZW50aWFsU2l6ZVswXSksXG4gICAgICAgIHk6IG5ldyBUcmFuc2l0aW9uYWJsZShpbml0aWFsRGlmZmVyZW50aWFsU2l6ZVsxXSksXG4gICAgICAgIHo6IG5ldyBUcmFuc2l0aW9uYWJsZShpbml0aWFsRGlmZmVyZW50aWFsU2l6ZVsyXSlcbiAgICB9O1xuICAgIHRoaXMuX2Fic29sdXRlID0ge1xuICAgICAgICB4OiBuZXcgVHJhbnNpdGlvbmFibGUoaW5pdGlhbEFic29sdXRlU2l6ZVswXSksXG4gICAgICAgIHk6IG5ldyBUcmFuc2l0aW9uYWJsZShpbml0aWFsQWJzb2x1dGVTaXplWzFdKSxcbiAgICAgICAgejogbmV3IFRyYW5zaXRpb25hYmxlKGluaXRpYWxBYnNvbHV0ZVNpemVbMl0pXG4gICAgfTtcbn1cblxuU2l6ZS5SRUxBVElWRSA9IENvcmVTaXplLlJFTEFUSVZFO1xuU2l6ZS5BQlNPTFVURSA9IENvcmVTaXplLkFCU09MVVRFO1xuU2l6ZS5SRU5ERVIgPSBDb3JlU2l6ZS5SRU5ERVI7XG5TaXplLkRFRkFVTFQgPSBDb3JlU2l6ZS5ERUZBVUxUO1xuXG5TaXplLnByb3RvdHlwZS5zZXRNb2RlID0gZnVuY3Rpb24gc2V0TW9kZSh4LCB5LCB6KSB7XG4gICAgdGhpcy5fbm9kZS5zZXRTaXplTW9kZSh4LCB5LCB6KTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuKiBTdHJpbmdpZmllcyBTaXplLlxuKlxuKiBAbWV0aG9kIHRvU3RyaW5nXG4qXG4qIEByZXR1cm4ge1N0cmluZ30gYFNpemVgXG4qL1xuU2l6ZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnU2l6ZSc7XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIGFic29sdXRlU2l6ZVZhbHVlXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByb3BlcnR5IHtTdHJpbmd9IHR5cGUgY3VycmVudCB0eXBlIG9mIHNpemluZyBiZWluZyBhcHBsaWVkICgnYWJzb2x1dGUnKVxuICogQHByb3BlcnR5IHtTdHJpbmd9IGNvbXBvbmVudCBjb21wb25lbnQgbmFtZSAoJ1NpemUnKVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHhcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB5XG4gKiBAcHJvcGVydHkge251bWJlcn0gelxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgcmVsYXRpdmVTaXplVmFsdWVcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJvcGVydHkge1N0cmluZ30gdHlwZSBjdXJyZW50IHR5cGUgb2Ygc2l6aW5nIGJlaW5nIGFwcGxpZWQgKCdyZWxhdGl2ZScpXG4gKiBAcHJvcGVydHkge1N0cmluZ30gY29tcG9uZW50IGNvbXBvbmVudCBuYW1lICgnU2l6ZScpXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGlmZmVyZW50aWFsXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGlmZmVyZW50aWFsLnhcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkaWZmZXJlbnRpYWwueVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRpZmZlcmVudGlhbC56XG4gKiBAcHJvcGVydHkge09iamVjdH0gcHJvcG9ydGlvbmFsXG4gKiBAcHJvcGVydHkge251bWJlcn0gcHJvcG9ydGlvbmFsLnhcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwcm9wb3J0aW9uYWwueVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHByb3BvcnRpb25hbC56XG4gKi9cblxuLyoqXG4qIFJldHVybnMgc2VyaWFsaXplZCBzdGF0ZSBvZiB0aGUgY29tcG9uZW50LlxuKlxuKiBAbWV0aG9kIGdldFZhbHVlXG4qXG4qIEByZXR1cm4ge2Fic29sdXRlU2l6ZVZhbHVlfHJlbGF0aXZlU2l6ZVZhbHVlfVxuKi9cblNpemUucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2l6ZU1vZGU6IHRoaXMuX25vZGUudmFsdWUuc2l6ZU1vZGUsXG4gICAgICAgIGFic29sdXRlOiB7XG4gICAgICAgICAgICB4OiB0aGlzLl9hYnNvbHV0ZS54LmdldCgpLFxuICAgICAgICAgICAgeTogdGhpcy5fYWJzb2x1dGUueS5nZXQoKSxcbiAgICAgICAgICAgIHo6IHRoaXMuX2Fic29sdXRlLnouZ2V0KClcbiAgICAgICAgfSxcbiAgICAgICAgZGlmZmVyZW50aWFsOiB7XG4gICAgICAgICAgICB4OiB0aGlzLl9kaWZmZXJlbnRpYWwueC5nZXQoKSxcbiAgICAgICAgICAgIHk6IHRoaXMuX2RpZmZlcmVudGlhbC55LmdldCgpLFxuICAgICAgICAgICAgejogdGhpcy5fZGlmZmVyZW50aWFsLnouZ2V0KClcbiAgICAgICAgfSxcbiAgICAgICAgcHJvcG9ydGlvbmFsOiB7XG4gICAgICAgICAgICB4OiB0aGlzLl9wcm9wb3J0aW9uYWwueC5nZXQoKSxcbiAgICAgICAgICAgIHk6IHRoaXMuX3Byb3BvcnRpb25hbC55LmdldCgpLFxuICAgICAgICAgICAgejogdGhpcy5fcHJvcG9ydGlvbmFsLnouZ2V0KClcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG4vKipcbiogVXBkYXRlcyBzdGF0ZSBvZiBjb21wb25lbnQuXG4qXG4qIEBtZXRob2Qgc2V0VmFsdWVcbipcbiogQHBhcmFtIHthYnNvbHV0ZVNpemVWYWx1ZXxyZWxhdGl2ZVNpemVWYWx1ZX0gc3RhdGUgc3RhdGUgZW5jb2RlZCBpbiBzYW1lXG4qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdCBhcyBzdGF0ZSByZXRyaWV2ZWRcbiogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3VnaCBgZ2V0VmFsdWVgXG4qIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvb2xlYW4gaW5kaWNhdGluZ1xuKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGV0aGVyIHRoZSBuZXcgc3RhdGUgaGFzXG4qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlZW4gYXBwbGllZFxuKi9cblNpemUucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gc2V0VmFsdWUoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUuY29tcG9uZW50ID09PSB0aGlzLmNvbnN0cnVjdG9yLnRvU3RyaW5nKCkpIHtcbiAgICAgICAgdGhpcy5zZXRNb2RlLmFwcGx5KHRoaXMsIHN0YXRlLnNpemVNb2RlKTtcbiAgICAgICAgaWYgKHN0YXRlLmFic29sdXRlKSB7XG4gICAgICAgICAgICB0aGlzLnNldEFic29sdXRlKHN0YXRlLmFic29sdXRlLngsIHN0YXRlLmFic29sdXRlLnksIHN0YXRlLmFic29sdXRlLnopO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5kaWZmZXJlbnRpYWwpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QWJzb2x1dGUoc3RhdGUuZGlmZmVyZW50aWFsLngsIHN0YXRlLmRpZmZlcmVudGlhbC55LCBzdGF0ZS5kaWZmZXJlbnRpYWwueik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLnByb3BvcnRpb25hbCkge1xuICAgICAgICAgICAgdGhpcy5zZXRBYnNvbHV0ZShzdGF0ZS5wcm9wb3J0aW9uYWwueCwgc3RhdGUucHJvcG9ydGlvbmFsLnksIHN0YXRlLnByb3BvcnRpb25hbC56KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5TaXplLnByb3RvdHlwZS5faXNBY3RpdmUgPSBmdW5jdGlvbiBfaXNBY3RpdmUodHlwZSkge1xuICAgIHJldHVybiB0eXBlLnguaXNBY3RpdmUoKSB8fCB0eXBlLnkuaXNBY3RpdmUoKSB8fCB0eXBlLnouaXNBY3RpdmUoKTtcbn07XG5cblNpemUucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gaXNBY3RpdmUoKXtcbiAgICByZXR1cm4gKFxuICAgICAgICB0aGlzLl9pc0FjdGl2ZSh0aGlzLl9hYnNvbHV0ZSkgfHxcbiAgICAgICAgdGhpcy5faXNBY3RpdmUodGhpcy5fcHJvcG9ydGlvbmFsKSB8fFxuICAgICAgICB0aGlzLl9pc0FjdGl2ZSh0aGlzLl9kaWZmZXJlbnRpYWwpXG4gICAgKTtcbn07XG5cblNpemUucHJvdG90eXBlLm9uVXBkYXRlID0gZnVuY3Rpb24gb25VcGRhdGUoKSB7XG4gICAgdmFyIGFicyA9IHRoaXMuX2Fic29sdXRlO1xuICAgIHRoaXMuX25vZGUuc2V0QWJzb2x1dGVTaXplKFxuICAgICAgICBhYnMueC5nZXQoKSxcbiAgICAgICAgYWJzLnkuZ2V0KCksXG4gICAgICAgIGFicy56LmdldCgpXG4gICAgKTtcbiAgICB2YXIgcHJvcCA9IHRoaXMuX3Byb3BvcnRpb25hbDtcbiAgICB2YXIgZGlmZiA9IHRoaXMuX2RpZmZlcmVudGlhbDtcbiAgICB0aGlzLl9ub2RlLnNldFByb3BvcnRpb25hbFNpemUoXG4gICAgICAgIHByb3AueC5nZXQoKSxcbiAgICAgICAgcHJvcC55LmdldCgpLFxuICAgICAgICBwcm9wLnouZ2V0KClcbiAgICApO1xuICAgIHRoaXMuX25vZGUuc2V0RGlmZmVyZW50aWFsU2l6ZShcbiAgICAgICAgZGlmZi54LmdldCgpLFxuICAgICAgICBkaWZmLnkuZ2V0KCksXG4gICAgICAgIGRpZmYuei5nZXQoKVxuICAgICk7XG5cbiAgICBpZiAodGhpcy5pc0FjdGl2ZSgpKSB0aGlzLl9ub2RlLnJlcXVlc3RVcGRhdGVPbk5leHRUaWNrKHRoaXMuX2lkKTtcbiAgICBlbHNlIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSBmYWxzZTtcbn07XG5cblxuLyoqXG4qIEFwcGxpZXMgYWJzb2x1dGUgc2l6ZS5cbipcbiogQG1ldGhvZCBzZXRBYnNvbHV0ZVxuKiBAY2hhaW5hYmxlXG4qXG4qIEBwYXJhbSB7TnVtYmVyfSB4IHVzZWQgdG8gc2V0IGFic29sdXRlIHNpemUgaW4geC1kaXJlY3Rpb24gKHdpZHRoKVxuKiBAcGFyYW0ge051bWJlcn0geSB1c2VkIHRvIHNldCBhYnNvbHV0ZSBzaXplIGluIHktZGlyZWN0aW9uIChoZWlnaHQpXG4qIEBwYXJhbSB7TnVtYmVyfSB6IHVzZWQgdG8gc2V0IGFic29sdXRlIHNpemUgaW4gei1kaXJlY3Rpb24gKGRlcHRoKVxuKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBvcHRpb25zIGhhc2hcbiogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgYWZ0ZXIgdGhlXG4qICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25zIGhhdmUgYmVlbiBjb21wbGV0ZWRcbiogQHJldHVybiB7U2l6ZX0gdGhpc1xuKi9cblNpemUucHJvdG90eXBlLnNldEFic29sdXRlID0gZnVuY3Rpb24gc2V0QWJzb2x1dGUoeCwgeSwgeiwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5fbm9kZS5yZXF1ZXN0VXBkYXRlKHRoaXMuX2lkKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHhDYWxsYmFjaztcbiAgICB2YXIgeUNhbGxiYWNrO1xuICAgIHZhciB6Q2FsbGJhY2s7XG5cbiAgICBpZiAoeiAhPSBudWxsKSB7XG4gICAgICAgIHpDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICBlbHNlIGlmICh5ICE9IG51bGwpIHtcbiAgICAgICAgeUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIGVsc2UgaWYgKHggIT0gbnVsbCkge1xuICAgICAgICB4Q2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICB2YXIgYWJzID0gdGhpcy5fYWJzb2x1dGU7XG4gICAgaWYgKHggIT0gbnVsbCkge1xuICAgICAgICBhYnMueC5zZXQoeCwgb3B0aW9ucywgeENhbGxiYWNrKTtcbiAgICB9XG4gICAgaWYgKHkgIT0gbnVsbCkge1xuICAgICAgICBhYnMueS5zZXQoeSwgb3B0aW9ucywgeUNhbGxiYWNrKTtcbiAgICB9XG4gICAgaWYgKHogIT0gbnVsbCkge1xuICAgICAgICBhYnMuei5zZXQoeiwgb3B0aW9ucywgekNhbGxiYWNrKTtcbiAgICB9XG59O1xuXG4vKipcbiogQXBwbGllcyBwcm9wb3J0aW9uYWwgc2l6ZS5cbipcbiogQG1ldGhvZCBzZXRQcm9wb3J0aW9uYWxcbiogQGNoYWluYWJsZVxuKlxuKiBAcGFyYW0ge051bWJlcn0geCB1c2VkIHRvIHNldCBwcm9wb3J0aW9uYWwgc2l6ZSBpbiB4LWRpcmVjdGlvbiAod2lkdGgpXG4qIEBwYXJhbSB7TnVtYmVyfSB5IHVzZWQgdG8gc2V0IHByb3BvcnRpb25hbCBzaXplIGluIHktZGlyZWN0aW9uIChoZWlnaHQpXG4qIEBwYXJhbSB7TnVtYmVyfSB6IHVzZWQgdG8gc2V0IHByb3BvcnRpb25hbCBzaXplIGluIHotZGlyZWN0aW9uIChkZXB0aClcbiogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgb3B0aW9ucyBoYXNoXG4qIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZVxuKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9ucyBoYXZlIGJlZW4gY29tcGxldGVkXG4qIEByZXR1cm4ge1NpemV9IHRoaXNcbiovXG5TaXplLnByb3RvdHlwZS5zZXRQcm9wb3J0aW9uYWwgPSBmdW5jdGlvbiBzZXRQcm9wb3J0aW9uYWwoeCwgeSwgeiwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5fbm9kZS5yZXF1ZXN0VXBkYXRlKHRoaXMuX2lkKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHhDYWxsYmFjaztcbiAgICB2YXIgeUNhbGxiYWNrO1xuICAgIHZhciB6Q2FsbGJhY2s7XG5cbiAgICBpZiAoeiAhPSBudWxsKSB7XG4gICAgICAgIHpDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICBlbHNlIGlmICh5ICE9IG51bGwpIHtcbiAgICAgICAgeUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIGVsc2UgaWYgKHggIT0gbnVsbCkge1xuICAgICAgICB4Q2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICB2YXIgcHJvcCA9IHRoaXMuX3Byb3BvcnRpb25hbDtcbiAgICBpZiAoeCAhPSBudWxsKSB7XG4gICAgICAgIHByb3AueC5zZXQoeCwgb3B0aW9ucywgeENhbGxiYWNrKTtcbiAgICB9XG4gICAgaWYgKHkgIT0gbnVsbCkge1xuICAgICAgICBwcm9wLnkuc2V0KHksIG9wdGlvbnMsIHlDYWxsYmFjayk7XG4gICAgfVxuICAgIGlmICh6ICE9IG51bGwpIHtcbiAgICAgICAgcHJvcC56LnNldCh6LCBvcHRpb25zLCB6Q2FsbGJhY2spO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuKiBBcHBsaWVzIGRpZmZlcmVudGlhbCBzaXplIHRvIFNpemUgY29tcG9uZW50LlxuKlxuKiBAbWV0aG9kIHNldERpZmZlcmVudGlhbFxuKiBAY2hhaW5hYmxlXG4qXG4qIEBwYXJhbSB7TnVtYmVyfSB4IHVzZWQgdG8gc2V0IGRpZmZlcmVudGlhbCBzaXplIGluIHgtZGlyZWN0aW9uICh3aWR0aClcbiogQHBhcmFtIHtOdW1iZXJ9IHkgdXNlZCB0byBzZXQgZGlmZmVyZW50aWFsIHNpemUgaW4geS1kaXJlY3Rpb24gKGhlaWdodClcbiogQHBhcmFtIHtOdW1iZXJ9IHogdXNlZCB0byBzZXQgZGlmZmVyZW50aWFsIHNpemUgaW4gei1kaXJlY3Rpb24gKGRlcHRoKVxuKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBvcHRpb25zIGhhc2hcbiogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgYWZ0ZXIgdGhlXG4qICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25zIGhhdmUgYmVlbiBjb21wbGV0ZWRcbiovXG5TaXplLnByb3RvdHlwZS5zZXREaWZmZXJlbnRpYWwgPSBmdW5jdGlvbiBzZXREaWZmZXJlbnRpYWwoeCwgeSwgeiwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5fbm9kZS5yZXF1ZXN0VXBkYXRlKHRoaXMuX2lkKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHhDYWxsYmFjaztcbiAgICB2YXIgeUNhbGxiYWNrO1xuICAgIHZhciB6Q2FsbGJhY2s7XG5cbiAgICBpZiAoeiAhPSBudWxsKSB7XG4gICAgICAgIHpDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICBlbHNlIGlmICh5ICE9IG51bGwpIHtcbiAgICAgICAgeUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIGVsc2UgaWYgKHggIT0gbnVsbCkge1xuICAgICAgICB4Q2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICB2YXIgZGlmZiA9IHRoaXMuX2RpZmZlcmVudGlhbDtcbiAgICBpZiAoeCAhPSBudWxsKSB7XG4gICAgICAgIGRpZmYueC5zZXQoeCwgb3B0aW9ucywgeENhbGxiYWNrKTtcbiAgICB9XG4gICAgaWYgKHkgIT0gbnVsbCkge1xuICAgICAgICBkaWZmLnkuc2V0KHksIG9wdGlvbnMsIHlDYWxsYmFjayk7XG4gICAgfVxuICAgIGlmICh6ICE9IG51bGwpIHtcbiAgICAgICAgZGlmZi56LnNldCh6LCBvcHRpb25zLCB6Q2FsbGJhY2spO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuKiBSZXRyaWV2ZXMgdGhlIGNvbXB1dGVkIHNpemUgYXBwbGllZCB0byB0aGUgdW5kZXJseWluZyBSZW5kZXJDb250ZXh0LlxuKlxuKiBAbWV0aG9kIGdldFxuKlxuKiBAcmV0dXJuIHtOdW1iZXJbXX0gc2l6ZSB0aHJlZSBkaW1lbnNpb25hbCBjb21wdXRlZCBzaXplXG4qL1xuU2l6ZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbm9kZS5nZXRTaXplKCk7XG59O1xuXG4vKipcbiAqIEhhbHRzIGFsbCBjdXJyZW50bHkgYWN0aXZlIHNpemUgdHJhbnNpdGlvbnMuXG4gKlxuICogQG1ldGhvZCBoYWx0XG4gKiBAY2hhaW5hYmxlXG4gKlxuICogQHJldHVybiB7U2l6ZX0gdGhpc1xuICovXG5TaXplLnByb3RvdHlwZS5oYWx0ID0gZnVuY3Rpb24gaGFsdCAoKSB7XG4gICAgdGhpcy5fcHJvcG9ydGlvbmFsLnguaGFsdCgpO1xuICAgIHRoaXMuX3Byb3BvcnRpb25hbC55LmhhbHQoKTtcbiAgICB0aGlzLl9wcm9wb3J0aW9uYWwuei5oYWx0KCk7XG4gICAgdGhpcy5fZGlmZmVyZW50aWFsLnguaGFsdCgpO1xuICAgIHRoaXMuX2RpZmZlcmVudGlhbC55LmhhbHQoKTtcbiAgICB0aGlzLl9kaWZmZXJlbnRpYWwuei5oYWx0KCk7XG4gICAgdGhpcy5fYWJzb2x1dGUueC5oYWx0KCk7XG4gICAgdGhpcy5fYWJzb2x1dGUueS5oYWx0KCk7XG4gICAgdGhpcy5fYWJzb2x1dGUuei5oYWx0KCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNpemU7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUcmFuc2l0aW9uYWJsZSA9IHJlcXVpcmUoJ2ZhbW91cy10cmFuc2l0aW9ucycpLlRyYW5zaXRpb25hYmxlO1xudmFyIFF1YXRlcm5pb24gPSByZXF1aXJlKCdmYW1vdXMtbWF0aCcpLlF1YXRlcm5pb247XG5cbnZhciBRX1JFR0lTVEVSID0gbmV3IFF1YXRlcm5pb24oKTtcbnZhciBRMl9SRUdJU1RFUiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cbmZ1bmN0aW9uIFZlYzNUcmFuc2l0aW9uYWJsZSh4LCB5LCB6LCB0cmFuc2Zvcm0pIHtcbiAgICB0aGlzLl90cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgdGhpcy5fZGlydHkgPSBmYWxzZTtcbiAgICB0aGlzLnggPSBuZXcgVHJhbnNpdGlvbmFibGUoeCk7XG4gICAgdGhpcy55ID0gbmV3IFRyYW5zaXRpb25hYmxlKHkpO1xuICAgIHRoaXMueiA9IG5ldyBUcmFuc2l0aW9uYWJsZSh6KTtcbiAgICB0aGlzLl92YWx1ZXMgPSB7eDogeCwgeTogeSwgejogen07XG59XG5cblZlYzNUcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0KCkge1xuICAgIHRoaXMuX3ZhbHVlcy54ID0gdGhpcy54LmdldCgpO1xuICAgIHRoaXMuX3ZhbHVlcy55ID0gdGhpcy55LmdldCgpO1xuICAgIHRoaXMuX3ZhbHVlcy56ID0gdGhpcy56LmdldCgpO1xuICAgIHJldHVybiB0aGlzLl92YWx1ZXM7XG59O1xuXG5WZWMzVHJhbnNpdGlvbmFibGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCh4LCB5LCB6LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIHRoaXMuZGlydHkoKTtcblxuICAgIHZhciBjYlggPSBudWxsO1xuICAgIHZhciBjYlkgPSBudWxsO1xuICAgIHZhciBjYlogPSBudWxsO1xuXG4gICAgaWYgKHogIT0gbnVsbCkgY2JaID0gY2FsbGJhY2s7XG4gICAgZWxzZSBpZiAoeSAhPSBudWxsKSBjYlkgPSBjYWxsYmFjaztcbiAgICBlbHNlIGlmICh4ICE9IG51bGwpIGNiWCA9IGNhbGxiYWNrO1xuXG4gICAgaWYgKHggIT0gbnVsbCkgdGhpcy54LnNldCh4LCBvcHRpb25zLCBjYlgpO1xuICAgIGlmICh5ICE9IG51bGwpIHRoaXMueS5zZXQoeSwgb3B0aW9ucywgY2JZKTtcbiAgICBpZiAoeiAhPSBudWxsKSB0aGlzLnouc2V0KHosIG9wdGlvbnMsIGNiWik7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cblZlYzNUcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiBpc0FjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy54LmlzQWN0aXZlKCkgfHwgdGhpcy55LmlzQWN0aXZlKCkgfHwgdGhpcy56LmlzQWN0aXZlKCk7XG59O1xuXG5WZWMzVHJhbnNpdGlvbmFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgdGhpcy54LnBhdXNlKCk7XG4gICAgdGhpcy55LnBhdXNlKCk7XG4gICAgdGhpcy56LnBhdXNlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5WZWMzVHJhbnNpdGlvbmFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uIHJlc3VtZSgpIHtcbiAgICB0aGlzLngucmVzdW1lKCk7XG4gICAgdGhpcy55LnJlc3VtZSgpO1xuICAgIHRoaXMuei5yZXN1bWUoKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cblZlYzNUcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUuaGFsdCA9IGZ1bmN0aW9uIGhhbHQoKSB7XG4gICAgdGhpcy54LmhhbHQoKTtcbiAgICB0aGlzLnkuaGFsdCgpO1xuICAgIHRoaXMuei5oYWx0KCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5WZWMzVHJhbnNpdGlvbmFibGUucHJvdG90eXBlLmRpcnR5ID0gZnVuY3Rpb24gZGlydHkoKSB7XG4gICAgaWYgKCF0aGlzLl90cmFuc2Zvcm0uX2RpcnR5KSB7XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybS5fbm9kZS5yZXF1ZXN0VXBkYXRlKHRoaXMuX3RyYW5zZm9ybS5faWQpO1xuICAgICAgICB0aGlzLl90cmFuc2Zvcm0uX2RpcnR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gUXVhdFRyYW5zaXRpb25hYmxlKHgsIHksIHosIHcsIHRyYW5zZm9ybSkge1xuICAgIHRoaXMuX3RyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuICAgIHRoaXMuX2Zyb250ID0gMDtcbiAgICB0aGlzLl9lbmQgPSAwO1xuICAgIHRoaXMuX2RpcnR5ID0gZmFsc2U7XG4gICAgdGhpcy5fdCA9IG5ldyBUcmFuc2l0aW9uYWJsZSgwKTtcbiAgICB0aGlzLl9mcm9tUSA9IG5ldyBRdWF0ZXJuaW9uKHcsIHgsIHksIHopO1xuICAgIHRoaXMuX3RvUSA9IG5ldyBRdWF0ZXJuaW9uKCk7XG4gICAgdGhpcy5fcSA9IG5ldyBRdWF0ZXJuaW9uKHcsIHgsIHksIHopO1xufVxuXG5RdWF0VHJhbnNpdGlvbmFibGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCgpIHtcbiAgICB2YXIgdCA9IHRoaXMuX3QuZ2V0KCk7XG4gICAgdmFyIHcsIHgsIHksIHo7XG4gICAgdmFyIHF1ZXVlID0gdGhpcy5fcXVldWU7XG4gICAgd2hpbGUgKHQgPj0gdGhpcy5fZnJvbnQgKyAxKSB7XG4gICAgICAgIHRoaXMuX2Zyb250Kys7XG4gICAgICAgIHcgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICB4ID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgeSA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIHogPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICB0aGlzLl9xLnNldCh3LCB4LCB5LCB6KTtcbiAgICAgICAgdGhpcy5fZnJvbVEuc2V0KHcsIHgsIHksIHopO1xuICAgICAgICBpZiAodGhpcy5fcXVldWUubGVuZ3RoICE9PSAwKSB0aGlzLl90b1Euc2V0KHF1ZXVlWzBdLCBxdWV1ZVsxXSwgcXVldWVbMl0sIHF1ZXVlWzNdKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3F1ZXVlLmxlbmd0aCAhPT0gMCkgdGhpcy5fZnJvbVEuc2xlcnAodGhpcy5fdG9RLCB0IC0gdGhpcy5fZnJvbnQsIHRoaXMuX3EpO1xuICAgIHJldHVybiB0aGlzLl9xO1xufTtcblxuUXVhdFRyYW5zaXRpb25hYmxlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQoeCwgeSwgeiwgdywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuX3RyYW5zZm9ybS5fZGlydHkpIHtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtLl9ub2RlLnJlcXVlc3RVcGRhdGUodGhpcy5fdHJhbnNmb3JtLl9pZCk7XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybS5fZGlydHkgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgaWYgKHRoaXMuX3F1ZXVlLmxlbmd0aCA9PT0gMCkgdGhpcy5fdG9RLnNldCh3LCB4LCB5LCB6KTtcbiAgICB0aGlzLl9xdWV1ZS5wdXNoKHcsIHgsIHksIHopO1xuICAgIHRoaXMuX2VuZCsrO1xuICAgIHRoaXMuX3Quc2V0KHRoaXMuX2VuZCwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuUXVhdFRyYW5zaXRpb25hYmxlLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uIGlzQWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLl90LmlzQWN0aXZlKCk7XG59O1xuXG5RdWF0VHJhbnNpdGlvbmFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgdGhpcy5fdC5wYXVzZSgpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuUXVhdFRyYW5zaXRpb25hYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiByZXN1bWUoKSB7XG4gICAgdGhpcy5fdC5yZXN1bWUoKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cblF1YXRUcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUuaGFsdCA9IGZ1bmN0aW9uIGhhbHQoKSB7XG4gICAgdGhpcy5fZGlydHkgPSBmYWxzZTtcbiAgICB0aGlzLl90LnJlc2V0KDApO1xuICAgIHRoaXMuX3F1ZXVlLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fZnJvbnQgPSAwO1xuICAgIHRoaXMuX2VuZCA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBUcmFuc2Zvcm0obm9kZSkge1xuICAgIHRoaXMuX25vZGUgPSBub2RlO1xuICAgIHRoaXMuX2lkID0gbm9kZS5hZGRDb21wb25lbnQodGhpcyk7XG4gICAgdGhpcy5vcmlnaW4gPSBudWxsO1xuICAgIHRoaXMubW91bnRQb2ludCA9IG51bGw7XG4gICAgdGhpcy5hbGlnbiA9IG51bGw7XG4gICAgdGhpcy5zY2FsZSA9IG51bGw7XG4gICAgdGhpcy5wb3NpdGlvbiA9IG51bGw7XG4gICAgdGhpcy5yb3RhdGlvbiA9IG51bGw7XG5cbiAgICB0aGlzLl9kaXJ0eSA9IGZhbHNlO1xufVxuXG5UcmFuc2Zvcm0udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ1RyYW5zZm9ybSc7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29tcG9uZW50OiB0aGlzLmNvbnN0cnVjdG9yLnRvU3RyaW5nKCksXG4gICAgICAgIG9yaWdpbjogdGhpcy5vcmlnaW4gJiYgdGhpcy5vcmlnaW4uZ2V0KCksXG4gICAgICAgIG1vdW50UG9pbnQ6IHRoaXMubW91bnRQb2ludCAmJiB0aGlzLm1vdW50UG9pbnQuZ2V0KCksXG4gICAgICAgIGFsaWduOiB0aGlzLmFsaWduICYmIHRoaXMuYWxpZ24uZ2V0KCksXG4gICAgICAgIHNjYWxlOiB0aGlzLnNjYWxlICYmIHRoaXMuc2NhbGUuZ2V0KCksXG4gICAgICAgIHBvc2l0aW9uOiB0aGlzLnBvc2l0aW9uICYmIHRoaXMucG9zaXRpb24uZ2V0KCksXG4gICAgICAgIHJvdGF0aW9uOiB0aGlzLnJvdGF0aW9uICYmIHRoaXMucm90YXRpb24uZ2V0KClcbiAgICB9O1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIHNldFN0YXRlKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmNvbXBvbmVudCA9PT0gdGhpcy5jb25zdHJ1Y3Rvci50b1N0cmluZygpKSB7XG4gICAgICAgIHN0YXRlLm9yaWdpbiAmJiB0aGlzLnNldE9yaWdpbihzdGF0ZS5vcmlnaW4ueCwgc3RhdGUub3JpZ2luLnksIHN0YXRlLm9yaWdpbi56KTtcbiAgICAgICAgc3RhdGUubW91bnRQb2ludCAmJiB0aGlzLnNldE1vdW50UG9pbnQoc3RhdGUubW91bnRQb2ludC54LCBzdGF0ZS5tb3VudFBvaW50LnksIHN0YXRlLm1vdW50UG9pbnQueik7XG4gICAgICAgIHN0YXRlLmFsaWduICYmIHRoaXMuc2V0QWxpZ24oc3RhdGUuYWxpZ24ueCwgc3RhdGUuYWxpZ24ueSwgc3RhdGUuYWxpZ24ueik7XG4gICAgICAgIHN0YXRlLnNjYWxlICYmIHRoaXMuc2V0U2NhbGUoc3RhdGUuc2NhbGUueCwgc3RhdGUuc2NhbGUueSwgc3RhdGUuc2NhbGUueik7XG4gICAgICAgIHN0YXRlLnBvc2l0aW9uICYmIHRoaXMuc2V0UG9zaXRpb24oc3RhdGUucG9zaXRpb24ueCwgc3RhdGUucG9zaXRpb24ueSwgc3RhdGUucG9zaXRpb24ueik7XG4gICAgICAgIHN0YXRlLnJvdGF0aW9uICYmIHRoaXMuc2V0Um90YXRpb24oc3RhdGUucm90YXRpb24ueCwgc3RhdGUucm90YXRpb24ueSwgc3RhdGUucm90YXRpb24ueiwgc3RhdGUucm90YXRpb24udyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNldE9yaWdpbiA9IGZ1bmN0aW9uIHNldE9yaWdpbih4LCB5LCB6LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5vcmlnaW4pIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLl9ub2RlLmdldE9yaWdpbigpO1xuICAgICAgICB0aGlzLm9yaWdpbiA9IG5ldyBWZWMzVHJhbnNpdGlvbmFibGUodlswXSwgdlsxXSwgdlsyXSwgdGhpcyk7XG4gICAgfVxuICAgIHRoaXMub3JpZ2luLnNldCh4LCB5LCB6LCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNldE1vdW50UG9pbnQgPSBmdW5jdGlvbiBzZXRNb3VudFBvaW50KHgsIHksIHosIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLm1vdW50UG9pbnQpIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLl9ub2RlLmdldE1vdW50UG9pbnQoKTtcbiAgICAgICAgdGhpcy5tb3VudFBvaW50ID0gbmV3IFZlYzNUcmFuc2l0aW9uYWJsZSh2WzBdLCB2WzFdLCB2WzJdLCB0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5tb3VudFBvaW50LnNldCh4LCB5LCB6LCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNldEFsaWduID0gZnVuY3Rpb24gc2V0QWxpZ24oeCwgeSwgeiwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuYWxpZ24pIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLl9ub2RlLmdldEFsaWduKCk7XG4gICAgICAgIHRoaXMuYWxpZ24gPSBuZXcgVmVjM1RyYW5zaXRpb25hYmxlKHZbMF0sIHZbMV0sIHZbMl0sIHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLmFsaWduLnNldCh4LCB5LCB6LCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNldFNjYWxlID0gZnVuY3Rpb24gc2V0U2NhbGUoeCwgeSwgeiwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuc2NhbGUpIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLl9ub2RlLmdldFNjYWxlKCk7XG4gICAgICAgIHRoaXMuc2NhbGUgPSBuZXcgVmVjM1RyYW5zaXRpb25hYmxlKHZbMF0sIHZbMV0sIHZbMl0sIHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLnNjYWxlLnNldCh4LCB5LCB6LCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24gc2V0UG9zaXRpb24oeCwgeSwgeiwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMucG9zaXRpb24pIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLl9ub2RlLmdldFBvc2l0aW9uKCk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBuZXcgVmVjM1RyYW5zaXRpb25hYmxlKHZbMF0sIHZbMV0sIHZbMl0sIHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLnBvc2l0aW9uLnNldCh4LCB5LCB6LCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIHRyYW5zbGF0ZSh4LCB5LCB6LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5wb3NpdGlvbikge1xuICAgICAgICB2YXIgdiA9IHRoaXMuX25vZGUuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IG5ldyBWZWMzVHJhbnNpdGlvbmFibGUodlswXSwgdlsxXSwgdlsyXSwgdGhpcyk7XG4gICAgfVxuICAgIHZhciBwID0gdGhpcy5wb3NpdGlvbjtcbiAgICB2YXIgeHEgPSBwLnguX3F1ZXVlO1xuICAgIHZhciB5cSA9IHAueS5fcXVldWU7XG4gICAgdmFyIHpxID0gcC56Ll9xdWV1ZTtcbiAgICB2YXIgeEVuZCA9IHggPT0gbnVsbCA/IG51bGwgOiB4ICsgKHhxLmxlbmd0aCA+IDAgPyB4cVt4cS5sZW5ndGggLSA0XSA6IHAueC5fZW5kKTtcbiAgICB2YXIgeUVuZCA9IHkgPT0gbnVsbCA/IG51bGwgOiB5ICsgKHlxLmxlbmd0aCA+IDAgPyB5cVt5cS5sZW5ndGggLSA0XSA6IHAueS5fZW5kKTtcbiAgICB2YXIgekVuZCA9IHogPT0gbnVsbCA/IG51bGwgOiB6ICsgKHpxLmxlbmd0aCA+IDAgPyB6cVt6cS5sZW5ndGggLSA0XSA6IHAuei5fZW5kKTtcbiAgICB0aGlzLnBvc2l0aW9uLnNldCh4RW5kLCB5RW5kLCB6RW5kLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNldFJvdGF0aW9uID0gZnVuY3Rpb24gc2V0Um90YXRpb24oeCwgeSwgeiwgdywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMucm90YXRpb24pIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLl9ub2RlLmdldFJvdGF0aW9uKCk7XG4gICAgICAgIHRoaXMucm90YXRpb24gPSBuZXcgUXVhdFRyYW5zaXRpb25hYmxlKHZbMF0sIHZbMV0sIHZbMl0sIHZbM10sIHRoaXMpO1xuICAgIH1cbiAgICB2YXIgcSA9IFFfUkVHSVNURVI7XG4gICAgaWYgKHR5cGVvZiB3ID09PSAnbnVtYmVyJykge1xuICAgICAgICBxLnNldCh3LCB4LCB5LCB6KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHEuZnJvbUV1bGVyKHgsIHksIHopO1xuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSB3O1xuICAgIH1cbiAgICB0aGlzLnJvdGF0aW9uLnNldChxLngsIHEueSwgcS56LCBxLncsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucm90YXRlID0gZnVuY3Rpb24gcm90YXRlKHgsIHksIHosIHcsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLnJvdGF0aW9uKSB7XG4gICAgICAgIHZhciB2ID0gdGhpcy5fbm9kZS5nZXRSb3RhdGlvbigpO1xuICAgICAgICB0aGlzLnJvdGF0aW9uID0gbmV3IFF1YXRUcmFuc2l0aW9uYWJsZSh2WzBdLCB2WzFdLCB2WzJdLCB2WzNdLCB0aGlzKTtcbiAgICB9XG4gICAgdmFyIHF1ZXVlID0gdGhpcy5yb3RhdGlvbi5fcXVldWU7XG4gICAgdmFyIGxlbiA9IHRoaXMucm90YXRpb24uX3F1ZXVlLmxlbmd0aDtcbiAgICB2YXIgcmVmZXJlbmNlUTtcbiAgICBpZiAobGVuICE9PSAwKSB7XG4gICAgICAgIHJlZmVyZW5jZVEgPSBRMl9SRUdJU1RFUi5zZXQocXVldWVbbGVuIC0gNF0sIHF1ZXVlW2xlbiAtIDNdLCBxdWV1ZVtsZW4gLSAyXSwgcXVldWVbbGVuIC0gMV0pO1xuICAgIH1cbiAgICBlbHNlIHJlZmVyZW5jZVEgPSBRMl9SRUdJU1RFUi5jb3B5KHRoaXMucm90YXRpb24uX3EpO1xuXG4gICAgdmFyIHJvdFEgPSBRX1JFR0lTVEVSO1xuICAgIGlmICh0eXBlb2YgdyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcm90US5zZXQodywgeCwgeSwgeik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByb3RRLmZyb21FdWxlcih4LCB5LCB6KTtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0gdztcbiAgICB9XG5cbiAgICB2YXIgcSA9IHJlZmVyZW5jZVEubXVsdGlwbHkocm90USk7XG4gICAgdGhpcy5yb3RhdGlvbi5zZXQocS54LCBxLnksIHEueiwgcS53LCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmNsZWFuID0gZnVuY3Rpb24gY2xlYW4oKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLl9ub2RlO1xuICAgIHZhciBjO1xuICAgIHZhciBpc0RpcnR5ID0gZmFsc2U7XG4gICAgaWYgKChjID0gdGhpcy5vcmlnaW4pICYmIGMuX2RpcnR5KSB7XG4gICAgICAgIG5vZGUuc2V0T3JpZ2luKGMueC5nZXQoKSwgYy55LmdldCgpLCBjLnouZ2V0KCkpO1xuICAgICAgICBjLl9kaXJ0eSA9IGMuaXNBY3RpdmUoKTtcbiAgICAgICAgaXNEaXJ0eSA9IGlzRGlydHkgfHwgYy5fZGlydHk7XG4gICAgfVxuICAgIGlmICgoYyA9IHRoaXMubW91bnRQb2ludCkgJiYgYy5fZGlydHkpIHtcbiAgICAgICAgbm9kZS5zZXRNb3VudFBvaW50KGMueC5nZXQoKSwgYy55LmdldCgpLCBjLnouZ2V0KCkpO1xuICAgICAgICBjLl9kaXJ0eSA9IGMuaXNBY3RpdmUoKTtcbiAgICAgICAgaXNEaXJ0eSA9IGlzRGlydHkgfHwgYy5fZGlydHk7XG4gICAgfVxuICAgIGlmICgoYyA9IHRoaXMuYWxpZ24pICYmIGMuX2RpcnR5KSB7XG4gICAgICAgIG5vZGUuc2V0QWxpZ24oYy54LmdldCgpLCBjLnkuZ2V0KCksIGMuei5nZXQoKSk7XG4gICAgICAgIGMuX2RpcnR5ID0gYy5pc0FjdGl2ZSgpO1xuICAgICAgICBpc0RpcnR5ID0gaXNEaXJ0eSB8fCBjLl9kaXJ0eTtcbiAgICB9XG4gICAgaWYgKChjID0gdGhpcy5zY2FsZSkgJiYgYy5fZGlydHkpIHtcbiAgICAgICAgbm9kZS5zZXRTY2FsZShjLnguZ2V0KCksIGMueS5nZXQoKSwgYy56LmdldCgpKTtcbiAgICAgICAgYy5fZGlydHkgPSBjLmlzQWN0aXZlKCk7XG4gICAgICAgIGlzRGlydHkgPSBpc0RpcnR5IHx8IGMuX2RpcnR5O1xuICAgIH1cbiAgICBpZiAoKGMgPSB0aGlzLnBvc2l0aW9uKSAmJiBjLl9kaXJ0eSkge1xuICAgICAgICBub2RlLnNldFBvc2l0aW9uKGMueC5nZXQoKSwgYy55LmdldCgpLCBjLnouZ2V0KCkpO1xuICAgICAgICBjLl9kaXJ0eSA9IGMuaXNBY3RpdmUoKTtcbiAgICAgICAgaXNEaXJ0eSA9IGlzRGlydHkgfHwgYy5fZGlydHk7XG4gICAgfVxuICAgIGlmICgoYyA9IHRoaXMucm90YXRpb24pICYmIGMuX2RpcnR5KSB7XG4gICAgICAgIGMuZ2V0KCk7XG4gICAgICAgIG5vZGUuc2V0Um90YXRpb24oYy5fcS54LCBjLl9xLnksIGMuX3EueiwgYy5fcS53KTtcbiAgICAgICAgYy5fZGlydHkgPSBjLmlzQWN0aXZlKCk7XG4gICAgICAgIGlzRGlydHkgPSBpc0RpcnR5IHx8IGMuX2RpcnR5O1xuICAgIH1cbiAgICBpZiAoaXNEaXJ0eSkgdGhpcy5fbm9kZS5yZXF1ZXN0VXBkYXRlT25OZXh0VGljayh0aGlzLl9pZCk7XG4gICAgZWxzZSB0aGlzLl9kaXJ0eSA9IGZhbHNlO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5vblVwZGF0ZSA9IFRyYW5zZm9ybS5wcm90b3R5cGUuY2xlYW47XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2FsbGJhY2tTdG9yZSA9IHJlcXVpcmUoJ2ZhbW91cy11dGlsaXRpZXMnKS5DYWxsYmFja1N0b3JlO1xuXG4vKipcbiAqIENvbXBvbmVudCB0byBtYW5hZ2UgRE9NIGV2ZW50cy4gV2hlbiByZWdpc3RlcmluZyBhbiBldmVudCwgdGhlIHVzZXIgbWF5IHNwZWNpZnkgLm1ldGhvZHMgYW5kXG4gKiAucHJvcGVydGllcyB0byBwcmVwcm9jZXNzIHRoZSBldmVudCBvYmplY3QuXG4gKlxuICogQGNsYXNzIFVJRXZlbnRIYW5kbGVyXG4gKiBAcGFyYW0ge0xvY2FsRGlzcGF0Y2h9IGRpc3BhdGNoIFRoZSBkaXNwYXRjaCB3aXRoIHdoaWNoIHRvIHJlZ2lzdGVyIHRoZSBoYW5kbGVyLlxuICogQHBhcmFtIHtPYmplY3RbXX0gZXZlbnRzIEFuIGFycmF5IG9mIGV2ZW50IG9iamVjdHMgc3BlY2lmeWluZyAuZXZlbnQgYW5kIC5jYWxsYmFjayBwcm9wZXJ0aWVzLlxuICovXG5mdW5jdGlvbiBVSUV2ZW50SGFuZGxlciAoZGlzcGF0Y2gsIGV2ZW50cykge1xuICAgIHRoaXMuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbiAgICB0aGlzLl9ldmVudHMgPSBuZXcgQ2FsbGJhY2tTdG9yZSgpO1xuXG4gICAgaWYgKGV2ZW50cykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZXZlbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLm9uKGV2ZW50c1tpXSwgZXZlbnRzW2ldLmNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuYW1lIG9mIFVJRXZlbnRIYW5kbGVyIGFzIGEgc3RyaW5nLlxuICpcbiAqIEBtZXRob2QgdG9TdHJpbmdcbiAqIEBzdGF0aWNcbiAqIEByZXR1cm4ge1N0cmluZ30gJ1VJRXZlbnRIYW5kbGVyJ1xuICovXG5VSUV2ZW50SGFuZGxlci50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnVUlFdmVudEhhbmRsZXInO1xufTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgb24gYW4gZXZlbnQuXG4gKlxuICogQG1ldGhvZCBvblxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBldiBUaGUgZXZlbnQgb2JqZWN0IG9yIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBUaGUgY2FsbGJhY2suXG4gKi9cblVJRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKGV2LCBjYikge1xuICAgIHZhciByZW5kZXJhYmxlcyA9IHRoaXMuZGlzcGF0Y2guZ2V0UmVuZGVyYWJsZXMoKTtcbiAgICB2YXIgZXZlbnROYW1lID0gZXYuZXZlbnQgfHwgZXY7XG4gICAgdmFyIG1ldGhvZHMgPSBldi5tZXRob2RzO1xuICAgIHZhciBwcm9wZXJ0aWVzID0gZXYucHJvcGVydGllcztcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcmVuZGVyYWJsZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKHJlbmRlcmFibGVzW2ldLm9uKSByZW5kZXJhYmxlc1tpXS5vbihldmVudE5hbWUsIG1ldGhvZHMsIHByb3BlcnRpZXMpO1xuICAgIH1cbiAgICB0aGlzLl9ldmVudHMub24oZXZlbnROYW1lLCBjYik7XG4gICAgdGhpcy5kaXNwYXRjaC5yZWdpc3RlclRhcmdldGVkRXZlbnQoZXZlbnROYW1lLCB0aGlzLnRyaWdnZXIuYmluZCh0aGlzLCBldmVudE5hbWUpKTtcbn07XG5cbi8qKlxuICogRGVyZWdpc3RlciBhIGNhbGxiYWNrIGZyb20gYW4gZXZlbnQuXG4gKlxuICogQG1ldGhvZCBvblxuICogQHBhcmFtIHtTdHJpbmd9IGV2IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgVGhlIGNhbGxiYWNrLlxuICovXG5VSUV2ZW50SGFuZGxlci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gb2ZmKGV2LCBjYikge1xuICAgIHRoaXMuX2V2ZW50cy5vZmYoZXYsIGNiKTtcbiAgICB0aGlzLmRpc3BhdGNoLmRlcmVnaXN0ZXJHbG9iYWxFdmVudChldiwgdGhpcy50cmlnZ2VyLmJpbmQodGhpcywgZXYpKTtcbn07XG5cbi8qKlxuICogVHJpZ2dlciB0aGUgY2FsbGJhY2sgYXNzb2NpYXRlZCB3aXRoIGFuIGV2ZW50LCBwYXNzaW5nIGluIGEgcGF5bG9hZC5cbiAqXG4gKiBAbWV0aG9kIHRyaWdnZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldiBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkIFRoZSBldmVudCBwYXlsb2FkLlxuICovXG5VSUV2ZW50SGFuZGxlci5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uIHRyaWdnZXIgKGV2LCBwYXlsb2FkKSB7XG4gICAgdGhpcy5fZXZlbnRzLnRyaWdnZXIoZXYsIHBheWxvYWQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBVSUV2ZW50SGFuZGxlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgQWxpZ246IHJlcXVpcmUoJy4vQWxpZ24nKSxcbiAgICBDYW1lcmE6IHJlcXVpcmUoJy4vQ2FtZXJhJyksXG4gICAgRXZlbnRFbWl0dGVyOiByZXF1aXJlKCcuL0V2ZW50RW1pdHRlcicpLFxuICAgIEV2ZW50SGFuZGxlcjogcmVxdWlyZSgnLi9FdmVudEhhbmRsZXInKSxcbiAgICBHZXN0dXJlSGFuZGxlcjogcmVxdWlyZSgnLi9HZXN0dXJlSGFuZGxlcicpLFxuICAgIE1vdW50UG9pbnQ6IHJlcXVpcmUoJy4vTW91bnRQb2ludCcpLFxuICAgIE9wYWNpdHk6IHJlcXVpcmUoJy4vT3BhY2l0eScpLFxuICAgIE9yaWdpbjogcmVxdWlyZSgnLi9PcmlnaW4nKSxcbiAgICBQb3NpdGlvbjogcmVxdWlyZSgnLi9Qb3NpdGlvbicpLFxuICAgIFJvdGF0aW9uOiByZXF1aXJlKCcuL1JvdGF0aW9uJyksXG4gICAgU2NhbGU6IHJlcXVpcmUoJy4vU2NhbGUnKSxcbiAgICBTaXplOiByZXF1aXJlKCcuL1NpemUnKSxcbiAgICBUcmFuc2Zvcm06IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyksXG4gICAgVUlFdmVudEhhbmRsZXI6IHJlcXVpcmUoJy4vVUlFdmVudEhhbmRsZXInKVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENhbGxiYWNrU3RvcmUgPSByZXF1aXJlKCdmYW1vdXMtdXRpbGl0aWVzJykuQ2FsbGJhY2tTdG9yZTtcblxudmFyIFJFTkRFUl9TSVpFID0gMjtcblxuLyoqXG4gKiBBIERPTUVsZW1lbnQgaXMgYSByZW5kZXJhYmxlIHRoYXQgY2FuIGJlIGFkZGVkIGp1c3QgbGlrZSBhIFwibm9ybWFsXCJcbiAqIGNvbXBvbmVudCB0byBhIG5vZGUgdXNpbmcgYGFkZENvbXBvbmVudGAuXG4gKiBSZW5kZXJhYmxlcyBzZW5kIGRyYXcgY29tbWFuZHMgdG8gdGhlIG5vZGUgdGhleSBhcmUgYXR0YWNoZWQgdG8uXG4gKiBUaG9zZSBjb21tYW5kcyB0aGVuIGdldCBpbnRlcnByZXRlZCBieSB0aGUgYERPTVJlbmRlcmVyYCBpbiB0aGUgTWFpbiB0aHJlYWRcbiAqIHRvIGJ1aWxkIHRoZSBhY3R1YWwgRE9NIHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIEBjbGFzcyBET01FbGVtZW50XG4gKiBAY29uc3RydWN0b3JcbiAqIFxuICogQHBhcmFtIHtOb2RlfSBub2RlICAgICAgICAgICAgICAgICAgIFRoZSBlbnRpdHkgdG8gd2hpY2ggdGhlIGBET01FbGVtZW50YFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmFibGUgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgICAgICAgICAgICAgIEluaXRpYWwgb3B0aW9ucyB1c2VkIGZvciBpbnN0YW50aWF0aW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIE5vZGUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wcm9wZXJ0aWVzICAgQ1NTIHByb3BlcnRpZXMgdGhhdCBzaG91bGQgYmUgYWRkZWQgdG9cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgYWN0dWFsIERPTUVsZW1lbnQgb24gdGhlIGluaXRpYWwgZHJhdy5cbiAqL1xuZnVuY3Rpb24gRE9NRWxlbWVudCAobm9kZSwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgJ0hUTUxFbGVtZW50IGNvbnN0cnVjdG9yIHNpZ25hdHVyZSBjaGFuZ2VkIVxcbicgK1xuICAgICAgICAgICAgJ1Bhc3MgaW4gYW4gb3B0aW9ucyBvYmplY3Qgd2l0aCB7dGFnTmFtZTogJyArIG9wdGlvbnMgKyAnfSBpbnN0ZWFkLidcbiAgICAgICAgKTtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHRhZ05hbWU6IG9wdGlvbnNcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLl9ub2RlID0gbm9kZTtcblxuICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSBmYWxzZTtcblxuICAgIHRoaXMuX2NoYW5nZVF1ZXVlID0gW107XG4gICAgXG4gICAgdGhpcy5fVUlFdmVudHMgPSBub2RlLmdldFVJRXZlbnRzKCkuc2xpY2UoMCk7XG4gICAgdGhpcy5fY2xhc3NlcyA9IFsnZmEtc3VyZmFjZSddO1xuICAgIHRoaXMuX3JlcXVlc3RpbmdFdmVudExpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMuX3N0eWxlcyA9IHtcbiAgICAgICAgZGlzcGxheTogbm9kZS5pc1Nob3duKCkgXG4gICAgfTtcbiAgICB0aGlzLl9hdHRyaWJ1dGVzID0ge307XG4gICAgdGhpcy5fY29udGVudCA9ICcnO1xuXG4gICAgdGhpcy5fdGFnTmFtZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy50YWdOYW1lID8gb3B0aW9ucy50YWdOYW1lIDogJ2Rpdic7XG4gICAgdGhpcy5faWQgPSBub2RlLmFkZENvbXBvbmVudCh0aGlzKTtcblxuICAgIHRoaXMuX2NhbGxiYWNrcyA9IG5ldyBDYWxsYmFja1N0b3JlKCk7XG5cbiAgICBpZiAoIW9wdGlvbnMpIHJldHVybjtcblxuICAgIGlmIChvcHRpb25zLmNsYXNzZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25zLmNsYXNzZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB0aGlzLmFkZENsYXNzKG9wdGlvbnMuY2xhc3Nlc1tpXSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlcykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5hdHRyaWJ1dGVzKVxuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoa2V5LCBvcHRpb25zLmF0dHJpYnV0ZXNba2V5XSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucHJvcGVydGllcykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5wcm9wZXJ0aWVzKVxuICAgICAgICAgICAgdGhpcy5zZXRQcm9wZXJ0eShrZXksIG9wdGlvbnMucHJvcGVydGllc1trZXldKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5pZCkgdGhpcy5zZXRJZChvcHRpb25zLmlkKTtcbiAgICBpZiAob3B0aW9ucy5jb250ZW50KSB0aGlzLnNldENvbnRlbnQob3B0aW9ucy5jb250ZW50KTtcbn1cblxuLyoqXG4gKiBTZXJpYWxpemVzIHRoZSBzdGF0ZSBvZiB0aGUgRE9NRWxlbWVudC4gVGhpcyBtZXRob2Qgd2lsbCBiZSBpbnZva2VkIGJ5XG4gKiBAe0BsaW5rIE5vZGUjZ2V0VmFsdWV9IGluIG9yZGVyIHRvIHNlcmlhbGl6ZSB0aGUgbm9kZSBhbmQgcG9zc2libHkgZW50aXJlXG4gKiBzY2VuZSBncmFwaCBoaWVyYXJjaGllcy5cbiAqXG4gKiBAbWV0aG9kIGdldFZhbHVlXG4gKiBcbiAqIEByZXR1cm4ge09iamVjdH0gICAgIHNlcmlhbGl6ZWQgY29tcG9uZW50LlxuICovXG5ET01FbGVtZW50LnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uIGdldFZhbHVlICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjbGFzc2VzOiB0aGlzLl9jbGFzc2VzLFxuICAgICAgICBzdHlsZXM6IHRoaXMuX3N0eWxlcyxcbiAgICAgICAgYXR0cmlidXRlczogdGhpcy5fYXR0cmlidXRlcyxcbiAgICAgICAgY29udGVudDogdGhpcy5fY29udGVudCxcbiAgICAgICAgaWQ6IHRoaXMuX2F0dHJpYnV0ZXMuaWQsXG4gICAgICAgIHRhZ05hbWU6IHRoaXMuX3RhZ05hbWVcbiAgICB9O1xufTtcblxuLyoqXG4gKiBNZXRob2QgdG8gYmUgaW52b2tlZCBieSB0aGUgbm9kZSBhcyBzb29uIGFzIGFuIHVwZGF0ZSBvY2N1cnMuIFRoaXMgYWxsb3dzXG4gKiB0aGUgRE9NRWxlbWVudCByZW5kZXJhYmxlIHRvIGR5bmFtaWNhbGx5IHJlYWN0IHRvIHN0YXRlIGNoYW5nZXMgb24gdGhlIE5vZGUuXG4gKlxuICogVGhpcyBmbHVzaGVzIHRoZSBpbnRlcm5hbCBkcmF3IGNvbW1hbmQgcXVldWUgYnkgc2VuZGluZyBpbmRpdmlkdWFsIGNvbW1hbmRzXG4gKiB0byB0aGUgbm9kZSB1c2luZyBgc2VuZERyYXdDb21tYW5kYC5cbiAqXG4gKiBAbWV0aG9kIG9uVXBkYXRlXG4gKi9cbkRPTUVsZW1lbnQucHJvdG90eXBlLm9uVXBkYXRlID0gZnVuY3Rpb24gb25VcGRhdGUgKCkge1xuICAgIHZhciBub2RlID0gdGhpcy5fbm9kZTtcbiAgICB2YXIgcXVldWUgPSB0aGlzLl9jaGFuZ2VRdWV1ZTtcbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuXG4gICAgaWYgKGxlbiAmJiBub2RlKSB7XG4gICAgICAgIG5vZGUuc2VuZERyYXdDb21tYW5kKCdXSVRIJyk7XG4gICAgICAgIG5vZGUuc2VuZERyYXdDb21tYW5kKG5vZGUuZ2V0TG9jYXRpb24oKSk7XG4gICAgICAgIG5vZGUuc2VuZERyYXdDb21tYW5kKCdET00nKTtcblxuICAgICAgICB3aGlsZSAobGVuLS0pIG5vZGUuc2VuZERyYXdDb21tYW5kKHF1ZXVlLnNoaWZ0KCkpO1xuICAgIH1cblxuICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogTWV0aG9kIHRvIGJlIGludm9rZWQgYnkgdGhlIE5vZGUgYXMgc29vbiBhcyB0aGUgbm9kZSAob3IgYW55IG9mIGl0c1xuICogYW5jZXN0b3JzKSBpcyBiZWluZyBtb3VudGVkLlxuICpcbiAqIEBtZXRob2Qgb25Nb3VudFxuICogXG4gKiBAcGFyYW0gIHtOb2RlfSBub2RlICAgICAgUGFyZW50IG5vZGUgdG8gd2hpY2ggdGhlIGNvbXBvbmVudCBzaG91bGQgYmUgYWRkZWQuXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGlkICAgICAgUGF0aCBhdCB3aGljaCB0aGUgY29tcG9uZW50IChvciBub2RlKSBpcyBiZWluZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFjaGVkLiBUaGUgcGF0aCBpcyBiZWluZyBzZXQgb24gdGhlIGFjdHVhbFxuICogICAgICAgICAgICAgICAgICAgICAgICAgIERPTUVsZW1lbnQgYXMgYSBgZGF0YS1mYS1wYXRoYC1hdHRyaWJ1dGUuXG4gKi9cbkRPTUVsZW1lbnQucHJvdG90eXBlLm9uTW91bnQgPSBmdW5jdGlvbiBvbk1vdW50IChub2RlLCBpZCkge1xuICAgIHRoaXMuX25vZGUgPSBub2RlO1xuICAgIHRoaXMuX2lkID0gaWQ7XG4gICAgdGhpcy5fVUlFdmVudHMgPSBub2RlLmdldFVJRXZlbnRzKCkuc2xpY2UoMCk7XG4gICAgdGhpcy5kcmF3KCk7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2RhdGEtZmEtcGF0aCcsIG5vZGUuZ2V0TG9jYXRpb24oKSk7XG59O1xuXG4vKipcbiAqIE1ldGhvZCB0byBiZSBpbnZva2VkIGJ5IHRoZSBOb2RlIGFzIHNvb24gYXMgdGhlIG5vZGUgaXMgYmVpbmcgZGlzbW91bnRlZCBcbiAqIGVpdGhlciBkaXJlY3RseSBvciBieSBkaXNtb3VudGluZyBvbmUgb2YgaXRzIGFuY2VzdG9ycykuXG4gKlxuICogQG1ldGhvZCBvbkRpc21vdW50XG4gKi9cbkRPTUVsZW1lbnQucHJvdG90eXBlLm9uRGlzbW91bnQgPSBmdW5jdGlvbiBvbkRpc21vdW50ICgpIHtcbiAgICB0aGlzLnNldFByb3BlcnR5KCdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnZGF0YS1mYS1wYXRoJywgJycpO1xuICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIE1ldGhvZCB0byBiZSBpbnZva2VkIGJ5IHRoZSBub2RlIGFzIHNvb24gYXMgdGhlIERPTUVsZW1lbnQgaXMgYmVpbmcgc2hvd24uXG4gKiBUaGlzIHJlc3VsdHMgaW50byB0aGUgRE9NRWxlbWVudCBzZXR0aW5nIHRoZSBgZGlzcGxheWAgcHJvcGVydHkgdG8gYGJsb2NrYFxuICogYW5kIHRoZXJlZm9yZSB2aXN1YWxseSBzaG93aW5nIHRoZSBjb3JyZXNwb25kaW5nIERPTUVsZW1lbnQgKGFnYWluKS5cbiAqXG4gKiBAbWV0aG9kIG9uU2hvd1xuICovXG5ET01FbGVtZW50LnByb3RvdHlwZS5vblNob3cgPSBmdW5jdGlvbiBvblNob3cgKCkge1xuICAgIHRoaXMuc2V0UHJvcGVydHkoJ2Rpc3BsYXknLCAnYmxvY2snKTtcbn07XG5cbi8qKlxuICogTWV0aG9kIHRvIGJlIGludm9rZWQgYnkgdGhlIG5vZGUgYXMgc29vbiBhcyB0aGUgRE9NRWxlbWVudCBpcyBiZWluZyBoaWRkZW4uXG4gKiBUaGlzIHJlc3VsdHMgaW50byB0aGUgRE9NRWxlbWVudCBzZXR0aW5nIHRoZSBgZGlzcGxheWAgcHJvcGVydHkgdG8gYG5vbmVgXG4gKiBhbmQgdGhlcmVmb3JlIHZpc3VhbGx5IGhpZGluZyB0aGUgY29ycmVzcG9uZGluZyBET01FbGVtZW50IChhZ2FpbikuXG4gKlxuICogQG1ldGhvZCBvbkhpZGVcbiAqL1xuRE9NRWxlbWVudC5wcm90b3R5cGUub25IaWRlID0gZnVuY3Rpb24gb25IaWRlICgpIHtcbiAgICB0aGlzLnNldFByb3BlcnR5KCdkaXNwbGF5JywgJ25vbmUnKTtcbn07XG5cbi8qKlxuICogTWV0aG9kIHRvIGJlIGludm9rZWQgYnkgdGhlIG5vZGUgYXMgc29vbiBhcyB0aGUgdHJhbnNmb3JtIG1hdHJpeCBhc3NvY2lhdGVkXG4gKiB3aXRoIHRoZSBub2RlIGNoYW5nZXMuXG4gKiBUaGUgRE9NRWxlbWVudCB3aWxsIHJlYWN0IHRvIHRyYW5zZm9ybSBjaGFuZ2VzIGJ5IHNlbmRpbmcgYENIQU5HRV9UUkFOU0ZPUk1gXG4gKiBjb21tYW5kcyB0byB0aGUgYERPTVJlbmRlcmVyYC5cbiAqXG4gKiBAbWV0aG9kIG9uVHJhbnNmb3JtQ2hhbmdlXG4gKiBcbiAqIEBwYXJhbSAge0Zsb2F0MzJBcnJheX0gdHJhbnNmb3JtICAgICBUaGUgZmluYWwgdHJhbnNmb3JtIG1hdHJpeC5cbiAqL1xuRE9NRWxlbWVudC5wcm90b3R5cGUub25UcmFuc2Zvcm1DaGFuZ2UgPSBmdW5jdGlvbiBvblRyYW5zZm9ybUNoYW5nZSAodHJhbnNmb3JtKSB7XG4gICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaCgnQ0hBTkdFX1RSQU5TRk9STScpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0cmFuc2Zvcm0ubGVuZ3RoIDsgaSA8IGxlbiA7IGkrKylcbiAgICAgICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaCh0cmFuc2Zvcm1baV0pO1xuXG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG59O1xuXG4vKipcbiAqIE1ldGhvZCB0byBiZSBpbnZva2VkIGJ5IHRoZSBub2RlIGFzIHNvb24gYXMgaXRzIGNvbXB1dGVkIHNpemUgY2hhbmdlcy5cbiAqIFxuICogQG1ldGhvZCBvblNpemVDaGFuZ2VcbiAqIEBjaGFpbmFibGVcbiAqIFxuICogQHBhcmFtICB7RmxvYXQzMkFycmF5fSBzaXplICAgICAgQWJzb2x1dGUsIHBpeGVsIHNpemUuXG4gKiBAcmV0dXJuIHtET01FbGVtZW50fSB0aGlzXG4gKi9cbkRPTUVsZW1lbnQucHJvdG90eXBlLm9uU2l6ZUNoYW5nZSA9IGZ1bmN0aW9uIG9uU2l6ZUNoYW5nZSAoc2l6ZSkge1xuICAgIHZhciBzaXplTW9kZSA9IHRoaXMuX25vZGUuZ2V0U2l6ZU1vZGUoKTtcbiAgICB2YXIgc2l6ZWRYID0gc2l6ZU1vZGVbMF0gIT09IFJFTkRFUl9TSVpFO1xuICAgIHZhciBzaXplZFkgPSBzaXplTW9kZVsxXSAhPT0gUkVOREVSX1NJWkU7XG4gICAgaWYgKHRoaXMuX2luaXRpYWxpemVkKSBcbiAgICAgICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaCgnQ0hBTkdFX1NJWkUnLFxuICAgICAgICAgICAgc2l6ZWRYID8gc2l6ZVswXSA6IHNpemVkWCxcbiAgICAgICAgICAgIHNpemVkWSA/IHNpemVbMV0gOiBzaXplZFkpO1xuXG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE1ldGhvZCB0byBiZSBpbnZva2VkIGJ5IHRoZSBub2RlIGFzIHNvb24gYXMgaXRzIG9wYWNpdHkgY2hhbmdlcy5cbiAqIFxuICogQG1ldGhvZCBvbk9wYWNpdHlDaGFuZ2VcbiAqIEBjaGFpbmFibGVcbiAqIFxuICogQHBhcmFtICB7TnVtYmVyfSBvcGFjaXR5ICAgICAgVGhlIG5ldyBvcGFjaXR5LCBhcyBhIHNjYWxhciBmcm9tIDAgdG8gMS5cbiAqIEByZXR1cm4ge0RPTUVsZW1lbnR9IHRoaXNcbiAqL1xuRE9NRWxlbWVudC5wcm90b3R5cGUub25PcGFjaXR5Q2hhbmdlID0gZnVuY3Rpb24gb25PcGFjaXR5Q2hhbmdlIChvcGFjaXR5KSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0UHJvcGVydHkoJ29wYWNpdHknLCBvcGFjaXR5KTtcbn07XG5cbi8qKlxuICogTWV0aG9kIHRvIGJlIGludm9rZWQgYnkgdGhlIG5vZGUgYXMgc29vbiBhcyBhIG5ldyBVSUV2ZW50IGlzIGJlaW5nIGFkZGVkLlxuICogVGhpcyByZXN1bHRzIGludG8gYW4gYEFERF9FVkVOVF9MSVNURU5FUmAgY29tbWFuZCBiZWluZyBzZW5kLlxuICogXG4gKiBAcGFyYW0gIHtTdHJpbmd9IFVJRXZlbnQgICAgIFVJRXZlbnQgdG8gYmUgc3Vic2NyaWJlZCB0byAoZS5nLiBgY2xpY2tgKS5cbiAqL1xuRE9NRWxlbWVudC5wcm90b3R5cGUub25BZGRVSUV2ZW50ID0gZnVuY3Rpb24gb25BZGRVSUV2ZW50IChVSUV2ZW50KSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5fVUlFdmVudHMuaW5kZXhPZihVSUV2ZW50KTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2goJ0FERF9FVkVOVF9MSVNURU5FUicsIFVJRXZlbnQsIHZvaWQgMCwgdHJ1ZSwgJ0VWRU5UX0VORCcpO1xuICAgICAgICB0aGlzLl9VSUV2ZW50cy5wdXNoKFVJRXZlbnQpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHRoaXMuX3JlcXVlc3RVcGRhdGUoKTtcbn07XG5cbi8qKlxuICogTWV0aG9kIHRvIGJlIGludm9rZWQgYnkgdGhlIG5vZGUgYXMgc29vbiBhcyB0aGUgdW5kZXJseWluZyBzaXplIG1vZGVcbiAqIGNoYW5nZXMuIFRoaXMgcmVzdWx0cyBpbnRvIHRoZSBzaXplIGJlaW5nIGZldGNoZWQgZnJvbSB0aGUgbm9kZSBpblxuICogb3JkZXIgdG8gdXBkYXRlIHRoZSBhY3R1YWwsIHJlbmRlcmVkIHNpemUuXG4gKlxuICogQG1ldGhvZCBvblNpemVNb2RlQ2hhbmdlXG4gKi9cbkRPTUVsZW1lbnQucHJvdG90eXBlLm9uU2l6ZU1vZGVDaGFuZ2UgPSBmdW5jdGlvbiBvblNpemVNb2RlQ2hhbmdlICgpIHtcbiAgICB0aGlzLm9uU2l6ZUNoYW5nZSh0aGlzLl9ub2RlLmdldFNpemUoKSk7XG59OyBcblxuRE9NRWxlbWVudC5wcm90b3R5cGUuX3JlcXVlc3RVcGRhdGUgPSBmdW5jdGlvbiBfcmVxdWVzdFVwZGF0ZSAoKSB7XG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX25vZGUucmVxdWVzdFVwZGF0ZSh0aGlzLl9pZCk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSB0cnVlO1xuICAgIH1cbn07XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIERPTUVsZW1lbnQgYnkgc2VuZGluZyB0aGUgYElOSVRfRE9NYCBjb21tYW5kLiBUaGlzIGNyZWF0ZXNcbiAqIG9yIHJlYWxsb2NhdGVzIGEgbmV3IEVsZW1lbnQgaW4gdGhlIGFjdHVhbCBET00gaGllcmFyY2h5LlxuICpcbiAqIEBtZXRob2QgaW5pdFxuICovXG5ET01FbGVtZW50LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdCAoKSB7XG4gICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaCgnSU5JVF9ET00nLCB0aGlzLl90YWdOYW1lKTtcbiAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgdGhpcy5vblRyYW5zZm9ybUNoYW5nZSh0aGlzLl9ub2RlLmdldFRyYW5zZm9ybSgpKTtcbiAgICB0aGlzLm9uU2l6ZUNoYW5nZSh0aGlzLl9ub2RlLmdldFNpemUoKSk7XG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGlkIGF0dHJpYnV0ZSBvZiB0aGUgRE9NRWxlbWVudC5cbiAqXG4gKiBAbWV0aG9kIHNldElkXG4gKiBAY2hhaW5hYmxlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlkICAgTmV3IGlkIHRvIGJlIHNldC5cbiAqL1xuRE9NRWxlbWVudC5wcm90b3R5cGUuc2V0SWQgPSBmdW5jdGlvbiBzZXRJZCAoaWQpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnaWQnLCBpZCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBuZXcgY2xhc3MgdG8gdGhlIGludGVybmFsIGNsYXNzIGxpc3Qgb2YgdGhlIHVuZGVybHlpbmcgRWxlbWVudCBpbiB0aGVcbiAqIERPTS5cbiAqXG4gKiBAbWV0aG9kIGFkZENsYXNzXG4gKiBAY2hhaW5hYmxlXG4gKiBcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSAgICBOZXcgY2xhc3MgbmFtZSB0byBiZSBhZGRlZC5cbiAqIEByZXR1cm4ge0RPTUVsZW1lbnR9IHRoaXNcbiAqL1xuRE9NRWxlbWVudC5wcm90b3R5cGUuYWRkQ2xhc3MgPSBmdW5jdGlvbiBhZGRDbGFzcyAodmFsdWUpIHtcbiAgICBpZiAodGhpcy5fY2xhc3Nlcy5pbmRleE9mKHZhbHVlKSA8IDApIHtcbiAgICAgICAgaWYgKHRoaXMuX2luaXRpYWxpemVkKSB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKCdBRERfQ0xBU1MnLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuX2NsYXNzZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIGlmICghdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSkgdGhpcy5fcmVxdWVzdFVwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faW5EcmF3KSB7XG4gICAgICAgIGlmICh0aGlzLl9pbml0aWFsaXplZCkgdGhpcy5fY2hhbmdlUXVldWUucHVzaCgnQUREX0NMQVNTJywgdmFsdWUpO1xuICAgICAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHRoaXMuX3JlcXVlc3RVcGRhdGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSBjbGFzcyBmcm9tIHRoZSBET01FbGVtZW50J3MgY2xhc3NMaXN0LlxuICpcbiAqIEBtZXRob2QgcmVtb3ZlQ2xhc3NcbiAqIFxuICogQHBhcmFtICB7U3RyaW5nfSB2YWx1ZSAgICAgICBDbGFzcyBuYW1lIHRvIGJlIHJlbW92ZWQuXG4gKiBAcmV0dXJuIHtET01FbGVtZW50fSB0aGlzXG4gKi9cbkRPTUVsZW1lbnQucHJvdG90eXBlLnJlbW92ZUNsYXNzID0gZnVuY3Rpb24gcmVtb3ZlQ2xhc3MgKHZhbHVlKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5fY2xhc3Nlcy5pbmRleE9mKHZhbHVlKTtcblxuICAgIGlmIChpbmRleCA8IDApIHJldHVybiB0aGlzO1xuXG4gICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaCgnUkVNT1ZFX0NMQVNTJywgdmFsdWUpO1xuXG4gICAgdGhpcy5fY2xhc3Nlcy5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgYW4gYXR0cmlidXRlIG9mIHRoZSBET01FbGVtZW50LlxuICpcbiAqIEBtZXRob2Qgc2V0QXR0cmlidXRlXG4gKiBcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lICAgICBBdHRyaWJ1dGUga2V5IChlLmcuIGBzcmNgKVxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlICAgIEF0dHJpYnV0ZSB2YWx1ZSAoZS5nLiBgaHR0cDovL2ZhbW8udXNgKVxuICovXG5ET01FbGVtZW50LnByb3RvdHlwZS5zZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiBzZXRBdHRyaWJ1dGUgKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX2F0dHJpYnV0ZXNbbmFtZV0gIT09IHZhbHVlIHx8IHRoaXMuX2luRHJhdykge1xuICAgICAgICB0aGlzLl9hdHRyaWJ1dGVzW25hbWVdID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLl9pbml0aWFsaXplZCkgdGhpcy5fY2hhbmdlUXVldWUucHVzaCgnQ0hBTkdFX0FUVFJJQlVURScsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgaWYgKCF0aGlzLl9yZXF1ZXN0VXBkYXRlKSB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIGEgQ1NTIHByb3BlcnR5LlxuICpcbiAqIEBtZXRob2Qgc2V0UHJvcGVydHlcbiAqIEBjaGFpbmFibGVcbiAqIFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgIE5hbWUgb2YgdGhlIENTUyBydWxlIChlLmcuIGBiYWNrZ3JvdW5kLWNvbG9yYCkuXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVmFsdWUgb2YgQ1NTIHByb3BlcnR5IChlLmcuIGByZWRgKS5cbiAqIEByZXR1cm4ge0RPTUVsZW1lbnR9IHRoaXNcbiAqL1xuRE9NRWxlbWVudC5wcm90b3R5cGUuc2V0UHJvcGVydHkgPSBmdW5jdGlvbiBzZXRQcm9wZXJ0eSAobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy5fc3R5bGVzW25hbWVdICE9PSB2YWx1ZSB8fCB0aGlzLl9pbkRyYXcpIHtcbiAgICAgICAgdGhpcy5fc3R5bGVzW25hbWVdID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLl9pbml0aWFsaXplZCkgdGhpcy5fY2hhbmdlUXVldWUucHVzaCgnQ0hBTkdFX1BST1BFUlRZJywgbmFtZSwgdmFsdWUpO1xuICAgICAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHRoaXMuX3JlcXVlc3RVcGRhdGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGNvbnRlbnQgb2YgdGhlIERPTUVsZW1lbnQuIFRoaXMgaXMgdXNpbmcgYGlubmVySFRNTGAsIGVzY2FwaW5nIHVzZXJcbiAqIGdlbmVyYXRlZCBjb250ZW50IGlzIHRoZXJlZm9yZSBlc3NlbnRpYWwgZm9yIHNlY3VyaXR5IHB1cnBvc2VzLlxuICpcbiAqIEBtZXRob2Qgc2V0Q29udGVudFxuICogXG4gKiBAcGFyYW0ge1N0cmluZ30gY29udGVudCAgICAgQ29udGVudCB0byBiZSBzZXQgdXNpbmcgYC5pbm5lckhUTUwgPSAuLi5gXG4gKi9cbkRPTUVsZW1lbnQucHJvdG90eXBlLnNldENvbnRlbnQgPSBmdW5jdGlvbiBzZXRDb250ZW50IChjb250ZW50KSB7XG4gICAgaWYgKHRoaXMuX2NvbnRlbnQgIT09IGNvbnRlbnQgfHwgdGhpcy5faW5EcmF3KSB7XG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2goJ0NIQU5HRV9DT05URU5UJywgY29udGVudCk7XG4gICAgICAgIGlmICghdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSkgdGhpcy5fcmVxdWVzdFVwZGF0ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3Vic2NyaWJlcyB0byBhIERPTUVsZW1lbnQgdXNpbmcuXG4gKlxuICogQG1ldGhvZCBvblxuICogXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGV2ZW50ICAgICAgIFRoZSBldmVudCB0eXBlIChlLmcuIGBjbGlja2ApLlxuICogQHBhcmFtICB7RnVuY3Rpb259IGxpc3RlbmVyICBIYW5kbGVyIGZ1bmN0aW9uIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50IHR5cGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gd2hpY2ggdGhlIHBheWxvYWQgZXZlbnQgb2JqZWN0IHdpbGwgYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFzc2VkIGludG8uXG4gKi9cbkRPTUVsZW1lbnQucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24gKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIHJldHVybiB0aGlzLl9jYWxsYmFja3Mub24oZXZlbnQsIGxpc3RlbmVyKTtcbn07XG5cbi8qKlxuICogRnVuY3Rpb24gdG8gYmUgaW52b2tlZCBieSB0aGUgTm9kZSB3aGVuZXZlciBhbiBVSUV2ZW50IGlzIGJlaW5nIHJlY2VpdmVkLlxuICogVGhlcmUgYXJlIHR3byBkaWZmZXJlbnQgd2F5cyB0byBzdWJzY3JpYmUgZm9yIHRob3NlIGV2ZW50czpcbiAqXG4gKiAxLiBCeSBvdmVycmlkaW5nIHRoZSBvblJlY2VpdmUgbWV0aG9kIChhbmQgcG9zc2libHkgdXNpbmcgYHN3aXRjaGAgaW4gb3JkZXJcbiAqICAgICB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW4gdGhlIGRpZmZlcmVudCBldmVudCB0eXBlcykuXG4gKiAyLiBCeSB1c2luZyBAe0BsaW5rIERPTUVsZW1lbnQjb259IGFuZCB1c2luZyB0aGUgYnVpbHQtaW5cbiAqICAgICBAe0BsaW5rQ2FsbGJhY2tTdG9yZX0uXG4gKlxuICogQG1ldGhvZCBvblJlY2VpdmVcbiAqIFxuICogQHBhcmFtICB7U3RyaW5nfSBldmVudCAgIEV2ZW50IHR5cGUgKGUuZy4gYGNsaWNrYCkuXG4gKiBAcGFyYW0gIHtPYmplY3R9IHBheWxvYWQgRXZlbnQgb2JqZWN0LlxuICovXG5ET01FbGVtZW50LnByb3RvdHlwZS5vblJlY2VpdmUgPSBmdW5jdGlvbiBvblJlY2VpdmUgKGV2ZW50LCBwYXlsb2FkKSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzLnRyaWdnZXIoZXZlbnQsIHBheWxvYWQpO1xufTtcblxuLyoqXG4gKiBUaGUgZHJhdyBmdW5jdGlvbiBpcyBiZWluZyB1c2VkIGluIG9yZGVyIHRvIGFsbG93IG11dGF0aW5nIHRoZSBET01FbGVtZW50XG4gKiBiZWZvcmUgYWN0dWFsbHkgbW91bnRpbmcgdGhlIGNvcnJlc3BvbmRpbmcgbm9kZS5cbiAqXG4gKiBAbWV0aG9kIGRyYXdcbiAqIEBwcml2YXRlXG4gKi9cbkRPTUVsZW1lbnQucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiBkcmF3ICgpIHtcbiAgICB2YXIga2V5O1xuICAgIHZhciBpO1xuICAgIHZhciBsZW47XG5cbiAgICB0aGlzLl9pbkRyYXcgPSB0cnVlO1xuXG4gICAgdGhpcy5pbml0KCk7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9jbGFzc2VzLmxlbmd0aCA7IGkgPCBsZW4gOyBpKyspXG4gICAgICAgIHRoaXMuYWRkQ2xhc3ModGhpcy5fY2xhc3Nlc1tpXSk7XG5cbiAgICB0aGlzLnNldENvbnRlbnQodGhpcy5fY29udGVudCk7XG5cbiAgICBmb3IgKGtleSBpbiB0aGlzLl9zdHlsZXMpIFxuICAgICAgICBpZiAodGhpcy5fc3R5bGVzW2tleV0pXG4gICAgICAgICAgICB0aGlzLnNldFByb3BlcnR5KGtleSwgdGhpcy5fc3R5bGVzW2tleV0pO1xuXG4gICAgZm9yIChrZXkgaW4gdGhpcy5fYXR0cmlidXRlcylcbiAgICAgICAgaWYgKHRoaXMuX2F0dHJpYnV0ZXNba2V5XSlcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGtleSwgdGhpcy5fYXR0cmlidXRlc1trZXldKTtcbiAgICBcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9VSUV2ZW50cy5sZW5ndGggOyBpIDwgbGVuIDsgaSsrKVxuICAgICAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKCdBRERfRVZFTlRfTElTVEVORVInLCB0aGlzLl9VSUV2ZW50c1tpXSwgdm9pZCAwLCB0cnVlLCAnRVZFTlRfRU5EJyk7XG5cbiAgICB0aGlzLl9pbkRyYXcgPSBmYWxzZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRE9NRWxlbWVudDtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NRWxlbWVudCA9IHJlcXVpcmUoJy4vRE9NRWxlbWVudCcpO1xudmFyIENhbGxiYWNrU3RvcmUgPSByZXF1aXJlKCdmYW1vdXMtdXRpbGl0aWVzJykuQ2FsbGJhY2tTdG9yZTtcblxudmFyIFdJVEggPSAnV0lUSCc7XG52YXIgQ0hBTkdFX1RSQU5TRk9STSA9ICdDSEFOR0VfVFJBTlNGT1JNJztcbnZhciBDSEFOR0VfUFJPUEVSVFkgPSAnQ0hBTkdFX1BST1BFUlRZJztcbnZhciBJTklUX0RPTSA9ICdJTklUX0RPTSc7XG52YXIgQ0hBTkdFX0FUVFJJQlVURSA9ICdDSEFOR0VfQVRUUklCVVRFJztcbnZhciBBRERfQ0xBU1MgPSAnQUREX0NMQVNTJztcbnZhciBSRU1PVkVfQ0xBU1MgPSAnUkVNT1ZFX0NMQVNTJztcbnZhciBDSEFOR0VfQVRUUklCVVRFID0gJ0NIQU5HRV9BVFRSSUJVVEUnO1xudmFyIENIQU5HRV9DT05URU5UID0gJ0NIQU5HRV9DT05URU5UJztcbnZhciBBRERfRVZFTlRfTElTVEVORVIgPSAnQUREX0VWRU5UX0xJU1RFTkVSJztcbnZhciBFVkVOVF9QUk9QRVJUSUVTID0gJ0VWRU5UX1BST1BFUlRJRVMnO1xudmFyIEVWRU5UX0VORCA9ICdFVkVOVF9FTkQnO1xudmFyIFJFQ0FMTCA9ICdSRUNBTEwnO1xuXG4vKipcbiAqIFRoZSBFbGVtZW50IGNsYXNzIGlzIHJlc3BvbnNpYmxlIGZvciBwcm92aWRpbmcgdGhlIEFQSSBmb3IgaG93XG4gKiAgIGEgUmVuZGVyTm9kZSB3aWxsIGludGVyYWN0IHdpdGggdGhlIERPTSBBUEkncy4gIFRoZSBlbGVtZW50IGlzXG4gKiAgIHJlc3BvbnNpYmxlIGZvciBhZGRpbmcgYSBzZXQgb2YgY29tbWFuZHMgdG8gdGhlIHJlbmRlcmVyLlxuICpcbiAqIEBjbGFzcyBIVE1MRWxlbWVudFxuICogQGNvbnN0cnVjdG9yXG4gKiBAY29tcG9uZW50XG4gKiBAcGFyYW0ge1JlbmRlck5vZGV9IFJlbmRlck5vZGUgdG8gd2hpY2ggdGhlIGluc3RhbmNlIG9mIEVsZW1lbnQgd2lsbCBiZSBhIGNvbXBvbmVudCBvZlxuICovXG5mdW5jdGlvbiBIVE1MRWxlbWVudChub2RlLCB0YWdOYW1lKSB7XG4gICAgY29uc29sZS53YXJuKFwiSFRNTEVsZW1lbnQgd2FzIGRlcHJpY2F0ZWRcXG4gdXNlIERPTUVsZW1lbnRcIik7XG4gICAgcmV0dXJuIG5ldyBET01FbGVtZW50KG5vZGUsIHRhZ05hbWUpO1xufSBcblxubW9kdWxlLmV4cG9ydHMgPSBIVE1MRWxlbWVudDtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgSFRNTEVsZW1lbnQ6IHJlcXVpcmUoJy4vSFRNTEVsZW1lbnQnKSxcbiAgICBET01FbGVtZW50OiByZXF1aXJlKCcuL0RPTUVsZW1lbnQnKVxufTtcbiIsIi8vIGh0dHA6Ly9wYXVsaXJpc2guY29tLzIwMTEvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1hbmltYXRpbmcvXG4vLyBodHRwOi8vbXkub3BlcmEuY29tL2Vtb2xsZXIvYmxvZy8yMDExLzEyLzIwL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtZXItYW5pbWF0aW5nXG4gXG4vLyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgcG9seWZpbGwgYnkgRXJpayBNw7ZsbGVyLiBmaXhlcyBmcm9tIFBhdWwgSXJpc2ggYW5kIFRpbm8gWmlqZGVsXG4gXG4vLyBNSVQgbGljZW5zZVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBsYXN0VGltZSA9IDA7XG52YXIgdmVuZG9ycyA9IFsnbXMnLCAnbW96JywgJ3dlYmtpdCcsICdvJ107XG5cbnZhciByQUYsIGNBRjtcblxuaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSB7XG4gICAgckFGID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTtcbiAgICBjQUYgPSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93LmNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZTtcbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHZlbmRvcnMubGVuZ3RoICYmICFyQUY7ICsreCkge1xuICAgICAgICByQUYgPSB3aW5kb3dbdmVuZG9yc1t4XSArICdSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcbiAgICAgICAgY0FGID0gd2luZG93W3ZlbmRvcnNbeF0gKyAnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ11cbiAgICAgICAgICAgIHx8IHdpbmRvd1t2ZW5kb3JzW3hdICsgJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJ107XG4gICAgfVxuXG4gICAgaWYgKHJBRiAmJiAhY0FGKSB7XG4gICAgICAgIC8vIGNBRiBub3Qgc3VwcG9ydGVkLlxuICAgICAgICAvLyBGYWxsIGJhY2sgdG8gc2V0SW50ZXJ2YWwgZm9yIG5vdyAodmVyeSByYXJlKS5cbiAgICAgICAgckFGID0gbnVsbDtcbiAgICB9XG59XG5cbnZhciBub3cgPSBEYXRlLm5vdyA/IERhdGUubm93IDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbn07XG5cbmlmICghckFGKSB7XG4gICAgckFGID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGN1cnJUaW1lID0gbm93KCk7XG4gICAgICAgIHZhciB0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAoY3VyclRpbWUgLSBsYXN0VGltZSkpO1xuICAgICAgICB2YXIgaWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGN1cnJUaW1lICsgdGltZVRvQ2FsbCk7XG4gICAgICAgIH0sIHRpbWVUb0NhbGwpO1xuICAgICAgICBsYXN0VGltZSA9IGN1cnJUaW1lICsgdGltZVRvQ2FsbDtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH07XG5cbiAgICBjQUYgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcbiAgICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWU6IHJBRixcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZTogY0FGXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWU6IHJlcXVpcmUoJy4vYW5pbWF0aW9uRnJhbWUnKS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUsXG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWU6IHJlcXVpcmUoJy4vYW5pbWF0aW9uRnJhbWUnKS5jYW5jZWxBbmltYXRpb25GcmFtZVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHBvbHlmaWxscyA9IHJlcXVpcmUoJ2ZhbW91cy1wb2x5ZmlsbHMnKTtcbnZhciByQUYgPSBwb2x5ZmlsbHMucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xudmFyIGNBRiA9IHBvbHlmaWxscy5jYW5jZWxBbmltYXRpb25GcmFtZTtcblxudmFyIF9ub3c7XG5pZiAodHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJykge1xuICAgIF9ub3cgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIH07XG59XG5lbHNlIHtcbiAgICBfbm93ID0gRGF0ZS5ub3c7XG59XG5cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIFZFTkRPUl9ISURERU4sIFZFTkRPUl9WSVNJQklMSVRZX0NIQU5HRTtcblxuICAgIC8vIE9wZXJhIDEyLjEwIGFuZCBGaXJlZm94IDE4IGFuZCBsYXRlciBzdXBwb3J0XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudC5oaWRkZW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIFZFTkRPUl9ISURERU4gPSAnaGlkZGVuJztcbiAgICAgICAgVkVORE9SX1ZJU0lCSUxJVFlfQ0hBTkdFID0gJ3Zpc2liaWxpdHljaGFuZ2UnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQubW96SGlkZGVuICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBWRU5ET1JfSElEREVOID0gJ21vekhpZGRlbic7XG4gICAgICAgIFZFTkRPUl9WSVNJQklMSVRZX0NIQU5HRSA9ICdtb3p2aXNpYmlsaXR5Y2hhbmdlJztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50Lm1zSGlkZGVuICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBWRU5ET1JfSElEREVOID0gJ21zSGlkZGVuJztcbiAgICAgICAgVkVORE9SX1ZJU0lCSUxJVFlfQ0hBTkdFID0gJ21zdmlzaWJpbGl0eWNoYW5nZSc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudC53ZWJraXRIaWRkZW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIFZFTkRPUl9ISURERU4gPSAnd2Via2l0SGlkZGVuJztcbiAgICAgICAgVkVORE9SX1ZJU0lCSUxJVFlfQ0hBTkdFID0gJ3dlYmtpdHZpc2liaWxpdHljaGFuZ2UnO1xuICAgIH1cbn1cblxuLyoqXG4gKiBFbmdpbmUgY2xhc3MgdXNlZCBmb3IgdXBkYXRpbmcgb2JqZWN0cyBvbiBhIGZyYW1lLWJ5LWZyYW1lLiBTeW5jaHJvbml6ZXMgdGhlXG4gKiBgdXBkYXRlYCBtZXRob2QgaW52b2NhdGlvbnMgdG8gdGhlIHJlZnJlc2ggcmF0ZSBvZiB0aGUgc2NyZWVuLiBNYW5hZ2VzXG4gKiB0aGUgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAtbG9vcCBieSBub3JtYWxpemluZyB0aGUgcGFzc2VkIGluIHRpbWVzdGFtcFxuICogd2hlbiBzd2l0Y2hpbmcgdGFicy5cbiAqIFxuICogQGNsYXNzIEVuZ2luZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEVuZ2luZSgpIHtcbiAgICB0aGlzLl91cGRhdGVzID0gW107XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLl9sb29wZXIgPSBmdW5jdGlvbih0aW1lKSB7XG4gICAgICAgIF90aGlzLmxvb3AodGltZSk7XG4gICAgfTtcbiAgICB0aGlzLl9zdG9wcGVkQXQgPSBfbm93KCk7XG4gICAgdGhpcy5fc2xlZXAgPSAwO1xuICAgIHRoaXMuX3N0YXJ0T25WaXNpYmlsaXR5Q2hhbmdlID0gdHJ1ZTtcbiAgICB0aGlzLl9yQUYgPSBudWxsO1xuICAgIHRoaXMuc3RhcnQoKTtcblxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoVkVORE9SX1ZJU0lCSUxJVFlfQ0hBTkdFLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChkb2N1bWVudFtWRU5ET1JfSElEREVOXSkge1xuICAgICAgICAgICAgICAgIGNBRih0aGlzLl9yQUYpO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydE9uVmlzaWJpbGl0eUNoYW5nZSA9IF90aGlzLl9zdGFydE9uVmlzaWJpbGl0eUNoYW5nZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zdG9wKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3N0YXJ0T25WaXNpYmlsaXR5Q2hhbmdlID0gc3RhcnRPblZpc2liaWxpdHlDaGFuZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX3N0YXJ0T25WaXNpYmlsaXR5Q2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogU3RhcnRzIHRoZSBFbmdpbmUuXG4gKlxuICogQG1ldGhvZCBzdGFydFxuICogQGNoYWluYWJsZVxuICogXG4gKiBAcmV0dXJuIHtFbmdpbmV9IHRoaXNcbiAqL1xuRW5naW5lLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgIGlmICghdGhpcy5fcnVubmluZykge1xuICAgICAgICB0aGlzLl9zdGFydE9uVmlzaWJpbGl0eUNoYW5nZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLl9zbGVlcCArPSBfbm93KCkgLSB0aGlzLl9zdG9wcGVkQXQ7XG4gICAgICAgIHRoaXMuX3JBRiA9IHJBRih0aGlzLl9sb29wZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3RvcHMgdGhlIEVuZ2luZS5cbiAqXG4gKiBAbWV0aG9kIHN0b3BcbiAqIEBjaGFpbmFibGVcbiAqIFxuICogQHJldHVybiB7RW5naW5lfSB0aGlzXG4gKi9cbkVuZ2luZS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgaWYgKHRoaXMuX3J1bm5pbmcpIHtcbiAgICAgICAgdGhpcy5fc3RhcnRPblZpc2liaWxpdHlDaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zdG9wcGVkQXQgPSBfbm93KCk7XG4gICAgICAgIGNBRih0aGlzLl9yQUYpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBFbmdpbmUgaXMgY3VycmVudGx5IHJ1bm5pbmcgb3Igbm90LlxuICpcbiAqIEBtZXRob2QgaXNSdW5uaW5nXG4gKiBcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBFbmdpbmUgaXNcbiAqICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseSBydW5uaW5nIG9yIG5vdFxuICovXG5FbmdpbmUucHJvdG90eXBlLmlzUnVubmluZyA9IGZ1bmN0aW9uIGlzUnVubmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fcnVubmluZztcbn07XG5cbi8qKlxuICogVXBkYXRlcyBhbGwgcmVnaXN0ZXJlZCBvYmplY3RzLlxuICpcbiAqIEBtZXRob2Qgc3RlcFxuICogQGNoYWluYWJsZVxuICogXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHRpbWUgaGlnaCByZXNvbHV0aW9uIHRpbXN0YW1wIHVzZWQgZm9yIGludm9raW5nIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgIGB1cGRhdGVgIG1ldGhvZCBvbiBhbGwgcmVnaXN0ZXJlZCBvYmplY3RzXG4gKiBAcmV0dXJuIHtFbmdpbmV9ICAgICAgdGhpc1xuICovXG5FbmdpbmUucHJvdG90eXBlLnN0ZXAgPSBmdW5jdGlvbiBzdGVwICh0aW1lKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3VwZGF0ZXMubGVuZ3RoIDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICB0aGlzLl91cGRhdGVzW2ldLnVwZGF0ZSh0aW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE1ldGhvZCBiZWluZyBjYWxsZWQgYnkgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgb24gZXZlcnkgcGFpbnQuIEluZGlyZWN0bHlcbiAqIHJlY3Vyc2l2ZSBieSBzY2hlZHVsaW5nIGEgZnV0dXJlIGludm9jYXRpb24gb2YgaXRzZWxmIG9uIHRoZSBuZXh0IHBhaW50LlxuICpcbiAqIEBtZXRob2QgbG9vcFxuICogQGNoYWluYWJsZVxuICogXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHRpbWUgaGlnaCByZXNvbHV0aW9uIHRpbXN0YW1wIHVzZWQgZm9yIGludm9raW5nIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgIGB1cGRhdGVgIG1ldGhvZCBvbiBhbGwgcmVnaXN0ZXJlZCBvYmplY3RzXG4gKiBAcmV0dXJuIHtFbmdpbmV9ICAgICAgdGhpc1xuICovXG5FbmdpbmUucHJvdG90eXBlLmxvb3AgPSBmdW5jdGlvbiBsb29wKHRpbWUpIHtcbiAgICB0aGlzLnN0ZXAodGltZSAtIHRoaXMuX3NsZWVwKTtcbiAgICB0aGlzLl9yQUYgPSByQUYodGhpcy5fbG9vcGVyKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVnaXN0ZXJlcyBhbiB1cGRhdGVhYmxlIG9iamVjdCB3aGljaCBgdXBkYXRlYCBtZXRob2Qgc2hvdWxkIGJlIGludm9rZWQgb25cbiAqIGV2ZXJ5IHBhaW50LCBzdGFydGluZyBvbiB0aGUgbmV4dCBwYWludCAoYXNzdW1pbmcgdGhlIEVuZ2luZSBpcyBydW5uaW5nKS5cbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICogQGNoYWluYWJsZVxuICogXG4gKiBAcGFyYW0gIHtPYmplY3R9IHVwZGF0ZWFibGUgICAgICAgICAgb2JqZWN0IHRvIGJlIHVwZGF0ZWRcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSB1cGRhdGVhYmxlLnVwZGF0ZSB1cGRhdGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyZWQgb2JqZWN0XG4gKiBAcmV0dXJuIHtFbmdpbmV9ICAgICAgICAgICAgICAgICAgICAgdGhpc1xuICovXG5FbmdpbmUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSh1cGRhdGVhYmxlKSB7XG4gICAgaWYgKHRoaXMuX3VwZGF0ZXMuaW5kZXhPZih1cGRhdGVhYmxlKSA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlcy5wdXNoKHVwZGF0ZWFibGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRGVyZWdpc3RlcnMgYW4gdXBkYXRlYWJsZSBvYmplY3QgcHJldmlvdXNseSByZWdpc3RlcmVkIHVzaW5nIGB1cGRhdGVgIHRvIGJlXG4gKiBubyBsb25nZXIgdXBkYXRlZC5cbiAqXG4gKiBAbWV0aG9kIG5vTG9uZ2VyVXBkYXRlXG4gKiBAY2hhaW5hYmxlXG4gKiBcbiAqIEBwYXJhbSAge09iamVjdH0gdXBkYXRlYWJsZSAgICAgICAgICB1cGRhdGVhYmxlIG9iamVjdCBwcmV2aW91c2x5XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXJlZCB1c2luZyBgdXBkYXRlYFxuICogQHJldHVybiB7RW5naW5lfSAgICAgICAgICAgICAgICAgICAgIHRoaXNcbiAqL1xuRW5naW5lLnByb3RvdHlwZS5ub0xvbmdlclVwZGF0ZSA9IGZ1bmN0aW9uIG5vTG9uZ2VyVXBkYXRlKHVwZGF0ZWFibGUpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLl91cGRhdGVzLmluZGV4T2YodXBkYXRlYWJsZSk7XG4gICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRW5naW5lO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVmVjMyA9IHJlcXVpcmUoJ2ZhbW91cy1tYXRoJykuVmVjMztcbnZhciBNYXQzMyA9IHJlcXVpcmUoJ2ZhbW91cy1tYXRoJykuTWF0MzM7XG5cbnZhciBPYmplY3RNYW5hZ2VyID0gcmVxdWlyZSgnZmFtb3VzLXV0aWxpdGllcycpLk9iamVjdE1hbmFnZXI7XG5PYmplY3RNYW5hZ2VyLnJlZ2lzdGVyKCdEeW5hbWljR2VvbWV0cnknLCBEeW5hbWljR2VvbWV0cnkpO1xuT2JqZWN0TWFuYWdlci5yZWdpc3RlcignRHluYW1pY0dlb21ldHJ5RmVhdHVyZScsIER5bmFtaWNHZW9tZXRyeUZlYXR1cmUpO1xudmFyIE9NUmVxdWVzdER5bmFtaWNHZW9tZXRyeUZlYXR1cmUgPSBPYmplY3RNYW5hZ2VyLnJlcXVlc3REeW5hbWljR2VvbWV0cnlGZWF0dXJlO1xudmFyIE9NRnJlZUR5bmFtaWNHZW9tZXRyeUZlYXR1cmUgPSBPYmplY3RNYW5hZ2VyLmZyZWVEeW5hbWljR2VvbWV0cnlGZWF0dXJlO1xuXG52YXIgVFJJUExFX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBUaGUgc28gY2FsbGVkIHRyaXBsZSBwcm9kdWN0LiBVc2VkIHRvIGZpbmQgYSB2ZWN0b3IgcGVycGVuZGljdWxhciB0byAodjIgLSB2MSkgaW4gdGhlIGRpcmVjdGlvbiBvZiB2My5cbiAqICh2MSB4IHYyKSB4IHYzLlxuICpcbiAqIEBtZXRob2QgdHJpcGxlUHJvZHVjdFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7VmVjM30gdjEgVGhlIGZpcnN0IFZlYzMuXG4gKiBAcGFyYW0ge1ZlYzN9IHYyIFRoZSBzZWNvbmQgVmVjMy5cbiAqIEBwYXJhbSB7VmVjM30gdjMgVGhlIHRoaXJkIFZlYzMuXG4gKiBAcmV0dXJuIHtWZWMzfSBUaGUgcmVzdWx0IG9mIHRoZSB0cmlwbGUgcHJvZHVjdC5cbiAqL1xuZnVuY3Rpb24gdHJpcGxlUHJvZHVjdCh2MSwgdjIsIHYzKSB7XG4gICAgdmFyIHYgPSBUUklQTEVfUkVHSVNURVI7XG5cbiAgICBWZWMzLmNyb3NzKHYxLCB2Miwgdik7XG4gICAgVmVjMy5jcm9zcyh2LCB2Mywgdik7XG5cbiAgICByZXR1cm4gdjtcbn1cblxuLyoqXG4gKiBPZiBhIHNldCBvZiB2ZXJ0aWNlcywgcmV0cmlldmVzIHRoZSB2ZXJ0ZXggZnVydGhlc3QgaW4gdGhlIGdpdmVuIGRpcmVjdGlvbi5cbiAqXG4gKiBAbWV0aG9kIF9odWxsU3VwcG9ydFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7VmVjM1tdfSB2ZXJ0aWNlcyBUaGUgcmVmZXJlbmNlIHNldCBvZiBWZWMzJ3MuXG4gKiBAcGFyYW0ge1ZlYzN9IGRpcmVjdGlvbiBUaGUgZGlyZWN0aW9uIHRvIGNvbXBhcmUgYWdhaW5zdC5cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHZlcnRleCBhbmQgaXRzIGluZGV4IGluIHRoZSB2ZXJ0ZXggYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIF9odWxsU3VwcG9ydCh2ZXJ0aWNlcywgZGlyZWN0aW9uKSB7XG4gICAgdmFyIGZ1cnRoZXN0O1xuICAgIHZhciBtYXggPSAtSW5maW5pdHk7XG4gICAgdmFyIGRvdDtcbiAgICB2YXIgdmVydGV4O1xuICAgIHZhciBpbmRleDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZlcnRleCA9IHZlcnRpY2VzW2ldO1xuICAgICAgICBkb3QgPSBWZWMzLmRvdCh2ZXJ0ZXgsIGRpcmVjdGlvbik7XG4gICAgICAgIGlmIChkb3QgPiBtYXgpIHtcbiAgICAgICAgICAgIGZ1cnRoZXN0ID0gdmVydGV4O1xuICAgICAgICAgICAgbWF4ID0gZG90O1xuICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmVydGV4OiBmdXJ0aGVzdCxcbiAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgfTtcbn1cblxudmFyIFZFQ19SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgUE9JTlRDSEVDS19SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgQU9fUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIEFCX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcbnZhciBBQ19SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgQURfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIEJDX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcbnZhciBCRF9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogVXNlZCBpbnRlcm5hbGx5IHRvIHJlcHJlc2VudCBwb2x5aGVkcmFsIGZhY2V0IGluZm9ybWF0aW9uLlxuICpcbiAqIEBjbGFzcyBEeW5hbWljR2VvbWV0cnlGZWF0dXJlXG4gKiBAcGFyYW0ge051bWJlcn0gZGlzdGFuY2UgVGhlIGRpc3RhbmNlIG9mIHRoZSBmZWF0dXJlIGZyb20gdGhlIG9yaWdpbi5cbiAqIEBwYXJhbSB7VmVjM30gbm9ybWFsIFRoZSBWZWMzIG9ydGhvZ29uYWwgdG8gdGhlIGZlYXR1cmUsIHBvaW50aW5nIG91dCBvZiB0aGUgZ2VvbWV0cnkuXG4gKiBAcGFyYW0ge051bWJlcltdfSB2ZXJ0ZXhJbmRpY2VzIFRoZSBpbmRpY2VzIG9mIHRoZSB2ZXJ0aWNlcyB3aGljaCBjb21wb3NlIHRoZSBmZWF0dXJlLlxuICovXG5mdW5jdGlvbiBEeW5hbWljR2VvbWV0cnlGZWF0dXJlKGRpc3RhbmNlLCBub3JtYWwsIHZlcnRleEluZGljZXMpIHtcbiAgICB0aGlzLmRpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgdGhpcy5ub3JtYWwgPSBub3JtYWw7XG4gICAgdGhpcy52ZXJ0ZXhJbmRpY2VzID0gdmVydGV4SW5kaWNlcztcbn1cblxuLyoqXG4gKiBVc2VkIGJ5IE9iamVjdE1hbmFnZXIgdG8gcmVzZXQgb2JqZWN0cy5cbiAqXG4gKiBAbWV0aG9kIHJlc2V0XG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIEFyZ3VtZW50IGFycmF5IGFuYWxvZ291cyB0byB0aGF0IHVzZWQgaW4gaW5zdGFudGlhdGlvbi5cbiAqIEBjaGFpbmFibGVcbiAqL1xuRHluYW1pY0dlb21ldHJ5RmVhdHVyZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbihkaXN0YW5jZSwgbm9ybWFsLCB2ZXJ0ZXhJbmRpY2VzKSB7XG4gICAgdGhpcy5kaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgIHRoaXMubm9ybWFsID0gbm9ybWFsO1xuICAgIHRoaXMudmVydGV4SW5kaWNlcyA9IHZlcnRleEluZGljZXM7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWJzdHJhY3Qgb2JqZWN0IHJlcHJlc2VudGluZyBhIGdyb3dpbmcgcG9seWhlZHJvbi4gVXNlZCBpbiBDb252ZXhIdWxsIGFuZCBpbiBHSksrRVBBIGNvbGxpc2lvbiBkZXRlY3Rpb24uXG4gKlxuICogQGNsYXNzIER5bmFtaWNHZW9tZXRyeVxuICovXG5mdW5jdGlvbiBEeW5hbWljR2VvbWV0cnkoKSB7XG4gICAgdGhpcy52ZXJ0aWNlcyA9IFtdO1xuICAgIHRoaXMubnVtVmVydGljZXMgPSAwO1xuICAgIHRoaXMuZmVhdHVyZXMgPSBbXTtcbiAgICB0aGlzLm51bUZlYXR1cmVzID0gMDtcbiAgICB0aGlzLmxhc3RWZXJ0ZXhJbmRleCA9IDA7XG5cbiAgICB0aGlzLl9JRFBvb2wgPSB7XG4gICAgICAgIHZlcnRpY2VzOiBbXSxcbiAgICAgICAgZmVhdHVyZXM6IFtdXG4gICAgfTtcbn1cblxuLyoqXG4gKiBVc2VkIGJ5IE9iamVjdE1hbmFnZXIgdG8gcmVzZXQgb2JqZWN0cy5cbiAqXG4gKiBAbWV0aG9kIHJlc2V0XG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIEFyZ3VtZW50IGFycmF5IGFuYWxvZ291cyB0byB0aGF0IHVzZWQgaW4gaW5zdGFudGlhdGlvbi5cbiAqIEBjaGFpbmFibGVcbiAqL1xuRHluYW1pY0dlb21ldHJ5LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHRoaXMudmVydGljZXMgPSBbXTtcbiAgICB0aGlzLm51bVZlcnRpY2VzID0gMDtcbiAgICB0aGlzLmZlYXR1cmVzID0gW107XG4gICAgdGhpcy5udW1GZWF0dXJlcyA9IDA7XG4gICAgdGhpcy5sYXN0VmVydGV4SW5kZXggPSAwO1xuXG4gICAgdGhpcy5fSURQb29sID0ge1xuICAgICAgICB2ZXJ0aWNlczogW10sXG4gICAgICAgIGZlYXR1cmVzOiBbXVxuICAgIH07XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkIGEgdmVydGV4IHRvIHRoZSBwb2x5aGVkcm9uLlxuICpcbiAqIEBtZXRob2QgYWRkVmVydGV4XG4gKiBAcGFyYW0ge09iamVjdH0gdmVydGV4T2JqIE9iamVjdCByZXR1cm5lZCBieSB0aGUgc3VwcG9ydCBmdW5jdGlvbi5cbiAqL1xuRHluYW1pY0dlb21ldHJ5LnByb3RvdHlwZS5hZGRWZXJ0ZXggPSBmdW5jdGlvbih2ZXJ0ZXhPYmopIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLl9JRFBvb2wudmVydGljZXMubGVuZ3RoID8gdGhpcy5fSURQb29sLnZlcnRpY2VzLnBvcCgpIDogdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XG4gICAgdGhpcy52ZXJ0aWNlc1tpbmRleF0gPSB2ZXJ0ZXhPYmo7XG4gICAgdGhpcy5sYXN0VmVydGV4SW5kZXggPSBpbmRleDtcbiAgICB0aGlzLm51bVZlcnRpY2VzKys7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhIHZlcnRleCBhbmQgcHVzaCBpdHMgbG9jYXRpb24gaW4gdGhlIHZlcnRleCBhcnJheSB0byB0aGUgSURQb29sIGZvciBsYXRlciB1c2UuXG4gKlxuICogQG1ldGhvZCByZW1vdmVWZXJ0ZXhcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBJbmRleCBvZiB0aGUgdmVydGV4IHRvIHJlbW92ZS5cbiAqL1xuRHluYW1pY0dlb21ldHJ5LnByb3RvdHlwZS5yZW1vdmVWZXJ0ZXggPSBmdW5jdGlvbihpbmRleCkge1xuICAgIHZhciB2ZXJ0ZXggPSB0aGlzLnZlcnRpY2VzW2luZGV4XTtcbiAgICB0aGlzLnZlcnRpY2VzW2luZGV4XSA9IG51bGw7XG4gICAgdGhpcy5fSURQb29sLnZlcnRpY2VzLnB1c2goaW5kZXgpO1xuICAgIHRoaXMubnVtVmVydGljZXMtLTtcblxuICAgIHJldHVybiB2ZXJ0ZXg7XG59O1xuXG4vKipcbiAqIEFkZCBhIGZlYXR1cmUgKGZhY2V0KSB0byB0aGUgcG9seWhlZHJvbi4gVXNlZCBpbnRlcm5hbGx5IGluIHRoZSByZXNoYXBpbmcgcHJvY2Vzcy5cbiAqXG4gKiBAbWV0aG9kIGFkZEZlYXR1cmVcbiAqIEBwYXJhbSB7TnVtYmVyfSBkaXN0YW5jZSBUaGUgZGlzdGFuY2Ugb2YgdGhlIGZlYXR1cmUgZnJvbSB0aGUgb3JpZ2luLlxuICogQHBhcmFtIHtWZWMzfSBub3JtYWwgVGhlIGZhY2V0IG5vcm1hbC5cbiAqIEBwYXJhbSB7TnVtYmVyW119IHZlcnRleEluZGljZXMgVGhlIGluZGljZXMgb2YgdGhlIHZlcnRpY2VzIHdoaWNoIGNvbXBvc2UgdGhlIGZlYXR1cmUuXG4gKi9cbkR5bmFtaWNHZW9tZXRyeS5wcm90b3R5cGUuYWRkRmVhdHVyZSA9IGZ1bmN0aW9uKGRpc3RhbmNlLCBub3JtYWwsIHZlcnRleEluZGljZXMpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLl9JRFBvb2wuZmVhdHVyZXMubGVuZ3RoID8gdGhpcy5fSURQb29sLmZlYXR1cmVzLnBvcCgpIDogdGhpcy5mZWF0dXJlcy5sZW5ndGg7XG4gICAgdGhpcy5mZWF0dXJlc1tpbmRleF0gPSBPTVJlcXVlc3REeW5hbWljR2VvbWV0cnlGZWF0dXJlKCkucmVzZXQoZGlzdGFuY2UsIG5vcm1hbCwgdmVydGV4SW5kaWNlcyk7XG4gICAgdGhpcy5udW1GZWF0dXJlcysrO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYSBmZWF0dXJlIGFuZCBwdXNoIGl0cyBsb2NhdGlvbiBpbiB0aGUgZmVhdHVyZSBhcnJheSB0byB0aGUgSURQb29sIGZvciBsYXRlciB1c2UuXG4gKlxuICogQG1ldGhvZCByZW1vdmVGZWF0dXJlXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXggSW5kZXggb2YgdGhlIGZlYXR1cmUgdG8gcmVtb3ZlLlxuICovXG5EeW5hbWljR2VvbWV0cnkucHJvdG90eXBlLnJlbW92ZUZlYXR1cmUgPSBmdW5jdGlvbihpbmRleCkge1xuICAgIHZhciBmZWF0dXJlID0gdGhpcy5mZWF0dXJlc1tpbmRleF07XG4gICAgdGhpcy5mZWF0dXJlc1tpbmRleF0gPSBudWxsO1xuICAgIHRoaXMuX0lEUG9vbC5mZWF0dXJlcy5wdXNoKGluZGV4KTtcbiAgICB0aGlzLm51bUZlYXR1cmVzLS07XG5cbiAgICBPTUZyZWVEeW5hbWljR2VvbWV0cnlGZWF0dXJlKGZlYXR1cmUpO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgbGFzdCB2ZXJ0ZXggb2JqZWN0IGFkZGVkIHRvIHRoZSBnZW9tZXRyeS5cbiAqXG4gKiBAbWV0aG9kIGdldExhc3RWZXJ0ZXhcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuRHluYW1pY0dlb21ldHJ5LnByb3RvdHlwZS5nZXRMYXN0VmVydGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudmVydGljZXNbdGhpcy5sYXN0VmVydGV4SW5kZXhdO1xufTtcblxuLyoqXG4gKiBPZiB0aGUgY2xvc2VzdCBmYWNlIHRvIHRoZSBvcmlnaW4sIHJldHVybnMgdGhlIG5vcm1hbCB2ZWN0b3IgcG9pbnRlZCBhd2F5IGZyb20gdGhlIG9yaWdpbi5cbiAqXG4gKiBAbWV0aG9kIGdldEZlYXR1cmVDbG9zZXN0VG9PcmlnaW5cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuRHluYW1pY0dlb21ldHJ5LnByb3RvdHlwZS5nZXRGZWF0dXJlQ2xvc2VzdFRvT3JpZ2luID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG1pbiA9IEluZmluaXR5O1xuICAgIHZhciBjbG9zZXN0ID0gbnVsbDtcbiAgICB2YXIgZmVhdHVyZXMgPSB0aGlzLmZlYXR1cmVzO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBmZWF0dXJlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgZmVhdHVyZSA9IGZlYXR1cmVzW2ldO1xuICAgICAgICBpZiAoIWZlYXR1cmUpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoZmVhdHVyZS5kaXN0YW5jZSA8IG1pbikge1xuICAgICAgICAgICAgbWluID0gZmVhdHVyZS5kaXN0YW5jZTtcbiAgICAgICAgICAgIGNsb3Nlc3QgPSBmZWF0dXJlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjbG9zZXN0O1xufTtcblxuLyoqXG4gKiBBZGRzIGVkZ2UgaWYgbm90IGFscmVhZHkgb24gdGhlIGZyb250aWVyLCByZW1vdmVzIGlmIHRoZSBlZGdlIG9yIGl0cyByZXZlcnNlIGFyZSBvbiB0aGUgZnJvbnRpZXIuXG4gKiBVc2VkIHdoZW4gcmVzaGFwaW5nIER5bmFtaWNHZW9tZXRyeSdzLlxuICpcbiAqIEBtZXRob2QgX3ZhbGlkYXRlRWRnZVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0W119IHZlcnRpY2VzIFZlYzMgcmVmZXJlbmNlIGFycmF5LlxuICogQHBhcmFtIHtOdW1iZXJbXVtdfSBmcm9udGllciBDdXJyZW50IGVkZ2VzIHBvdGVudGlhbGx5IHNlcGFyYXRpbmcgdGhlIGZlYXR1cmVzIHRvIHJlbW92ZSBmcm9tIHRoZSBwZXJzaXN0YW50IHNoYXBlLlxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IFRoZSBpbmRleCBvZiB0aGUgc3RhcnRpbmcgVmVjMyBvbiB0aGUgZWRnZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgVGhlIGluZGV4IG9mIHRoZSBjdWxtaW5hdGluZyBWZWMzLlxuICovXG5mdW5jdGlvbiBfdmFsaWRhdGVFZGdlKHZlcnRpY2VzLCBmcm9udGllciwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBlMCA9IHZlcnRpY2VzW3N0YXJ0XS52ZXJ0ZXg7XG4gICAgdmFyIGUxID0gdmVydGljZXNbZW5kXS52ZXJ0ZXg7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGZyb250aWVyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBlZGdlID0gZnJvbnRpZXJbaV07XG4gICAgICAgIGlmICghZWRnZSkgY29udGludWU7XG4gICAgICAgIHZhciB2MCA9IHZlcnRpY2VzW2VkZ2VbMF1dLnZlcnRleDtcbiAgICAgICAgdmFyIHYxID0gdmVydGljZXNbZWRnZVsxXV0udmVydGV4O1xuICAgICAgICBpZiAoKGUwID09PSB2MCAmJiAoZTEgPT09IHYxKSkgfHwgKGUwID09PSB2MSAmJiAoZTEgPT09IHYwKSkpIHtcbiAgICAgICAgICAgIGZyb250aWVyW2ldID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmcm9udGllci5wdXNoKFtzdGFydCwgZW5kXSk7XG59XG5cbi8qKlxuICogQmFzZWQgb24gdGhlIGxhc3QgKGV4dGVyaW9yKSBwb2ludCBhZGRlZCB0byB0aGUgcG9seWhlZHJvbiwgcmVtb3ZlcyBmZWF0dXJlcyBhcyBuZWNlc3NhcnkgYW5kIHJlZGV0ZXJtaW5lc1xuICogaXRzIChjb252ZXgpIHNoYXBlIHRvIGluY2x1ZGUgdGhlIG5ldyBwb2ludCBieSBhZGRpbmcgdHJpYW5nbGUgZmVhdHVyZXMuIFVzZXMgcmVmZXJlbmNlUG9pbnQsIGEgcG9pbnQgb24gdGhlIHNoYXBlJ3NcbiAqIGludGVyaW9yLCB0byBlbnN1cmUgZmVhdHVyZSBub3JtYWxzIHBvaW50IG91dHdhcmQsIGVsc2UgdGFrZXMgcmVmZXJlbmNlUG9pbnQgdG8gYmUgdGhlIG9yaWdpbi5cbiAqXG4gKiBAbWV0aG9kIHJlc2hhcGVcbiAqIEBwYXJhbSB7VmVjM30gcmVmZXJlbmNlUG9pbnQgUG9pbnQga25vd24gdG8gYmUgaW4gdGhlIGludGVyaW9yLCB1c2VkIHRvIG9yaWVudCBmZWF0dXJlIG5vcm1hbHMuXG4gKi9cbkR5bmFtaWNHZW9tZXRyeS5wcm90b3R5cGUucmVzaGFwZSA9IGZ1bmN0aW9uKHJlZmVyZW5jZVBvaW50KSB7XG4gICAgdmFyIHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcztcbiAgICB2YXIgcG9pbnQgPSB0aGlzLmdldExhc3RWZXJ0ZXgoKS52ZXJ0ZXg7XG4gICAgdmFyIGZlYXR1cmVzID0gdGhpcy5mZWF0dXJlcztcbiAgICB2YXIgdmVydGV4T25GZWF0dXJlO1xuICAgIHZhciBmZWF0dXJlVmVydGljZXM7XG5cbiAgICB2YXIgaSwgaiwgbGVuO1xuXG4gICAgLy8gVGhlIHJlbW92YWwgb2YgZmVhdHVyZXMgY3JlYXRlcyBhIGhvbGUgaW4gdGhlIHBvbHloZWRyb24gLS0gZnJvbnRpZXJFZGdlcyBtYWludGFpbnMgdGhlIGVkZ2VzXG4gICAgLy8gb2YgdGhpcyBob2xlLCBlYWNoIG9mIHdoaWNoIHdpbGwgZm9ybSBvbmUgZWRnZSBvZiBhIG5ldyBmZWF0dXJlIHRvIGJlIGNyZWF0ZWRcbiAgICB2YXIgZnJvbnRpZXJFZGdlcyA9IFtdO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gZmVhdHVyZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKCFmZWF0dXJlc1tpXSkgY29udGludWU7XG4gICAgICAgIGZlYXR1cmVWZXJ0aWNlcyA9IGZlYXR1cmVzW2ldLnZlcnRleEluZGljZXM7XG4gICAgICAgIHZlcnRleE9uRmVhdHVyZSA9IHZlcnRpY2VzW2ZlYXR1cmVWZXJ0aWNlc1swXV0udmVydGV4O1xuICAgICAgICAvLyBJZiBwb2ludCBpcyAnYWJvdmUnIHRoZSBmZWF0dXJlLCByZW1vdmUgdGhhdCBmZWF0dXJlLCBhbmQgY2hlY2sgdG8gYWRkIGl0cyBlZGdlcyB0byB0aGUgZnJvbnRpZXIuXG4gICAgICAgIGlmIChWZWMzLmRvdChmZWF0dXJlc1tpXS5ub3JtYWwsIFZlYzMuc3VidHJhY3QocG9pbnQsIHZlcnRleE9uRmVhdHVyZSwgUE9JTlRDSEVDS19SRUdJU1RFUikpID4gLTAuMDAxKSB7XG4gICAgICAgICAgICBfdmFsaWRhdGVFZGdlKHZlcnRpY2VzLCBmcm9udGllckVkZ2VzLCBmZWF0dXJlVmVydGljZXNbMF0sIGZlYXR1cmVWZXJ0aWNlc1sxXSk7XG4gICAgICAgICAgICBfdmFsaWRhdGVFZGdlKHZlcnRpY2VzLCBmcm9udGllckVkZ2VzLCBmZWF0dXJlVmVydGljZXNbMV0sIGZlYXR1cmVWZXJ0aWNlc1syXSk7XG4gICAgICAgICAgICBfdmFsaWRhdGVFZGdlKHZlcnRpY2VzLCBmcm9udGllckVkZ2VzLCBmZWF0dXJlVmVydGljZXNbMl0sIGZlYXR1cmVWZXJ0aWNlc1swXSk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUZlYXR1cmUoaSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgQSA9IHBvaW50O1xuICAgIHZhciBhID0gdGhpcy5sYXN0VmVydGV4SW5kZXg7XG4gICAgZm9yIChqID0gMCwgbGVuID0gZnJvbnRpZXJFZGdlcy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICBpZiAoIWZyb250aWVyRWRnZXNbal0pIGNvbnRpbnVlO1xuICAgICAgICB2YXIgYiA9IGZyb250aWVyRWRnZXNbal1bMF07XG4gICAgICAgIHZhciBjID0gZnJvbnRpZXJFZGdlc1tqXVsxXTtcbiAgICAgICAgdmFyIEIgPSB2ZXJ0aWNlc1tiXS52ZXJ0ZXg7XG4gICAgICAgIHZhciBDID0gdmVydGljZXNbY10udmVydGV4O1xuXG4gICAgICAgIHZhciBBQiA9IFZlYzMuc3VidHJhY3QoQiwgQSwgQUJfUkVHSVNURVIpO1xuICAgICAgICB2YXIgQUMgPSBWZWMzLnN1YnRyYWN0KEMsIEEsIEFDX1JFR0lTVEVSKTtcbiAgICAgICAgdmFyIEFCQyA9IFZlYzMuY3Jvc3MoQUIsIEFDLCBuZXcgVmVjMygpKTtcbiAgICAgICAgQUJDLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgIGlmICghcmVmZXJlbmNlUG9pbnQpIHtcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IFZlYzMuZG90KEFCQywgQSk7XG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPCAwKSB7XG4gICAgICAgICAgICAgICAgQUJDLmludmVydCgpO1xuICAgICAgICAgICAgICAgIGRpc3RhbmNlICo9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hZGRGZWF0dXJlKGRpc3RhbmNlLCBBQkMsIFthLCBiLCBjXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVmZXJlbmNlID0gVmVjMy5zdWJ0cmFjdChyZWZlcmVuY2VQb2ludCwgQSwgVkVDX1JFR0lTVEVSKTtcbiAgICAgICAgICAgIGlmIChWZWMzLmRvdChBQkMsIHJlZmVyZW5jZSkgPiAtMC4wMDEpIEFCQy5pbnZlcnQoKTtcbiAgICAgICAgICAgIHRoaXMuYWRkRmVhdHVyZShudWxsLCBBQkMsIFthLCBiLCBjXSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgU2ltcGxleCBpbnN0YW5jZSBjb250YWlucyB0aGUgb3JpZ2luLCByZXR1cm5zIHRydWUgb3IgZmFsc2UuXG4gKiBJZiBmYWxzZSwgcmVtb3ZlcyBhIHBvaW50IGFuZCwgYXMgYSBzaWRlIGVmZmVjdCwgY2hhbmdlcyBpbnB1dCBkaXJlY3Rpb24gdG8gYmUgYm90aFxuICogb3J0aG9nb25hbCB0byB0aGUgY3VycmVudCB3b3JraW5nIHNpbXBsZXggYW5kIHBvaW50IHRvd2FyZCB0aGUgb3JpZ2luLlxuICogQ2FsbHMgY2FsbGJhY2sgb24gdGhlIHJlbW92ZWQgcG9pbnQuXG4gKlxuICogQG1ldGhvZCBzaW1wbGV4Q29udGFpbnNPcmlnaW5cbiAqIEBwYXJhbSB7VmVjM30gZGlyZWN0aW9uIFZlY3RvciB1c2VkIHRvIHN0b3JlIHRoZSBuZXcgc2VhcmNoIGRpcmVjdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIEZ1bmN0aW9uIGludm9rZWQgd2l0aCB0aGUgcmVtb3ZlZCB2ZXJ0ZXgsIHVzZWQgZS5nLiB0byBmcmVlIHRoZSB2ZXJ0ZXggb2JqZWN0XG4gKiBpbiB0aGUgb2JqZWN0IG1hbmFnZXIuXG4gKiBAcmV0dXJuIHtCb29sZWFufSBUaGUgcmVzdWx0IG9mIHRoZSBjb250YWlubWVudCBjaGVjay5cbiAqL1xuRHluYW1pY0dlb21ldHJ5LnByb3RvdHlwZS5zaW1wbGV4Q29udGFpbnNPcmlnaW4gPSBmdW5jdGlvbihkaXJlY3Rpb24sIGNhbGxiYWNrKSB7XG4gICAgdmFyIG51bVZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XG5cbiAgICB2YXIgYSA9IHRoaXMubGFzdFZlcnRleEluZGV4O1xuICAgIHZhciBiID0gYSAtIDE7XG4gICAgdmFyIGMgPSBhIC0gMjtcbiAgICB2YXIgZCA9IGEgLSAzO1xuXG4gICAgYiA9IGIgPCAwID8gYiArIG51bVZlcnRpY2VzIDogYjtcbiAgICBjID0gYyA8IDAgPyBjICsgbnVtVmVydGljZXMgOiBjO1xuICAgIGQgPSBkIDwgMCA/IGQgKyBudW1WZXJ0aWNlcyA6IGQ7XG5cbiAgICB2YXIgQSA9IHRoaXMudmVydGljZXNbYV0udmVydGV4O1xuICAgIHZhciBCID0gdGhpcy52ZXJ0aWNlc1tiXS52ZXJ0ZXg7XG4gICAgdmFyIEMgPSB0aGlzLnZlcnRpY2VzW2NdLnZlcnRleDtcbiAgICB2YXIgRCA9IHRoaXMudmVydGljZXNbZF0udmVydGV4O1xuXG4gICAgdmFyIEFPID0gVmVjMy5zY2FsZShBLCAtMSwgQU9fUkVHSVNURVIpO1xuICAgIHZhciBBQiA9IFZlYzMuc3VidHJhY3QoQiwgQSwgQUJfUkVHSVNURVIpO1xuICAgIHZhciBBQywgQUQsIEJDLCBCRDtcbiAgICB2YXIgQUJDLCBBQ0QsIEFCRCwgQkNEO1xuICAgIHZhciBkaXN0YW5jZUFCQywgZGlzdGFuY2VBQ0QsIGRpc3RhbmNlQUJELCBkaXN0YW5jZUJDRDtcblxuICAgIHZhciB2ZXJ0ZXhUb1JlbW92ZTtcblxuICAgIGlmIChudW1WZXJ0aWNlcyA9PT0gNCkge1xuICAgICAgICAvLyBUZXRyYWhlZHJvblxuICAgICAgICBBQyA9IFZlYzMuc3VidHJhY3QoQywgQSwgQUNfUkVHSVNURVIpO1xuICAgICAgICBBRCA9IFZlYzMuc3VidHJhY3QoRCwgQSwgQURfUkVHSVNURVIpO1xuXG4gICAgICAgIEFCQyA9IFZlYzMuY3Jvc3MoQUIsIEFDLCBuZXcgVmVjMygpKTtcbiAgICAgICAgQUNEID0gVmVjMy5jcm9zcyhBQywgQUQsIG5ldyBWZWMzKCkpO1xuICAgICAgICBBQkQgPSBWZWMzLmNyb3NzKEFCLCBBRCwgbmV3IFZlYzMoKSk7XG4gICAgICAgIEFCQy5ub3JtYWxpemUoKTtcbiAgICAgICAgQUNELm5vcm1hbGl6ZSgpO1xuICAgICAgICBBQkQubm9ybWFsaXplKCk7XG4gICAgICAgIGlmIChWZWMzLmRvdChBQkMsIEFEKSA+IDApIEFCQy5pbnZlcnQoKTtcbiAgICAgICAgaWYgKFZlYzMuZG90KEFDRCwgQUIpID4gMCkgQUNELmludmVydCgpO1xuICAgICAgICBpZiAoVmVjMy5kb3QoQUJELCBBQykgPiAwKSBBQkQuaW52ZXJ0KCk7XG4gICAgICAgIC8vIERvbid0IG5lZWQgdG8gY2hlY2sgQkNEIGJlY2F1c2Ugd2Ugd291bGQgaGF2ZSBqdXN0IGNoZWNrZWQgdGhhdCBpbiB0aGUgcHJldmlvdXMgaXRlcmF0aW9uXG4gICAgICAgIC8vIC0tIHdlIGFkZGVkIEEgdG8gdGhlIEJDRCB0cmlhbmdsZSBiZWNhdXNlIEEgd2FzIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIG9yaWdpbi5cblxuICAgICAgICBkaXN0YW5jZUFCQyA9IFZlYzMuZG90KEFCQywgQU8pO1xuICAgICAgICBkaXN0YW5jZUFDRCA9IFZlYzMuZG90KEFDRCwgQU8pO1xuICAgICAgICBkaXN0YW5jZUFCRCA9IFZlYzMuZG90KEFCRCwgQU8pO1xuXG4gICAgICAgIC8vIE5vcm1zIHBvaW50IGF3YXkgZnJvbSBvcmlnaW4gLT4gb3JpZ2luIGlzIGluc2lkZSB0ZXRyYWhlZHJvblxuICAgICAgICBpZiAoZGlzdGFuY2VBQkMgPCAwLjAwMSAmJiBkaXN0YW5jZUFCRCA8IDAuMDAxICYmIGRpc3RhbmNlQUNEIDwgMC4wMDEpIHtcbiAgICAgICAgICAgIEJDID0gVmVjMy5zdWJ0cmFjdChDLCBCLCBCQ19SRUdJU1RFUik7XG4gICAgICAgICAgICBCRCA9IFZlYzMuc3VidHJhY3QoRCwgQiwgQkRfUkVHSVNURVIpO1xuICAgICAgICAgICAgQkNEID0gVmVjMy5jcm9zcyhCQywgQkQsIG5ldyBWZWMzKCkpO1xuICAgICAgICAgICAgQkNELm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgaWYgKFZlYzMuZG90KEJDRCwgQUIpIDw9IDApIEJDRC5pbnZlcnQoKTtcbiAgICAgICAgICAgIGRpc3RhbmNlQkNEID0gLTEgKiBWZWMzLmRvdChCQ0QsQik7XG4gICAgICAgICAgICAvLyBQcmVwIGZlYXR1cmVzIGZvciBFUEFcbiAgICAgICAgICAgIHRoaXMuYWRkRmVhdHVyZSgtZGlzdGFuY2VBQkMsIEFCQywgW2EsYixjXSk7XG4gICAgICAgICAgICB0aGlzLmFkZEZlYXR1cmUoLWRpc3RhbmNlQUNELCBBQ0QsIFthLGMsZF0pO1xuICAgICAgICAgICAgdGhpcy5hZGRGZWF0dXJlKC1kaXN0YW5jZUFCRCwgQUJELCBbYSxkLGJdKTtcbiAgICAgICAgICAgIHRoaXMuYWRkRmVhdHVyZSgtZGlzdGFuY2VCQ0QsIEJDRCwgW2IsYyxkXSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkaXN0YW5jZUFCQyA+PSAwLjAwMSkge1xuICAgICAgICAgICAgdmVydGV4VG9SZW1vdmUgPSB0aGlzLnJlbW92ZVZlcnRleChkKTtcbiAgICAgICAgICAgIGRpcmVjdGlvbi5jb3B5KEFCQyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGlzdGFuY2VBQ0QgPj0gMC4wMDEpIHtcbiAgICAgICAgICAgIHZlcnRleFRvUmVtb3ZlID0gdGhpcy5yZW1vdmVWZXJ0ZXgoYik7XG4gICAgICAgICAgICBkaXJlY3Rpb24uY29weShBQ0QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmVydGV4VG9SZW1vdmUgPSB0aGlzLnJlbW92ZVZlcnRleChjKTtcbiAgICAgICAgICAgIGRpcmVjdGlvbi5jb3B5KEFCRCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAobnVtVmVydGljZXMgPT09IDMpIHtcbiAgICAgICAgLy8gVHJpYW5nbGVcbiAgICAgICAgQUMgPSBWZWMzLnN1YnRyYWN0KEMsIEEsIEFDX1JFR0lTVEVSKTtcbiAgICAgICAgVmVjMy5jcm9zcyhBQiwgQUMsIGRpcmVjdGlvbik7XG4gICAgICAgIGlmIChWZWMzLmRvdChkaXJlY3Rpb24sIEFPKSA8PSAwKSBkaXJlY3Rpb24uaW52ZXJ0KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBMaW5lXG4gICAgICAgIGRpcmVjdGlvbi5jb3B5KHRyaXBsZVByb2R1Y3QoQUIsIEFPLCBBQikpO1xuICAgIH1cbiAgICBpZiAodmVydGV4VG9SZW1vdmUgJiYgY2FsbGJhY2spIGNhbGxiYWNrKHZlcnRleFRvUmVtb3ZlKTtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIEdpdmVuIGFuIGFycmF5IG9mIFZlYzMncywgY29tcHV0ZXMgdGhlIGNvbnZleCBodWxsLiBVc2VkIGluIGNvbnN0cnVjdGluZyBib2RpZXMgaW4gdGhlIHBoeXNpY3Mgc3lzdGVtIGFuZCB0b1xuICogY3JlYXRlIGN1c3RvbSBHTCBtZXNoZXMuXG4gKlxuICogQGNsYXNzIENvbnZleEh1bGxcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtWZWMzW119IHZlcnRpY2VzIENsb3VkIG9mIHZlcnRpY2VzIG9mIHdoaWNoIHRoZSBlbmNsb3NpbmcgY29udmV4IGh1bGwgaXMgZGVzaXJlZC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbaXRlcmF0aW9ucyA9IDFlM10gTWF4aW11bSBudW1iZXIgb2YgdmVydGljZXMgdG8gY29tcG9zZSB0aGUgY29udmV4IGh1bGwuXG4gKi9cbmZ1bmN0aW9uIENvbnZleEh1bGwodmVydGljZXMsIGl0ZXJhdGlvbnMpIHtcbiAgICBpdGVyYXRpb25zID0gaXRlcmF0aW9ucyB8fCAxZTM7XG4gICAgdmFyIGh1bGwgPSBfY29tcHV0ZUNvbnZleEh1bGwodmVydGljZXMsIGl0ZXJhdGlvbnMpO1xuXG4gICAgdmFyIGksIGxlbjtcblxuICAgIHZhciBpbmRpY2VzID0gW107XG4gICAgZm9yIChpID0gMCwgbGVuID0gaHVsbC5mZWF0dXJlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgZiA9IGh1bGwuZmVhdHVyZXNbaV07XG4gICAgICAgIGlmIChmKSBpbmRpY2VzLnB1c2goZi52ZXJ0ZXhJbmRpY2VzKTtcbiAgICB9XG5cbiAgICB2YXIgcG9seWhlZHJhbFByb3BlcnRpZXMgPSBfY29tcHV0ZVBvbHloZWRyYWxQcm9wZXJ0aWVzKGh1bGwudmVydGljZXMsIGluZGljZXMpO1xuICAgIHZhciBjZW50cm9pZCA9IHBvbHloZWRyYWxQcm9wZXJ0aWVzLmNlbnRyb2lkO1xuXG4gICAgdmFyIHdvcmxkVmVydGljZXMgPSBbXTtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBodWxsLnZlcnRpY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHdvcmxkVmVydGljZXMucHVzaChWZWMzLnN1YnRyYWN0KGh1bGwudmVydGljZXNbaV0udmVydGV4LCBjZW50cm9pZCwgbmV3IFZlYzMoKSkpO1xuICAgIH1cblxuICAgIHZhciBub3JtYWxzID0gW107XG4gICAgZm9yIChpID0gMCwgbGVuID0gd29ybGRWZXJ0aWNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBub3JtYWxzLnB1c2goVmVjMy5ub3JtYWxpemUod29ybGRWZXJ0aWNlc1tpXSwgbmV3IFZlYzMoKSkpO1xuICAgIH1cblxuICAgIHZhciBncmFwaCA9IHt9O1xuICAgIHZhciBfbmVpZ2hib3JNYXRyaXggPSB7fTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYSA9IGluZGljZXNbaV1bMF07XG4gICAgICAgIHZhciBiID0gaW5kaWNlc1tpXVsxXTtcbiAgICAgICAgdmFyIGMgPSBpbmRpY2VzW2ldWzJdO1xuXG4gICAgICAgIF9uZWlnaGJvck1hdHJpeFthXSA9IF9uZWlnaGJvck1hdHJpeFthXSB8fCB7fTtcbiAgICAgICAgX25laWdoYm9yTWF0cml4W2JdID0gX25laWdoYm9yTWF0cml4W2JdIHx8IHt9O1xuICAgICAgICBfbmVpZ2hib3JNYXRyaXhbY10gPSBfbmVpZ2hib3JNYXRyaXhbY10gfHwge307XG5cbiAgICAgICAgZ3JhcGhbYV0gPSBncmFwaFthXSB8fCBbXTtcbiAgICAgICAgZ3JhcGhbYl0gPSBncmFwaFtiXSB8fCBbXTtcbiAgICAgICAgZ3JhcGhbY10gPSBncmFwaFtjXSB8fCBbXTtcblxuICAgICAgICBpZiAoIV9uZWlnaGJvck1hdHJpeFthXVtiXSkge1xuICAgICAgICAgICAgX25laWdoYm9yTWF0cml4W2FdW2JdID0gMTtcbiAgICAgICAgICAgIGdyYXBoW2FdLnB1c2goYik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFfbmVpZ2hib3JNYXRyaXhbYV1bY10pIHtcbiAgICAgICAgICAgIF9uZWlnaGJvck1hdHJpeFthXVtjXSA9IDE7XG4gICAgICAgICAgICBncmFwaFthXS5wdXNoKGMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghX25laWdoYm9yTWF0cml4W2JdW2FdKSB7XG4gICAgICAgICAgICBfbmVpZ2hib3JNYXRyaXhbYl1bYV0gPSAxO1xuICAgICAgICAgICAgZ3JhcGhbYl0ucHVzaChhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIV9uZWlnaGJvck1hdHJpeFtiXVtjXSkge1xuICAgICAgICAgICAgX25laWdoYm9yTWF0cml4W2JdW2NdID0gMTtcbiAgICAgICAgICAgIGdyYXBoW2JdLnB1c2goYyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFfbmVpZ2hib3JNYXRyaXhbY11bYV0pIHtcbiAgICAgICAgICAgIF9uZWlnaGJvck1hdHJpeFtjXVthXSA9IDE7XG4gICAgICAgICAgICBncmFwaFtjXS5wdXNoKGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghX25laWdoYm9yTWF0cml4W2NdW2JdKSB7XG4gICAgICAgICAgICBfbmVpZ2hib3JNYXRyaXhbY11bYl0gPSAxO1xuICAgICAgICAgICAgZ3JhcGhbY10ucHVzaChiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuaW5kaWNlcyA9IGluZGljZXM7XG4gICAgdGhpcy52ZXJ0aWNlcyA9IHdvcmxkVmVydGljZXM7XG4gICAgdGhpcy5ub3JtYWxzID0gbm9ybWFscztcbiAgICB0aGlzLnBvbHloZWRyYWxQcm9wZXJ0aWVzID0gcG9seWhlZHJhbFByb3BlcnRpZXM7XG4gICAgdGhpcy5ncmFwaCA9IGdyYXBoO1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIHRoZSBhY3R1YWwgY29tcHV0YXRpb24gb2YgdGhlIGNvbnZleCBodWxsLlxuICpcbiAqIEBtZXRob2QgX2NvbXB1dGVDb252ZXhIdWxsXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtWZWMzW119IHZlcnRpY2VzIENsb3VkIG9mIHZlcnRpY2VzIG9mIHdoaWNoIHRoZSBlbmNsb3NpbmcgY29udmV4IGh1bGwgaXMgZGVzaXJlZC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhJdGVyYXRpb25zIE1heGltdW0gbnVtYmVyIG9mIHZlcnRpY2VzIHRvIGNvbXBvc2UgdGhlIGNvbnZleCBodWxsLlxuICogQHJldHVybiB7RHluYW1pY0dlb21ldHJ5fSBUaGUgY29tcHV0ZWQgaHVsbC5cbiAqL1xuZnVuY3Rpb24gX2NvbXB1dGVDb252ZXhIdWxsKHZlcnRpY2VzLCBtYXhJdGVyYXRpb25zKSB7XG4gICAgdmFyIGh1bGwgPSBuZXcgRHluYW1pY0dlb21ldHJ5KCk7XG5cbiAgICBodWxsLmFkZFZlcnRleChfaHVsbFN1cHBvcnQodmVydGljZXMsIG5ldyBWZWMzKDEsIDAsIDApKSk7XG4gICAgaHVsbC5hZGRWZXJ0ZXgoX2h1bGxTdXBwb3J0KHZlcnRpY2VzLCBuZXcgVmVjMygtMSwgMCwgMCkpKTtcbiAgICB2YXIgQSA9IGh1bGwudmVydGljZXNbMF0udmVydGV4O1xuICAgIHZhciBCID0gaHVsbC52ZXJ0aWNlc1sxXS52ZXJ0ZXg7XG4gICAgdmFyIEFCID0gVmVjMy5zdWJ0cmFjdChCLCBBLCBBQl9SRUdJU1RFUik7XG5cbiAgICB2YXIgZG90O1xuICAgIHZhciB2ZXJ0ZXg7XG4gICAgdmFyIGZ1cnRoZXN0O1xuICAgIHZhciBpbmRleDtcbiAgICB2YXIgaSwgbGVuO1xuXG4gICAgdmFyIG1heCA9IC1JbmZpbml0eTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmVydGV4ID0gdmVydGljZXNbaV07XG4gICAgICAgIGlmICh2ZXJ0ZXggPT09IEEgfHwgdmVydGV4ID09PSBCKSBjb250aW51ZTtcbiAgICAgICAgdmFyIEFWID0gVmVjMy5zdWJ0cmFjdCh2ZXJ0ZXgsIEEsIFZFQ19SRUdJU1RFUik7XG4gICAgICAgIGRvdCA9IFZlYzMuZG90KEFWLCB0cmlwbGVQcm9kdWN0KEFCLCBBViwgQUIpKTtcbiAgICAgICAgZG90ID0gZG90IDwgMCA/IGRvdCAqIC0xIDogZG90O1xuICAgICAgICBpZiAoZG90ID4gbWF4KSB7XG4gICAgICAgICAgICBtYXggPSBkb3Q7XG4gICAgICAgICAgICBmdXJ0aGVzdCA9IHZlcnRleDtcbiAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBodWxsLmFkZFZlcnRleCh7XG4gICAgICAgIHZlcnRleDogZnVydGhlc3QsXG4gICAgICAgIGluZGV4OiBpbmRleFxuICAgIH0pO1xuXG4gICAgdmFyIEMgPSBmdXJ0aGVzdDtcbiAgICB2YXIgQUMgPSBWZWMzLnN1YnRyYWN0KEMsIEEsIEFDX1JFR0lTVEVSKTtcbiAgICB2YXIgQUJDID0gVmVjMy5jcm9zcyhBQiwgQUMsIG5ldyBWZWMzKCkpO1xuICAgIEFCQy5ub3JtYWxpemUoKTtcblxuICAgIG1heCA9IC1JbmZpbml0eTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmVydGV4ID0gdmVydGljZXNbaV07XG4gICAgICAgIGlmICh2ZXJ0ZXggPT09IEEgfHwgdmVydGV4ID09PSBCIHx8IHZlcnRleCA9PT0gQykgY29udGludWU7XG4gICAgICAgIGRvdCA9IFZlYzMuZG90KFZlYzMuc3VidHJhY3QodmVydGV4LCBBLCBWRUNfUkVHSVNURVIpLCBBQkMpO1xuICAgICAgICBkb3QgPSBkb3QgPCAwID8gZG90ICogLTEgOiBkb3Q7XG4gICAgICAgIGlmIChkb3QgPiBtYXgpIHtcbiAgICAgICAgICAgIG1heCA9IGRvdDtcbiAgICAgICAgICAgIGZ1cnRoZXN0ID0gdmVydGV4O1xuICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGh1bGwuYWRkVmVydGV4KHtcbiAgICAgICAgdmVydGV4OiBmdXJ0aGVzdCxcbiAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgfSk7XG5cbiAgICB2YXIgRCA9IGZ1cnRoZXN0O1xuICAgIHZhciBBRCA9IFZlYzMuc3VidHJhY3QoRCwgQSwgQURfUkVHSVNURVIpO1xuICAgIHZhciBCQyA9IFZlYzMuc3VidHJhY3QoQywgQiwgQkNfUkVHSVNURVIpO1xuICAgIHZhciBCRCA9IFZlYzMuc3VidHJhY3QoRCwgQiwgQkRfUkVHSVNURVIpO1xuXG4gICAgdmFyIEFDRCA9IFZlYzMuY3Jvc3MoQUMsIEFELCBuZXcgVmVjMygpKTtcbiAgICB2YXIgQUJEID0gVmVjMy5jcm9zcyhBQiwgQUQsIG5ldyBWZWMzKCkpO1xuICAgIHZhciBCQ0QgPSBWZWMzLmNyb3NzKEJDLCBCRCwgbmV3IFZlYzMoKSk7XG4gICAgQUNELm5vcm1hbGl6ZSgpO1xuICAgIEFCRC5ub3JtYWxpemUoKTtcbiAgICBCQ0Qubm9ybWFsaXplKCk7XG4gICAgaWYgKFZlYzMuZG90KEFCQywgQUQpID4gMCkgQUJDLmludmVydCgpO1xuICAgIGlmIChWZWMzLmRvdChBQ0QsIEFCKSA+IDApIEFDRC5pbnZlcnQoKTtcbiAgICBpZiAoVmVjMy5kb3QoQUJELCBBQykgPiAwKSBBQkQuaW52ZXJ0KCk7XG4gICAgaWYgKFZlYzMuZG90KEJDRCwgQUIpIDwgMCkgQkNELmludmVydCgpO1xuXG4gICAgdmFyIGEgPSAwO1xuICAgIHZhciBiID0gMTtcbiAgICB2YXIgYyA9IDI7XG4gICAgdmFyIGQgPSAzO1xuXG4gICAgaHVsbC5hZGRGZWF0dXJlKG51bGwsIEFCQywgW2EsIGIsIGNdKTtcbiAgICBodWxsLmFkZEZlYXR1cmUobnVsbCwgQUNELCBbYSwgYywgZF0pO1xuICAgIGh1bGwuYWRkRmVhdHVyZShudWxsLCBBQkQsIFthLCBiLCBkXSk7XG4gICAgaHVsbC5hZGRGZWF0dXJlKG51bGwsIEJDRCwgW2IsIGMsIGRdKTtcblxuICAgIHZhciBhc3NpZ25lZCA9IHt9O1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IGh1bGwudmVydGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICBhc3NpZ25lZFtodWxsLnZlcnRpY2VzW2ldLmluZGV4XSA9IHRydWU7XG4gICAgfVxuXG5cbiAgICB2YXIgY3ggPSBBLnggKyBCLnggKyBDLnggKyBELng7XG4gICAgdmFyIGN5ID0gQS55ICsgQi55ICsgQy55ICsgRC55O1xuICAgIHZhciBjeiA9IEEueiArIEIueiArIEMueiArIEQuejtcbiAgICB2YXIgcmVmZXJlbmNlUG9pbnQgPSBuZXcgVmVjMyhjeCwgY3ksIGN6KTtcbiAgICByZWZlcmVuY2VQb2ludC5zY2FsZSgwLjI1KTtcblxuICAgIHZhciBmZWF0dXJlcyA9IGh1bGwuZmVhdHVyZXM7XG4gICAgdmFyIGl0ZXJhdGlvbiA9IDA7XG4gICAgd2hpbGUgKGl0ZXJhdGlvbisrIDwgbWF4SXRlcmF0aW9ucykge1xuICAgICAgICB2YXIgY3VycmVudEZlYXR1cmUgPSBudWxsO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBmZWF0dXJlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKCFmZWF0dXJlc1tpXSB8fCBmZWF0dXJlc1tpXS5kb25lKSBjb250aW51ZTtcbiAgICAgICAgICAgIGN1cnJlbnRGZWF0dXJlID0gZmVhdHVyZXNbaV07XG4gICAgICAgICAgICBmdXJ0aGVzdCA9IG51bGw7XG4gICAgICAgICAgICBpbmRleCA9IG51bGw7XG4gICAgICAgICAgICBBID0gaHVsbC52ZXJ0aWNlc1tjdXJyZW50RmVhdHVyZS52ZXJ0ZXhJbmRpY2VzWzBdXS52ZXJ0ZXg7XG4gICAgICAgICAgICB2YXIgcyA9IF9odWxsU3VwcG9ydCh2ZXJ0aWNlcywgY3VycmVudEZlYXR1cmUubm9ybWFsKTtcbiAgICAgICAgICAgIGZ1cnRoZXN0ID0gcy52ZXJ0ZXg7XG4gICAgICAgICAgICBpbmRleCA9IHMuaW5kZXg7XG4gICAgICAgICAgICB2YXIgZGlzdCA9IFZlYzMuZG90KFZlYzMuc3VidHJhY3QoZnVydGhlc3QsIEEsIFZFQ19SRUdJU1RFUiksIGN1cnJlbnRGZWF0dXJlLm5vcm1hbCk7XG5cbiAgICAgICAgICAgIGlmIChkaXN0IDwgMC4wMDEgfHwgYXNzaWduZWRbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEZlYXR1cmUuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFzc2lnbmVkW2luZGV4XSA9IHRydWU7XG4gICAgICAgICAgICBodWxsLmFkZFZlcnRleChzKTtcbiAgICAgICAgICAgIGh1bGwucmVzaGFwZShyZWZlcmVuY2VQb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vIGZlYXR1cmUgaGFzIHBvaW50cyAnYWJvdmUnIGl0IC0+IGZpbmlzaGVkXG4gICAgICAgIGlmIChjdXJyZW50RmVhdHVyZSA9PT0gbnVsbCkgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIGh1bGw7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHVzZWQgaW4gX2NvbXB1dGVQb2x5aGVkcmFsUHJvcGVydGllcy5cbiAqIFNldHMgZjAgLSBmMiBhbmQgZzAgLSBnMiBkZXBlbmRpbmcgb24gdzAgLSB3Mi5cbiAqXG4gKiBAbWV0aG9kIF9zdWJleHByZXNzaW9uc1xuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSB3MCBSZWZlcmVuY2UgeCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtOdW1iZXJ9IHcxIFJlZmVyZW5jZSB5IGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge051bWJlcn0gdzIgUmVmZXJlbmNlIHogY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7TnVtYmVyW119IGYgT25lIG9mIHR3byBvdXRwdXQgcmVnaXN0ZXJzIHRvIGNvbnRhaW4gdGhlIHJlc3VsdCBvZiB0aGUgY2FsY3VsYXRpb24uXG4gKiBAcGFyYW0ge051bWJlcltdfSBnIE9uZSBvZiB0d28gb3V0cHV0IHJlZ2lzdGVycyB0byBjb250YWluIHRoZSByZXN1bHQgb2YgdGhlIGNhbGN1bGF0aW9uLlxuICovXG5mdW5jdGlvbiBfc3ViZXhwcmVzc2lvbnModzAsIHcxLCB3MiwgZiwgZykge1xuICAgIHZhciB0MCA9IHcwICsgdzE7XG4gICAgZlswXSA9IHQwICsgdzI7XG4gICAgdmFyIHQxID0gdzAgKiB3MDtcbiAgICB2YXIgdDIgPSB0MSArIHcxICogdDA7XG4gICAgZlsxXSA9IHQyICsgdzIgKiBmWzBdO1xuICAgIGZbMl0gPSB3MCAqIHQxICsgdzEgKiB0MiArIHcyICogZlsxXTtcbiAgICBnWzBdID0gZlsxXSArIHcwICogKGZbMF0gKyB3MCk7XG4gICAgZ1sxXSA9IGZbMV0gKyB3MSAqIChmWzBdICsgdzEpO1xuICAgIGdbMl0gPSBmWzFdICsgdzIgKiAoZlswXSArIHcyKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHZhcmlvdXMgcHJvcGVydGllcyBvZiB0aGUgdm9sdW1lLlxuICpcbiAqIEBtZXRob2QgX2NvbXB1dGVQb2x5aGVkcmFsUHJvcGVydGllc1xuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7VmVjM1tdfSB2ZXJ0aWNlcyBUaGUgdmVydGljZXMgb2YgdGhlIHBvbHloZWRyb24uXG4gKiBAcGFyYW0ge051bWJlcltdW119IGluZGljZXMgQXJyYXkgb2YgYXJyYXlzIG9mIGluZGljZXMgb2YgdmVydGljZXMgY29tcG9zaW5nIHRoZSB0cmlhbmd1bGFyIGZlYXR1cmVzIG9mIHRoZSBwb2x5aGVkcm9uLFxuICogb25lIGFycmF5IGZvciBlYWNoIGZlYXR1cmUuXG4gKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCBob2xkaW5nIHRoZSBjYWxjdWxhdGVkIHNwYW4sIHZvbHVtZSwgY2VudGVyLCBhbmQgZXVsZXIgdGVuc29yLlxuICovXG5mdW5jdGlvbiBfY29tcHV0ZVBvbHloZWRyYWxQcm9wZXJ0aWVzKHZlcnRpY2VzLCBpbmRpY2VzKSB7XG4gICAgLy8gT3JkZXI6IDEsIHgsIHksIHosIHheMiwgeV4yLCB6XjIsIHh5LCB5eiwgenhcbiAgICB2YXIgaW50ZWdyYWxzID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdO1xuICAgIHZhciBmeCA9IFtdO1xuICAgIHZhciBmeSA9IFtdO1xuICAgIHZhciBmeiA9IFtdO1xuICAgIHZhciBneCA9IFtdO1xuICAgIHZhciBneSA9IFtdO1xuICAgIHZhciBneiA9IFtdO1xuXG4gICAgdmFyIGksIGxlbjtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGluZGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIEEgPSB2ZXJ0aWNlc1tpbmRpY2VzW2ldWzBdXS52ZXJ0ZXg7XG4gICAgICAgIHZhciBCID0gdmVydGljZXNbaW5kaWNlc1tpXVsxXV0udmVydGV4O1xuICAgICAgICB2YXIgQyA9IHZlcnRpY2VzW2luZGljZXNbaV1bMl1dLnZlcnRleDtcbiAgICAgICAgdmFyIEFCID0gVmVjMy5zdWJ0cmFjdChCLCBBLCBBQl9SRUdJU1RFUik7XG4gICAgICAgIHZhciBBQyA9IFZlYzMuc3VidHJhY3QoQywgQSwgQUNfUkVHSVNURVIpO1xuICAgICAgICB2YXIgQUJDID0gQUIuY3Jvc3MoQUMpO1xuICAgICAgICBpZiAoVmVjMy5kb3QoQSwgQUJDKSA8IDApIEFCQy5pbnZlcnQoKTtcblxuICAgICAgICB2YXIgZDAgPSBBQkMueDtcbiAgICAgICAgdmFyIGQxID0gQUJDLnk7XG4gICAgICAgIHZhciBkMiA9IEFCQy56O1xuXG4gICAgICAgIHZhciB4MCA9IEEueDtcbiAgICAgICAgdmFyIHkwID0gQS55O1xuICAgICAgICB2YXIgejAgPSBBLno7XG4gICAgICAgIHZhciB4MSA9IEIueDtcbiAgICAgICAgdmFyIHkxID0gQi55O1xuICAgICAgICB2YXIgejEgPSBCLno7XG4gICAgICAgIHZhciB4MiA9IEMueDtcbiAgICAgICAgdmFyIHkyID0gQy55O1xuICAgICAgICB2YXIgejIgPSBDLno7XG5cbiAgICAgICAgX3N1YmV4cHJlc3Npb25zKHgwLCB4MSwgeDIsIGZ4LCBneCk7XG4gICAgICAgIF9zdWJleHByZXNzaW9ucyh5MCwgeTEsIHkyLCBmeSwgZ3kpO1xuICAgICAgICBfc3ViZXhwcmVzc2lvbnMoejAsIHoxLCB6MiwgZnosIGd6KTtcblxuICAgICAgICBpbnRlZ3JhbHNbMF0gKz0gZDAgKiBmeFswXTtcbiAgICAgICAgaW50ZWdyYWxzWzFdICs9IGQwICogZnhbMV07XG4gICAgICAgIGludGVncmFsc1syXSArPSBkMSAqIGZ5WzFdO1xuICAgICAgICBpbnRlZ3JhbHNbM10gKz0gZDIgKiBmelsxXTtcbiAgICAgICAgaW50ZWdyYWxzWzRdICs9IGQwICogZnhbMl07XG4gICAgICAgIGludGVncmFsc1s1XSArPSBkMSAqIGZ5WzJdO1xuICAgICAgICBpbnRlZ3JhbHNbNl0gKz0gZDIgKiBmelsyXTtcbiAgICAgICAgaW50ZWdyYWxzWzddICs9IGQwICogKHkwICogZ3hbMF0gKyB5MSAqIGd4WzFdICsgeTIgKiBneFsyXSk7XG4gICAgICAgIGludGVncmFsc1s4XSArPSBkMSAqICh6MCAqIGd5WzBdICsgejEgKiBneVsxXSArIHoyICogZ3lbMl0pO1xuICAgICAgICBpbnRlZ3JhbHNbOV0gKz0gZDIgKiAoeDAgKiBnelswXSArIHgxICogZ3pbMV0gKyB4MiAqIGd6WzJdKTtcbiAgICB9XG5cbiAgICBpbnRlZ3JhbHNbMF0gLz0gNjtcbiAgICBpbnRlZ3JhbHNbMV0gLz0gMjQ7XG4gICAgaW50ZWdyYWxzWzJdIC89IDI0O1xuICAgIGludGVncmFsc1szXSAvPSAyNDtcbiAgICBpbnRlZ3JhbHNbNF0gLz0gNjA7XG4gICAgaW50ZWdyYWxzWzVdIC89IDYwO1xuICAgIGludGVncmFsc1s2XSAvPSA2MDtcbiAgICBpbnRlZ3JhbHNbN10gLz0gMTIwO1xuICAgIGludGVncmFsc1s4XSAvPSAxMjA7XG4gICAgaW50ZWdyYWxzWzldIC89IDEyMDtcblxuICAgIHZhciBtaW5YID0gSW5maW5pdHksIG1heFggPSAtSW5maW5pdHk7XG4gICAgdmFyIG1pblkgPSBJbmZpbml0eSwgbWF4WSA9IC1JbmZpbml0eTtcbiAgICB2YXIgbWluWiA9IEluZmluaXR5LCBtYXhaID0gLUluZmluaXR5O1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gdmVydGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIHZlcnRleCA9IHZlcnRpY2VzW2ldLnZlcnRleDtcbiAgICAgICAgaWYgKHZlcnRleC54IDwgbWluWCkgbWluWCA9IHZlcnRleC54O1xuICAgICAgICBpZiAodmVydGV4LnggPiBtYXhYKSBtYXhYID0gdmVydGV4Lng7XG4gICAgICAgIGlmICh2ZXJ0ZXgueSA8IG1pblkpIG1pblkgPSB2ZXJ0ZXgueTtcbiAgICAgICAgaWYgKHZlcnRleC55ID4gbWF4WSkgbWF4WSA9IHZlcnRleC55O1xuICAgICAgICBpZiAodmVydGV4LnogPCBtaW5aKSBtaW5aID0gdmVydGV4Lno7XG4gICAgICAgIGlmICh2ZXJ0ZXgueiA+IG1heFopIG1heFogPSB2ZXJ0ZXguejtcbiAgICB9XG5cbiAgICB2YXIgc2l6ZSA9IFttYXhYIC0gbWluWCwgbWF4WSAtIG1pblksIG1heFogLSBtaW5aXTtcbiAgICB2YXIgdm9sdW1lID0gaW50ZWdyYWxzWzBdO1xuICAgIHZhciBjZW50cm9pZCA9IG5ldyBWZWMzKGludGVncmFsc1sxXSwgaW50ZWdyYWxzWzJdLCBpbnRlZ3JhbHNbM10pO1xuICAgIGNlbnRyb2lkLnNjYWxlKDEgLyB2b2x1bWUpO1xuXG4gICAgdmFyIGV1bGVyVGVuc29yID0gbmV3IE1hdDMzKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlZ3JhbHNbNF0sIGludGVncmFsc1s3XSwgaW50ZWdyYWxzWzldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVncmFsc1s3XSwgaW50ZWdyYWxzWzVdLCBpbnRlZ3JhbHNbOF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZWdyYWxzWzldLCBpbnRlZ3JhbHNbOF0sIGludGVncmFsc1s2XVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzaXplOiBzaXplLFxuICAgICAgICB2b2x1bWU6IHZvbHVtZSxcbiAgICAgICAgY2VudHJvaWQ6IGNlbnRyb2lkLFxuICAgICAgICBldWxlclRlbnNvcjogZXVsZXJUZW5zb3JcbiAgICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBEeW5hbWljR2VvbWV0cnk6IER5bmFtaWNHZW9tZXRyeSxcbiAgICBDb252ZXhIdWxsOiBDb252ZXhIdWxsXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUGFydGljbGUgPSByZXF1aXJlKCcuL2JvZGllcy9QYXJ0aWNsZScpO1xudmFyIENvbnN0cmFpbnQgPSByZXF1aXJlKCcuL2NvbnN0cmFpbnRzL0NvbnN0cmFpbnQnKTtcbnZhciBGb3JjZSA9IHJlcXVpcmUoJy4vZm9yY2VzL0ZvcmNlJyk7XG5cbnZhciBWZWMzID0gcmVxdWlyZSgnZmFtb3VzLW1hdGgnKS5WZWMzO1xudmFyIFF1YXRlcm5pb24gPSByZXF1aXJlKCdmYW1vdXMtbWF0aCcpLlF1YXRlcm5pb247XG5cbnZhciBWRUNfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIFpZWF9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgUVVBVF9SRUdJU1RFUiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG52YXIgREVMVEFfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIFNpbmdsZXRvbiBQaHlzaWNzRW5naW5lIG9iamVjdC5cbiAqIE1hbmFnZXMgYm9kaWVzLCBmb3JjZXMsIGNvbnN0cmFpbnRzLlxuICpcbiAqIEBjbGFzcyBQaHlzaWNzRW5naW5lXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBIGhhc2ggb2YgY29uZmlndXJhYmxlIG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIFBoeXNpY3NFbmdpbmUob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIC8qKiBAcHJvcCBib2RpZXMgVGhlIGJvZGllcyBjdXJyZW50bHkgYWN0aXZlIGluIHRoZSBlbmdpbmUuICovXG4gICAgdGhpcy5ib2RpZXMgPSBbXTtcbiAgICAvKiogQHByb3AgZm9yY2VzIFRoZSBmb3JjZXMgY3VycmVudGx5IGFjdGl2ZSBpbiB0aGUgZW5naW5lLiAqL1xuICAgIHRoaXMuZm9yY2VzID0gW107XG4gICAgLyoqIEBwcm9wIGNvbnN0cmFpbnRzIFRoZSBjb25zdHJhaW50cyBjdXJyZW50bHkgYWN0aXZlIGluIHRoZSBlbmdpbmUuICovXG4gICAgdGhpcy5jb25zdHJhaW50cyA9IFtdO1xuXG4gICAgLyoqIEBwcm9wIHN0ZXAgVGhlIHRpbWUgYmV0d2VlbiBmcmFtZXMgaW4gdGhlIGVuZ2luZS4gKi9cbiAgICB0aGlzLnN0ZXAgPSBvcHRpb25zLnN0ZXAgfHwgMTAwMC82MDtcbiAgICAvKiogQHByb3AgaXRlcmF0aW9ucyBUaGUgbnVtYmVyIG9mIHRpbWVzIGVhY2ggY29uc3RyYWludCBpcyBzb2x2ZWQgcGVyIGZyYW1lLiAqL1xuICAgIHRoaXMuaXRlcmF0aW9ucyA9IG9wdGlvbnMuaXRlcmF0aW9ucyB8fCAxMDtcbiAgICAvKiogQHByb3AgX2luZGV4UG9vbCBQb29scyBvZiBpbmRpY2llcyB0byB0cmFjayBob2xlcyBpbiB0aGUgYXJyYXlzLiAqL1xuICAgIHRoaXMuX2luZGV4UG9vbHMgPSB7XG4gICAgICAgIGJvZGllczogW10sXG4gICAgICAgIGZvcmNlczogW10sXG4gICAgICAgIGNvbnN0cmFpbnRzOiBbXVxuICAgIH07XG5cbiAgICB0aGlzLl9lbnRpdHlNYXBzID0ge1xuICAgICAgICBib2RpZXM6IHt9LFxuICAgICAgICBmb3JjZXM6IHt9LFxuICAgICAgICBjb25zdHJhaW50czoge31cbiAgICB9O1xuXG4gICAgdGhpcy5zcGVlZCA9IG9wdGlvbnMuc3BlZWQgfHwgMS4wO1xuICAgIHRoaXMudGltZSA9IDA7XG4gICAgdGhpcy5kZWx0YSA9IDA7XG5cbiAgICB0aGlzLm9yaWdpbiA9IG9wdGlvbnMub3JpZ2luIHx8IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5vcmllbnRhdGlvbiA9IG9wdGlvbnMub3JpZW50YXRpb24gPyBvcHRpb25zLm9yaWVudGF0aW9uLm5vcm1hbGl6ZSgpIDogIG5ldyBRdWF0ZXJuaW9uKCk7XG5cbiAgICB0aGlzLnByZXN0ZXAgPSBbXTtcbiAgICB0aGlzLnBvc3RzdGVwID0gW107XG5cbiAgICB0aGlzLmZyYW1lRGVwZW5kZW50ID0gb3B0aW9ucy5mcmFtZURlcGVuZGVudCB8fCBmYWxzZTtcblxuICAgIHRoaXMudHJhbnNmb3JtQnVmZmVycyA9IHtcbiAgICAgICAgcG9zaXRpb246IFswLCAwLCAwXSxcbiAgICAgICAgcm90YXRpb246IFswLCAwLCAwXVxuICAgIH07XG59XG5cbi8qKlxuICogU2V0IHRoZSBvcmlnaW4gb2YgdGhlIHdvcmxkLlxuICpcbiAqIEBtZXRob2Qgc2V0T3JpZ2luXG4gKiBAY2hhaW5hYmxlXG4gKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBjb21wb25lbnQuXG4gKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBjb21wb25lbnQuXG4gKiBAcGFyYW0ge051bWJlcn0geiBUaGUgeiBjb21wb25lbnQuXG4gKi9cblBoeXNpY3NFbmdpbmUucHJvdG90eXBlLnNldE9yaWdpbiA9IGZ1bmN0aW9uIHNldE9yaWdpbih4LCB5LCB6KSB7XG4gICAgdGhpcy5vcmlnaW4uc2V0KHgsIHksIHopO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG9yaWVudGF0aW9uIG9mIHRoZSB3b3JsZC5cbiAqXG4gKiBAbWV0aG9kIHNldE9yaWVudGF0aW9uXG4gKiBAY2hhaW5hYmxlXG4gKiBAcGFyYW0ge051bWJlcn0gdyBUaGUgdyBjb21wb25lbnQuXG4gKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBjb21wb25lbnQuXG4gKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBjb21wb25lbnQuXG4gKiBAcGFyYW0ge051bWJlcn0geiBUaGUgeiBjb21wb25lbnQuXG4gKi9cblBoeXNpY3NFbmdpbmUucHJvdG90eXBlLnNldE9yaWVudGF0aW9uID0gZnVuY3Rpb24gc2V0T3JpZW50YXRpb24odywgeCwgeSwgeikge1xuICAgIHRoaXMub3JpZW50YXRpb24uc2V0KHcsIHgsIHksIHopLm5vcm1hbGl6ZSgpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQcml2YXRlIGhlbHBlciBtZXRob2QgdG8gc3RvcmUgYW4gZWxlbWVudCBpbiBhIGxpYnJhcnkgYXJyYXkuXG4gKlxuICogQG1ldGhvZCBfYWRkRWxlbWVudFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IFRoZSBib2R5LCBmb3JjZSwgb3IgY29uc3RyYWludCB0byBhZGQuXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5IFdoZXJlIHRvIHN0b3JlIHRoZSBlbGVtZW50LlxuICovXG5mdW5jdGlvbiBfYWRkRWxlbWVudChjb250ZXh0LCBlbGVtZW50LCBrZXkpIHtcbiAgICB2YXIgbWFwID0gY29udGV4dC5fZW50aXR5TWFwc1trZXldO1xuICAgIGlmIChtYXBbZWxlbWVudC5fSURdID09IG51bGwpIHtcbiAgICAgICAgdmFyIGxpYnJhcnkgPSBjb250ZXh0W2tleV07XG4gICAgICAgIHZhciBpbmRleFBvb2wgPSBjb250ZXh0Ll9pbmRleFBvb2xzW2tleV07XG4gICAgICAgIGlmIChpbmRleFBvb2wubGVuZ3RoKSBtYXBbZWxlbWVudC5fSURdID0gaW5kZXhQb29sLnBvcCgpO1xuICAgICAgICBlbHNlIG1hcFtlbGVtZW50Ll9JRF0gPSBsaWJyYXJ5Lmxlbmd0aDtcbiAgICAgICAgbGlicmFyeVttYXBbZWxlbWVudC5fSURdXSA9IGVsZW1lbnQ7XG4gICAgfVxufVxuXG4vKipcbiAqIFByaXZhdGUgaGVscGVyIG1ldGhvZCB0byByZW1vdmUgYW4gZWxlbWVudCBmcm9tIGEgbGlicmFyeSBhcnJheS5cbiAqXG4gKiBAbWV0aG9kIF9yZW1vdmVFbGVtZW50XG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgVGhlIGJvZHksIGZvcmNlLCBvciBjb25zdHJhaW50IHRvIHJlbW92ZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgV2hlcmUgdG8gc3RvcmUgdGhlIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIF9yZW1vdmVFbGVtZW50KGNvbnRleHQsIGVsZW1lbnQsIGtleSkge1xuICAgIHZhciBtYXAgPSBjb250ZXh0Ll9lbnRpdHlNYXBzW2tleV07XG4gICAgdmFyIGluZGV4ID0gbWFwW2VsZW1lbnQuX0lEXTtcbiAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgICBjb250ZXh0Ll9pbmRleFBvb2xzW2tleV0ucHVzaChpbmRleCk7XG4gICAgICAgIGNvbnRleHRba2V5XVtpbmRleF0gPSBudWxsO1xuICAgICAgICBtYXBbZWxlbWVudC5fSURdID0gbnVsbDtcbiAgICB9XG59XG5cbi8qKlxuICogQWRkIGEgZ3JvdXAgb2YgYm9kaWVzLCBmb3JjZSwgb3IgY29uc3RyYWludHMgdG8gdGhlIGVuZ2luZS5cbiAqXG4gKiBAbWV0aG9kIGFkZFxuICogQGNoYWluYWJsZVxuICovXG5QaHlzaWNzRW5naW5lLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoKSB7XG4gICAgZm9yICh2YXIgaiA9IDAsIGxlbmogPSBhcmd1bWVudHMubGVuZ3RoOyBqIDwgbGVuajsgaisrKSB7XG4gICAgICAgIHZhciBlbnRpdHkgPSBhcmd1bWVudHNbal07XG4gICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGVudGl0eS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBlID0gZW50aXR5W2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIFBhcnRpY2xlKSB0aGlzLmFkZEJvZHkoZW50aXR5KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGVudGl0eSBpbnN0YW5jZW9mIENvbnN0cmFpbnQpIHRoaXMuYWRkQ29uc3RyYWludChlbnRpdHkpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZW50aXR5IGluc3RhbmNlb2YgRm9yY2UpIHRoaXMuYWRkRm9yY2UoZW50aXR5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgZ3JvdXAgb2YgYm9kaWVzLCBmb3JjZSwgb3IgY29uc3RyYWludHMgZnJvbSB0aGUgZW5naW5lLlxuICpcbiAqIEBtZXRob2QgcmVtb3ZlXG4gKiBAY2hhaW5hYmxlXG4gKi9cblBoeXNpY3NFbmdpbmUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICBmb3IgKHZhciBqID0gMCwgbGVuaiA9IGFyZ3VtZW50cy5sZW5ndGg7IGogPCBsZW5qOyBqKyspIHtcbiAgICAgICAgdmFyIGVudGl0eSA9IGFyZ3VtZW50c1tqXTtcbiAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZW50aXR5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSBlbnRpdHlbaV07XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgUGFydGljbGUpIHRoaXMucmVtb3ZlQm9keShlbnRpdHkpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZW50aXR5IGluc3RhbmNlb2YgQ29uc3RyYWludCkgdGhpcy5yZW1vdmVDb25zdHJhaW50KGVudGl0eSk7XG4gICAgICAgICAgICBlbHNlIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBGb3JjZSkgdGhpcy5yZW1vdmVGb3JjZShlbnRpdHkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBCZWdpbiB0cmFja2luZyBhIGJvZHkuXG4gKlxuICogQG1ldGhvZCBhZGRCb2R5XG4gKiBAcGFyYW0ge1BhcnRpY2xlfSBib2R5IFRoZSBib2R5IHRvIHRyYWNrLlxuICovXG5QaHlzaWNzRW5naW5lLnByb3RvdHlwZS5hZGRCb2R5ID0gZnVuY3Rpb24gYWRkQm9keShib2R5KSB7XG4gICAgX2FkZEVsZW1lbnQodGhpcywgYm9keSwgJ2JvZGllcycpO1xufTtcblxuLyoqXG4gKiBCZWdpbiB0cmFja2luZyBhIGZvcmNlLlxuICpcbiAqIEBtZXRob2QgYWRkRm9yY2VcbiAqIEBwYXJhbSB7Rm9yY2V9IGZvcmNlIFRoZSBmb3JjZSB0byB0cmFjay5cbiAqL1xuUGh5c2ljc0VuZ2luZS5wcm90b3R5cGUuYWRkRm9yY2UgPSBmdW5jdGlvbiBhZGRGb3JjZShmb3JjZSkge1xuICAgIF9hZGRFbGVtZW50KHRoaXMsIGZvcmNlLCAnZm9yY2VzJyk7XG59O1xuXG4vKipcbiAqIEJlZ2luIHRyYWNraW5nIGEgY29uc3RyYWludC5cbiAqXG4gKiBAbWV0aG9kIGFkZENvbnN0cmFpbnRcbiAqIEBwYXJhbSB7Q29uc3RyYWludH0gY29uc3RyYWludCBUaGUgY29uc3RyYWludCB0byB0cmFjay5cbiAqL1xuUGh5c2ljc0VuZ2luZS5wcm90b3R5cGUuYWRkQ29uc3RyYWludCA9IGZ1bmN0aW9uIGFkZENvbnN0cmFpbnQoY29uc3RyYWludCkge1xuICAgIF9hZGRFbGVtZW50KHRoaXMsIGNvbnN0cmFpbnQsICdjb25zdHJhaW50cycpO1xufTtcblxuLyoqXG4gKiBTdG9wIHRyYWNraW5nIGEgYm9keS5cbiAqXG4gKiBAbWV0aG9kIHJlbW92ZUJvZHlcbiAqIEBwYXJhbSB7UGFydGljbGV9IGJvZHkgVGhlIGJvZHkgdG8gc3RvcCB0cmFja2luZy5cbiAqL1xuUGh5c2ljc0VuZ2luZS5wcm90b3R5cGUucmVtb3ZlQm9keSA9IGZ1bmN0aW9uIHJlbW92ZUJvZHkoYm9keSkge1xuICAgIF9yZW1vdmVFbGVtZW50KHRoaXMsIGJvZHksICdib2RpZXMnKTtcbn07XG5cbi8qKlxuICogU3RvcCB0cmFja2luZyBhIGZvcmNlLlxuICpcbiAqIEBtZXRob2QgcmVtb3ZlRm9yY2VcbiAqIEBwYXJhbSB7Rm9yY2V9IGZvcmNlIFRoZSBmb3JjZSB0byBzdG9wIHRyYWNraW5nLlxuICovXG5QaHlzaWNzRW5naW5lLnByb3RvdHlwZS5yZW1vdmVGb3JjZSA9IGZ1bmN0aW9uIHJlbW92ZUZvcmNlKGZvcmNlKSB7XG4gICAgX3JlbW92ZUVsZW1lbnQodGhpcywgZm9yY2UsICdmb3JjZXMnKTtcbn07XG5cbi8qKlxuICogU3RvcCB0cmFja2luZyBhIGNvbnN0cmFpbnQuXG4gKlxuICogQG1ldGhvZCByZW1vdmVDb25zdHJhaW50XG4gKiBAcGFyYW0ge0NvbnN0cmFpbnR9IGNvbnN0cmFpbnQgVGhlIGNvbnN0cmFpbnQgdG8gc3RvcCB0cmFja2luZy5cbiAqL1xuUGh5c2ljc0VuZ2luZS5wcm90b3R5cGUucmVtb3ZlQ29uc3RyYWludCA9IGZ1bmN0aW9uIHJlbW92ZUNvbnN0cmFpbnQoY29uc3RyYWludCkge1xuICAgIF9yZW1vdmVFbGVtZW50KHRoaXMsIGNvbnN0cmFpbnQsICdjb25zdHJhaW50cycpO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIHBoeXNpY3Mgc3lzdGVtIHRvIHJlZmxlY3QgdGhlIGNoYW5nZXMgc2luY2UgdGhlIGxhc3QgZnJhbWUuIFN0ZXBzIGZvcndhcmQgaW4gaW5jcmVtZW50cyBvZlxuICogUGh5c2ljc0VuZ2luZS5zdGVwLlxuICpcbiAqIEBtZXRob2QgdXBkYXRlXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZVxuICovXG5QaHlzaWNzRW5naW5lLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUodGltZSkge1xuICAgIGlmICh0aGlzLnRpbWUgPT09IDApIHRoaXMudGltZSA9IHRpbWU7XG5cbiAgICB2YXIgYm9kaWVzID0gdGhpcy5ib2RpZXM7XG4gICAgdmFyIGZvcmNlcyA9IHRoaXMuZm9yY2VzO1xuICAgIHZhciBjb25zdHJhaW50cyA9IHRoaXMuY29uc3RyYWludHM7XG5cbiAgICB2YXIgZnJhbWVEZXBlbmRlbnQgPSB0aGlzLmZyYW1lRGVwZW5kZW50O1xuICAgIHZhciBzdGVwID0gdGhpcy5zdGVwO1xuICAgIHZhciBkdCA9IHN0ZXAgKiAwLjAwMTtcbiAgICB2YXIgc3BlZWQgPSB0aGlzLnNwZWVkO1xuXG4gICAgdmFyIGRlbHRhID0gdGhpcy5kZWx0YTtcbiAgICBkZWx0YSArPSAodGltZSAtIHRoaXMudGltZSkgKiBzcGVlZDtcbiAgICB0aGlzLnRpbWUgPSB0aW1lO1xuXG4gICAgdmFyIGksIGxlbjtcbiAgICB2YXIgZm9yY2UsIGJvZHksIGNvbnN0cmFpbnQ7XG5cbiAgICB3aGlsZShkZWx0YSA+IHN0ZXApIHtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gdGhpcy5wcmVzdGVwLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnByZXN0ZXBbaV0odGltZSwgZHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIEZvcmNlcyBvbiBwYXJ0aWNsZXNcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gZm9yY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBmb3JjZSA9IGZvcmNlc1tpXTtcbiAgICAgICAgICAgIGlmIChmb3JjZSA9PT0gbnVsbCkgY29udGludWU7XG4gICAgICAgICAgICBmb3JjZS51cGRhdGUodGltZSwgZHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGVudGF0aXZlbHkgdXBkYXRlIHZlbG9jaXRpZXNcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gYm9kaWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBib2R5ID0gYm9kaWVzW2ldO1xuICAgICAgICAgICAgaWYgKGJvZHkgPT09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgX2ludGVncmF0ZVZlbG9jaXR5KGJvZHksIGR0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFByZXAgY29uc3RyYWludHMgZm9yIHNvbHZlclxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjb25zdHJhaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29uc3RyYWludCA9IGNvbnN0cmFpbnRzW2ldO1xuICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnQgPT09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3RyYWludC51cGRhdGUodGltZSwgZHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSXRlcmF0aXZlbHkgcmVzb2x2ZSBjb25zdHJhaW50c1xuICAgICAgICBmb3IgKHZhciBqID0gMCwgbnVtSXRlcmF0aW9ucyA9IHRoaXMuaXRlcmF0aW9uczsgaiA8IG51bUl0ZXJhdGlvbnM7IGorKykge1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gY29uc3RyYWludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdHJhaW50ID0gY29uc3RyYWludHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnQgPT09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0cmFpbnQucmVzb2x2ZSh0aW1lLCBkdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbmNyZW1lbnQgcG9zaXRpb25zIGFuZCBvcmllbnRhdGlvbnNcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gYm9kaWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBib2R5ID0gYm9kaWVzW2ldO1xuICAgICAgICAgICAgaWYgKGJvZHkgPT09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgX2ludGVncmF0ZVBvc2UoYm9keSwgZHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gdGhpcy5wb3N0c3RlcC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdGhpcy5wb3N0c3RlcFtpXSh0aW1lLCBkdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZnJhbWVEZXBlbmRlbnQpIGRlbHRhID0gMDtcbiAgICAgICAgZWxzZSBkZWx0YSAtPSBzdGVwO1xuICAgIH1cblxuICAgIHRoaXMuZGVsdGEgPSBkZWx0YTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSB0cmFuc2Zvcm0gZXF1aXZhbGVudCB0byB0aGUgUGFydGljbGUncyBwb3NpdGlvbiBhbmQgb3JpZW50YXRpb24uXG4gKlxuICogQG1ldGhvZCBnZXRUcmFuc2Zvcm1cbiAqIEByZXR1cm4ge09iamVjdH0gUG9zaXRpb24gYW5kIHJvdGF0aW9uIG9mIHRoZSBib3ksIHRha2luZyBpbnRvIGFjY291bnRcbiAqIHRoZSBvcmlnaW4gYW5kIG9yaWVudGF0aW9uIG9mIHRoZSB3b3JsZC5cbiAqL1xuUGh5c2ljc0VuZ2luZS5wcm90b3R5cGUuZ2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gZ2V0VHJhbnNmb3JtKGJvZHkpIHtcbiAgICB2YXIgbyA9IHRoaXMub3JpZ2luO1xuICAgIHZhciBvcSA9IHRoaXMub3JpZW50YXRpb247XG4gICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtQnVmZmVycztcblxuICAgIHZhciBwID0gYm9keS5wb3NpdGlvbjtcbiAgICB2YXIgcSA9IGJvZHkub3JpZW50YXRpb247XG4gICAgdmFyIHJvdCA9IHE7XG4gICAgdmFyIGxvYyA9IHA7XG5cbiAgICBpZiAob3EudyAhPT0gMSkge1xuICAgICAgICByb3QgPSBRdWF0ZXJuaW9uLm11bHRpcGx5KHEsIG9xLCBRVUFUX1JFR0lTVEVSKTtcbiAgICAgICAgbG9jID0gb3Eucm90YXRlVmVjdG9yKHAsIFZFQ19SRUdJU1RFUik7XG4gICAgfVxuICAgIHZhciBaWVggPSByb3QudG9FdWxlcihaWVhfUkVHSVNURVIpO1xuXG4gICAgdHJhbnNmb3JtLnBvc2l0aW9uWzBdID0gby54K2xvYy54O1xuICAgIHRyYW5zZm9ybS5wb3NpdGlvblsxXSA9IG8ueStsb2MueTtcbiAgICB0cmFuc2Zvcm0ucG9zaXRpb25bMl0gPSBvLnorbG9jLno7XG5cbiAgICB0cmFuc2Zvcm0ucm90YXRpb25bMF0gPSBaWVgueDtcbiAgICB0cmFuc2Zvcm0ucm90YXRpb25bMV0gPSBaWVgueTtcbiAgICB0cmFuc2Zvcm0ucm90YXRpb25bMl0gPSBaWVguejtcblxuICAgIHJldHVybiB0cmFuc2Zvcm07XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgUGFydGljbGUgbW9tZW50YSBiYXNlZCBvZmYgb2YgY3VycmVudCBpbmNpZGVudCBmb3JjZSBhbmQgdG9ycXVlLlxuICpcbiAqIEBtZXRob2QgX2ludGVncmF0ZVZlbG9jaXR5XG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtQYXJ0aWNsZX0gYm9keVxuICogQHBhcmFtIHtOdW1iZXJ9IGR0IGRlbHRhIHRpbWVcbiAqL1xuZnVuY3Rpb24gX2ludGVncmF0ZVZlbG9jaXR5KGJvZHksIGR0KSB7XG4gICAgYm9keS5tb21lbnR1bS5hZGQoVmVjMy5zY2FsZShib2R5LmZvcmNlLCBkdCwgREVMVEFfUkVHSVNURVIpKTtcbiAgICBib2R5LmFuZ3VsYXJNb21lbnR1bS5hZGQoVmVjMy5zY2FsZShib2R5LnRvcnF1ZSwgZHQsIERFTFRBX1JFR0lTVEVSKSk7XG4gICAgVmVjMy5zY2FsZShib2R5Lm1vbWVudHVtLCBib2R5LmludmVyc2VNYXNzLCBib2R5LnZlbG9jaXR5KTtcbiAgICBib2R5LmludmVyc2VJbmVydGlhLnZlY3Rvck11bHRpcGx5KGJvZHkuYW5ndWxhck1vbWVudHVtLCBib2R5LmFuZ3VsYXJWZWxvY2l0eSk7XG4gICAgYm9keS5mb3JjZS5jbGVhcigpO1xuICAgIGJvZHkudG9ycXVlLmNsZWFyKCk7XG59XG5cbi8qKlxuICogVXBkYXRlIHRoZSBQYXJ0aWNsZSBwb3NpdGlvbiBhbmQgb3JpZW50YXRpb24gYmFzZWQgb2ZmIGN1cnJlbnQgdHJhbnNsYXRpb25hbCBhbmQgYW5ndWxhciB2ZWxvY2l0aWVzLlxuICpcbiAqIEBtZXRob2QgX2ludGVncmF0ZVBvc2VcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1BhcnRpY2xlfSBib2R5XG4gKiBAcGFyYW0gZHQge051bWJlcn0gZGVsdGEgdGltZVxuICovXG5mdW5jdGlvbiBfaW50ZWdyYXRlUG9zZShib2R5LCBkdCkge1xuICAgIGlmIChib2R5LnJlc3RyaWN0aW9ucyAhPT0gMCkge1xuICAgICAgICB2YXIgcmVzdHJpY3Rpb25zID0gYm9keS5yZXN0cmljdGlvbnM7XG4gICAgICAgIHZhciB4ID0gbnVsbDtcbiAgICAgICAgdmFyIHkgPSBudWxsO1xuICAgICAgICB2YXIgeiA9IG51bGw7XG4gICAgICAgIHZhciBheCA9IG51bGw7XG4gICAgICAgIHZhciBheSA9IG51bGw7XG4gICAgICAgIHZhciBheiA9IG51bGw7XG5cbiAgICAgICAgaWYgKHJlc3RyaWN0aW9ucyAmIDMyKSB4ID0gMDtcbiAgICAgICAgaWYgKHJlc3RyaWN0aW9ucyAmIDE2KSB5ID0gMDtcbiAgICAgICAgaWYgKHJlc3RyaWN0aW9ucyAmIDgpIHogPSAwO1xuICAgICAgICBpZiAocmVzdHJpY3Rpb25zICYgNCkgYXggPSAwO1xuICAgICAgICBpZiAocmVzdHJpY3Rpb25zICYgMikgYXkgPSAwO1xuICAgICAgICBpZiAocmVzdHJpY3Rpb25zICYgMSkgYXogPSAwO1xuXG4gICAgICAgIGlmICh4ICE9PSBudWxsIHx8IHkgIT09IG51bGwgfHwgeiAhPT0gbnVsbCkgYm9keS5zZXRWZWxvY2l0eSh4LHkseik7XG4gICAgICAgIGlmIChheCAhPT0gbnVsbCB8fCBheSAhPT0gbnVsbCB8fCBheiAhPT0gbnVsbCkgYm9keS5zZXRBbmd1bGFyVmVsb2NpdHkoYXgsIGF5LCBheik7XG4gICAgfVxuXG4gICAgYm9keS5wb3NpdGlvbi5hZGQoVmVjMy5zY2FsZShib2R5LnZlbG9jaXR5LCBkdCwgREVMVEFfUkVHSVNURVIpKTtcblxuICAgIHZhciB3ID0gYm9keS5hbmd1bGFyVmVsb2NpdHk7XG4gICAgdmFyIHEgPSBib2R5Lm9yaWVudGF0aW9uO1xuICAgIHZhciB3eCA9IHcueDtcbiAgICB2YXIgd3kgPSB3Lnk7XG4gICAgdmFyIHd6ID0gdy56O1xuXG4gICAgdmFyIHF3ID0gcS53O1xuICAgIHZhciBxeCA9IHEueDtcbiAgICB2YXIgcXkgPSBxLnk7XG4gICAgdmFyIHF6ID0gcS56O1xuXG4gICAgdmFyIGhkdCA9IGR0ICogMC41O1xuICAgIHEudyArPSAoLXd4ICogcXggLSB3eSAqIHF5IC0gd3ogKiBxeikgKiBoZHQ7XG4gICAgcS54ICs9ICh3eCAqIHF3ICsgd3kgKiBxeiAtIHd6ICogcXkpICogaGR0O1xuICAgIHEueSArPSAod3kgKiBxdyArIHd6ICogcXggLSB3eCAqIHF6KSAqIGhkdDtcbiAgICBxLnogKz0gKHd6ICogcXcgKyB3eCAqIHF5IC0gd3kgKiBxeCkgKiBoZHQ7XG5cbiAgICBxLm5vcm1hbGl6ZSgpO1xuXG4gICAgYm9keS51cGRhdGVJbmVydGlhKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUGh5c2ljc0VuZ2luZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFZlYzMgPSByZXF1aXJlKCdmYW1vdXMtbWF0aCcpLlZlYzM7XG52YXIgQ29udmV4Qm9keUZhY3RvcnkgPSByZXF1aXJlKCcuL0NvbnZleEJvZHlGYWN0b3J5Jyk7XG5cbnZhciBfQm94ID0gQ29udmV4Qm9keUZhY3RvcnkoW1xuICAgICAgICAgICAgLy8gT3JkZXI6IGJhY2stbGVmdCxiYWNrLXJpZ2h0LGZyb250LWxlZnQsZnJvbnQtcmlnaHRcbiAgICAgICAgICAgIC8vIFRvcCBoYWxmXG4gICAgICAgICAgICBuZXcgVmVjMygtMTAwLCAtMTAwLCAtMTAwKSxcbiAgICAgICAgICAgIG5ldyBWZWMzKDEwMCwgLTEwMCwgLTEwMCksXG4gICAgICAgICAgICBuZXcgVmVjMygtMTAwLCAtMTAwLCAxMDApLFxuICAgICAgICAgICAgbmV3IFZlYzMoMTAwLCAtMTAwLCAxMDApLFxuICAgICAgICAgICAgLy8gQm90dG9tIGhhbGZcbiAgICAgICAgICAgIG5ldyBWZWMzKC0xMDAsIDEwMCwgLTEwMCksXG4gICAgICAgICAgICBuZXcgVmVjMygxMDAsIDEwMCwgLTEwMCksXG4gICAgICAgICAgICBuZXcgVmVjMygtMTAwLCAxMDAsIDEwMCksXG4gICAgICAgICAgICBuZXcgVmVjMygxMDAsIDEwMCwgMTAwKSxcbiAgICAgICAgXSk7XG5cbi8qKlxuICogQGNsYXNzIEJveFxuICogQGV4dGVuZHMgUGFydGljbGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIEJveChvcHRpb25zKSB7XG4gICAgX0JveC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIHRoaXMubm9ybWFscyA9IFtcbiAgICAgICAgLy8gT3JkZXI6IHRvcCwgcmlnaHQsIGZyb250XG4gICAgICAgIG5ldyBWZWMzKDAsIDEsIDApLFxuICAgICAgICBuZXcgVmVjMygxLCAwLCAwKSxcbiAgICAgICAgbmV3IFZlYzMoMCwgMCwgMSlcbiAgICBdO1xuXG4gICAgdGhpcy50eXBlID0gMSA8PCAxO1xufVxuXG5Cb3gucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShfQm94LnByb3RvdHlwZSk7XG5Cb3gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQm94O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJveDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFBhcnRpY2xlID0gcmVxdWlyZSgnLi4vYm9kaWVzL1BhcnRpY2xlJyk7XG52YXIgTWF0MzMgPSByZXF1aXJlKCdmYW1vdXMtbWF0aCcpLk1hdDMzO1xudmFyIFZlYzMgPSByZXF1aXJlKCdmYW1vdXMtbWF0aCcpLlZlYzM7XG52YXIgR2VvbWV0cnkgPSByZXF1aXJlKCcuLi9HZW9tZXRyeScpO1xudmFyIENvbnZleEh1bGwgPSBHZW9tZXRyeS5Db252ZXhIdWxsO1xuXG52YXIgVEVNUF9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogUmV0dXJucyBhIGNvbnN0cnVjdG9yIGZvciBhIHBoeXNpY2FsIGJvZHkgcmVmbGVjdGluZyB0aGUgc2hhcGUgZGVmaW5lZCBieSBpbnB1dCBDb252ZXhIdWxsIG9yIFZlYzMgYXJyYXkuXG4gKlxuICogQG1ldGhvZCBDb252ZXhCb2R5RmFjdG9yeVxuICogQHBhcmFtIHtDb252ZXhIdWxsIHwgVmVjM1tdfSBodWxsXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGNvbnN0cnVjdG9yLlxuICovXG5mdW5jdGlvbiBDb252ZXhCb2R5RmFjdG9yeShodWxsKSB7XG4gICAgaWYgKCEoaHVsbCBpbnN0YW5jZW9mIENvbnZleEh1bGwpKSB7XG4gICAgICAgIGlmICghKGh1bGwgaW5zdGFuY2VvZiBBcnJheSkpIHRocm93IG5ldyBFcnJvcignQ29udmV4Qm9keUZhY3RvcnkgcmVxdWlyZXMgYSBDb252ZXhIdWxsIG9iamVjdCBvciBhbiBhcnJheSBvZiBWZWMzXFwncyBhcyBpbnB1dC4nKTtcbiAgICAgICAgZWxzZSBodWxsID0gbmV3IENvbnZleEh1bGwoaHVsbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJvZHkgY2xhc3Mgd2l0aCBpbmVydGlhIGFuZCB2ZXJ0aWNlcyBpbmZlcnJlZCBmcm9tIHRoZSBpbnB1dCBDb252ZXhIdWxsIG9yIFZlYzMgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAY2xhc3MgQ29udmV4Qm9keVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIGhhc2guXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29udmV4Qm9keShvcHRpb25zKSB7XG4gICAgICAgIFBhcnRpY2xlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgICAgICAgdmFyIG9yaWdpbmFsU2l6ZSA9IGh1bGwucG9seWhlZHJhbFByb3BlcnRpZXMuc2l6ZTtcbiAgICAgICAgdmFyIHNpemUgPSBvcHRpb25zLnNpemUgfHwgb3JpZ2luYWxTaXplO1xuXG4gICAgICAgIHZhciBzY2FsZVggPSBzaXplWzBdIC8gb3JpZ2luYWxTaXplWzBdO1xuICAgICAgICB2YXIgc2NhbGVZID0gc2l6ZVsxXSAvIG9yaWdpbmFsU2l6ZVsxXTtcbiAgICAgICAgdmFyIHNjYWxlWiA9IHNpemVbMl0gLyBvcmlnaW5hbFNpemVbMl07XG5cbiAgICAgICAgdGhpcy5fc2NhbGUgPSBbc2NhbGVYLCBzY2FsZVksIHNjYWxlWl07XG5cbiAgICAgICAgdmFyIFQgPSBuZXcgTWF0MzMoW3NjYWxlWCwgMCwgMCwgMCwgc2NhbGVZLCAwLCAwLCAwLCBzY2FsZVpdKTtcblxuICAgICAgICB0aGlzLmh1bGwgPSBodWxsO1xuXG4gICAgICAgIHRoaXMudmVydGljZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGh1bGwudmVydGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMudmVydGljZXMucHVzaChULnZlY3Rvck11bHRpcGx5KGh1bGwudmVydGljZXNbaV0sIG5ldyBWZWMzKCkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9jb21wdXRlSW5lcnRpYVByb3BlcnRpZXMuY2FsbCh0aGlzLCBUKTtcbiAgICAgICAgdGhpcy5pbnZlcnNlSW5lcnRpYS5jb3B5KHRoaXMubG9jYWxJbnZlcnNlSW5lcnRpYSk7XG4gICAgICAgIHRoaXMudXBkYXRlSW5lcnRpYSgpO1xuICAgIH1cblxuICAgIENvbnZleEJvZHkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQYXJ0aWNsZS5wcm90b3R5cGUpO1xuICAgIENvbnZleEJvZHkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29udmV4Qm9keTtcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgc2l6ZSBhbmQgcmVjYWxjdWxhdGVcbiAgICAgKlxuICAgICAqIEBtZXRob2Qgc2V0U2l6ZVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBzcGFuLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IHNwYW4uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHogVGhlIHogc3Bhbi5cbiAgICAgKi9cbiAgICBDb252ZXhCb2R5LnByb3RvdHlwZS5zZXRTaXplID0gZnVuY3Rpb24gc2V0U2l6ZSh4LHkseikge1xuICAgICAgICB2YXIgb3JpZ2luYWxTaXplID0gaHVsbC5wb2x5aGVkcmFsUHJvcGVydGllcy5zaXplO1xuXG4gICAgICAgIHRoaXMuc2l6ZVswXSA9IHg7XG4gICAgICAgIHRoaXMuc2l6ZVsxXSA9IHk7XG4gICAgICAgIHRoaXMuc2l6ZVsyXSA9IHo7XG5cbiAgICAgICAgdmFyIHNjYWxlWCA9IHggLyBvcmlnaW5hbFNpemVbMF07XG4gICAgICAgIHZhciBzY2FsZVkgPSB5IC8gb3JpZ2luYWxTaXplWzFdO1xuICAgICAgICB2YXIgc2NhbGVaID0geiAvIG9yaWdpbmFsU2l6ZVsyXTtcblxuICAgICAgICB0aGlzLl9zY2FsZSA9IFtzY2FsZVgsIHNjYWxlWSwgc2NhbGVaXTtcblxuICAgICAgICB2YXIgVCA9IG5ldyBNYXQzMyhbc2NhbGVYLCAwLCAwLCAwLCBzY2FsZVksIDAsIDAsIDAsIHNjYWxlWl0pO1xuXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBodWxsLnZlcnRpY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBULnZlY3Rvck11bHRpcGx5KGh1bGwudmVydGljZXNbaV0sIHZlcnRpY2VzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGxvY2FsIGluZXJ0aWEgYW5kIGludmVyc2UgaW5lcnRpYSB0byByZWZsZWN0IHRoZSBjdXJyZW50IHNpemUuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZUxvY2FsSW5lcnRpYVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBDb252ZXhCb2R5LnByb3RvdHlwZS51cGRhdGVMb2NhbEluZXJ0aWEgPSBmdW5jdGlvbiB1cGRhdGVJbmVydGlhKCkge1xuICAgICAgICB2YXIgc2NhbGVYID0gdGhpcy5fc2NhbGVbMF07XG4gICAgICAgIHZhciBzY2FsZVkgPSB0aGlzLl9zY2FsZVsxXTtcbiAgICAgICAgdmFyIHNjYWxlWiA9IHRoaXMuX3NjYWxlWzJdO1xuXG4gICAgICAgIHZhciBUID0gbmV3IE1hdDMzKFtzY2FsZVgsIDAsIDAsIDAsIHNjYWxlWSwgMCwgMCwgMCwgc2NhbGVaXSk7XG5cbiAgICAgICAgX2NvbXB1dGVJbmVydGlhUHJvcGVydGllcy5jYWxsKHRoaXMsIFQpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgdmVydGV4IGZ1cnRoZXN0IGluIGEgZGlyZWN0aW9uLiBVc2VkIGludGVybmFsbHkgZm9yIGNvbGxpc2lvbiBkZXRlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHN1cHBvcnRcbiAgICAgKiBAcmV0dXJuIHtWZWMzfSBUaGUgZnVydGhlc3QgdmVydGV4LlxuICAgICAqL1xuICAgIENvbnZleEJvZHkucHJvdG90eXBlLnN1cHBvcnQgPSBmdW5jdGlvbiBzdXBwb3J0KGRpcmVjdGlvbikge1xuICAgICAgICB2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xuICAgICAgICB2YXIgdmVydGV4LCBkb3QsIGZ1cnRoZXN0O1xuICAgICAgICB2YXIgbWF4ID0gLUluZmluaXR5O1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdmVydGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZlcnRleCA9IHZlcnRpY2VzW2ldO1xuICAgICAgICAgICAgZG90ID0gVmVjMy5kb3QodmVydGV4LGRpcmVjdGlvbik7XG4gICAgICAgICAgICBpZiAoZG90ID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgZnVydGhlc3QgPSB2ZXJ0ZXg7XG4gICAgICAgICAgICAgICAgbWF4ID0gZG90O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdXJ0aGVzdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHZlcnRpY2VzIHRvIHJlZmxlY3QgY3VycmVudCBvcmllbnRhdGlvbi5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgdXBkYXRlU2hhcGVcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgQ29udmV4Qm9keS5wcm90b3R5cGUudXBkYXRlU2hhcGUgPSBmdW5jdGlvbiB1cGRhdGVTaGFwZSgpIHtcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcztcbiAgICAgICAgdmFyIHEgPSB0aGlzLm9yaWVudGF0aW9uO1xuICAgICAgICB2YXIgbW9kZWxWZXJ0aWNlcyA9IHRoaXMuaHVsbC52ZXJ0aWNlcztcblxuICAgICAgICB2YXIgc2NhbGVYID0gdGhpcy5fc2NhbGVbMF07XG4gICAgICAgIHZhciBzY2FsZVkgPSB0aGlzLl9zY2FsZVsxXTtcbiAgICAgICAgdmFyIHNjYWxlWiA9IHRoaXMuX3NjYWxlWzJdO1xuXG4gICAgICAgIHZhciB0ID0gVEVNUF9SRUdJU1RFUjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0LmNvcHkobW9kZWxWZXJ0aWNlc1tpXSk7XG4gICAgICAgICAgICB0LnggKj0gc2NhbGVYO1xuICAgICAgICAgICAgdC55ICo9IHNjYWxlWTtcbiAgICAgICAgICAgIHQueiAqPSBzY2FsZVo7XG4gICAgICAgICAgICBWZWMzLmFwcGx5Um90YXRpb24odCwgcSwgdmVydGljZXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHJldHVybiBDb252ZXhCb2R5O1xufVxuXG4vKipcbiAqIERldGVybWluZXMgbWFzcyBhbmQgaW5lcnRpYSB0ZW5zb3IgYmFzZWQgb2ZmIHRoZSBkZW5zaXR5LCBzaXplLCBhbmQgZmFjZXQgaW5mb3JtYXRpb24gb2YgdGhlIHBvbHloZWRyb24uXG4gKlxuICogQG1ldGhvZCBfY29tcHV0ZUluZXJ0aWFQcm9wZXJ0aWVzXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtNYXQzM30gVCBUaGUgbWF0cml4IHRyYW5zZm9ybWluZyB0aGUgaW50aWFsIHNldCBvZiB2ZXJ0aWNlcyB0byBhIHNldCByZWZsZWN0aW5nIHRoZSBib2R5IHNpemUuXG4gKi9cbmZ1bmN0aW9uIF9jb21wdXRlSW5lcnRpYVByb3BlcnRpZXMoVCkge1xuICAgIHZhciBwb2x5aGVkcmFsUHJvcGVydGllcyA9IHRoaXMuaHVsbC5wb2x5aGVkcmFsUHJvcGVydGllcztcbiAgICB2YXIgVF92YWx1ZXMgPSBULmdldCgpO1xuICAgIHZhciBkZXRUID0gVF92YWx1ZXNbMF0gKiBUX3ZhbHVlc1s0XSAqIFRfdmFsdWVzWzhdO1xuXG4gICAgdmFyIEVfbyA9IHBvbHloZWRyYWxQcm9wZXJ0aWVzLmV1bGVyVGVuc29yO1xuXG4gICAgdmFyIEUgPSBuZXcgTWF0MzMoKTtcbiAgICBNYXQzMy5tdWx0aXBseShULCBFX28sIEUpO1xuICAgIE1hdDMzLm11bHRpcGx5KEUsIFQsIEUpO1xuICAgIHZhciBFX3ZhbHVlcyA9IEUuZ2V0KCk7XG5cbiAgICB2YXIgRXh4ID0gRV92YWx1ZXNbMF07XG4gICAgdmFyIEV5eSA9IEVfdmFsdWVzWzRdO1xuICAgIHZhciBFenogPSBFX3ZhbHVlc1s4XTtcbiAgICB2YXIgRXh5ID0gRV92YWx1ZXNbMV07XG4gICAgdmFyIEV5eiA9IEVfdmFsdWVzWzddO1xuICAgIHZhciBFeHogPSBFX3ZhbHVlc1syXTtcblxuICAgIHZhciBuZXdWb2x1bWUgPSBwb2x5aGVkcmFsUHJvcGVydGllcy52b2x1bWUgKiBkZXRUO1xuICAgIHZhciBtYXNzID0gdGhpcy5tYXNzO1xuICAgIHZhciBkZW5zaXR5ID0gbWFzcyAvIG5ld1ZvbHVtZTtcblxuICAgIHZhciBJeHggPSBFeXkgKyBFeno7XG4gICAgdmFyIEl5eSA9IEV4eCArIEV6ejtcbiAgICB2YXIgSXp6ID0gRXh4ICsgRXl5O1xuICAgIHZhciBJeHkgPSAtRXh5O1xuICAgIHZhciBJeXogPSAtRXl6O1xuICAgIHZhciBJeHogPSAtRXh6O1xuXG4gICAgdmFyIGNlbnRyb2lkID0gcG9seWhlZHJhbFByb3BlcnRpZXMuY2VudHJvaWQ7XG5cbiAgICBJeHggLT0gbmV3Vm9sdW1lICogKGNlbnRyb2lkLnkgKiBjZW50cm9pZC55ICsgY2VudHJvaWQueiAqIGNlbnRyb2lkLnopO1xuICAgIEl5eSAtPSBuZXdWb2x1bWUgKiAoY2VudHJvaWQueiAqIGNlbnRyb2lkLnogKyBjZW50cm9pZC54ICogY2VudHJvaWQueCk7XG4gICAgSXp6IC09IG5ld1ZvbHVtZSAqIChjZW50cm9pZC54ICogY2VudHJvaWQueCArIGNlbnRyb2lkLnkgKiBjZW50cm9pZC55KTtcbiAgICBJeHkgKz0gbmV3Vm9sdW1lICogY2VudHJvaWQueCAqIGNlbnRyb2lkLnk7XG4gICAgSXl6ICs9IG5ld1ZvbHVtZSAqIGNlbnRyb2lkLnkgKiBjZW50cm9pZC56O1xuICAgIEl4eiArPSBuZXdWb2x1bWUgKiBjZW50cm9pZC56ICogY2VudHJvaWQueDtcblxuICAgIEl4eCAqPSBkZW5zaXR5ICogZGV0VDtcbiAgICBJeXkgKj0gZGVuc2l0eSAqIGRldFQ7XG4gICAgSXp6ICo9IGRlbnNpdHkgKiBkZXRUO1xuICAgIEl4eSAqPSBkZW5zaXR5ICogZGV0VDtcbiAgICBJeXogKj0gZGVuc2l0eSAqIGRldFQ7XG4gICAgSXh6ICo9IGRlbnNpdHkgKiBkZXRUO1xuXG4gICAgdmFyIGluZXJ0aWEgPSBbXG4gICAgICAgIEl4eCwgSXh5LCBJeHosXG4gICAgICAgIEl4eSwgSXl5LCBJeXosXG4gICAgICAgIEl4eiwgSXl6LCBJenpcbiAgICBdO1xuXG4gICAgdGhpcy5sb2NhbEluZXJ0aWEuc2V0KGluZXJ0aWEpO1xuICAgIE1hdDMzLmludmVyc2UodGhpcy5sb2NhbEluZXJ0aWEsIHRoaXMubG9jYWxJbnZlcnNlSW5lcnRpYSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udmV4Qm9keUZhY3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBWZWMzID0gcmVxdWlyZSgnZmFtb3VzLW1hdGgnKS5WZWMzO1xudmFyIFF1YXRlcm5pb24gPSByZXF1aXJlKCdmYW1vdXMtbWF0aCcpLlF1YXRlcm5pb247XG52YXIgTWF0MzMgPSByZXF1aXJlKCdmYW1vdXMtbWF0aCcpLk1hdDMzO1xuXG52YXIgQ2FsbGJhY2tTdG9yZSA9IHJlcXVpcmUoJ2ZhbW91cy11dGlsaXRpZXMnKS5DYWxsYmFja1N0b3JlO1xuXG52YXIgWkVST19WRUNUT1IgPSBuZXcgVmVjMygpO1xuXG52YXIgTUFUMV9SRUdJU1RFUiA9IG5ldyBNYXQzMygpO1xuXG52YXIgX0lEID0gMDtcbi8qKlxuICogRnVuZGFtZW50YWwgcGh5c2ljYWwgYm9keS4gTWFpbnRhaW5zIHRyYW5zbGF0aW9uYWwgYW5kIGFuZ3VsYXIgbW9tZW50dW0sIHBvc2l0aW9uIGFuZCBvcmllbnRhdGlvbiwgYW5kIG90aGVyIHByb3BlcnRpZXNcbiAqIHN1Y2ggYXMgc2l6ZSBhbmQgY29lZmZpY2llbnRzIG9mIHJlc3RpdHV0aW9uIGFuZCBmcmljdGlvbiB1c2VkIGluIGNvbGxpc2lvbiByZXNwb25zZS5cbiAqXG4gKiBAY2xhc3MgUGFydGljbGVcbiAqIEBleHRlbmRzIFBhcnRpY2xlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBzZXRzIHRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSBQYXJ0aWNsZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFBhcnRpY2xlKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHRoaXMuZXZlbnRzID0gbmV3IENhbGxiYWNrU3RvcmUoKTtcblxuICAgIHRoaXMucG9zaXRpb24gPSBvcHRpb25zLnBvc2l0aW9uIHx8IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5vcmllbnRhdGlvbiA9IG9wdGlvbnMub3JpZW50YXRpb24gfHwgbmV3IFF1YXRlcm5pb24oKTtcblxuICAgIHRoaXMudmVsb2NpdHkgPSBuZXcgVmVjMygpO1xuICAgIHRoaXMubW9tZW50dW0gPSBuZXcgVmVjMygpO1xuICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5ID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLmFuZ3VsYXJNb21lbnR1bSA9IG5ldyBWZWMzKCk7XG5cbiAgICB0aGlzLm1hc3MgPSBvcHRpb25zLm1hc3MgfHwgMTtcbiAgICB0aGlzLmludmVyc2VNYXNzID0gMSAvIHRoaXMubWFzcztcblxuICAgIHRoaXMuZm9yY2UgPSBuZXcgVmVjMygpO1xuICAgIHRoaXMudG9ycXVlID0gbmV3IFZlYzMoKTtcblxuICAgIHRoaXMucmVzdGl0dXRpb24gPSBvcHRpb25zLnJlc3RpdHV0aW9uICE9IG51bGwgPyBvcHRpb25zLnJlc3RpdHV0aW9uIDogMC40O1xuICAgIHRoaXMuZnJpY3Rpb24gPSBvcHRpb25zLmZyaWN0aW9uICE9IG51bGwgPyBvcHRpb25zLmZyaWN0aW9uIDogMC4yO1xuXG4gICAgdGhpcy5pbnZlcnNlSW5lcnRpYSA9IG5ldyBNYXQzMyhbMCwwLDAsMCwwLDAsMCwwLDBdKTtcblxuICAgIHRoaXMubG9jYWxJbmVydGlhID0gbmV3IE1hdDMzKFswLDAsMCwwLDAsMCwwLDAsMF0pO1xuICAgIHRoaXMubG9jYWxJbnZlcnNlSW5lcnRpYSA9IG5ldyBNYXQzMyhbMCwwLDAsMCwwLDAsMCwwLDBdKTtcblxuICAgIHRoaXMuc2l6ZSA9IG9wdGlvbnMuc2l6ZSB8fCBbMCwgMCwgMF07XG5cbiAgICB2YXIgdiA9IG9wdGlvbnMudmVsb2NpdHk7XG4gICAgdmFyIHcgPSBvcHRpb25zLmFuZ3VsYXJWZWxvY2l0eTtcbiAgICBpZiAodikgdGhpcy5zZXRWZWxvY2l0eSh2LngsIHYueSwgdi56KTtcbiAgICBpZiAodykgdGhpcy5zZXRBbmd1bGFyVmVsb2NpdHkody54LCB3LnksIHcueik7XG5cbiAgICB0aGlzLnJlc3RyaWN0aW9ucyA9IDA7XG4gICAgdGhpcy5zZXRSZXN0cmljdGlvbnMuYXBwbHkodGhpcywgb3B0aW9ucy5yZXN0cmljdGlvbnMgfHwgW10pO1xuXG4gICAgdGhpcy5jb2xsaXNpb25NYXNrID0gb3B0aW9ucy5jb2xsaXNpb25NYXNrIHx8IDE7XG4gICAgdGhpcy5jb2xsaXNpb25Hcm91cCA9IG9wdGlvbnMuY29sbGlzaW9uR3JvdXAgfHwgMTtcblxuICAgIHRoaXMudHlwZSA9IDEgPDwgMDtcblxuICAgIHRoaXMuX0lEID0gX0lEKys7XG59XG5cbi8qKlxuICogR2V0dGVyIGZvciB0aGUgcmVzdHJpY3Rpb24gYml0bWFzay4gQ29udmVydHMgdGhlIHJlc3RyaWN0aW9ucyB0byB0aGVpciBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG4gKlxuICogQG1ldGhvZCBnZXRSZXN0cmljdGlvbnNcbiAqIEByZXR1cm4ge1N0cmluZ1tdfSByZXN0cmljdGlvbnNcbiAqL1xuUGFydGljbGUucHJvdG90eXBlLmdldFJlc3RyaWN0aW9ucyA9IGZ1bmN0aW9uIGdldFJlc3RyaWN0aW9ucygpIHtcbiAgICB2YXIgbGluZWFyID0gJyc7XG4gICAgdmFyIGFuZ3VsYXIgPSAnJztcbiAgICB2YXIgcmVzdHJpY3Rpb25zID0gdGhpcy5yZXN0cmljdGlvbnM7XG4gICAgaWYgKHJlc3RyaWN0aW9ucyAmIDMyKSBsaW5lYXIgKz0gJ3gnO1xuICAgIGlmIChyZXN0cmljdGlvbnMgJiAxNikgbGluZWFyICs9ICd5JztcbiAgICBpZiAocmVzdHJpY3Rpb25zICYgOCkgbGluZWFyICs9ICd6JztcbiAgICBpZiAocmVzdHJpY3Rpb25zICYgNCkgYW5ndWxhciArPSAneCc7XG4gICAgaWYgKHJlc3RyaWN0aW9ucyAmIDIpIGFuZ3VsYXIgKz0gJ3knO1xuICAgIGlmIChyZXN0cmljdGlvbnMgJiAxKSBhbmd1bGFyICs9ICd6JztcblxuICAgIHJldHVybiBbbGluZWFyLCBhbmd1bGFyXTtcbn07XG5cbi8qKlxuICogU2V0dGVyIGZvciB0aGUgcGFydGljbGUgcmVzdHJpY3Rpb24gYml0bWFzay5cbiAqXG4gKiBAbWV0aG9kIHNldFJlc3RyaWN0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zUmVzdHJpY3Rpb25zXG4gKiBAcGFyYW0ge1N0cmluZ30gcm90UmVzdHJpY3Rpb25zXG4gKiBAY2hhaW5hYmxlXG4gKi9cblBhcnRpY2xlLnByb3RvdHlwZS5zZXRSZXN0cmljdGlvbnMgPSBmdW5jdGlvbiBzZXRSZXN0cmljdGlvbnModHJhbnNSZXN0cmljdGlvbnMsIHJvdFJlc3RyaWN0aW9ucykge1xuICAgIHRyYW5zUmVzdHJpY3Rpb25zID0gdHJhbnNSZXN0cmljdGlvbnMgfHwgJyc7XG4gICAgcm90UmVzdHJpY3Rpb25zID0gcm90UmVzdHJpY3Rpb25zIHx8ICcnO1xuICAgIHRoaXMucmVzdHJpY3Rpb25zID0gMDtcbiAgICBpZiAodHJhbnNSZXN0cmljdGlvbnMuaW5kZXhPZigneCcpID4gLTEpIHRoaXMucmVzdHJpY3Rpb25zIHw9IDMyO1xuICAgIGlmICh0cmFuc1Jlc3RyaWN0aW9ucy5pbmRleE9mKCd5JykgPiAtMSkgdGhpcy5yZXN0cmljdGlvbnMgfD0gMTY7XG4gICAgaWYgKHRyYW5zUmVzdHJpY3Rpb25zLmluZGV4T2YoJ3onKSA+IC0xKSB0aGlzLnJlc3RyaWN0aW9ucyB8PSA4O1xuICAgIGlmIChyb3RSZXN0cmljdGlvbnMuaW5kZXhPZigneCcpID4gLTEpIHRoaXMucmVzdHJpY3Rpb25zIHw9IDQ7XG4gICAgaWYgKHJvdFJlc3RyaWN0aW9ucy5pbmRleE9mKCd5JykgPiAtMSkgdGhpcy5yZXN0cmljdGlvbnMgfD0gMjtcbiAgICBpZiAocm90UmVzdHJpY3Rpb25zLmluZGV4T2YoJ3onKSA+IC0xKSB0aGlzLnJlc3RyaWN0aW9ucyB8PSAxO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXR0ZXIgZm9yIG1hc3NcbiAqXG4gKiBAbWV0aG9kIGdldE1hc3NcbiAqIEByZXR1cm4ge051bWJlcn0gbWFzc1xuICovXG5QYXJ0aWNsZS5wcm90b3R5cGUuZ2V0TWFzcyA9IGZ1bmN0aW9uIGdldE1hc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFzcztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtYXNzIG9mIHRoZSBQYXJ0aWNsZS4gIENhbiBiZSB1c2VkIHRvIGNoYW5nZSB0aGUgbWFzcyBzZXZlcmFsIHRpbWVzXG4gKlxuICogQG1ldGhvZCBzZXRNYXNzXG4gKiBAcGFyYW0ge051bWJlcn0gbWFzc1xuICogQGNoYWluYWJsZVxuICovXG5QYXJ0aWNsZS5wcm90b3R5cGUuc2V0TWFzcyA9IGZ1bmN0aW9uIHNldE1hc3MobWFzcykge1xuICAgIHRoaXMubWFzcyA9IG1hc3M7XG4gICAgdGhpcy5pbnZlcnNlTWFzcyA9IDEgLyBtYXNzO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXR0ZXIgZm9yIGludmVyc2UgbWFzc1xuICpcbiAqIEBtZXRob2QgZ2V0SW52ZXJzZU1hc3NcbiAqIEByZXR1cm4ge051bWJlcn0gaW52ZXJzZSBtYXNzXG4gKi9cblBhcnRpY2xlLnByb3RvdHlwZS5nZXRJbnZlcnNlTWFzcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmludmVyc2VNYXNzO1xufTtcblxuLyoqXG4gKiBSZXNldHMgdGhlIGluZXJ0aWEgdGVuc29yIGFuZCBpdHMgaW52ZXJzZSB0byByZWZsZWN0IHRoZSBjdXJyZW50IHNoYXBlLlxuICpcbiAqIEBtZXRob2QgdXBkYXRlTG9jYWxJbmVydGlhXG4gKiBAY2hhaW5hYmxlXG4gKiBAcGFyYW0ge01hdDMzfSBNYXQzM1xuICovXG5QYXJ0aWNsZS5wcm90b3R5cGUudXBkYXRlTG9jYWxJbmVydGlhID0gZnVuY3Rpb24gdXBkYXRlTG9jYWxJbmVydGlhKCkge1xuICAgIHRoaXMubG9jYWxJbmVydGlhLnNldChbMCwwLDAsMCwwLDAsMCwwLDBdKTtcbiAgICB0aGlzLmxvY2FsSW52ZXJzZUluZXJ0aWEuc2V0KFswLDAsMCwwLDAsMCwwLDAsMF0pO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSB3b3JsZCBpbnZlcnNlIGluZXJ0aWEgdGVuc29yLlxuICpcbiAqIEBtZXRob2QgdXBkYXRlSW5lcnRpYVxuICogQGNoYWluYWJsZVxuICovXG5QYXJ0aWNsZS5wcm90b3R5cGUudXBkYXRlSW5lcnRpYSA9IGZ1bmN0aW9uIHVwZGF0ZUluZXJ0aWEoKSB7XG4gICAgdmFyIGxvY2FsSW52SSA9IHRoaXMubG9jYWxJbnZlcnNlSW5lcnRpYTtcbiAgICB2YXIgcSA9IHRoaXMub3JpZW50YXRpb247XG4gICAgaWYgKGxvY2FsSW52SVswXSA9PT0gbG9jYWxJbnZJWzRdICYmIGxvY2FsSW52SVs0XSA9PT0gbG9jYWxJbnZJWzhdKSByZXR1cm47XG4gICAgaWYgKHEudyA9PT0gMSkgcmV0dXJuO1xuICAgIHZhciBSID0gcS50b01hdHJpeChNQVQxX1JFR0lTVEVSKTtcbiAgICBNYXQzMy5tdWx0aXBseShSLCB0aGlzLmludmVyc2VJbmVydGlhLCB0aGlzLmludmVyc2VJbmVydGlhKTtcbiAgICBNYXQzMy5tdWx0aXBseSh0aGlzLmxvY2FsSW52ZXJzZUluZXJ0aWEsIFIudHJhbnNwb3NlKCksIHRoaXMuaW52ZXJzZUluZXJ0aWEpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXR0ZXIgZm9yIHBvc2l0aW9uXG4gKlxuICogQG1ldGhvZCBnZXRQb3NpdGlvblxuICogQHJldHVybiB7VmVjM30gcG9zaXRpb25cbiAqL1xuUGFydGljbGUucHJvdG90eXBlLmdldFBvc2l0aW9uID0gZnVuY3Rpb24gZ2V0UG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucG9zaXRpb247XG59O1xuXG4vKipcbiAqIFNldHRlciBmb3IgcG9zaXRpb25cbiAqXG4gKiBAbWV0aG9kIHNldFBvc2l0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0geCB0aGUgeCBjb29yZGluYXRlIGZvciBwb3NpdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHkgdGhlIHkgY29vcmRpbmF0ZSBmb3IgcG9zaXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSB6IHRoZSB6IGNvb3JkaW5hdGUgZm9yIHBvc2l0aW9uXG4gKiBAcmV0dXJuIHtQYXJ0aWNsZX0gdGhpc1xuICogQGNoYWluYWJsZVxuICovXG5QYXJ0aWNsZS5wcm90b3R5cGUuc2V0UG9zaXRpb24gPSBmdW5jdGlvbiBzZXRQb3NpdGlvbih4LCB5LCB6KSB7XG4gICAgdGhpcy5wb3NpdGlvbi5zZXQoeCwgeSwgeik7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEdldHRlciBmb3IgdmVsb2NpdHlcbiAqXG4gKiBAbWV0aG9kIGdldFZlbG9jaXR5XG4gKiBAcmV0dXJuIHtWZWMzfSB2ZWxvY2l0eVxuICovXG5QYXJ0aWNsZS5wcm90b3R5cGUuZ2V0VmVsb2NpdHkgPSBmdW5jdGlvbiBnZXRWZWxvY2l0eSgpIHtcbiAgICByZXR1cm4gdGhpcy52ZWxvY2l0eTtcbn07XG5cbi8qKlxuICogU2V0dGVyIGZvciB2ZWxvY2l0eVxuICpcbiAqIEBtZXRob2Qgc2V0dmVsb2NpdHlcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IHRoZSB4IGNvb3JkaW5hdGUgZm9yIHZlbG9jaXR5XG4gKiBAcGFyYW0ge051bWJlcn0geSB0aGUgeSBjb29yZGluYXRlIGZvciB2ZWxvY2l0eVxuICogQHBhcmFtIHtOdW1iZXJ9IHogdGhlIHogY29vcmRpbmF0ZSBmb3IgdmVsb2NpdHlcbiAqIEBjaGFpbmFibGVcbiAqL1xuUGFydGljbGUucHJvdG90eXBlLnNldFZlbG9jaXR5ID0gZnVuY3Rpb24gc2V0VmVsb2NpdHkoeCwgeSwgeikge1xuICAgIHRoaXMudmVsb2NpdHkuc2V0KHgsIHksIHopO1xuICAgIFZlYzMuc2NhbGUodGhpcy52ZWxvY2l0eSwgdGhpcy5tYXNzLCB0aGlzLm1vbWVudHVtKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogR2V0dGVyIGZvciBtb21lbnV0bVxuICpcbiAqIEBtZXRob2QgZ2V0TW9tZW50dW1cbiAqIEByZXR1cm4ge1ZlYzN9IG1vbWVudHVtXG4gKi9cblBhcnRpY2xlLnByb3RvdHlwZS5nZXRNb21lbnR1bSA9IGZ1bmN0aW9uIGdldE1vbWVudHVtKCkge1xuICAgIHJldHVybiB0aGlzLm1vbWVudHVtO1xufTtcblxuLyoqXG4gKiBTZXR0ZXIgZm9yIG1vbWVudHVtXG4gKlxuICogQG1ldGhvZCBzZXRNb21lbnR1bVxuICogQHBhcmFtIHtOdW1iZXJ9IHggdGhlIHggY29vcmRpbmF0ZSBmb3IgbW9tZW50dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSB5IHRoZSB5IGNvb3JkaW5hdGUgZm9yIG1vbWVudHVtXG4gKiBAcGFyYW0ge051bWJlcn0geiB0aGUgeiBjb29yZGluYXRlIGZvciBtb21lbnR1bVxuICogQGNoYWluYWJsZVxuICovXG5QYXJ0aWNsZS5wcm90b3R5cGUuc2V0TW9tZW50dW0gPSBmdW5jdGlvbiBzZXRNb21lbnR1bSh4LCB5LCB6KSB7XG4gICAgdGhpcy5tb21lbnR1bS5zZXQoeCwgeSwgeik7XG4gICAgVmVjMy5zY2FsZSh0aGlzLm1vbWVudHVtLCB0aGlzLmludmVyc2VNYXNzLCB0aGlzLnZlbG9jaXR5KTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogR2V0dGVyIGZvciBvcmllbnRhdGlvblxuICpcbiAqIEBtZXRob2QgZ2V0T3JpZW50YXRpb25cbiAqIEByZXR1cm4ge1F1YXRlcm5pb259IG9yaWVudGF0aW9uXG4gKi9cblBhcnRpY2xlLnByb3RvdHlwZS5nZXRPcmllbnRhdGlvbiA9IGZ1bmN0aW9uIGdldE9yaWVudGF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm9yaWVudGF0aW9uO1xufTtcblxuLyoqXG4gKiBTZXR0ZXIgZm9yIG9yaWVudGF0aW9uXG4gKlxuICogQG1ldGhvZCBzZXRPcmllbnRhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHdcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHBhcmFtIHtOdW1iZXJ9IHpcbiAqIEBjaGFpbmFibGVcbiAqL1xuUGFydGljbGUucHJvdG90eXBlLnNldE9yaWVudGF0aW9uID0gZnVuY3Rpb24gc2V0T3JpZW50YXRpb24odyx4LHkseikge1xuICAgIHRoaXMub3JpZW50YXRpb24uc2V0KHcseCx5LHopLm5vcm1hbGl6ZSgpO1xuICAgIHRoaXMudXBkYXRlSW5lcnRpYSgpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXR0ZXIgZm9yIGFuZ3VsYXIgdmVsb2NpdHlcbiAqXG4gKiBAbWV0aG9kIGdldEFuZ3VsYXJWZWxvY2l0eVxuICogQHJldHVybiB7VmVjM30gYW5ndWxhclZlbG9jaXR5XG4gKi9cblBhcnRpY2xlLnByb3RvdHlwZS5nZXRBbmd1bGFyVmVsb2NpdHkgPSBmdW5jdGlvbiBnZXRBbmd1bGFyVmVsb2NpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuYW5ndWxhclZlbG9jaXR5O1xufTtcblxuLyoqXG4gKiBTZXR0ZXIgZm9yIGFuZ3VsYXIgdmVsb2NpdHlcbiAqXG4gKiBAbWV0aG9kIHNldEFuZ3VsYXJWZWxvY2l0eVxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcGFyYW0ge051bWJlcn0gelxuICovXG5QYXJ0aWNsZS5wcm90b3R5cGUuc2V0QW5ndWxhclZlbG9jaXR5ID0gZnVuY3Rpb24gc2V0QW5ndWxhclZlbG9jaXR5KHgseSx6KSB7XG4gICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkuc2V0KHgseSx6KTtcbiAgICB2YXIgSSA9IE1hdDMzLmludmVyc2UodGhpcy5pbnZlcnNlSW5lcnRpYSwgTUFUMV9SRUdJU1RFUik7XG4gICAgaWYgKEkpIEkudmVjdG9yTXVsdGlwbHkodGhpcy5hbmd1bGFyVmVsb2NpdHksIHRoaXMuYW5ndWxhck1vbWVudHVtKTtcbiAgICBlbHNlIHRoaXMuYW5ndWxhck1vbWVudHVtLmNsZWFyKCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEdldHRlciBmb3IgYW5ndWxhciBtb21lbnR1bVxuICpcbiAqIEBtZXRob2QgZ2V0QW5ndWxhck1vbWVudHVtXG4gKiBAcmV0dXJuIHtWZWMzfSBhbmd1bGFyIG1vbWVudHVtXG4gKi9cblBhcnRpY2xlLnByb3RvdHlwZS5nZXRBbmd1bGFyTW9tZW50dW0gPSBmdW5jdGlvbiBnZXRBbmd1bGFyTW9tZW50dW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuYW5ndWxhck1vbWVudHVtO1xufTtcblxuLyoqXG4gKiBTZXR0ZXIgZm9yIGFuZ3VsYXIgbW9tZW50dW1cbiAqXG4gKiBAbWV0aG9kIHNldEFuZ3VsYXJNb21lbnR1bVxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcGFyYW0ge051bWJlcn0gelxuICovXG5QYXJ0aWNsZS5wcm90b3R5cGUuc2V0QW5ndWxhck1vbWVudHVtID0gZnVuY3Rpb24gc2V0QW5ndWxhck1vbWVudHVtKHgseSx6KSB7XG4gICAgdGhpcy5hbmd1bGFyTW9tZW50dW0uc2V0KHgseSx6KTtcbiAgICB0aGlzLmludmVyc2VJbmVydGlhLnZlY3Rvck11bHRpcGx5KHRoaXMuYW5ndWxhck1vbWVudHVtLCB0aGlzLmFuZ3VsYXJWZWxvY2l0eSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEdldHRlciBmb3IgdGhlIGZvcmNlIG9uIHRoZSBQYXJ0aWNsZVxuICpcbiAqIEBtZXRob2QgZ2V0Rm9yY2VcbiAqIEByZXR1cm4ge1ZlYzN9IGZvcmNlXG4gKi9cblBhcnRpY2xlLnByb3RvdHlwZS5nZXRGb3JjZSA9IGZ1bmN0aW9uIGdldEZvcmNlKCkge1xuICAgIHJldHVybiB0aGlzLmZvcmNlO1xufTtcblxuLyoqXG4gKiBTZXR0ZXIgZm9yIHRoZSBmb3JjZSBvbiB0aGUgUGFydGljbGVcbiAqXG4gKiBAbWV0aG9kIHNldEZvcmNlXG4gKiBAcGFyYW0ge1ZlYzN9IHYgdGhlIG5ldyBGb3JjZVxuICogQGNoYWluYWJsZVxuICovXG5QYXJ0aWNsZS5wcm90b3R5cGUuc2V0Rm9yY2UgPSBmdW5jdGlvbiBzZXRGb3JjZSh4LCB5LCB6KSB7XG4gICAgdGhpcy5mb3JjZS5zZXQoeCwgeSwgeik7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEdldHRlciBmb3IgdG9ycXVlLlxuICpcbiAqIEBtZXRob2QgZ2V0VG9ycXVlXG4gKi9cblBhcnRpY2xlLnByb3RvdHlwZS5nZXRUb3JxdWUgPSBmdW5jdGlvbiBnZXRUb3JxdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9ycXVlO1xufTtcblxuLyoqXG4gKiBTZXR0ZXIgZm9yIHRvcnF1ZS5cbiAqXG4gKiBAbWV0aG9kIHNldFRvcnF1ZVxuICogQHBhcmFtIHtWZWMzfSB2XG4gKiBAY2hhaW5hYmxlXG4gKi9cblBhcnRpY2xlLnByb3RvdHlwZS5zZXRUb3JxdWUgPSBmdW5jdGlvbiBzZXRUb3JxdWUoeCwgeSwgeikge1xuICAgIHRoaXMudG9ycXVlLnNldCh4LCB5LCB6KTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRXh0ZW5kcyBQYXJ0aWNsZS5hcHBseUZvcmNlIHdpdGggYW4gb3B0aW9uYWwgYXJndW1lbnRcbiAqIHRvIGFwcGx5IHRoZSBmb3JjZSBhdCBhbiBvZmYtY2VudGVyZWQgbG9jYXRpb24sIHJlc3VsdGluZyBpbiBhIHRvcnF1ZS5cbiAqXG4gKiBAbWV0aG9kIGFwcGx5Rm9yY2VcbiAqIEBwYXJhbSBmb3JjZSB7VmVjM30gZm9yY2VcbiAqIEBwYXJhbSB7VmVjM30gbG9jYXRpb24gb2ZmLWNlbnRlciBsb2NhdGlvbiBvbiB0aGUgUGFydGljbGUgKG9wdGlvbmFsKVxuICovXG5QYXJ0aWNsZS5wcm90b3R5cGUuYXBwbHlGb3JjZSA9IGZ1bmN0aW9uIGFwcGx5Rm9yY2UoZm9yY2UpIHtcbiAgICB0aGlzLmZvcmNlLmFkZChmb3JjZSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFwcGxpZWQgYSB0b3JxdWUgZm9yY2UgdG8gYSBQYXJ0aWNsZSwgaW5kdWNpbmcgYSByb3RhdGlvbi5cbiAqXG4gKiBAbWV0aG9kIGFwcGx5VG9ycXVlXG4gKiBAcGFyYW0gdG9ycXVlIHtWZWMzfSB0b3JxdWVcbiAqL1xuUGFydGljbGUucHJvdG90eXBlLmFwcGx5VG9ycXVlID0gZnVuY3Rpb24gYXBwbHlUb3JxdWUodG9ycXVlKSB7XG4gICAgdGhpcy50b3JxdWUuYWRkKHRvcnF1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFwcGxpZXMgYW4gaW1wdWxzZSB0byBtb21lbnR1bSBhbmQgdXBkYXRlcyB2ZWxvY2l0eS5cbiAqXG4gKiBAbWV0aG9kIGFwcGx5SW1wdWxzZVxuICogQHBhcmFtIHtWZWMzfSBpbXB1bHNlXG4gKi9cblBhcnRpY2xlLnByb3RvdHlwZS5hcHBseUltcHVsc2UgPSBmdW5jdGlvbiBhcHBseUltcHVsc2UoaW1wdWxzZSkge1xuICAgIHRoaXMubW9tZW50dW0uYWRkKGltcHVsc2UpO1xuICAgIFZlYzMuc2NhbGUodGhpcy5tb21lbnR1bSwgdGhpcy5pbnZlcnNlTWFzcywgdGhpcy52ZWxvY2l0eSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFwcGxpZXMgYW4gYW5ndWxhciBpbXB1bHNlIHRvIGFuZ3VsYXIgbW9tZW50dW0gYW5kIHVwZGF0ZXMgYW5ndWxhciB2ZWxvY2l0eS5cbiAqXG4gKiBAbWV0aG9kIGFwcGx5QW5ndWxhckltcHVsc2VcbiAqIEBwYXJhbSB7VmVjM30gYW5ndWxhckltcHVsc2VcbiAqL1xuUGFydGljbGUucHJvdG90eXBlLmFwcGx5QW5ndWxhckltcHVsc2UgPSBmdW5jdGlvbiBhcHBseUFuZ3VsYXJJbXB1bHNlKGFuZ3VsYXJJbXB1bHNlKSB7XG4gICAgdGhpcy5hbmd1bGFyTW9tZW50dW0uYWRkKGFuZ3VsYXJJbXB1bHNlKTtcbiAgICB0aGlzLmludmVyc2VJbmVydGlhLnZlY3Rvck11bHRpcGx5KHRoaXMuYW5ndWxhck1vbWVudHVtLCB0aGlzLmFuZ3VsYXJWZWxvY2l0eSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFVzZWQgaW4gY29sbGlzaW9uIGRldGVjdGlvbi4gVGhlIHN1cHBvcnQgZnVuY3Rpb24gc2hvdWxkIGFjY2VwdCBhIFZlYzMgZGlyZWN0aW9uXG4gKiBhbmQgcmV0dXJuIHRoZSBwb2ludCBvbiB0aGUgYm9keSdzIHNoYXBlIGZ1cnRoZXN0IGluIHRoYXQgZGlyZWN0aW9uLiBGb3IgcG9pbnQgcGFydGljbGVzLFxuICogdGhpcyByZXR1cm5zIHRoZSB6ZXJvIHZlY3Rvci5cbiAqXG4gKiBAbWV0aG9kIHN1cHBvcnRcbiAqIEByZXR1cm4ge1ZlYzN9XG4gKi9cblBhcnRpY2xlLnByb3RvdHlwZS5zdXBwb3J0ID0gZnVuY3Rpb24gc3VwcG9ydCgpIHtcbiAgICByZXR1cm4gWkVST19WRUNUT1I7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgYm9keSdzIHNoYXBlIHRvIHJlZmxlY3QgY3VycmVudCBvcmllbnRhdGlvbi4gQ2FsbGVkIGluIF9pbnRlZ3JhdGVQb3NlLlxuICogTm9vcCBmb3IgcG9pbnQgcGFydGljbGVzLlxuICpcbiAqIEBtZXRob2QgdXBkYXRlU2hhcGVcbiAqL1xuUGFydGljbGUucHJvdG90eXBlLnVwZGF0ZVNoYXBlID0gZnVuY3Rpb24gdXBkYXRlU2hhcGUoKSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBQYXJ0aWNsZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFBhcnRpY2xlID0gcmVxdWlyZSgnLi9QYXJ0aWNsZScpO1xudmFyIFZlYzMgPSByZXF1aXJlKCdmYW1vdXMtbWF0aCcpLlZlYzM7XG5cbnZhciBTVVBQT1JUX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBTcGhlcmljYWwgUmlnaWQgYm9keVxuICpcbiAqIEBjbGFzcyBTcGhlcmVcbiAqIEBleHRlbmRzIFBhcnRpY2xlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBTcGhlcmUob3B0aW9ucykge1xuICAgIFBhcnRpY2xlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgdmFyIHIgID0gb3B0aW9ucy5yYWRpdXMgfHwgMTtcbiAgICB0aGlzLnJhZGl1cyA9IHI7XG4gICAgdGhpcy5zaXplID0gWzIqciwgMipyLCAyKnJdO1xuICAgIHRoaXMudXBkYXRlTG9jYWxJbmVydGlhKCk7XG4gICAgdGhpcy5pbnZlcnNlSW5lcnRpYS5jb3B5KHRoaXMubG9jYWxJbnZlcnNlSW5lcnRpYSk7XG5cbiAgICB0aGlzLnR5cGUgPSAxIDw8IDI7XG59XG5cblNwaGVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBhcnRpY2xlLnByb3RvdHlwZSk7XG5TcGhlcmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3BoZXJlO1xuXG4vKipcbiAqIEdldHRlciBmb3IgcmFkaXVzLlxuICpcbiAqIEBtZXRob2QgZ2V0UmFkaXVzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHJhZGl1c1xuICovXG5TcGhlcmUucHJvdG90eXBlLmdldFJhZGl1cyA9IGZ1bmN0aW9uIGdldFJhZGl1cygpIHtcbiAgICByZXR1cm4gdGhpcy5yYWRpdXM7XG59O1xuXG4vKipcbiAqIFNldHRlciBmb3IgcmFkaXVzLlxuICpcbiAqIEBtZXRob2Qgc2V0UmFkaXVzXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzIFRoZSBpbnRlbmRlZCByYWRpdXMgb2YgdGhlIHNwaGVyZS5cbiAqIEBjaGFpbmFibGVcbiAqL1xuU3BoZXJlLnByb3RvdHlwZS5zZXRSYWRpdXMgPSBmdW5jdGlvbiBzZXRSYWRpdXMocmFkaXVzKSB7XG4gICAgdGhpcy5yYWRpdXMgPSByYWRpdXM7XG4gICAgdGhpcy5zaXplID0gWzIqdGhpcy5yYWRpdXMsIDIqdGhpcy5yYWRpdXMsIDIqdGhpcy5yYWRpdXNdO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBJbmZlcnMgdGhlIGluZXJ0aWEgdGVuc29yLlxuICpcbiAqIEBvdmVycmlkZVxuICogQG1ldGhvZCB1cGRhdGVJbmVydGlhXG4gKi9cblNwaGVyZS5wcm90b3R5cGUudXBkYXRlTG9jYWxJbmVydGlhID0gZnVuY3Rpb24gdXBkYXRlSW5lcnRpYSgpIHtcbiAgICB2YXIgbSA9IHRoaXMubWFzcztcbiAgICB2YXIgciA9IHRoaXMucmFkaXVzO1xuXG4gICAgdmFyIG1yciA9IG0gKiByICogcjtcblxuICAgIHRoaXMubG9jYWxJbmVydGlhLnNldChbXG4gICAgICAgIDAuNCAqIG1yciwgMCwgMCxcbiAgICAgICAgMCwgMC40ICogbXJyLCAwLFxuICAgICAgICAwLCAwLCAwLjQgKiBtcnJcbiAgICBdKTtcblxuICAgIHRoaXMubG9jYWxJbnZlcnNlSW5lcnRpYS5zZXQoW1xuICAgICAgICAyLjUgLyBtcnIsIDAsIDAsXG4gICAgICAgIDAsIDIuNSAvIG1yciwgMCxcbiAgICAgICAgMCwgMCwgMi41IC8gbXJyXG4gICAgXSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHBvaW50IG9uIHRoZSBzcGhlcmUgZnVydGhlc3QgaW4gYSBnaXZlbiBkaXJlY3Rpb24uXG4gKlxuICogQG1ldGhvZCBzdXBwb3J0XG4gKiBAcGFyYW0ge1ZlYzN9IGRpcmVjdGlvblxuICogQHBhcmFtIHtWZWMzfVxuICovXG5TcGhlcmUucHJvdG90eXBlLnN1cHBvcnQgPSBmdW5jdGlvbiBzdXBwb3J0KGRpcmVjdGlvbikge1xuICAgIHJldHVybiBWZWMzLnNjYWxlKGRpcmVjdGlvbiwgdGhpcy5yYWRpdXMsIFNVUFBPUlRfUkVHSVNURVIpO1xufTtcblxuLyoqXG4gKiBAZXhwb3J0cyBTcGhlcmVcbiAqIEBtb2R1bGUgU3BoZXJlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gU3BoZXJlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUGFydGljbGUgPSByZXF1aXJlKCcuL1BhcnRpY2xlJyk7XG52YXIgVmVjMyA9IHJlcXVpcmUoJ2ZhbW91cy1tYXRoJykuVmVjMztcblxuLyoqXG4gKiBAZW51bSBkaXJlY3Rpb25zXG4gKi9cbldhbGwuRE9XTiA9IDA7XG5XYWxsLlVQID0gMTtcbldhbGwuTEVGVCA9IDI7XG5XYWxsLlJJR0hUID0gMztcbldhbGwuRk9SV0FSRCA9IDQ7XG5XYWxsLkJBQ0tXQVJEID0gNTtcblxuLyoqXG4gKiBBbiBheGlzLWFsaWduZWQgYm91bmRhcnkuIFdpbGwgbm90IHJlc3BvbmQgdG8gZm9yY2VzIG9yIGltcHVsc2VzLlxuICpcbiAqIEBjbGFzcyBXYWxsXG4gKiBAZXh0ZW5kcyBQYXJ0aWNsZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gV2FsbChvcHRpb25zKSB7XG4gICAgUGFydGljbGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICAgIHZhciBuID0gdGhpcy5ub3JtYWwgPSBuZXcgVmVjMygpO1xuXG4gICAgdmFyIGQgPSB0aGlzLmRpcmVjdGlvbiA9IG9wdGlvbnMuZGlyZWN0aW9uO1xuICAgIHN3aXRjaCAoZCkge1xuICAgICAgICBjYXNlIFdhbGwuRE9XTjpcbiAgICAgICAgICAgIG4uc2V0KDAsIDEsIDApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgV2FsbC5VUDpcbiAgICAgICAgICAgIG4uc2V0KDAsIC0xLCAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFdhbGwuTEVGVDpcbiAgICAgICAgICAgIG4uc2V0KC0xLCAwLCAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFdhbGwuUklHSFQ6XG4gICAgICAgICAgICBuLnNldCgxLCAwLCAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFdhbGwuRk9SV0FSRDpcbiAgICAgICAgICAgIG4uc2V0KDAsIDAsIC0xKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFdhbGwuQkFDS1dBUkQ6XG4gICAgICAgICAgICBuLnNldCgwLCAwLCAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdGhpcy5pbnZOb3JtYWwgPSBWZWMzLmNsb25lKG4sIG5ldyBWZWMzKCkpLmludmVydCgpO1xuXG4gICAgdGhpcy5tYXNzID0gSW5maW5pdHk7XG4gICAgdGhpcy5pbnZlcnNlTWFzcyA9IDA7XG5cbiAgICB0aGlzLnR5cGUgPSAxIDw8IDM7XG59XG5cbldhbGwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQYXJ0aWNsZS5wcm90b3R5cGUpO1xuV2FsbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBXYWxsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdhbGw7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDb25zdHJhaW50ID0gcmVxdWlyZSgnLi9Db25zdHJhaW50Jyk7XG52YXIgVmVjMyA9IHJlcXVpcmUoJ2ZhbW91cy1tYXRoJykuVmVjMztcbnZhciBNYXQzMyA9IHJlcXVpcmUoJ2ZhbW91cy1tYXRoJykuTWF0MzM7XG5cbnZhciBERUxUQV9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogIEEgY29uc3RyYWludCB0aGF0IGtlZXBzIGEgcGh5c2ljcyBib2R5IGEgZ2l2ZW4gZGlyZWN0aW9uIGF3YXkgZnJvbSBhIGdpdmVuXG4gKiAgYW5jaG9yLCBvciBhbm90aGVyIGF0dGFjaGVkIGJvZHkuXG4gKlxuICogIEBjbGFzcyBBbmdsZVxuICogIEBleHRlbmRzIENvbnN0cmFpbnRcbiAqICBAcGFyYW0ge1BhcnRpY2xlfSBhIE9uZSBvZiB0aGUgYm9kaWVzLlxuICogIEBwYXJhbSB7UGFydGljbGV9IGIgVGhlIG90aGVyIGJvZHkuXG4gKiAgQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQW4gb2JqZWN0IG9mIGNvbmZpZ3VyYWJsZSBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBBbmdsZShhLCBiLCBvcHRpb25zKSB7XG4gICAgdGhpcy5hID0gYTtcbiAgICB0aGlzLmIgPSBiO1xuXG4gICAgQ29uc3RyYWludC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5lZmZlY3RpdmVJbmVydGlhID0gbmV3IE1hdDMzKCk7XG4gICAgdGhpcy5hbmd1bGFySW1wdWxzZSA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5lcnJvciA9IDA7XG59XG5cbkFuZ2xlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ29uc3RyYWludC5wcm90b3R5cGUpO1xuQW5nbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQW5nbGU7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgQW5nbGUuIFNldHMgZGVmYXVsdHMgaWYgYSBwcm9wZXJ0eSB3YXMgbm90IGFscmVhZHkgc2V0LlxuICpcbiAqIEBtZXRob2QgaW5pdFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgaGFzaC5cbiAqL1xuQW5nbGUucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNvc0FuZ2xlID0gdGhpcy5jb3NBbmdsZSB8fCB0aGlzLmEub3JpZW50YXRpb24uZG90KHRoaXMuYi5vcmllbnRhdGlvbik7XG59O1xuXG4vKipcbiAqIFdhcm1zdGFydCB0aGUgY29uc3RyYWludCBhbmQgcHJlcGFyZSBjYWxjdWxhdGlvbnMgdXNlZCBpbiAucmVzb2x2ZS5cbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICovXG5BbmdsZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIHZhciBhID0gdGhpcy5hO1xuICAgIHZhciBiID0gdGhpcy5iO1xuXG4gICAgdmFyIHExID0gYS5vcmllbnRhdGlvbjtcbiAgICB2YXIgcTIgPSBiLm9yaWVudGF0aW9uO1xuXG4gICAgdmFyIGNvc1RoZXRhID0gcTEuZG90KHEyKTtcbiAgICB2YXIgZGlmZiA9IDIqKGNvc1RoZXRhIC0gdGhpcy5jb3NBbmdsZSk7XG5cbiAgICB0aGlzLmVycm9yID0gZGlmZjtcblxuICAgIHZhciBhbmd1bGFySW1wdWxzZSA9IHRoaXMuYW5ndWxhckltcHVsc2U7XG4gICAgYi5hcHBseUFuZ3VsYXJJbXB1bHNlKGFuZ3VsYXJJbXB1bHNlKTtcbiAgICBhLmFwcGx5QW5ndWxhckltcHVsc2UoYW5ndWxhckltcHVsc2UuaW52ZXJ0KCkpO1xuXG4gICAgTWF0MzMuYWRkKGEuaW52ZXJzZUluZXJ0aWEsIGIuaW52ZXJzZUluZXJ0aWEsIHRoaXMuZWZmZWN0aXZlSW5lcnRpYSk7XG4gICAgdGhpcy5lZmZlY3RpdmVJbmVydGlhLmludmVyc2UoKTtcblxuICAgIGFuZ3VsYXJJbXB1bHNlLmNsZWFyKCk7XG59O1xuXG4vKipcbiAqIEFkZHMgYW4gYW5ndWxhciBpbXB1bHNlIHRvIGEgcGh5c2ljcyBib2R5J3MgYW5ndWxhciB2ZWxvY2l0eS5cbiAqXG4gKiBAbWV0aG9kIHJlc29sdmVcbiAqL1xuQW5nbGUucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgdmFyIGEgPSB0aGlzLmE7XG4gICAgdmFyIGIgPSB0aGlzLmI7XG5cbiAgICB2YXIgZGlmZlcgPSBERUxUQV9SRUdJU1RFUjtcblxuICAgIHZhciB3MSA9IGEuYW5ndWxhclZlbG9jaXR5O1xuICAgIHZhciB3MiA9IGIuYW5ndWxhclZlbG9jaXR5O1xuXG4gICAgVmVjMy5zdWJ0cmFjdCh3MSwgdzIsIGRpZmZXKTtcbiAgICBkaWZmVy5zY2FsZSgxICsgdGhpcy5lcnJvcik7XG5cbiAgICB2YXIgYW5ndWxhckltcHVsc2UgPSBkaWZmVy5hcHBseU1hdHJpeCh0aGlzLmVmZmVjdGl2ZUluZXJ0aWEpO1xuXG4gICAgYi5hcHBseUFuZ3VsYXJJbXB1bHNlKGFuZ3VsYXJJbXB1bHNlKTtcbiAgICBhLmFwcGx5QW5ndWxhckltcHVsc2UoYW5ndWxhckltcHVsc2UuaW52ZXJ0KCkpO1xuICAgIGFuZ3VsYXJJbXB1bHNlLmludmVydCgpO1xuICAgIHRoaXMuYW5ndWxhckltcHVsc2UuYWRkKGFuZ3VsYXJJbXB1bHNlKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQW5nbGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBWZWMzID0gcmVxdWlyZSgnZmFtb3VzLW1hdGgnKS5WZWMzO1xudmFyIENvbnN0cmFpbnQgPSByZXF1aXJlKCcuL0NvbnN0cmFpbnQnKTtcblxudmFyIFN3ZWVwQW5kUHJ1bmUgPSByZXF1aXJlKCcuL2NvbGxpc2lvbi9Td2VlcEFuZFBydW5lJyk7XG52YXIgQnJ1dGVGb3JjZSA9IHJlcXVpcmUoJy4vY29sbGlzaW9uL0JydXRlRm9yY2UnKTtcbnZhciBDb252ZXhDb2xsaXNpb24gPSByZXF1aXJlKCcuL2NvbGxpc2lvbi9Db252ZXhDb2xsaXNpb25EZXRlY3Rpb24nKTtcbnZhciBHSksgPSBDb252ZXhDb2xsaXNpb24uR0pLO1xudmFyIEVQQSA9IENvbnZleENvbGxpc2lvbi5FUEE7XG52YXIgQ29udGFjdE1hbmlmb2xkVGFibGUgPSByZXF1aXJlKCcuL2NvbGxpc2lvbi9Db250YWN0TWFuaWZvbGQnKTtcblxudmFyIE9iamVjdE1hbmFnZXIgPSByZXF1aXJlKCdmYW1vdXMtdXRpbGl0aWVzJykuT2JqZWN0TWFuYWdlcjtcbk9iamVjdE1hbmFnZXIucmVnaXN0ZXIoJ0NvbGxpc2lvbkRhdGEnLCBDb2xsaXNpb25EYXRhKTtcbnZhciBPTVJlcXVlc3RDb2xsaXNpb25EYXRhID0gT2JqZWN0TWFuYWdlci5yZXF1ZXN0Q29sbGlzaW9uRGF0YTtcblxudmFyIFZFQ19SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGNsYW1wIGEgdmFsdWUgdG8gYSBnaXZlbiByYW5nZS5cbiAqXG4gKiBAbWV0aG9kIGNsYW1wXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge051bWJlcn0gbG93ZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSB1cHBlclxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiBjbGFtcCh2YWx1ZSwgbG93ZXIsIHVwcGVyKSB7XG4gICAgcmV0dXJuIHZhbHVlIDwgbG93ZXIgPyBsb3dlciA6IHZhbHVlID4gdXBwZXIgPyB1cHBlciA6IHZhbHVlO1xufVxuXG4vKipcbiAqIE9iamVjdCBtYWludGFpbmluZyB2YXJpb3VzIGZpZ3VyZXMgb2YgYSBjb2xsaXNpb24uIFJlZ2lzdGVyZWQgaW4gT2JqZWN0TWFuYWdlci5cbiAqXG4gKiBAY2xhc3MgQ29sbGlzaW9uRGF0YVxuICogQHBhcmFtIHtOdW1iZXJ9IHBlbmV0cmF0aW9uXG4gKiBAcGFyYW0ge1ZlYzN9IG5vcm1hbFxuICogQHBhcmFtIHtWZWMzfSB3b3JsZENvbnRhY3RBXG4gKiBAcGFyYW0ge1ZlYzN9IHdvcmxkQ29udGFjdEJcbiAqIEBwYXJhbSB7VmVjM30gbG9jYWxDb250YWN0QVxuICogQHBhcmFtIHtWZWMzfSBsb2NhbENvbnRhY3RCXG4gKi9cbmZ1bmN0aW9uIENvbGxpc2lvbkRhdGEocGVuZXRyYXRpb24sIG5vcm1hbCwgd29ybGRDb250YWN0QSwgd29ybGRDb250YWN0QiwgbG9jYWxDb250YWN0QSwgbG9jYWxDb250YWN0Qikge1xuICAgIHRoaXMucGVuZXRyYXRpb24gPSBwZW5ldHJhdGlvbjtcbiAgICB0aGlzLm5vcm1hbCA9IG5vcm1hbDtcbiAgICB0aGlzLndvcmxkQ29udGFjdEEgPSB3b3JsZENvbnRhY3RBO1xuICAgIHRoaXMud29ybGRDb250YWN0QiA9IHdvcmxkQ29udGFjdEI7XG4gICAgdGhpcy5sb2NhbENvbnRhY3RBID0gbG9jYWxDb250YWN0QTtcbiAgICB0aGlzLmxvY2FsQ29udGFjdEIgPSBsb2NhbENvbnRhY3RCO1xufVxuXG4vKipcbiAqIFVzZWQgYnkgT2JqZWN0TWFuYWdlciB0byByZXNldCB0aGUgb2JqZWN0IHdpdGggZGlmZmVyZW50IGRhdGEuXG4gKlxuICogQG1ldGhvZCByZXNldFxuICogQHBhcmFtIHtPYmplY3RbXX0gYXJnc1xuICogQGNoYWluYWJsZVxuICovXG5Db2xsaXNpb25EYXRhLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KHBlbmV0cmF0aW9uLCBub3JtYWwsIHdvcmxkQ29udGFjdEEsIHdvcmxkQ29udGFjdEIsIGxvY2FsQ29udGFjdEEsIGxvY2FsQ29udGFjdEIpIHtcbiAgICB0aGlzLnBlbmV0cmF0aW9uID0gcGVuZXRyYXRpb247XG4gICAgdGhpcy5ub3JtYWwgPSBub3JtYWw7XG4gICAgdGhpcy53b3JsZENvbnRhY3RBID0gd29ybGRDb250YWN0QTtcbiAgICB0aGlzLndvcmxkQ29udGFjdEIgPSB3b3JsZENvbnRhY3RCO1xuICAgIHRoaXMubG9jYWxDb250YWN0QSA9IGxvY2FsQ29udGFjdEE7XG4gICAgdGhpcy5sb2NhbENvbnRhY3RCID0gbG9jYWxDb250YWN0QjtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSaWRpZCBib2R5IEVsYXN0aWMgQ29sbGlzaW9uXG4gKlxuICogQGNsYXNzIENvbGxpc2lvblxuICogQGV4dGVuZHMgQ29uc3RyYWludFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gQ29sbGlzaW9uKHRhcmdldHMsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnRhcmdldHMgPSBbXS5jb25jYXQodGFyZ2V0cyk7XG5cbiAgICBDb25zdHJhaW50LmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cbkNvbGxpc2lvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENvbnN0cmFpbnQucHJvdG90eXBlKTtcbkNvbGxpc2lvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb2xsaXNpb247XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgQ29sbGlzaW9uIHRyYWNrZXIuIFNldHMgZGVmYXVsdHMgaWYgYSBwcm9wZXJ0eSB3YXMgbm90IGFscmVhZHkgc2V0LlxuICpcbiAqIEBtZXRob2QgaW5pdFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgaGFzaC5cbiAqL1xuQ29sbGlzaW9uLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuYnJvYWRQaGFzZSkge1xuICAgICAgICBpZiAodGhpcy5icm9hZFBoYXNlIGluc3RhbmNlb2YgRnVuY3Rpb24pIHRoaXMuYnJvYWRQaGFzZSA9IG5ldyB0aGlzLmJyb2FkUGhhc2UodGhpcy50YXJnZXRzKTtcbiAgICB9XG4gICAgZWxzZSB0aGlzLmJyb2FkUGhhc2UgPSBuZXcgU3dlZXBBbmRQcnVuZSh0aGlzLnRhcmdldHMpO1xuICAgIHRoaXMuY29udGFjdE1hbmlmb2xkVGFibGUgPSB0aGlzLmNvbnRhY3RNYW5pZm9sZFRhYmxlIHx8IG5ldyBDb250YWN0TWFuaWZvbGRUYWJsZSgpO1xufTtcblxuLyoqXG4gKiBDb2xsaXNvbiBkZXRlY3Rpb24uIFVwZGF0ZXMgdGhlIGV4aXN0aW5nIGNvbnRhY3QgbWFuaWZvbGRzLCBydW5zIHRoZSBicm9hZHBoYXNlLCBhbmQgcGVyZm9ybXMgbmFycm93cGhhc2VcbiAqIGNvbGxpc2lvbiBkZXRlY3Rpb24uIFdhcm0gc3RhcnRzIHRoZSBjb250YWN0cyBiYXNlZCBvbiB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgcGh5c2ljcyBmcmFtZVxuICogYW5kIHByZXBhcmVzIG5lY2Vzc3NhcnkgY2FsY3VsYXRpb25zIGZvciB0aGUgcmVzb2x1dGlvbi5cbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgVGhlIGN1cnJlbnQgdGltZSBpbiB0aGUgcGh5c2ljcyBlbmdpbmUuXG4gKiBAcGFyYW0ge051bWJlcn0gZHQgVGhlIHBoeXNpY3MgZW5naW5lIGZyYW1lIGRlbHRhLlxuICovXG4gQ29sbGlzaW9uLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUodGltZSwgZHQpIHtcbiAgICB0aGlzLmNvbnRhY3RNYW5pZm9sZFRhYmxlLnVwZGF0ZShkdCk7XG4gICAgaWYgKHRoaXMudGFyZ2V0cy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICB2YXIgaSwgbGVuO1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IHRoaXMudGFyZ2V0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0aGlzLnRhcmdldHNbaV0udXBkYXRlU2hhcGUoKTtcbiAgICB9XG4gICAgdmFyIHBvdGVudGlhbENvbGxpc2lvbnMgPSB0aGlzLmJyb2FkUGhhc2UudXBkYXRlKCk7XG4gICAgdmFyIHBhaXI7XG4gICAgZm9yIChpID0gMCwgbGVuID0gcG90ZW50aWFsQ29sbGlzaW9ucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAocGFpciA9IHBvdGVudGlhbENvbGxpc2lvbnNbaV0pICYmIHRoaXMuYXBwbHlOYXJyb3dQaGFzZShwYWlyKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWN0TWFuaWZvbGRUYWJsZS5wcmVwQ29udGFjdHMoZHQpO1xufTtcblxuLyoqXG4gKiBBcHBseSBpbXB1bHNlcyB0byByZXNvbHZlIGFsbCBDb250YWN0IGNvbnN0cmFpbnRzLlxuICpcbiAqIEBtZXRob2QgcmVzb2x2ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgVGhlIGN1cnJlbnQgdGltZSBpbiB0aGUgcGh5c2ljcyBlbmdpbmUuXG4gKiBAcGFyYW0ge051bWJlcn0gZHQgVGhlIHBoeXNpY3MgZW5naW5lIGZyYW1lIGRlbHRhLlxuICovXG5Db2xsaXNpb24ucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlKHRpbWUsIGR0KSB7XG4gICAgdGhpcy5jb250YWN0TWFuaWZvbGRUYWJsZS5yZXNvbHZlTWFuaWZvbGRzKGR0KTtcbn07XG5cbi8qKlxuICogQWRkIGEgdGFyZ2V0IG9yIHRhcmdldHMgdG8gdGhlIGNvbGxpc2lvbiBzeXN0ZW0uXG4gKlxuICogQG1ldGhvZCBhZGRUYXJnZXRcbiAqIEBwYXJhbSB7UGFydGljbGV9XG4gKi9cbkNvbGxpc2lvbi5wcm90b3R5cGUuYWRkVGFyZ2V0ID0gZnVuY3Rpb24gYWRkVGFyZ2V0KHRhcmdldCkge1xuICAgIHRoaXMudGFyZ2V0cy5wdXNoKHRhcmdldCk7XG4gICAgdGhpcy5icm9hZFBoYXNlLmFkZCh0YXJnZXQpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYSB0YXJnZXQgb3IgdGFyZ2V0cyBmcm9tIHRoZSBjb2xsaXNpb24gc3lzdGVtLlxuICpcbiAqIEBtZXRob2QgYWRkVGFyZ2V0XG4gKiBAcGFyYW0ge1BhcnRpY2xlfVxuICovXG5Db2xsaXNpb24ucHJvdG90eXBlLnJlbW92ZVRhcmdldCA9IGZ1bmN0aW9uIHJlbW92ZVRhcmdldCh0YXJnZXQpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLnRhcmdldHMuaW5kZXhPZih0YXJnZXQpO1xuICAgIGlmIChpbmRleCA8IDApIHJldHVybjtcbiAgICB0aGlzLnRhcmdldHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB0aGlzLmJyb2FkUGhhc2UucmVtb3ZlKHRhcmdldCk7XG59O1xuXG5cbnZhciBDT05WRVggPSAxIDw8IDA7XG52YXIgQk9YID0gMSA8PCAxO1xudmFyIFNQSEVSRSA9IDEgPDwgMjtcbnZhciBXQUxMID0gMSA8PCAzO1xuXG52YXIgQ09OVkVYX0NPTlZFWCA9IENPTlZFWCB8IENPTlZFWDtcbnZhciBCT1hfQk9YID0gQk9YIHwgQk9YO1xudmFyIEJPWF9DT05WRVggPSBCT1ggfCBDT05WRVg7XG52YXIgU1BIRVJFX1NQSEVSRSA9IFNQSEVSRSB8IFNQSEVSRTtcbnZhciBCT1hfU1BIRVJFID0gQk9YIHwgU1BIRVJFO1xudmFyIENPTlZFWF9TUEhFUkUgPSBDT05WRVggfCBTUEhFUkU7XG52YXIgQ09OVkVYX1dBTEwgPSBDT05WRVggfCBXQUxMO1xudmFyIEJPWF9XQUxMID0gQk9YIHwgV0FMTDtcbnZhciBTUEhFUkVfV0FMTCA9IFNQSEVSRSB8IFdBTEw7XG5cbnZhciBkaXNwYXRjaCA9IHt9O1xuZGlzcGF0Y2hbQ09OVkVYX0NPTlZFWF0gPSBjb252ZXhJbnRlcnNlY3RDb252ZXg7XG5kaXNwYXRjaFtCT1hfQk9YXSA9IGNvbnZleEludGVyc2VjdENvbnZleDtcbmRpc3BhdGNoW0JPWF9DT05WRVhdID0gY29udmV4SW50ZXJzZWN0Q29udmV4O1xuZGlzcGF0Y2hbQ09OVkVYX1NQSEVSRV0gPSBjb252ZXhJbnRlcnNlY3RDb252ZXg7XG5kaXNwYXRjaFtTUEhFUkVfU1BIRVJFXSA9IHNwaGVyZUludGVyc2VjdFNwaGVyZTtcbmRpc3BhdGNoW0JPWF9TUEhFUkVdID0gYm94SW50ZXJzZWN0U3BoZXJlO1xuZGlzcGF0Y2hbQ09OVkVYX1dBTExdID0gY29udmV4SW50ZXJzZWN0V2FsbDtcbmRpc3BhdGNoW0JPWF9XQUxMXSA9IGNvbnZleEludGVyc2VjdFdhbGw7XG5kaXNwYXRjaFtTUEhFUkVfV0FMTF0gPSBjb252ZXhJbnRlcnNlY3RXYWxsO1xuXG4vKipcbiAqIE5hcnJvd3BoYXNlIGNvbGxpc2lvbiBkZXRlY3Rpb24sXG4gKiByZWdpc3RlcnMgdGhlIENvbnRhY3QgY29uc3RyYWludHMgZm9yIGNvbGxpZGluZyBib2RpZXMuXG4gKlxuICogV2lsbCBkZXRlY3QgdGhlIHR5cGUgb2YgYm9kaWVzIGluIHRoZSBjb2xsaXNpb24uXG4gKlxuICogQG1ldGhvZCBhcHBseU5hcnJvd1BoYXNlXG4gKiBAcGFyYW0ge1BhcnRpY2xlW119IHRhcmdldHNcbiAqL1xuQ29sbGlzaW9uLnByb3RvdHlwZS5hcHBseU5hcnJvd1BoYXNlID0gZnVuY3Rpb24gYXBwbHlOYXJyb3dQaGFzZSh0YXJnZXRzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRhcmdldHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIHZhciAgYSA9IHRhcmdldHNbaV07XG4gICAgICAgICAgICB2YXIgYiA9IHRhcmdldHNbal07XG5cbiAgICAgICAgICAgIGlmICgoYS5jb2xsaXNpb25NYXNrICYgYi5jb2xsaXNpb25Hcm91cCAmJiBhLmNvbGxpc2lvbkdyb3VwICYgYi5jb2xsaXNpb25NYXNrKSA9PT0gMCkgY29udGludWU7XG5cbiAgICAgICAgICAgIHZhciBjb2xsaXNpb25UeXBlID0gYS50eXBlIHwgYi50eXBlO1xuXG4gICAgICAgICAgICBkaXNwYXRjaFtjb2xsaXNpb25UeXBlXSAmJiBkaXNwYXRjaFtjb2xsaXNpb25UeXBlXSh0aGlzLCBhLCBiKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogRGV0ZWN0cyBzcGhlcmUtc3BoZXJlIGNvbGxpc2lvbnMgYW5kIHJlZ2lzdGVycyB0aGUgQ29udGFjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCBzcGhlcmVJbnRlcnNlY3RTcGhlcmVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKiBAcGFyYW0ge1NwaGVyZX0gc3BoZXJlMVxuICogQHBhcmFtIHtTcGhlcmV9IHNwaGVyZTJcbiAqL1xuZnVuY3Rpb24gc3BoZXJlSW50ZXJzZWN0U3BoZXJlKGNvbnRleHQsIHNwaGVyZTEsIHNwaGVyZTIpIHtcbiAgICB2YXIgcDEgPSBzcGhlcmUxLnBvc2l0aW9uO1xuICAgIHZhciBwMiA9IHNwaGVyZTIucG9zaXRpb247XG4gICAgdmFyIHJlbGF0aXZlUG9zaXRpb24gPSBWZWMzLnN1YnRyYWN0KHAyLCBwMSwgbmV3IFZlYzMoKSk7XG4gICAgdmFyIGRpc3RhbmNlID0gcmVsYXRpdmVQb3NpdGlvbi5sZW5ndGgoKTtcbiAgICB2YXIgc3VtUmFkaWkgPSBzcGhlcmUxLnJhZGl1cyArIHNwaGVyZTIucmFkaXVzO1xuICAgIHZhciBuID0gcmVsYXRpdmVQb3NpdGlvbi5zY2FsZSgxL2Rpc3RhbmNlKTtcblxuICAgIHZhciBvdmVybGFwID0gc3VtUmFkaWkgLSBkaXN0YW5jZTtcblxuICAgIC8vIERpc3RhbmNlIGNoZWNrXG4gICAgaWYgKG92ZXJsYXAgPCAwKSByZXR1cm47XG5cbiAgICB2YXIgclNwaGVyZTEgPSBWZWMzLnNjYWxlKG4sIHNwaGVyZTEucmFkaXVzLCBuZXcgVmVjMygpKTtcbiAgICB2YXIgclNwaGVyZTIgPSBWZWMzLnNjYWxlKG4sIC1zcGhlcmUyLnJhZGl1cywgbmV3IFZlYzMoKSk7XG5cbiAgICB2YXIgd1NwaGVyZTEgPSBWZWMzLmFkZChwMSwgclNwaGVyZTEsIG5ldyBWZWMzKCkpO1xuICAgIHZhciB3U3BoZXJlMiA9IFZlYzMuYWRkKHAyLCByU3BoZXJlMiwgbmV3IFZlYzMoKSk7XG5cbiAgICB2YXIgY29sbGlzaW9uRGF0YSA9IE9NUmVxdWVzdENvbGxpc2lvbkRhdGEoKS5yZXNldChvdmVybGFwLCBuLCB3U3BoZXJlMSwgd1NwaGVyZTIsIHJTcGhlcmUxLCByU3BoZXJlMik7XG5cbiAgICBjb250ZXh0LmNvbnRhY3RNYW5pZm9sZFRhYmxlLnJlZ2lzdGVyQ29udGFjdChzcGhlcmUxLCBzcGhlcmUyLCBjb2xsaXNpb25EYXRhKTtcbn1cblxuLyoqXG4qIERldGVjdHMgYm94LXNwaGVyZSBjb2xsaXNpb25zIGFuZCByZWdpc3RlcnMgdGhlIENvbnRhY3QuXG4qXG4qIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4qIEBwYXJhbSB7Qm94fSBib3hcbiogQHBhcmFtIHtTcGhlcmV9IHNwaGVyZVxuKi9cbmZ1bmN0aW9uIGJveEludGVyc2VjdFNwaGVyZShjb250ZXh0LCBib3gsIHNwaGVyZSkge1xuICAgIGlmIChib3gudHlwZSA9PT0gU1BIRVJFKSB7XG4gICAgICAgIHZhciB0ZW1wID0gc3BoZXJlO1xuICAgICAgICBzcGhlcmUgPSBib3g7XG4gICAgICAgIGJveCA9IHRlbXA7XG4gICAgfVxuXG4gICAgdmFyIHBiID0gYm94LnBvc2l0aW9uO1xuICAgIHZhciBwcyA9IHNwaGVyZS5wb3NpdGlvbjtcbiAgICB2YXIgcmVsYXRpdmVQb3NpdGlvbiA9IFZlYzMuc3VidHJhY3QocHMsIHBiLCBWRUNfUkVHSVNURVIpO1xuXG4gICAgdmFyIHEgPSBib3gub3JpZW50YXRpb247XG5cbiAgICB2YXIgciA9IHNwaGVyZS5yYWRpdXM7XG5cbiAgICB2YXIgYnNpemUgPSBib3guc2l6ZTtcbiAgICB2YXIgaGFsZldpZHRoID0gYnNpemVbMF0qMC41O1xuICAgIHZhciBoYWxmSGVpZ2h0ID0gYnNpemVbMV0qMC41O1xuICAgIHZhciBoYWxmRGVwdGggPSBic2l6ZVsyXSowLjU7XG5cbiAgICAvLyB4LCB5LCB6XG4gICAgdmFyIGJub3JtYWxzID0gYm94Lm5vcm1hbHM7XG4gICAgdmFyIG4xID0gcS5yb3RhdGVWZWN0b3IoYm5vcm1hbHNbMV0sIG5ldyBWZWMzKCkpO1xuICAgIHZhciBuMiA9IHEucm90YXRlVmVjdG9yKGJub3JtYWxzWzBdLCBuZXcgVmVjMygpKTtcbiAgICB2YXIgbjMgPSBxLnJvdGF0ZVZlY3Rvcihibm9ybWFsc1syXSwgbmV3IFZlYzMoKSk7XG5cbiAgICAvLyBGaW5kIHRoZSBwb2ludCBvbiB0aGUgY3ViZSBjbG9zZXN0IHRvIHRoZSBjZW50ZXIgb2YgdGhlIHNwaGVyZVxuICAgIHZhciBjbG9zZXN0UG9pbnQgPSBuZXcgVmVjMygpO1xuICAgIGNsb3Nlc3RQb2ludC54ID0gY2xhbXAoVmVjMy5kb3QocmVsYXRpdmVQb3NpdGlvbixuMSksIC1oYWxmV2lkdGgsIGhhbGZXaWR0aCk7XG4gICAgY2xvc2VzdFBvaW50LnkgPSBjbGFtcChWZWMzLmRvdChyZWxhdGl2ZVBvc2l0aW9uLG4yKSwgLWhhbGZIZWlnaHQsIGhhbGZIZWlnaHQpO1xuICAgIGNsb3Nlc3RQb2ludC56ID0gY2xhbXAoVmVjMy5kb3QocmVsYXRpdmVQb3NpdGlvbixuMyksIC1oYWxmRGVwdGgsIGhhbGZEZXB0aCk7XG4gICAgLy8gVGhlIHZlY3RvciBmb3VuZCBpcyByZWxhdGl2ZSB0byB0aGUgY2VudGVyIG9mIHRoZSB1bnJvdGF0ZWQgYm94IC0tIHJvdGF0ZSBpdFxuICAgIC8vIHRvIGZpbmQgdGhlIHBvaW50IHcuci50LiB0byBjdXJyZW50IG9yaWVudGF0aW9uXG4gICAgY2xvc2VzdFBvaW50LmFwcGx5Um90YXRpb24ocSk7XG5cbiAgICAvLyBUaGUgaW1wYWN0IHBvaW50IGluIHdvcmxkIHNwYWNlXG4gICAgdmFyIGltcGFjdFBvaW50ID0gVmVjMy5hZGQocGIsIGNsb3Nlc3RQb2ludCwgbmV3IFZlYzMoKSk7XG4gICAgdmFyIHNwaGVyZVRvSW1wYWN0ID0gVmVjMy5zdWJ0cmFjdChpbXBhY3RQb2ludCwgcHMsIGltcGFjdFBvaW50KTtcbiAgICB2YXIgZGlzdGFuY2VUb1NwaGVyZSA9IHNwaGVyZVRvSW1wYWN0Lmxlbmd0aCgpO1xuXG4gICAgLy8gSWYgaW1wYWN0IHBvaW50IGlzIG5vdCBjbG9zZXIgdG8gdGhlIHNwaGVyZSdzIGNlbnRlciB0aGFuIGl0cyByYWRpdXMgLT4gbm8gY29sbGlzaW9uXG4gICAgdmFyIG92ZXJsYXAgPSByIC0gZGlzdGFuY2VUb1NwaGVyZTtcbiAgICBpZiAob3ZlcmxhcCA8IDApIHJldHVybjtcblxuICAgIHZhciBuID0gVmVjMy5zY2FsZShzcGhlcmVUb0ltcGFjdCwgLTEgLyBkaXN0YW5jZVRvU3BoZXJlLCBuZXcgVmVjMygpKTtcbiAgICB2YXIgckJveCA9IGNsb3Nlc3RQb2ludDtcbiAgICB2YXIgclNwaGVyZSA9IHNwaGVyZVRvSW1wYWN0O1xuXG4gICAgdmFyIHdCb3ggPSBWZWMzLmFkZChwYiwgckJveCwgbmV3IFZlYzMoKSk7XG4gICAgdmFyIHdTcGhlcmUgPSBWZWMzLmFkZChwcywgclNwaGVyZSwgbmV3IFZlYzMoKSk7XG5cbiAgICB2YXIgY29sbGlzaW9uRGF0YSA9IE9NUmVxdWVzdENvbGxpc2lvbkRhdGEoKS5yZXNldChvdmVybGFwLCBuLCB3Qm94LCB3U3BoZXJlLCByQm94LCByU3BoZXJlKTtcblxuICAgIGNvbnRleHQuY29udGFjdE1hbmlmb2xkVGFibGUucmVnaXN0ZXJDb250YWN0KGJveCwgc3BoZXJlLCBjb2xsaXNpb25EYXRhKTtcbn1cblxuLyoqXG4qIERldGVjdHMgY29udmV4LWNvbnZleCBjb2xsaXNpb25zIGFuZCByZWdpc3RlcnMgdGhlIENvbnRhY3QuIFVzZXMgR0pLIHRvIGRldGVybWluZSBvdmVybGFwIGFuZCB0aGVuXG4qIEVQQSB0byBkZXRlcm1pbmUgdGhlIGFjdHVhbCBjb2xsaXNpb24gZGF0YS5cbipcbiogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiogQHBhcmFtIHtDb252ZXhCb2R5fSBjb252ZXgxXG4qIEBwYXJhbSB7Q29udmV4Qm9keX0gY29udmV4MlxuKi9cbmZ1bmN0aW9uIGNvbnZleEludGVyc2VjdENvbnZleChjb250ZXh0LCBjb252ZXgxLCBjb252ZXgyKSB7XG4gICAgdmFyIGdsa1NpbXBsZXggPSBHSksoY29udmV4MSwgY29udmV4Mik7XG5cbiAgICAvLyBObyBzaW1wbGV4IC0+IG5vIGNvbGxpc2lvblxuICAgIGlmICghZ2xrU2ltcGxleCkgcmV0dXJuO1xuXG4gICAgdmFyIGNvbGxpc2lvbkRhdGEgPSBFUEEoY29udmV4MSwgY29udmV4MiwgZ2xrU2ltcGxleCk7XG4gICAgaWYgKGNvbGxpc2lvbkRhdGEgIT09IG51bGwpIGNvbnRleHQuY29udGFjdE1hbmlmb2xkVGFibGUucmVnaXN0ZXJDb250YWN0KGNvbnZleDEsIGNvbnZleDIsIGNvbGxpc2lvbkRhdGEpO1xufVxuXG4vKipcbiogRGV0ZWN0cyBjb252ZXgtd2FsbCBjb2xsaXNpb25zIGFuZCByZWdpc3RlcnMgdGhlIENvbnRhY3QuXG4qXG4qIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4qIEBwYXJhbSB7Q29udmV4Qm9keX0gY29udmV4XG4qIEBwYXJhbSB7Q29udmV4Qm9keX0gd2FsbFxuKi9cbmZ1bmN0aW9uIGNvbnZleEludGVyc2VjdFdhbGwoY29udGV4dCwgY29udmV4LCB3YWxsKSB7XG4gICAgaWYgKGNvbnZleC50eXBlID09PSBXQUxMKSB7XG4gICAgICAgIHZhciB0ZW1wID0gd2FsbDtcbiAgICAgICAgd2FsbCA9IGNvbnZleDtcbiAgICAgICAgY29udmV4ID0gdGVtcDtcbiAgICB9XG5cbiAgICB2YXIgY29udmV4UG9zID0gY29udmV4LnBvc2l0aW9uO1xuICAgIHZhciB3YWxsUG9zID0gd2FsbC5wb3NpdGlvbjtcblxuICAgIHZhciBuID0gd2FsbC5ub3JtYWw7XG4gICAgdmFyIGludk4gPSB3YWxsLmludk5vcm1hbDtcblxuICAgIHZhciByQ29udmV4ID0gY29udmV4LnN1cHBvcnQoaW52Tik7XG4gICAgdmFyIHdDb252ZXggPSBWZWMzLmFkZChjb252ZXhQb3MsIHJDb252ZXgsIG5ldyBWZWMzKCkpO1xuXG4gICAgdmFyIGRpZmYgPSBWZWMzLnN1YnRyYWN0KHdDb252ZXgsIHdhbGxQb3MsIFZFQ19SRUdJU1RFUik7XG5cbiAgICB2YXIgcGVuZXRyYXRpb24gPSBWZWMzLmRvdChkaWZmLCBpbnZOKTtcblxuICAgIGlmIChwZW5ldHJhdGlvbiA8IDApIHJldHVybjtcblxuICAgIHZhciB3V2FsbCA9IFZlYzMuc2NhbGUobiwgcGVuZXRyYXRpb24sIG5ldyBWZWMzKCkpLmFkZCh3Q29udmV4KTtcbiAgICB2YXIgcldhbGwgPSBWZWMzLnN1YnRyYWN0KHdXYWxsLCB3YWxsLnBvc2l0aW9uLCBuZXcgVmVjMygpKTtcblxuICAgIHZhciBjb2xsaXNpb25EYXRhID0gT01SZXF1ZXN0Q29sbGlzaW9uRGF0YSgpLnJlc2V0KHBlbmV0cmF0aW9uLCBpbnZOLCB3Q29udmV4LCB3V2FsbCwgckNvbnZleCwgcldhbGwpO1xuXG4gICAgY29udGV4dC5jb250YWN0TWFuaWZvbGRUYWJsZS5yZWdpc3RlckNvbnRhY3QoY29udmV4LCB3YWxsLCBjb2xsaXNpb25EYXRhKTtcbn1cblxuQ29sbGlzaW9uLlN3ZWVwQW5kUHJ1bmUgPSBTd2VlcEFuZFBydW5lO1xuQ29sbGlzaW9uLkJydXRlRm9yY2UgPSBCcnV0ZUZvcmNlLkJydXRlRm9yY2U7XG5Db2xsaXNpb24uQnJ1dGVGb3JjZUFBQkIgPSBCcnV0ZUZvcmNlLkJydXRlRm9yY2VBQUJCO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbGxpc2lvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9JRCA9IDA7XG4vKipcbiAqIEJhc2UgQ29uc3RyYWludCBjbGFzcyB0byBiZSB1c2VkIGluIHRoZSBQaHlzaWNzXG4gKiBTdWJjbGFzcyB0aGlzIGNsYXNzIHRvIGltcGxlbWVudCBhIGNvbnN0cmFpbnRcbiAqXG4gKiBAdmlydHVhbFxuICogQGNsYXNzIENvbnN0cmFpbnRcbiAqL1xuZnVuY3Rpb24gQ29uc3RyYWludChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgdGhpcy5fSUQgPSBfSUQrKztcbn1cblxuLyoqXG4gKiBEZWNvcmF0ZXMgdGhlIENvbnN0cmFpbnQgd2l0aCB0aGUgb3B0aW9ucyBvYmplY3QuXG4gKlxuICogQG1ldGhvZCBzZXRPcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gT3B0aW9uc1xuICovXG5Db25zdHJhaW50LnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHRoaXNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICB0aGlzLmluaXQob3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIE1ldGhvZCBpbnZva2VkIHVwb24gaW5zdGFudGlhdGlvbiBhbmQgdGhlIHNldHRpbmcgb2Ygb3B0aW9ucy5cbiAqXG4gKiBAbWV0aG9kIGluaXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIGhhc2guXG4gKi9cbkNvbnN0cmFpbnQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiBpbml0KG9wdGlvbnMpIHt9O1xuXG4vKipcbiAqIERldGVjdCB2aW9sYXRpb25zIG9mIHRoZSBjb25zdHJhaW50LiBXYXJtIHN0YXJ0IHRoZSBjb25zdHJhaW50LCBpZiBwb3NzaWJsZS5cbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgVGhlIGN1cnJlbnQgdGltZSBpbiB0aGUgcGh5c2ljcyBlbmdpbmUuXG4gKiBAcGFyYW0ge051bWJlcn0gZHQgVGhlIHBoeXNpY3MgZW5naW5lIGZyYW1lIGRlbHRhLlxuICovXG5Db25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUodGltZSwgZHQpIHt9O1xuXG4vKipcbiAqIEFwcGx5IGltcHVsc2VzIHRvIHJlc29sdmUgdGhlIGNvbnN0cmFpbnQuXG4gKlxuICogQG1ldGhvZCByZXNvbHZlXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZSBUaGUgY3VycmVudCB0aW1lIGluIHRoZSBwaHlzaWNzIGVuZ2luZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBkdCBUaGUgcGh5c2ljcyBlbmdpbmUgZnJhbWUgZGVsdGEuXG4gKi9cbkNvbnN0cmFpbnQucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlKHRpbWUsIGR0KSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb25zdHJhaW50O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ29uc3RyYWludCA9IHJlcXVpcmUoJy4vQ29uc3RyYWludCcpO1xudmFyIFZlYzMgPSByZXF1aXJlKCdmYW1vdXMtbWF0aCcpLlZlYzM7XG5cbnZhciBJTVBVTFNFX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcbnZhciBOT1JNQUxfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xuXG4vKiogQGNvbnN0ICovXG52YXIgRVBTSUxTT04gPSAxZS03O1xuLyoqIEBjb25zdCAqL1xudmFyIFBJID0gTWF0aC5QSTtcblxuXG4vKipcbiAqICBBIGNvbnN0cmFpbnQgdGhhdCBrZWVwcyBhIHBoeXNpY3MgYm9keSBvbiBhIGdpdmVuIGltcGxpY2l0IGN1cnZlLlxuICpcbiAqICBAY2xhc3MgQ3VydmVcbiAqICBAY29uc3RydWN0b3JcbiAqICBAZXh0ZW5kcyBDb25zdHJhaW50XG4gKi9cbmZ1bmN0aW9uIEN1cnZlKHRhcmdldHMsIG9wdGlvbnMpIHtcbiAgICBpZiAodGFyZ2V0cykge1xuICAgICAgICBpZiAodGFyZ2V0cyBpbnN0YW5jZW9mIEFycmF5KSB0aGlzLnRhcmdldHMgPSB0YXJnZXRzO1xuICAgICAgICBlbHNlIHRoaXMudGFyZ2V0cyA9IFt0YXJnZXRzXTtcbiAgICB9XG4gICAgZWxzZSB0aGlzLnRhcmdldHMgPSBbXTtcblxuICAgIENvbnN0cmFpbnQuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICAgIHRoaXMuaW1wdWxzZXMgPSB7fTtcbiAgICB0aGlzLm5vcm1hbHMgPSB7fTtcbiAgICB0aGlzLnZlbG9jaXR5Qmlhc2VzID0ge307XG4gICAgdGhpcy5kaXZpc29ycyA9IHt9O1xufVxuXG5DdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENvbnN0cmFpbnQucHJvdG90eXBlKTtcbkN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEN1cnZlO1xuXG4vKipcbiAqIEluaXRpYWxpemUgdGhlIEN1cnZlLiBTZXRzIGRlZmF1bHRzIGlmIGEgcHJvcGVydHkgd2FzIG5vdCBhbHJlYWR5IHNldC5cbiAqXG4gKiBAbWV0aG9kIGluaXRcbiAqL1xuQ3VydmUucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmVxdWF0aW9uMSA9IHRoaXMuZXF1YXRpb24xIHx8IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgIHRoaXMuZXF1YXRpb24yID0gdGhpcy5lcXVhdGlvbjIgfHwgZnVuY3Rpb24oeCwgeSwgeikge1xuICAgICAgICByZXR1cm4gejtcbiAgICB9O1xuICAgIHRoaXMucGVyaW9kID0gdGhpcy5wZXJpb2QgfHwgMTtcbiAgICB0aGlzLmRhbXBpbmdSYXRpbyA9IHRoaXMuZGFtcGluZ1JhdGlvIHx8IDAuNTtcblxuICAgIHRoaXMuc3RpZmZuZXNzID0gNCAqIFBJICogUEkgLyAodGhpcy5wZXJpb2QgKiB0aGlzLnBlcmlvZCk7XG4gICAgdGhpcy5kYW1waW5nID0gNCAqIFBJICogdGhpcy5kYW1waW5nUmF0aW8gLyB0aGlzLnBlcmlvZDtcbn07XG5cbi8qKlxuICogV2FybXN0YXJ0IHRoZSBjb25zdHJhaW50IGFuZCBwcmVwYXJlIGNhbGN1bGF0aW9ucyB1c2VkIGluIHRoZSAucmVzb2x2ZSBzdGVwLlxuICpcbiAqIEBtZXRob2QgdXBkYXRlXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZSBUaGUgY3VycmVudCB0aW1lIGluIHRoZSBwaHlzaWNzIGVuZ2luZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBkdCBUaGUgcGh5c2ljcyBlbmdpbmUgZnJhbWUgZGVsdGEuXG4gKi9cbkN1cnZlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUodGltZSwgZHQpIHtcbiAgICB2YXIgdGFyZ2V0cyA9IHRoaXMudGFyZ2V0cztcblxuICAgIHZhciBub3JtYWxzID0gdGhpcy5ub3JtYWxzO1xuICAgIHZhciB2ZWxvY2l0eUJpYXNlcyA9IHRoaXMudmVsb2NpdHlCaWFzZXM7XG4gICAgdmFyIGRpdmlzb3JzID0gdGhpcy5kaXZpc29ycztcbiAgICB2YXIgaW1wdWxzZXMgPSB0aGlzLmltcHVsc2VzO1xuXG4gICAgdmFyIGltcHVsc2UgPSBJTVBVTFNFX1JFR0lTVEVSO1xuICAgIHZhciBuID0gTk9STUFMX1JFR0lTVEVSO1xuXG4gICAgdmFyIGYgPSB0aGlzLmVxdWF0aW9uMTtcbiAgICB2YXIgZyA9IHRoaXMuZXF1YXRpb24yO1xuXG4gICAgdmFyIF9jID0gdGhpcy5kYW1waW5nO1xuICAgIHZhciBfayA9IHRoaXMuc3RpZmZuZXNzO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRhcmdldHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGJvZHkgPSB0YXJnZXRzW2ldO1xuICAgICAgICB2YXIgSUQgPSBib2R5Ll9JRDtcbiAgICAgICAgaWYgKGJvZHkuaW1tdW5lKSBjb250aW51ZTtcblxuICAgICAgICB2YXIgcCA9IGJvZHkucG9zaXRpb247XG4gICAgICAgIHZhciBtID0gYm9keS5tYXNzO1xuXG4gICAgICAgIHZhciBnYW1tYTtcbiAgICAgICAgdmFyIGJldGE7XG5cbiAgICAgICAgaWYgKHRoaXMucGVyaW9kID09PSAwKSB7XG4gICAgICAgICAgICBnYW1tYSA9IDA7XG4gICAgICAgICAgICBiZXRhID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjID0gX2MgKiBtO1xuICAgICAgICAgICAgdmFyIGsgPSBfayAqIG07XG5cbiAgICAgICAgICAgIGdhbW1hID0gMSAvIChkdCooYyArIGR0KmspKTtcbiAgICAgICAgICAgIGJldGEgID0gZHQqayAvIChjICsgZHQqayk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeCA9IHAueDtcbiAgICAgICAgdmFyIHkgPSBwLnk7XG4gICAgICAgIHZhciB6ID0gcC56O1xuXG4gICAgICAgIHZhciBmMCA9IGYoeCwgeSwgeik7XG4gICAgICAgIHZhciBkZnggPSAoZih4ICsgRVBTSUxTT04sIHksIHopIC0gZjApIC8gRVBTSUxTT047XG4gICAgICAgIHZhciBkZnkgPSAoZih4LCB5ICsgRVBTSUxTT04sIHopIC0gZjApIC8gRVBTSUxTT047XG4gICAgICAgIHZhciBkZnogPSAoZih4LCB5LCB6ICsgRVBTSUxTT04pIC0gZjApIC8gRVBTSUxTT047XG5cbiAgICAgICAgdmFyIGcwID0gZyh4LCB5LCB6KTtcbiAgICAgICAgdmFyIGRneCA9IChnKHggKyBFUFNJTFNPTiwgeSwgeikgLSBnMCkgLyBFUFNJTFNPTjtcbiAgICAgICAgdmFyIGRneSA9IChnKHgsIHkgKyBFUFNJTFNPTiwgeikgLSBnMCkgLyBFUFNJTFNPTjtcbiAgICAgICAgdmFyIGRneiA9IChnKHgsIHksIHogKyBFUFNJTFNPTikgLSBnMCkgLyBFUFNJTFNPTjtcblxuICAgICAgICBuLnNldChkZnggKyBkZ3gsIGRmeSArIGRneSwgZGZ6ICsgZGd6KTtcbiAgICAgICAgbi5ub3JtYWxpemUoKTtcblxuICAgICAgICB2YXIgYmF1bWdhcnRlID0gYmV0YSAqIChmMCArIGcwKSAvIGR0O1xuICAgICAgICB2YXIgZGl2aXNvciA9IGdhbW1hICsgMSAvIG07XG5cbiAgICAgICAgdmFyIGxhbWJkYSA9IGltcHVsc2VzW0lEXSB8fCAwO1xuICAgICAgICBWZWMzLnNjYWxlKG4sIGxhbWJkYSwgaW1wdWxzZSk7XG4gICAgICAgIGJvZHkuYXBwbHlJbXB1bHNlKGltcHVsc2UpO1xuXG4gICAgICAgIG5vcm1hbHNbSURdID0gbm9ybWFsc1tJRF0gfHwgbmV3IFZlYzMoKTtcbiAgICAgICAgbm9ybWFsc1tJRF0uY29weShuKTtcbiAgICAgICAgdmVsb2NpdHlCaWFzZXNbSURdID0gYmF1bWdhcnRlO1xuICAgICAgICBkaXZpc29yc1tJRF0gPSBkaXZpc29yO1xuICAgICAgICBpbXB1bHNlc1tJRF0gPSAwO1xuICAgIH1cbn07XG5cbi8qKlxuICogQWRkcyBhIGN1cnZlIGltcHVsc2UgdG8gYSBwaHlzaWNzIGJvZHkuXG4gKlxuICogQG1ldGhvZCByZXNvbHZlXG4gKi9cbkN1cnZlLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZSgpIHtcbiAgICB2YXIgdGFyZ2V0cyA9IHRoaXMudGFyZ2V0cztcblxuICAgIHZhciBub3JtYWxzID0gdGhpcy5ub3JtYWxzO1xuICAgIHZhciB2ZWxvY2l0eUJpYXNlcyA9IHRoaXMudmVsb2NpdHlCaWFzZXM7XG4gICAgdmFyIGRpdmlzb3JzID0gdGhpcy5kaXZpc29ycztcbiAgICB2YXIgaW1wdWxzZXMgPSB0aGlzLmltcHVsc2VzO1xuXG4gICAgdmFyIGltcHVsc2UgPSBJTVBVTFNFX1JFR0lTVEVSO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRhcmdldHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGJvZHkgPSB0YXJnZXRzW2ldO1xuICAgICAgICB2YXIgSUQgPSBib2R5Ll9JRDtcbiAgICAgICAgaWYgKGJvZHkuaW1tdW5lKSBjb250aW51ZTtcblxuICAgICAgICB2YXIgdiA9IGJvZHkudmVsb2NpdHk7XG4gICAgICAgIHZhciBuID0gbm9ybWFsc1tJRF07XG5cbiAgICAgICAgdmFyIGxhbWJkYSA9IC0oVmVjMy5kb3QobiwgdikgKyB2ZWxvY2l0eUJpYXNlc1tJRF0pIC8gZGl2aXNvcnNbSURdO1xuXG4gICAgICAgIFZlYzMuc2NhbGUobiwgbGFtYmRhLCBpbXB1bHNlKTtcbiAgICAgICAgYm9keS5hcHBseUltcHVsc2UoaW1wdWxzZSk7XG5cblxuICAgICAgICBpbXB1bHNlc1tJRF0gKz0gbGFtYmRhO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ3VydmU7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ29uc3RyYWludCA9IHJlcXVpcmUoJy4vQ29uc3RyYWludCcpO1xudmFyIFZlYzMgPSByZXF1aXJlKCdmYW1vdXMtbWF0aCcpLlZlYzM7XG5cbnZhciBOT1JNQUxfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIElNUFVMU0VfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIFZfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIFBfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIERJUkVDVElPTl9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG5cbi8qKiBAY29uc3QgKi9cbnZhciBQSSA9IE1hdGguUEk7XG5cbi8qKlxuICogIEEgY29uc3RyYWludCB0aGF0IG1haW50YWlucyB0aGUgZGlyZWN0aW9uIG9mIG9uZSBib2R5IGZyb20gYW5vdGhlci5cbiAqXG4gKiAgQGNsYXNzIERpcmVjdGlvblxuICogIEBleHRlbmRzIENvbnN0cmFpbnRcbiAqICBAcGFyYW0ge1BhcnRpY2xlfSBhIE9uZSBvZiB0aGUgYm9kaWVzLlxuICogIEBwYXJhbSB7UGFydGljbGV9IGIgVGhlIG90aGVyIGJvZHkuXG4gKiAgQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQW4gb2JqZWN0IG9mIGNvbmZpZ3VyYWJsZSBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBEaXJlY3Rpb24oYSwgYiwgb3B0aW9ucykge1xuICAgIHRoaXMuYSA9IGE7XG4gICAgdGhpcy5iID0gYjtcblxuICAgIENvbnN0cmFpbnQuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICAgIHRoaXMuaW1wdWxzZSA9IDA7XG4gICAgdGhpcy5kaXN0YW5jZSA9IDA7XG4gICAgdGhpcy5ub3JtYWwgPSBuZXcgVmVjMygpO1xuICAgIHRoaXMudmVsb2NpdHlCaWFzID0gMDtcbiAgICB0aGlzLmRpdmlzb3IgPSAwO1xufVxuXG5EaXJlY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDb25zdHJhaW50LnByb3RvdHlwZSk7XG5EaXJlY3Rpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRGlyZWN0aW9uO1xuXG4vKipcbiAqIEluaXRpYWxpemUgdGhlIERpcmVjdGlvbi4gU2V0cyBkZWZhdWx0cyBpZiBhIHByb3BlcnR5IHdhcyBub3QgYWxyZWFkeSBzZXQuXG4gKlxuICogQG1ldGhvZCBpbml0XG4gKi9cbkRpcmVjdGlvbi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZGlyZWN0aW9uID0gdGhpcy5kaXJlY3Rpb24gfHwgVmVjMy5zdWJ0cmFjdCh0aGlzLmIucG9zaXRpb24sIHRoaXMuYS5wb3NpdGlvbiwgbmV3IFZlYzMoKSk7XG4gICAgdGhpcy5kaXJlY3Rpb24ubm9ybWFsaXplKCk7XG4gICAgdGhpcy5taW5MZW5ndGggPSB0aGlzLm1pbkxlbmd0aCB8fCAwO1xuICAgIHRoaXMucGVyaW9kID0gdGhpcy5wZXJpb2QgfHwgMC4yO1xuICAgIHRoaXMuZGFtcGluZ1JhdGlvID0gdGhpcy5kYW1waW5nUmF0aW8gfHwgMC41O1xuXG4gICAgdGhpcy5zdGlmZm5lc3MgPSA0ICogUEkgKiBQSSAvICh0aGlzLnBlcmlvZCAqIHRoaXMucGVyaW9kKTtcbiAgICB0aGlzLmRhbXBpbmcgPSA0ICogUEkgKiB0aGlzLmRhbXBpbmdSYXRpbyAvIHRoaXMucGVyaW9kO1xufTtcblxuLyoqXG4gKiBXYXJtc3RhcnQgdGhlIGNvbnN0cmFpbnQgYW5kIHByZXBhcmUgY2FsY3VsYXRpb25zIHVzZWQgaW4gLnJlc29sdmUuXG4gKlxuICogQG1ldGhvZCB1cGRhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIFRoZSBjdXJyZW50IHRpbWUgaW4gdGhlIHBoeXNpY3MgZW5naW5lLlxuICogQHBhcmFtIHtOdW1iZXJ9IGR0IFRoZSBwaHlzaWNzIGVuZ2luZSBmcmFtZSBkZWx0YS5cbiAqL1xuRGlyZWN0aW9uLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUodGltZSwgZHQpIHtcbiAgICB2YXIgYSA9IHRoaXMuYTtcbiAgICB2YXIgYiA9IHRoaXMuYjtcblxuICAgIHZhciBuID0gTk9STUFMX1JFR0lTVEVSO1xuICAgIHZhciBkaWZmUCA9IFBfUkVHSVNURVI7XG4gICAgdmFyIGltcHVsc2UgPSBJTVBVTFNFX1JFR0lTVEVSO1xuICAgIHZhciBkaXJlY3Rpb25WZWN0b3IgPSBESVJFQ1RJT05fUkVHSVNURVI7XG5cbiAgICB2YXIgcDEgPSBhLnBvc2l0aW9uO1xuICAgIHZhciB3MSA9IGEuaW52ZXJzZU1hc3M7XG5cbiAgICB2YXIgcDIgPSBiLnBvc2l0aW9uO1xuICAgIHZhciB3MiA9IGIuaW52ZXJzZU1hc3M7XG5cbiAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5kaXJlY3Rpb247XG5cbiAgICBWZWMzLnN1YnRyYWN0KHAyLCBwMSwgZGlmZlApO1xuICAgIFZlYzMuc2NhbGUoZGlyZWN0aW9uLCBWZWMzLmRvdChkaXJlY3Rpb24sIGRpZmZQKSwgZGlyZWN0aW9uVmVjdG9yKTtcbiAgICB2YXIgZ29hbCA9IGRpcmVjdGlvblZlY3Rvci5hZGQocDEpO1xuXG4gICAgVmVjMy5zdWJ0cmFjdChwMiwgZ29hbCwgbik7XG4gICAgdmFyIGRpc3QgPSBuLmxlbmd0aCgpO1xuICAgIG4ubm9ybWFsaXplKCk7XG5cbiAgICB2YXIgaW52RWZmZWN0aXZlTWFzcyA9IHcxICsgdzI7XG4gICAgdmFyIGVmZmVjdGl2ZU1hc3MgPSAxIC8gaW52RWZmZWN0aXZlTWFzcztcbiAgICB2YXIgZ2FtbWE7XG4gICAgdmFyIGJldGE7XG5cbiAgICBpZiAodGhpcy5wZXJpb2QgPT09IDApIHtcbiAgICAgICAgZ2FtbWEgPSAwO1xuICAgICAgICBiZXRhICA9IDE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgYyA9IHRoaXMuZGFtcGluZyAqIGVmZmVjdGl2ZU1hc3M7XG4gICAgICAgIHZhciBrID0gdGhpcy5zdGlmZm5lc3MgKiBlZmZlY3RpdmVNYXNzO1xuXG4gICAgICAgIGdhbW1hID0gMSAvIChkdCooYyArIGR0KmspKTtcbiAgICAgICAgYmV0YSAgPSBkdCprIC8gKGMgKyBkdCprKTtcbiAgICB9XG5cbiAgICB2YXIgYmF1bWdhcnRlID0gYmV0YSAqIGRpc3QgLyBkdDtcbiAgICB2YXIgZGl2aXNvciA9IGdhbW1hICsgaW52RWZmZWN0aXZlTWFzcztcblxuICAgIHZhciBsYW1iZGEgPSB0aGlzLmltcHVsc2U7XG4gICAgVmVjMy5zY2FsZShuLCBsYW1iZGEsIGltcHVsc2UpO1xuICAgIGIuYXBwbHlJbXB1bHNlKGltcHVsc2UpO1xuICAgIGEuYXBwbHlJbXB1bHNlKGltcHVsc2UuaW52ZXJ0KCkpO1xuXG4gICAgdGhpcy5ub3JtYWwuY29weShuKTtcbiAgICB0aGlzLmRpc3RhbmNlID0gZGlzdDtcbiAgICB0aGlzLnZlbG9jaXR5QmlhcyA9IGJhdW1nYXJ0ZTtcbiAgICB0aGlzLmRpdmlzb3IgPSBkaXZpc29yO1xuICAgIHRoaXMuaW1wdWxzZSA9IDA7XG59O1xuXG4vKipcbiAqIEFkZHMgYW4gaW1wdWxzZSB0byBhIHBoeXNpY3MgYm9keSdzIHZlbG9jaXR5IGR1ZSB0byB0aGUgY29uc3RyYWludFxuICpcbiAqIEBtZXRob2QgcmVzb2x2ZVxuICovXG5EaXJlY3Rpb24ucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgdmFyIGEgPSB0aGlzLmE7XG4gICAgdmFyIGIgPSB0aGlzLmI7XG5cbiAgICB2YXIgaW1wdWxzZSAgPSBJTVBVTFNFX1JFR0lTVEVSO1xuICAgIHZhciBkaWZmViA9IFZfUkVHSVNURVI7XG5cbiAgICB2YXIgbWluTGVuZ3RoID0gdGhpcy5taW5MZW5ndGg7XG5cbiAgICB2YXIgZGlzdCA9IHRoaXMuZGlzdGFuY2U7XG4gICAgaWYgKE1hdGguYWJzKGRpc3QpIDwgbWluTGVuZ3RoKSByZXR1cm47XG5cbiAgICB2YXIgdjEgPSBhLnZlbG9jaXR5O1xuICAgIHZhciB2MiA9IGIudmVsb2NpdHk7XG4gICAgdmFyIG4gPSB0aGlzLm5vcm1hbDtcblxuICAgIFZlYzMuc3VidHJhY3QodjIsIHYxLCBkaWZmVik7XG5cbiAgICB2YXIgbGFtYmRhID0gLShWZWMzLmRvdChuLCBkaWZmVikgKyB0aGlzLnZlbG9jaXR5QmlhcykgLyB0aGlzLmRpdmlzb3I7XG4gICAgVmVjMy5zY2FsZShuLCBsYW1iZGEsIGltcHVsc2UpO1xuICAgIGIuYXBwbHlJbXB1bHNlKGltcHVsc2UpO1xuICAgIGEuYXBwbHlJbXB1bHNlKGltcHVsc2UuaW52ZXJ0KCkpO1xuXG4gICAgdGhpcy5pbXB1bHNlICs9IGxhbWJkYTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGlyZWN0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ29uc3RyYWludCA9IHJlcXVpcmUoJy4vQ29uc3RyYWludCcpO1xudmFyIFZlYzMgPSByZXF1aXJlKCdmYW1vdXMtbWF0aCcpLlZlYzM7XG5cbnZhciBOT1JNQUxfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIElNUFVMU0VfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIFZfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIFBfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xuXG4vKiogQGNvbnN0ICovXG52YXIgUEkgPSBNYXRoLlBJO1xuXG4vKipcbiAqICBBIGNvbnN0cmFpbnQgdGhhdCBrZWVwcyB0d28gYm9kaWVzIHdpdGhpbiBhIGNlcnRhaW4gZGlzdGFuY2UuXG4gKlxuICogIEBjbGFzcyBEaXN0YW5jZVxuICogIEBleHRlbmRzIENvbnN0cmFpbnRcbiAqICBAcGFyYW0ge1BhcnRpY2xlfSBhIE9uZSBvZiB0aGUgYm9kaWVzLlxuICogIEBwYXJhbSB7UGFydGljbGV9IGIgVGhlIG90aGVyIGJvZHkuXG4gKiAgQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQW4gb2JqZWN0IG9mIGNvbmZpZ3VyYWJsZSBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBEaXN0YW5jZShhLCBiLCBvcHRpb25zKSB7XG4gICAgdGhpcy5hID0gYTtcbiAgICB0aGlzLmIgPSBiO1xuXG4gICAgQ29uc3RyYWludC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5pbXB1bHNlID0gMDtcbiAgICB0aGlzLmRpc3RhbmNlID0gMDtcbiAgICB0aGlzLm5vcm1hbCA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy52ZWxvY2l0eUJpYXMgPSAwO1xuICAgIHRoaXMuZGl2aXNvciA9IDA7XG59XG5cbkRpc3RhbmNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ29uc3RyYWludC5wcm90b3R5cGUpO1xuRGlzdGFuY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRGlzdGFuY2U7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgRGlzdGFuY2UuIFNldHMgZGVmYXVsdHMgaWYgYSBwcm9wZXJ0eSB3YXMgbm90IGFscmVhZHkgc2V0LlxuICpcbiAqIEBtZXRob2QgaW5pdFxuICovXG5EaXN0YW5jZS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubGVuZ3RoID0gdGhpcy5sZW5ndGggfHwgVmVjMy5zdWJ0cmFjdCh0aGlzLmIucG9zaXRpb24sIHRoaXMuYS5wb3NpdGlvbiwgUF9SRUdJU1RFUikubGVuZ3RoKCk7XG4gICAgdGhpcy5taW5MZW5ndGggPSB0aGlzLm1pbkxlbmd0aCB8fCAwO1xuICAgIHRoaXMucGVyaW9kID0gdGhpcy5wZXJpb2QgfHwgMC4yO1xuICAgIHRoaXMuZGFtcGluZ1JhdGlvID0gdGhpcy5kYW1waW5nUmF0aW8gfHwgMC41O1xuXG4gICAgdGhpcy5zdGlmZm5lc3MgPSA0ICogUEkgKiBQSSAvICh0aGlzLnBlcmlvZCAqIHRoaXMucGVyaW9kKTtcbiAgICB0aGlzLmRhbXBpbmcgPSA0ICogUEkgKiB0aGlzLmRhbXBpbmdSYXRpbyAvIHRoaXMucGVyaW9kO1xufTtcblxuLyoqXG4gKiBEZXRlY3QgdmlvbGF0aW9ucyBvZiB0aGUgY29uc3RyYWludC4gV2FybSBzdGFydCB0aGUgY29uc3RyYWludCwgaWYgcG9zc2libGUuXG4gKlxuICogQG1ldGhvZCB1cGRhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIFRoZSBjdXJyZW50IHRpbWUgaW4gdGhlIHBoeXNpY3MgZW5naW5lLlxuICogQHBhcmFtIHtOdW1iZXJ9IGR0IFRoZSBwaHlzaWNzIGVuZ2luZSBmcmFtZSBkZWx0YS5cbiAqL1xuRGlzdGFuY2UucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKHRpbWUsIGR0KSB7XG4gICAgdmFyIGEgPSB0aGlzLmE7XG4gICAgdmFyIGIgPSB0aGlzLmI7XG5cbiAgICB2YXIgbiA9IE5PUk1BTF9SRUdJU1RFUjtcbiAgICB2YXIgZGlmZlAgPSBQX1JFR0lTVEVSO1xuICAgIHZhciBpbXB1bHNlID0gSU1QVUxTRV9SRUdJU1RFUjtcblxuICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aDtcblxuICAgIHZhciBwMSA9IGEucG9zaXRpb247XG4gICAgdmFyIHcxID0gYS5pbnZlcnNlTWFzcztcblxuICAgIHZhciBwMiA9IGIucG9zaXRpb247XG4gICAgdmFyIHcyID0gYi5pbnZlcnNlTWFzcztcblxuICAgIFZlYzMuc3VidHJhY3QocDIsIHAxLCBkaWZmUCk7XG5cbiAgICB2YXIgc2VwYXJhdGlvbiA9IGRpZmZQLmxlbmd0aCgpO1xuXG4gICAgVmVjMy5zY2FsZShkaWZmUCwgMSAvIHNlcGFyYXRpb24sIG4pO1xuXG4gICAgdmFyIGRpc3QgPSBzZXBhcmF0aW9uIC0gbGVuZ3RoO1xuXG4gICAgdmFyIGludkVmZmVjdGl2ZU1hc3MgPSB3MSArIHcyO1xuICAgIHZhciBlZmZlY3RpdmVNYXNzID0gMSAvIGludkVmZmVjdGl2ZU1hc3M7XG4gICAgdmFyIGdhbW1hO1xuICAgIHZhciBiZXRhO1xuXG4gICAgaWYgKHRoaXMucGVyaW9kID09PSAwKSB7XG4gICAgICAgIGdhbW1hID0gMDtcbiAgICAgICAgYmV0YSAgPSAxO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLmRhbXBpbmcgKiBlZmZlY3RpdmVNYXNzO1xuICAgICAgICB2YXIgayA9IHRoaXMuc3RpZmZuZXNzICogZWZmZWN0aXZlTWFzcztcblxuICAgICAgICBnYW1tYSA9IDEgLyAoZHQqKGMgKyBkdCprKSk7XG4gICAgICAgIGJldGEgID0gZHQqayAvIChjICsgZHQqayk7XG4gICAgfVxuXG4gICAgdmFyIGJhdW1nYXJ0ZSA9IGJldGEgKiBkaXN0IC8gZHQ7XG4gICAgdmFyIGRpdmlzb3IgPSBnYW1tYSArIGludkVmZmVjdGl2ZU1hc3M7XG5cbiAgICB2YXIgbGFtYmRhID0gdGhpcy5pbXB1bHNlO1xuICAgIFZlYzMuc2NhbGUobiwgbGFtYmRhLCBpbXB1bHNlKTtcbiAgICBiLmFwcGx5SW1wdWxzZShpbXB1bHNlKTtcbiAgICBhLmFwcGx5SW1wdWxzZShpbXB1bHNlLmludmVydCgpKTtcblxuICAgIHRoaXMubm9ybWFsLmNvcHkobik7XG4gICAgdGhpcy5kaXN0YW5jZSA9IGRpc3Q7XG4gICAgdGhpcy52ZWxvY2l0eUJpYXMgPSBiYXVtZ2FydGU7XG4gICAgdGhpcy5kaXZpc29yID0gZGl2aXNvcjtcbiAgICB0aGlzLmltcHVsc2UgPSAwO1xufTtcblxuLyoqXG4gKiBBcHBseSBpbXB1bHNlcyB0byByZXNvbHZlIHRoZSBjb25zdHJhaW50LlxuICpcbiAqIEBtZXRob2QgcmVzb2x2ZVxuICovXG5EaXN0YW5jZS5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUoKSB7XG4gICAgdmFyIGEgPSB0aGlzLmE7XG4gICAgdmFyIGIgPSB0aGlzLmI7XG5cbiAgICB2YXIgaW1wdWxzZSA9IElNUFVMU0VfUkVHSVNURVI7XG4gICAgdmFyIGRpZmZWID0gVl9SRUdJU1RFUjtcblxuICAgIHZhciBtaW5MZW5ndGggPSB0aGlzLm1pbkxlbmd0aDtcblxuICAgIHZhciBkaXN0ID0gdGhpcy5kaXN0YW5jZTtcbiAgICBpZiAoTWF0aC5hYnMoZGlzdCkgPCBtaW5MZW5ndGgpIHJldHVybjtcblxuICAgIHZhciB2MSA9IGEuZ2V0VmVsb2NpdHkoKTtcbiAgICB2YXIgdjIgPSBiLmdldFZlbG9jaXR5KCk7XG5cbiAgICB2YXIgbiA9IHRoaXMubm9ybWFsO1xuXG4gICAgVmVjMy5zdWJ0cmFjdCh2MiwgdjEsIGRpZmZWKTtcbiAgICB2YXIgbGFtYmRhID0gLShWZWMzLmRvdChuLCBkaWZmVikgKyB0aGlzLnZlbG9jaXR5QmlhcykgLyB0aGlzLmRpdmlzb3I7XG4gICAgVmVjMy5zY2FsZShuLCBsYW1iZGEsIGltcHVsc2UpO1xuICAgIGIuYXBwbHlJbXB1bHNlKGltcHVsc2UpO1xuICAgIGEuYXBwbHlJbXB1bHNlKGltcHVsc2UuaW52ZXJ0KCkpO1xuXG4gICAgdGhpcy5pbXB1bHNlICs9IGxhbWJkYTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGlzdGFuY2U7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDb25zdHJhaW50ID0gcmVxdWlyZSgnLi9Db25zdHJhaW50Jyk7XG52YXIgVmVjMyA9IHJlcXVpcmUoJ2ZhbW91cy1tYXRoJykuVmVjMztcbnZhciBNYXQzMyA9IHJlcXVpcmUoJ2ZhbW91cy1tYXRoJykuTWF0MzM7XG52YXIgUXVhdGVybmlvbiA9IHJlcXVpcmUoJ2ZhbW91cy1tYXRoJykuUXVhdGVybmlvbjtcblxudmFyIFZFQzFfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIFZFQzJfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIFZFQzNfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIFZFQzRfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIFZCMV9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgVkIyX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcbnZhciBXeFJfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIERFTFRBX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiAgQSBjb25zdHJhaW50IHRoYXQgY29uZmluZXMgdHdvIGJvZGllcyB0byB0aGUgcGxhbmUgZGVmaW5lZCBieSB0aGUgYXhpcyBvZiB0aGUgaGluZ2UuXG4gKlxuICogIEBjbGFzcyBIaW5nZVxuICogIEBleHRlbmRzIENvbnN0cmFpbnRcbiAqICBAcGFyYW0ge09wdGlvbnN9IFtvcHRpb25zXSBBbiBvYmplY3Qgb2YgY29uZmlndXJhYmxlIG9wdGlvbnMuXG4gKlxuICovXG5mdW5jdGlvbiBIaW5nZShhLCBiLCBvcHRpb25zKSB7XG4gICAgdGhpcy5hID0gYTtcbiAgICB0aGlzLmIgPSBiO1xuXG4gICAgQ29uc3RyYWludC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5pbXB1bHNlID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLmFuZ0ltcHVsc2VBID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLmFuZ0ltcHVsc2VCID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLmVycm9yID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLmVycm9yUm90ID0gWzAsMF07XG4gICAgdGhpcy5lZmZNYXNzTWF0cml4ID0gbmV3IE1hdDMzKCk7XG4gICAgdGhpcy5lZmZNYXNzTWF0cml4Um90ID0gW107XG59XG5cbkhpbmdlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ29uc3RyYWludC5wcm90b3R5cGUpO1xuSGluZ2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSGluZ2U7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgSGluZ2UuIFNldHMgZGVmYXVsdHMgaWYgYSBwcm9wZXJ0eSB3YXMgbm90IGFscmVhZHkgc2V0LlxuICpcbiAqIEBtZXRob2QgaW5pdFxuICovXG5IaW5nZS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB3ID0gdGhpcy5hbmNob3I7XG5cbiAgICB2YXIgdSA9IHRoaXMuYXhpcy5ub3JtYWxpemUoKTtcblxuICAgIHZhciBhID0gdGhpcy5hO1xuICAgIHZhciBiID0gdGhpcy5iO1xuXG4gICAgdmFyIHExdCA9IFF1YXRlcm5pb24uY29uanVnYXRlKGEub3JpZW50YXRpb24sIG5ldyBRdWF0ZXJuaW9uKCkpO1xuICAgIHZhciBxMnQgPSBRdWF0ZXJuaW9uLmNvbmp1Z2F0ZShiLm9yaWVudGF0aW9uLCBuZXcgUXVhdGVybmlvbigpKTtcblxuICAgIHRoaXMuckEgPSBWZWMzLnN1YnRyYWN0KHcsIGEucG9zaXRpb24sIG5ldyBWZWMzKCkpO1xuICAgIHRoaXMuckIgPSBWZWMzLnN1YnRyYWN0KHcsIGIucG9zaXRpb24sIG5ldyBWZWMzKCkpO1xuXG4gICAgdGhpcy5ib2R5UkEgPSBxMXQucm90YXRlVmVjdG9yKHRoaXMuckEsIG5ldyBWZWMzKCkpO1xuICAgIHRoaXMuYm9keVJCID0gcTJ0LnJvdGF0ZVZlY3Rvcih0aGlzLnJCLCBuZXcgVmVjMygpKTtcblxuICAgIHRoaXMuYXhpc0EgPSBWZWMzLmNsb25lKHUpO1xuICAgIHRoaXMuYXhpc0IgPSBWZWMzLmNsb25lKHUpO1xuXG4gICAgdGhpcy5heGlzQlRhbmdlbnQxID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLmF4aXNCVGFuZ2VudDIgPSBuZXcgVmVjMygpO1xuXG4gICAgdGhpcy50MXhBID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLnQyeEEgPSBuZXcgVmVjMygpO1xuXG4gICAgdGhpcy5ib2R5QXhpc0EgPSBxMXQucm90YXRlVmVjdG9yKHUsIG5ldyBWZWMzKCkpO1xuICAgIHRoaXMuYm9keUF4aXNCID0gcTJ0LnJvdGF0ZVZlY3Rvcih1LCBuZXcgVmVjMygpKTtcbn07XG5cbi8qKlxuICogRGV0ZWN0IHZpb2xhdGlvbnMgb2YgdGhlIGNvbnN0cmFpbnQuIFdhcm0gc3RhcnQgdGhlIGNvbnN0cmFpbnQsIGlmIHBvc3NpYmxlLlxuICpcbiAqIEBtZXRob2QgdXBkYXRlXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZSBUaGUgY3VycmVudCB0aW1lIGluIHRoZSBwaHlzaWNzIGVuZ2luZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBkdCBUaGUgcGh5c2ljcyBlbmdpbmUgZnJhbWUgZGVsdGEuXG4gKi9cbkhpbmdlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbih0aW1lLCBkdCkge1xuICAgIHZhciBhID0gdGhpcy5hO1xuICAgIHZhciBiID0gdGhpcy5iO1xuXG4gICAgdmFyIGF4aXNBID0gYS5vcmllbnRhdGlvbi5yb3RhdGVWZWN0b3IodGhpcy5ib2R5QXhpc0EsIHRoaXMuYXhpc0EpO1xuICAgIHZhciBheGlzQiA9IGIub3JpZW50YXRpb24ucm90YXRlVmVjdG9yKHRoaXMuYm9keUF4aXNCLCB0aGlzLmF4aXNCKTtcbiAgICB0aGlzLmF4aXMuY29weShheGlzQik7XG5cbiAgICB2YXIgbiA9IGF4aXNCO1xuICAgIHZhciB0MSA9IHRoaXMuYXhpc0JUYW5nZW50MTtcbiAgICB2YXIgdDIgPSB0aGlzLmF4aXNCVGFuZ2VudDI7XG5cbiAgICBpZiAobi54ID49IDAuNTc3MzUpIHtcbiAgICAgICAgdDEuc2V0KG4ueSwgLW4ueCwgMCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0MS5zZXQoMCwgbi56LCAtbi55KTtcbiAgICB9XG4gICAgdDEubm9ybWFsaXplKCk7XG4gICAgVmVjMy5jcm9zcyhuLCB0MSwgdDIpO1xuXG4gICAgdmFyIHQxeEEgPSBWZWMzLmNyb3NzKHQxLCBheGlzQSwgdGhpcy50MXhBKTtcbiAgICB2YXIgdDJ4QSA9IFZlYzMuY3Jvc3ModDIsIGF4aXNBLCB0aGlzLnQyeEEpO1xuXG4gICAgdmFyIHJBID0gYS5vcmllbnRhdGlvbi5yb3RhdGVWZWN0b3IodGhpcy5ib2R5UkEsIHRoaXMuckEpO1xuICAgIHZhciByQiA9IGIub3JpZW50YXRpb24ucm90YXRlVmVjdG9yKHRoaXMuYm9keVJCLCB0aGlzLnJCKTtcblxuICAgIHZhciB4UkEgPSBuZXcgTWF0MzMoWzAsckEueiwtckEueSwtckEueiwwLHJBLngsckEueSwtckEueCwwXSk7XG4gICAgdmFyIHhSQiA9IG5ldyBNYXQzMyhbMCxyQi56LC1yQi55LC1yQi56LDAsckIueCxyQi55LC1yQi54LDBdKTtcblxuICAgIHZhciBSSWFSdCA9IE1hdDMzLm11bHRpcGx5KHhSQSwgYS5pbnZlcnNlSW5lcnRpYSwgbmV3IE1hdDMzKCkpLm11bHRpcGx5KHhSQS50cmFuc3Bvc2UoKSk7XG4gICAgdmFyIFJJYlJ0ID0gTWF0MzMubXVsdGlwbHkoeFJCLCBiLmludmVyc2VJbmVydGlhLCBuZXcgTWF0MzMoKSkubXVsdGlwbHkoeFJCLnRyYW5zcG9zZSgpKTtcblxuICAgIHZhciBpbnZFZmZJbmVydGlhID0gTWF0MzMuYWRkKFJJYVJ0LCBSSWJSdCwgUklhUnQpO1xuXG4gICAgdmFyIHdvcmxkQSA9IFZlYzMuYWRkKGEucG9zaXRpb24sIHRoaXMuckEsIHRoaXMuYW5jaG9yKTtcbiAgICB2YXIgd29ybGRCID0gVmVjMy5hZGQoYi5wb3NpdGlvbiwgdGhpcy5yQiwgVkVDMV9SRUdJU1RFUik7XG5cbiAgICB2YXIgaW52RHQgPSAxL2R0O1xuICAgIFZlYzMuc3VidHJhY3Qod29ybGRCLCB3b3JsZEEsIHRoaXMuZXJyb3IpO1xuICAgIHRoaXMuZXJyb3Iuc2NhbGUoMC4yKmludkR0KTtcblxuICAgIHZhciBpbUEgPSBhLmludmVyc2VNYXNzO1xuICAgIHZhciBpbUIgPSBiLmludmVyc2VNYXNzO1xuXG4gICAgdmFyIGludkVmZk1hc3MgPSBuZXcgTWF0MzMoW2ltQSArIGltQiwwLDAsMCxpbUEgKyBpbUIsMCwwLDAsaW1BICsgaW1CXSk7XG5cbiAgICBNYXQzMy5hZGQoaW52RWZmSW5lcnRpYSwgaW52RWZmTWFzcywgdGhpcy5lZmZNYXNzTWF0cml4KTtcbiAgICB0aGlzLmVmZk1hc3NNYXRyaXguaW52ZXJzZSgpO1xuXG4gICAgdmFyIGludklBdDF4QSA9IGEuaW52ZXJzZUluZXJ0aWEudmVjdG9yTXVsdGlwbHkodDF4QSwgVkVDMV9SRUdJU1RFUik7XG4gICAgdmFyIGludklBdDJ4QSA9IGEuaW52ZXJzZUluZXJ0aWEudmVjdG9yTXVsdGlwbHkodDJ4QSwgVkVDMl9SRUdJU1RFUik7XG4gICAgdmFyIGludklCdDF4QSA9IGIuaW52ZXJzZUluZXJ0aWEudmVjdG9yTXVsdGlwbHkodDF4QSwgVkVDM19SRUdJU1RFUik7XG4gICAgdmFyIGludklCdDJ4QSA9IGIuaW52ZXJzZUluZXJ0aWEudmVjdG9yTXVsdGlwbHkodDJ4QSwgVkVDNF9SRUdJU1RFUik7XG5cbiAgICB2YXIgYTExID0gVmVjMy5kb3QodDF4QSwgaW52SUF0MXhBKSArIFZlYzMuZG90KHQxeEEsIGludklCdDF4QSk7XG4gICAgdmFyIGExMiA9IFZlYzMuZG90KHQxeEEsIGludklBdDJ4QSkgKyBWZWMzLmRvdCh0MXhBLCBpbnZJQnQyeEEpO1xuICAgIHZhciBhMjEgPSBWZWMzLmRvdCh0MnhBLCBpbnZJQXQxeEEpICsgVmVjMy5kb3QodDJ4QSwgaW52SUJ0MXhBKTtcbiAgICB2YXIgYTIyID0gVmVjMy5kb3QodDJ4QSwgaW52SUF0MnhBKSArIFZlYzMuZG90KHQyeEEsIGludklCdDJ4QSk7XG5cbiAgICB2YXIgZGV0ID0gMSAvIChhMTEqYTIyIC0gYTEyKmEyMSk7XG5cbiAgICB0aGlzLmVmZk1hc3NNYXRyaXhSb3RbMF0gPSBhMjIgKiBkZXQ7XG4gICAgdGhpcy5lZmZNYXNzTWF0cml4Um90WzFdID0gLWEyMSAqIGRldDtcbiAgICB0aGlzLmVmZk1hc3NNYXRyaXhSb3RbMl0gPSAtYTEyICogZGV0O1xuICAgIHRoaXMuZWZmTWFzc01hdHJpeFJvdFszXSA9IGExMSAqIGRldDtcblxuICAgIHRoaXMuZXJyb3JSb3RbMF0gPSBWZWMzLmRvdChheGlzQSwgdDEpICogMC4yKmludkR0O1xuICAgIHRoaXMuZXJyb3JSb3RbMV0gPSBWZWMzLmRvdChheGlzQSwgdDIpICogMC4yKmludkR0O1xuXG4gICAgdmFyIGltcHVsc2UgPSB0aGlzLmltcHVsc2Uuc2NhbGUoMC41KTtcbiAgICB2YXIgYW5nSW1wdWxzZUEgPSB0aGlzLmFuZ0ltcHVsc2VBLnNjYWxlKDAuNSk7XG4gICAgdmFyIGFuZ0ltcHVsc2VCID0gdGhpcy5hbmdJbXB1bHNlQi5zY2FsZSgwLjUpO1xuXG4gICAgYi5hcHBseUltcHVsc2UoaW1wdWxzZSk7XG4gICAgYi5hcHBseUFuZ3VsYXJJbXB1bHNlKGFuZ0ltcHVsc2VCKTtcbiAgICBpbXB1bHNlLmludmVydCgpO1xuICAgIGEuYXBwbHlJbXB1bHNlKGltcHVsc2UpO1xuICAgIGEuYXBwbHlBbmd1bGFySW1wdWxzZShhbmdJbXB1bHNlQSk7XG5cbiAgICBpbXB1bHNlLmNsZWFyKCk7XG4gICAgYW5nSW1wdWxzZUEuY2xlYXIoKTtcbiAgICBhbmdJbXB1bHNlQi5jbGVhcigpO1xufTtcblxuLyoqXG4gKiBBcHBseSBpbXB1bHNlcyB0byByZXNvbHZlIHRoZSBjb25zdHJhaW50LlxuICpcbiAqIEBtZXRob2QgcmVzb2x2ZVxuICovXG5IaW5nZS5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUoKSB7XG4gICAgdmFyIGEgPSB0aGlzLmE7XG4gICAgdmFyIGIgPSB0aGlzLmI7XG5cbiAgICB2YXIgckEgPSB0aGlzLnJBO1xuICAgIHZhciByQiA9IHRoaXMuckI7XG5cbiAgICB2YXIgdDF4QSA9IHRoaXMudDF4QTtcbiAgICB2YXIgdDJ4QSA9IHRoaXMudDJ4QTtcblxuICAgIHZhciB3MSA9IGEuYW5ndWxhclZlbG9jaXR5O1xuICAgIHZhciB3MiA9IGIuYW5ndWxhclZlbG9jaXR5O1xuXG4gICAgdmFyIHYxID0gVmVjMy5hZGQoYS52ZWxvY2l0eSwgVmVjMy5jcm9zcyh3MSwgckEsIFd4Ul9SRUdJU1RFUiksIFZCMV9SRUdJU1RFUik7XG4gICAgdmFyIHYyID0gVmVjMy5hZGQoYi52ZWxvY2l0eSwgVmVjMy5jcm9zcyh3MiwgckIsIFd4Ul9SRUdJU1RFUiksIFZCMl9SRUdJU1RFUik7XG5cbiAgICB2YXIgaW1wdWxzZSA9IHYxLnN1YnRyYWN0KHYyKS5zdWJ0cmFjdCh0aGlzLmVycm9yKS5hcHBseU1hdHJpeCh0aGlzLmVmZk1hc3NNYXRyaXgpO1xuXG4gICAgdmFyIGRpZmZXID0gVmVjMy5zdWJ0cmFjdCh3MiwgdzEsIERFTFRBX1JFR0lTVEVSKTtcblxuICAgIHZhciBlcnJvclJvdCA9IHRoaXMuZXJyb3JSb3Q7XG4gICAgdmFyIGp2MSA9IFZlYzMuZG90KHQxeEEsIGRpZmZXKSArIGVycm9yUm90WzBdO1xuICAgIHZhciBqdjIgPSBWZWMzLmRvdCh0MnhBLCBkaWZmVykgKyBlcnJvclJvdFsxXTtcblxuICAgIHZhciBLID0gdGhpcy5lZmZNYXNzTWF0cml4Um90O1xuXG4gICAgdmFyIGwxID0gLShLWzBdKmp2MSArIEtbMV0qanYyKTtcbiAgICB2YXIgbDIgPSAtKEtbMl0qanYxICsgS1szXSpqdjIpO1xuXG4gICAgdmFyIGFuZ0ltcHVsc2UgPSBWZWMzLnNjYWxlKHQxeEEsIGwxLCBWRUMyX1JFR0lTVEVSKS5hZGQoVmVjMy5zY2FsZSh0MnhBLCBsMiwgVkVDM19SRUdJU1RFUikpO1xuXG4gICAgdmFyIGFuZ0ltcHVsc2VCID0gVmVjMy5jcm9zcyhyQiwgaW1wdWxzZSwgVkVDMV9SRUdJU1RFUikuYWRkKGFuZ0ltcHVsc2UpO1xuICAgIHZhciBhbmdJbXB1bHNlQSA9IFZlYzMuY3Jvc3MockEsIGltcHVsc2UsIFZFQzRfUkVHSVNURVIpLmludmVydCgpLnN1YnRyYWN0KGFuZ0ltcHVsc2UpO1xuXG4gICAgYi5hcHBseUltcHVsc2UoaW1wdWxzZSk7XG4gICAgYi5hcHBseUFuZ3VsYXJJbXB1bHNlKGFuZ0ltcHVsc2VCKTtcbiAgICBpbXB1bHNlLmludmVydCgpO1xuICAgIGEuYXBwbHlJbXB1bHNlKGltcHVsc2UpO1xuICAgIGEuYXBwbHlBbmd1bGFySW1wdWxzZShhbmdJbXB1bHNlQSk7XG4gICAgaW1wdWxzZS5pbnZlcnQoKTtcblxuICAgIHRoaXMuaW1wdWxzZS5hZGQoaW1wdWxzZSk7XG4gICAgdGhpcy5hbmdJbXB1bHNlQS5hZGQoYW5nSW1wdWxzZUEpO1xuICAgIHRoaXMuYW5nSW1wdWxzZUIuYWRkKGFuZ0ltcHVsc2VCKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSGluZ2U7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDb25zdHJhaW50ID0gcmVxdWlyZSgnLi9Db25zdHJhaW50Jyk7XG52YXIgVmVjMyA9IHJlcXVpcmUoJ2ZhbW91cy1tYXRoJykuVmVjMztcbnZhciBNYXQzMyA9IHJlcXVpcmUoJ2ZhbW91cy1tYXRoJykuTWF0MzM7XG52YXIgUXVhdGVybmlvbiA9IHJlcXVpcmUoJ2ZhbW91cy1tYXRoJykuUXVhdGVybmlvbjtcblxudmFyIFZFQzFfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIFZFQzJfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIFZCMV9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgVkIyX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcbnZhciBXeFJfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqICBBIGNvbnN0cmFpbnQgdGhhdCBtYWludGFpbnMgcG9zaXRpb25zIGFuZCBvcmllbnRhdGlvbnMgd2l0aCByZXNwZWN0IHRvIGEgc3BlY2lmaWMgYW5jaG9yIHBvaW50LlxuICpcbiAqICBAY2xhc3MgUG9pbnQyUG9pbnRcbiAqICBAZXh0ZW5kcyBDb25zdHJhaW50XG4gKiAgQHBhcmFtIHtQYXJ0aWNsZX0gYSBPbmUgb2YgdGhlIGJvZGllcy5cbiAqICBAcGFyYW0ge1BhcnRpY2xlfSBiIFRoZSBvdGhlciBib2R5LlxuICogIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9ucyBBbiBvYmplY3Qgb2YgY29uZmlndXJhYmxlIG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIFBvaW50MlBvaW50KGEsIGIsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmEgPSBhO1xuICAgIHRoaXMuYiA9IGI7XG5cbiAgICBDb25zdHJhaW50LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgICB0aGlzLmltcHVsc2UgPSBuZXcgVmVjMygpO1xuICAgIHRoaXMuYW5nSW1wdWxzZUEgPSBuZXcgVmVjMygpO1xuICAgIHRoaXMuYW5nSW1wdWxzZUIgPSBuZXcgVmVjMygpO1xuICAgIHRoaXMuZXJyb3IgPSBuZXcgVmVjMygpO1xuICAgIHRoaXMuZWZmTWFzc01hdHJpeCA9IG5ldyBNYXQzMygpO1xufVxuXG5Qb2ludDJQb2ludC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENvbnN0cmFpbnQucHJvdG90eXBlKTtcblBvaW50MlBvaW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBvaW50MlBvaW50O1xuXG4vKipcbiAqIEluaXRpYWxpemUgdGhlIFBvaW50MlBvaW50LiBTZXRzIGRlZmF1bHRzIGlmIGEgcHJvcGVydHkgd2FzIG5vdCBhbHJlYWR5IHNldC5cbiAqXG4gKiBAbWV0aG9kIGluaXRcbiAqL1xuUG9pbnQyUG9pbnQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdyA9IHRoaXMuYW5jaG9yO1xuXG4gICAgdmFyIGEgPSB0aGlzLmE7XG4gICAgdmFyIGIgPSB0aGlzLmI7XG5cbiAgICB2YXIgcTF0ID0gUXVhdGVybmlvbi5jb25qdWdhdGUoYS5vcmllbnRhdGlvbiwgbmV3IFF1YXRlcm5pb24oKSk7XG4gICAgdmFyIHEydCA9IFF1YXRlcm5pb24uY29uanVnYXRlKGIub3JpZW50YXRpb24sIG5ldyBRdWF0ZXJuaW9uKCkpO1xuXG4gICAgdGhpcy5yQSA9IFZlYzMuc3VidHJhY3QodywgYS5wb3NpdGlvbiwgbmV3IFZlYzMoKSk7XG4gICAgdGhpcy5yQiA9IFZlYzMuc3VidHJhY3QodywgYi5wb3NpdGlvbiwgbmV3IFZlYzMoKSk7XG5cbiAgICB0aGlzLmJvZHlSQSA9IHExdC5yb3RhdGVWZWN0b3IodGhpcy5yQSwgbmV3IFZlYzMoKSk7XG4gICAgdGhpcy5ib2R5UkIgPSBxMnQucm90YXRlVmVjdG9yKHRoaXMuckIsIG5ldyBWZWMzKCkpO1xufTtcblxuLyoqXG4gKiBEZXRlY3QgdmlvbGF0aW9ucyBvZiB0aGUgY29uc3RyYWludC4gV2FybSBzdGFydCB0aGUgY29uc3RyYWludCwgaWYgcG9zc2libGUuXG4gKlxuICogQG1ldGhvZCB1cGRhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIFRoZSBjdXJyZW50IHRpbWUgaW4gdGhlIHBoeXNpY3MgZW5naW5lLlxuICogQHBhcmFtIHtOdW1iZXJ9IGR0IFRoZSBwaHlzaWNzIGVuZ2luZSBmcmFtZSBkZWx0YS5cbiAqL1xuUG9pbnQyUG9pbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKHRpbWUsIGR0KSB7XG4gICAgdmFyIGEgPSB0aGlzLmE7XG4gICAgdmFyIGIgPSB0aGlzLmI7XG5cbiAgICB2YXIgckEgPSBhLm9yaWVudGF0aW9uLnJvdGF0ZVZlY3Rvcih0aGlzLmJvZHlSQSwgdGhpcy5yQSk7XG4gICAgdmFyIHJCID0gYi5vcmllbnRhdGlvbi5yb3RhdGVWZWN0b3IodGhpcy5ib2R5UkIsIHRoaXMuckIpO1xuXG4gICAgdmFyIHhSQSA9IG5ldyBNYXQzMyhbMCxyQS56LC1yQS55LC1yQS56LDAsckEueCxyQS55LC1yQS54LDBdKTtcbiAgICB2YXIgeFJCID0gbmV3IE1hdDMzKFswLHJCLnosLXJCLnksLXJCLnosMCxyQi54LHJCLnksLXJCLngsMF0pO1xuXG4gICAgdmFyIFJJYVJ0ID0gTWF0MzMubXVsdGlwbHkoeFJBLCBhLmludmVyc2VJbmVydGlhLCBuZXcgTWF0MzMoKSkubXVsdGlwbHkoeFJBLnRyYW5zcG9zZSgpKTtcbiAgICB2YXIgUkliUnQgPSBNYXQzMy5tdWx0aXBseSh4UkIsIGIuaW52ZXJzZUluZXJ0aWEsIG5ldyBNYXQzMygpKS5tdWx0aXBseSh4UkIudHJhbnNwb3NlKCkpO1xuXG4gICAgdmFyIGludkVmZkluZXJ0aWEgPSBNYXQzMy5hZGQoUklhUnQsIFJJYlJ0LCBSSWFSdCk7XG5cbiAgICB2YXIgd29ybGRBID0gVmVjMy5hZGQoYS5wb3NpdGlvbiwgdGhpcy5yQSwgdGhpcy5hbmNob3IpO1xuICAgIHZhciB3b3JsZEIgPSBWZWMzLmFkZChiLnBvc2l0aW9uLCB0aGlzLnJCLCBWRUMyX1JFR0lTVEVSKTtcblxuICAgIFZlYzMuc3VidHJhY3Qod29ybGRCLCB3b3JsZEEsIHRoaXMuZXJyb3IpO1xuICAgIHRoaXMuZXJyb3Iuc2NhbGUoMC4yL2R0KTtcblxuICAgIHZhciBpbUEgPSBhLmludmVyc2VNYXNzO1xuICAgIHZhciBpbUIgPSBiLmludmVyc2VNYXNzO1xuXG4gICAgdmFyIGludkVmZk1hc3MgPSBuZXcgTWF0MzMoW2ltQSArIGltQiwwLDAsMCxpbUEgKyBpbUIsMCwwLDAsaW1BICsgaW1CXSk7XG5cbiAgICBNYXQzMy5hZGQoaW52RWZmSW5lcnRpYSwgaW52RWZmTWFzcywgdGhpcy5lZmZNYXNzTWF0cml4KTtcbiAgICB0aGlzLmVmZk1hc3NNYXRyaXguaW52ZXJzZSgpO1xuXG4gICAgdmFyIGltcHVsc2UgPSB0aGlzLmltcHVsc2U7XG4gICAgdmFyIGFuZ0ltcHVsc2VBID0gdGhpcy5hbmdJbXB1bHNlQTtcbiAgICB2YXIgYW5nSW1wdWxzZUIgPSB0aGlzLmFuZ0ltcHVsc2VCO1xuXG4gICAgYi5hcHBseUltcHVsc2UoaW1wdWxzZSk7XG4gICAgYi5hcHBseUFuZ3VsYXJJbXB1bHNlKGFuZ0ltcHVsc2VCKTtcbiAgICBpbXB1bHNlLmludmVydCgpO1xuICAgIGEuYXBwbHlJbXB1bHNlKGltcHVsc2UpO1xuICAgIGEuYXBwbHlBbmd1bGFySW1wdWxzZShhbmdJbXB1bHNlQSk7XG5cbiAgICBpbXB1bHNlLmNsZWFyKCk7XG4gICAgYW5nSW1wdWxzZUEuY2xlYXIoKTtcbiAgICBhbmdJbXB1bHNlQi5jbGVhcigpO1xufTtcblxuLyoqXG4gKiBBcHBseSBpbXB1bHNlcyB0byByZXNvbHZlIHRoZSBjb25zdHJhaW50LlxuICpcbiAqIEBtZXRob2QgcmVzb2x2ZVxuICovXG5Qb2ludDJQb2ludC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUoKSB7XG4gICAgdmFyIGEgPSB0aGlzLmE7XG4gICAgdmFyIGIgPSB0aGlzLmI7XG5cbiAgICB2YXIgckEgPSB0aGlzLnJBO1xuICAgIHZhciByQiA9IHRoaXMuckI7XG5cbiAgICB2YXIgdjEgPSBWZWMzLmFkZChhLnZlbG9jaXR5LCBWZWMzLmNyb3NzKGEuYW5ndWxhclZlbG9jaXR5LCByQSwgV3hSX1JFR0lTVEVSKSwgVkIxX1JFR0lTVEVSKTtcbiAgICB2YXIgdjIgPSBWZWMzLmFkZChiLnZlbG9jaXR5LCBWZWMzLmNyb3NzKGIuYW5ndWxhclZlbG9jaXR5LCByQiwgV3hSX1JFR0lTVEVSKSwgVkIyX1JFR0lTVEVSKTtcblxuICAgIHZhciBpbXB1bHNlID0gdjEuc3VidHJhY3QodjIpLnN1YnRyYWN0KHRoaXMuZXJyb3IpLmFwcGx5TWF0cml4KHRoaXMuZWZmTWFzc01hdHJpeCk7XG4gICAgdmFyIGFuZ0ltcHVsc2VCID0gVmVjMy5jcm9zcyhyQiwgaW1wdWxzZSwgVkVDMV9SRUdJU1RFUik7XG4gICAgdmFyIGFuZ0ltcHVsc2VBID0gVmVjMy5jcm9zcyhyQSwgaW1wdWxzZSwgVkVDMl9SRUdJU1RFUikuaW52ZXJ0KCk7XG5cbiAgICBiLmFwcGx5SW1wdWxzZShpbXB1bHNlKTtcbiAgICBiLmFwcGx5QW5ndWxhckltcHVsc2UoYW5nSW1wdWxzZUIpO1xuICAgIGltcHVsc2UuaW52ZXJ0KCk7XG4gICAgYS5hcHBseUltcHVsc2UoaW1wdWxzZSk7XG4gICAgYS5hcHBseUFuZ3VsYXJJbXB1bHNlKGFuZ0ltcHVsc2VBKTtcbiAgICBpbXB1bHNlLmludmVydCgpO1xuXG4gICAgdGhpcy5pbXB1bHNlLmFkZChpbXB1bHNlKTtcbiAgICB0aGlzLmFuZ0ltcHVsc2VBLmFkZChhbmdJbXB1bHNlQSk7XG4gICAgdGhpcy5hbmdJbXB1bHNlQi5hZGQoYW5nSW1wdWxzZUIpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb2ludDJQb2ludDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBeGlzLWFsaWduZWQgYm91bmRpbmcgYm94LiBVc2VkIGluIGNvbGxpc2lvbiBicm9hZHBoYXNlcy5cbiAqXG4gKiBAY2xhc3MgQUFCQlxuICovXG5mdW5jdGlvbiBBQUJCKGJvZHkpIHtcbiAgICB0aGlzLl9ib2R5ID0gYm9keTtcbiAgICB0aGlzLl9JRCA9IGJvZHkuX0lEO1xuICAgIHRoaXMucG9zaXRpb24gPSBudWxsO1xuICAgIHRoaXMudmVydGljZXMgPSB7XG4gICAgICAgIHg6IFtdLFxuICAgICAgICB5OiBbXSxcbiAgICAgICAgejogW11cbiAgICB9O1xuICAgIHRoaXMudXBkYXRlKCk7XG59XG5cbnZhciBTUEhFUkUgPSAxIDw8IDI7XG52YXIgV0FMTCA9IDEgPDwgMztcblxudmFyIERPV04gPSAwO1xudmFyIFVQID0gMTtcbnZhciBMRUZUID0gMjtcbnZhciBSSUdIVCA9IDM7XG52YXIgRk9SV0FSRCA9IDQ7XG52YXIgQkFDS1dBUkQgPSA1O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgYm91bmRzIHRvIHJlZmxlY3QgdGhlIGN1cnJlbnQgb3JpZW50YXRpb24gYW5kIHBvc2l0aW9uIG9mIHRoZSBwYXJlbnQgQm9keS5cbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICovXG5BQUJCLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYm9keSA9IHRoaXMuX2JvZHk7XG4gICAgdmFyIHBvcyA9IHRoaXMucG9zaXRpb24gPSBib2R5LnBvc2l0aW9uO1xuXG4gICAgdmFyIG1pblggPSBJbmZpbml0eSwgbWF4WCA9IC1JbmZpbml0eTtcbiAgICB2YXIgbWluWSA9IEluZmluaXR5LCBtYXhZID0gLUluZmluaXR5O1xuICAgIHZhciBtaW5aID0gSW5maW5pdHksIG1heFogPSAtSW5maW5pdHk7XG5cbiAgICB2YXIgdHlwZSA9IGJvZHkudHlwZTtcbiAgICBpZiAodHlwZSA9PT0gU1BIRVJFKSB7XG4gICAgICAgIG1heFggPSBtYXhZID0gbWF4WiA9IGJvZHkucmFkaXVzO1xuICAgICAgICBtaW5YID0gbWluWSA9IG1pblogPSAtYm9keS5yYWRpdXM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFdBTEwpIHtcbiAgICAgICAgdmFyIGQgPSBib2R5LmRpcmVjdGlvbjtcbiAgICAgICAgbWF4WCA9IG1heFkgPSBtYXhaID0gMWU2O1xuICAgICAgICBtaW5YID0gbWluWSA9IG1pblogPSAtMWU2O1xuICAgICAgICBzd2l0Y2ggKGQpIHtcbiAgICAgICAgICAgIGNhc2UgRE9XTjpcbiAgICAgICAgICAgICAgICBtYXhZID0gMjU7XG4gICAgICAgICAgICAgICAgbWluWSA9IC0xZTM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFVQOlxuICAgICAgICAgICAgICAgIG1heFkgPSAxZTM7XG4gICAgICAgICAgICAgICAgbWluWSA9IC0yNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTEVGVDpcbiAgICAgICAgICAgICAgICBtYXhYID0gMjU7XG4gICAgICAgICAgICAgICAgbWluWCA9IC0xZTM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFJJR0hUOlxuICAgICAgICAgICAgICAgIG1heFggPSAxZTM7XG4gICAgICAgICAgICAgICAgbWluWCA9IC0yNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRk9SV0FSRDpcbiAgICAgICAgICAgICAgICBtYXhaID0gMjU7XG4gICAgICAgICAgICAgICAgbWluWiA9IC0xZTM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJBQ0tXQVJEOlxuICAgICAgICAgICAgICAgIG1heFogPSAxZTM7XG4gICAgICAgICAgICAgICAgbWluWiA9IC0yNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChib2R5LnZlcnRpY2VzKSB7XG4gICAgICAgIC8vIENvbnZleEJvZHlcbiAgICAgICAgdmFyIGJvZHlWZXJ0aWNlcyA9IGJvZHkudmVydGljZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBib2R5VmVydGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB2ZXJ0ZXggPSBib2R5VmVydGljZXNbaV07XG4gICAgICAgICAgICBpZiAodmVydGV4LnggPCBtaW5YKSBtaW5YID0gdmVydGV4Lng7XG4gICAgICAgICAgICBpZiAodmVydGV4LnggPiBtYXhYKSBtYXhYID0gdmVydGV4Lng7XG4gICAgICAgICAgICBpZiAodmVydGV4LnkgPCBtaW5ZKSBtaW5ZID0gdmVydGV4Lnk7XG4gICAgICAgICAgICBpZiAodmVydGV4LnkgPiBtYXhZKSBtYXhZID0gdmVydGV4Lnk7XG4gICAgICAgICAgICBpZiAodmVydGV4LnogPCBtaW5aKSBtaW5aID0gdmVydGV4Lno7XG4gICAgICAgICAgICBpZiAodmVydGV4LnogPiBtYXhaKSBtYXhaID0gdmVydGV4Lno7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBQYXJ0aWNsZVxuICAgICAgICBtYXhYID0gbWF4WSA9IG1heFogPSAyNTtcbiAgICAgICAgbWluWCA9IG1pblkgPSBtaW5aID0gLTI1O1xuICAgIH1cbiAgICB2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xuICAgIHZlcnRpY2VzLnhbMF0gPSBtaW5YICsgcG9zLng7XG4gICAgdmVydGljZXMueFsxXSA9IG1heFggKyBwb3MueDtcbiAgICB2ZXJ0aWNlcy55WzBdID0gbWluWSArIHBvcy55O1xuICAgIHZlcnRpY2VzLnlbMV0gPSBtYXhZICsgcG9zLnk7XG4gICAgdmVydGljZXMuelswXSA9IG1pblogKyBwb3MuejtcbiAgICB2ZXJ0aWNlcy56WzFdID0gbWF4WiArIHBvcy56O1xufTtcblxuLyoqXG4gKiBDaGVjayBmb3Igb3ZlcmxhcCBiZXR3ZWVuIHR3byBBQUJCJ3MuXG4gKlxuICogQG1ldGhvZCBjaGVja092ZXJsYXBcbiAqIEBwYXJhbSB7QUFCQn0gYWFiYjFcbiAqIEBwYXJhbSB7QUFCQn0gYWFiYjJcbiAqL1xuQUFCQi5jaGVja092ZXJsYXAgPSBmdW5jdGlvbihhYWJiMSwgYWFiYjIpIHtcbiAgICB2YXIgdmVydGljZXMxID0gYWFiYjEudmVydGljZXM7XG4gICAgdmFyIHZlcnRpY2VzMiA9IGFhYmIyLnZlcnRpY2VzO1xuXG4gICAgdmFyIHgxMCA9IHZlcnRpY2VzMS54WzBdO1xuICAgIHZhciB4MTEgPSB2ZXJ0aWNlczEueFsxXTtcbiAgICB2YXIgeDIwID0gdmVydGljZXMyLnhbMF07XG4gICAgdmFyIHgyMSA9IHZlcnRpY2VzMi54WzFdO1xuICAgIGlmICgoeDIwIDw9IHgxMCAmJiB4MTAgPD0geDIxKSB8fCAoeDEwIDw9IHgyMCAmJiB4MjAgPD0geDExKSkge1xuICAgICAgICB2YXIgeTEwID0gdmVydGljZXMxLnlbMF07XG4gICAgICAgIHZhciB5MTEgPSB2ZXJ0aWNlczEueVsxXTtcbiAgICAgICAgdmFyIHkyMCA9IHZlcnRpY2VzMi55WzBdO1xuICAgICAgICB2YXIgeTIxID0gdmVydGljZXMyLnlbMV07XG4gICAgICAgIGlmICgoeTIwIDw9IHkxMCAmJiB5MTAgPD0geTIxKSB8fCAoeTEwIDw9IHkyMCAmJiB5MjAgPD0geTExKSkge1xuICAgICAgICAgICAgdmFyIHoxMCA9IHZlcnRpY2VzMS56WzBdO1xuICAgICAgICAgICAgdmFyIHoxMSA9IHZlcnRpY2VzMS56WzFdO1xuICAgICAgICAgICAgdmFyIHoyMCA9IHZlcnRpY2VzMi56WzBdO1xuICAgICAgICAgICAgdmFyIHoyMSA9IHZlcnRpY2VzMi56WzFdO1xuICAgICAgICAgICAgaWYgKCh6MjAgPD0gejEwICYmIHoxMCA8PSB6MjEpIHx8ICh6MTAgPD0gejIwICYmIHoyMCA8PSB6MTEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuQUFCQi52ZXJ0ZXhUaHJlc2hvbGQgPSAxMDA7XG5cbm1vZHVsZS5leHBvcnRzID0gQUFCQjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEFBQkIgPSByZXF1aXJlKCcuL0FBQkInKTtcblxuLyoqXG4gKiBPKG5eMikgY29tcGFyaXNvbnMgd2l0aCBhbiBBQUJCIGNoZWNrIGZvciBhIG1pZHBoYXNlLiBMaWtlbHkgdG8gYmUgbW9yZSBwZXJmb3JtYW50XG4gKiB0aGF0IHRoZSBCcnV0ZUZvcmNlIHdoZW4gdGhlIGJvZGllcyBoYXZlIG1hbnkgdmVydGljZXMuIE9ubHkgZmVhc2libGUgZm9yIGEgc21hbGwgbnVtYmVyIG9mIGJvZGllcy5cbiAqXG4gKiBAY2xhc3MgQnJ1dGVGb3JBQUJCXG4gKiBAcGFyYW0ge1BhcnRpY2xlc1tdfSB0YXJnZXRzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBCcnV0ZUZvcmNlQUFCQih0YXJnZXRzKSB7XG4gICAgdGhpcy5fdm9sdW1lcyA9IFtdO1xuICAgIHRoaXMuX2VudGl0eVJlZ2lzdHJ5ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuYWRkKHRhcmdldHNbaV0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBTdGFydCB0cmFja2luZyBhIFBhcnRpY2xlLlxuICpcbiAqIEBtZXRob2QgYWRkXG4gKiBAcGFyYW0ge1BhcnRpY2xlfSBib2R5XG4gKi9cbkJydXRlRm9yY2VBQUJCLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoYm9keSkge1xuICAgIHZhciBib3VuZGluZ1ZvbHVtZSA9IG5ldyBBQUJCKGJvZHkpO1xuXG4gICAgdGhpcy5fZW50aXR5UmVnaXN0cnlbYm9keS5fSURdID0gYm9keTtcbiAgICB0aGlzLl92b2x1bWVzLnB1c2goYm91bmRpbmdWb2x1bWUpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYW4gYXJyYXkgb2YgcG9zc2libGUgY29sbGlzaW9uIHBhaXJzLCBjdWxsZWQgYnkgYW4gQUFCQiBpbnRlcnNlY3Rpb24gdGVzdC5cbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICogQHJldHVybiB7UGFydGljbGVbXVtdfVxuICovXG5CcnV0ZUZvcmNlQUFCQi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIHZhciBfdm9sdW1lcyA9IHRoaXMuX3ZvbHVtZXM7XG4gICAgdmFyIF9lbnRpdHlSZWdpc3RyeSA9IHRoaXMuX2VudGl0eVJlZ2lzdHJ5O1xuXG4gICAgZm9yICh2YXIgayA9IDAsIGxlbiA9IF92b2x1bWVzLmxlbmd0aDsgayA8IGxlbjsgaysrKSB7XG4gICAgICAgIF92b2x1bWVzW2tdLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbnVtVGFyZ2V0cyA9IF92b2x1bWVzLmxlbmd0aDsgaSA8IG51bVRhcmdldHM7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBudW1UYXJnZXRzOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChBQUJCLmNoZWNrT3ZlcmxhcChfdm9sdW1lc1tpXSwgX3ZvbHVtZXNbal0pKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goW19lbnRpdHlSZWdpc3RyeVtpXSwgX2VudGl0eVJlZ2lzdHJ5W2pdXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogVGhlIG1vc3Qgc2ltcGxlIHlldCBjb21wdXRhdGlvbmFsbHkgaW50ZW5zaXZlIGJyb2FkLXBoYXNlLiBJbW1lZGlhdGVseSBwYXNzZXMgaXRzIHRhcmdldHMgdG8gdGhlIG5hcnJvdy1waGFzZSxcbiAqIHJlc3VsdGluZyBpbiBhbiBPKG5eMikgcHJvY2Vzcy4gT25seSBmZWFzaWJsZSBmb3IgYSByZWxhdGl2ZWx5IHNtYWxsIG51bWJlciBvZiBib2RpZXMuXG4gKlxuICogQGNsYXNzIEJydXRlRm9yY2VcbiAqIEBwYXJhbSB7UGFydGljbGVbXX0gdGFyZ2V0c1xuICovXG5mdW5jdGlvbiBCcnV0ZUZvcmNlKHRhcmdldHMpIHtcbiAgICB0aGlzLnRhcmdldHMgPSB0YXJnZXRzO1xufVxuXG4vKipcbiAqIFN0YXJ0IHRyYWNraW5nIGEgUGFydGljbGUuXG4gKlxuICogQG1ldGhvZCBhZGRcbiAqIEBwYXJhbSB7UGFydGljbGV9IGJvZHlcbiAqL1xuQnJ1dGVGb3JjZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKGJvZHkpIHtcbiAgICB0aGlzLnRhcmdldHMucHVzaChib2R5KTtcbn07XG5cbi8qKlxuICogSW1tZWRpYXRlbHkgcmV0dXJucyBhbiBhcnJheSBvZiBwb3NzaWJsZSBjb2xsaXNpb25zLlxuICpcbiAqIEBtZXRob2QgdXBkYXRlXG4gKiBAcmV0dXJuIHtQYXJ0aWNsZVtdW119XG4gKi9cbkJydXRlRm9yY2UucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICByZXR1cm4gW3RoaXMudGFyZ2V0c107XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5CcnV0ZUZvcmNlQUFCQiA9IEJydXRlRm9yY2VBQUJCO1xubW9kdWxlLmV4cG9ydHMuQnJ1dGVGb3JjZSA9IEJydXRlRm9yY2U7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBWZWMzID0gcmVxdWlyZSgnZmFtb3VzLW1hdGgnKS5WZWMzO1xudmFyIE9iamVjdE1hbmFnZXIgPSByZXF1aXJlKCdmYW1vdXMtdXRpbGl0aWVzJykuT2JqZWN0TWFuYWdlcjtcblxuT2JqZWN0TWFuYWdlci5yZWdpc3RlcignTWFuaWZvbGQnLCBNYW5pZm9sZCk7XG5PYmplY3RNYW5hZ2VyLnJlZ2lzdGVyKCdDb250YWN0JywgQ29udGFjdCk7XG52YXIgT01SZXF1ZXN0TWFuaWZvbGQgPSBPYmplY3RNYW5hZ2VyLnJlcXVlc3RNYW5pZm9sZDtcbnZhciBPTVJlcXVlc3RDb250YWN0ID0gT2JqZWN0TWFuYWdlci5yZXF1ZXN0Q29udGFjdDtcbnZhciBPTUZyZWVNYW5pZm9sZCA9IE9iamVjdE1hbmFnZXIuZnJlZU1hbmlmb2xkO1xudmFyIE9NRnJlZUNvbnRhY3QgPSBPYmplY3RNYW5hZ2VyLmZyZWVDb250YWN0O1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBjbGFtcCBhIHZhbHVlIHRvIGEgZ2l2ZW4gcmFuZ2UuXG4gKlxuICogQG1ldGhvZCBjbGFtcFxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge051bWJlcn0gbG93ZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSB1cHBlclxuICogQHJldHVybiB7TnVtYmVyfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2xhbXAodmFsdWUsIGxvd2VyLCB1cHBlcikge1xuICAgIHJldHVybiB2YWx1ZSA8IGxvd2VyID8gbG93ZXIgOiB2YWx1ZSA+IHVwcGVyID8gdXBwZXIgOiB2YWx1ZTtcbn1cblxudmFyIFZFQzFfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIFZFQzJfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIFZCMV9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgVkIyX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcbnZhciBXeFJfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIFIxX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcbnZhciBSMl9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgTk9STUFMSU1QVUxTRV9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgVEFOR0VOVElNUFVMU0UxX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcbnZhciBUQU5HRU5USU1QVUxTRTJfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIFdBX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcbnZhciBXQl9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgUEVORVRSQVRJTkdfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIERSSUZUQV9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgRFJJRlRCX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBUYWJsZSBtYWludGFpbmluZyBhbmQgbWFuYWdpbmcgY3VycmVudCBjb250YWN0IG1hbmlmb2xkcy5cbiAqXG4gKiBAY2xhc3MgQ29udGFjdE1hbmlmb2xkVGFibGVcbiAqL1xuZnVuY3Rpb24gQ29udGFjdE1hbmlmb2xkVGFibGUoKSB7XG4gICAgdGhpcy5tYW5pZm9sZHMgPSBbXTtcbiAgICB0aGlzLmNvbGxpc2lvbk1hdHJpeCA9IHt9O1xuICAgIHRoaXMuX0lEUG9vbCA9IFtdO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBjb250YWN0IG1hbmlmb2xkLiBUcmFja2VkIGJ5IHRoZSBjb2xsaXNpb25NYXRyaXggYWNjb3JkaW5nIHRvXG4gKiBpdHMgbG93LWhpZ2ggb3JkZXJlZCBJRCBwYWlyLlxuICpcbiAqIEBtZXRob2QgYWRkTWFuaWZvbGRcbiAqIEBwYXJhbSB7TnVtYmVyfSBsb3dJZFxuICogQHBhcmFtIHtOdW1iZXJ9IGhpZ2hJRFxuICogQHBhcmFtIHtQYXJ0aWNsZX0gYm9keUFcbiAqIEBwYXJhbSB7UGFydGljbGV9IGJvZHlCXG4gKiBAcmV0dXJuIHtDb250YWN0TWFuaWZvbGR9XG4gKi9cbkNvbnRhY3RNYW5pZm9sZFRhYmxlLnByb3RvdHlwZS5hZGRNYW5pZm9sZCA9IGZ1bmN0aW9uIGFkZE1hbmlmb2xkKGxvd0lELCBoaWdoSUQsIGJvZHlBLCBib2R5Qikge1xuICAgIHZhciBjb2xsaXNpb25NYXRyaXggPSB0aGlzLmNvbGxpc2lvbk1hdHJpeDtcbiAgICBjb2xsaXNpb25NYXRyaXhbbG93SURdID0gY29sbGlzaW9uTWF0cml4W2xvd0lEXSB8fCB7fTtcblxuICAgIHZhciBpbmRleCA9IHRoaXMuX0lEUG9vbC5sZW5ndGggPyB0aGlzLl9JRFBvb2wucG9wKCkgOiB0aGlzLm1hbmlmb2xkcy5sZW5ndGg7XG4gICAgdGhpcy5jb2xsaXNpb25NYXRyaXhbbG93SURdW2hpZ2hJRF0gPSBpbmRleDtcbiAgICB2YXIgbWFuaWZvbGQgPSBPTVJlcXVlc3RNYW5pZm9sZCgpLnJlc2V0KGxvd0lELCBoaWdoSUQsIGJvZHlBLCBib2R5Qik7XG4gICAgdGhpcy5tYW5pZm9sZHNbaW5kZXhdID0gbWFuaWZvbGQ7XG5cbiAgICByZXR1cm4gbWFuaWZvbGQ7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhIG1hbmlmb2xkIGFuZCBmcmVlIGl0IGZvciBsYXRlciByZXVzZS5cbiAqXG4gKiBAbWV0aG9kIHJlbW92ZU1hbmlmb2xkXG4gKiBAcGFyYW0ge0NvbnRhY3RNYW5pZm9sZH0gbWFuaWZvbGRcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICovXG5Db250YWN0TWFuaWZvbGRUYWJsZS5wcm90b3R5cGUucmVtb3ZlTWFuaWZvbGQgPSBmdW5jdGlvbiByZW1vdmVNYW5pZm9sZChtYW5pZm9sZCwgaW5kZXgpIHtcbiAgICB2YXIgY29sbGlzaW9uTWF0cml4ID0gdGhpcy5jb2xsaXNpb25NYXRyaXg7XG5cbiAgICB0aGlzLm1hbmlmb2xkc1tpbmRleF0gPSBudWxsO1xuICAgIGNvbGxpc2lvbk1hdHJpeFttYW5pZm9sZC5sb3dJRF1bbWFuaWZvbGQuaGlnaElEXSA9IG51bGw7XG4gICAgdGhpcy5fSURQb29sLnB1c2goaW5kZXgpO1xuXG4gICAgT01GcmVlTWFuaWZvbGQobWFuaWZvbGQpO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgZWFjaCBvZiB0aGUgbWFuaWZvbGRzLCByZW1vdmluZyB0aG9zZSB0aGF0IG5vIGxvbmdlciBjb250YWluIGNvbnRhY3QgcG9pbnRzLlxuICpcbiAqIEBtZXRob2QgdXBkYXRlXG4gKiBAcGFyYW0ge051bWJlcn0gZHRcbiAqL1xuQ29udGFjdE1hbmlmb2xkVGFibGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShkdCkge1xuICAgIHZhciBtYW5pZm9sZHMgPSB0aGlzLm1hbmlmb2xkcztcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbWFuaWZvbGRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBtYW5pZm9sZCA9IG1hbmlmb2xkc1tpXTtcbiAgICAgICAgaWYgKCFtYW5pZm9sZCkgY29udGludWU7XG4gICAgICAgIHZhciBwZXJzaXN0cyA9IG1hbmlmb2xkLnVwZGF0ZShkdCk7XG4gICAgICAgIGlmICghcGVyc2lzdHMpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTWFuaWZvbGQobWFuaWZvbGQsIGkpO1xuICAgICAgICAgICAgbWFuaWZvbGQuYm9keUEuZXZlbnRzLnRyaWdnZXIoJ2NvbGxpc2lvbjplbmQnLCBtYW5pZm9sZCk7XG4gICAgICAgICAgICBtYW5pZm9sZC5ib2R5Qi5ldmVudHMudHJpZ2dlcignY29sbGlzaW9uOmVuZCcsIG1hbmlmb2xkKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogV2FybSBzdGFydCBhbGwgQ29udGFjdHMsIGFuZCBwZXJmb3JtIHByZWNhbGN1bGF0aW9ucyBuZWVkZWQgaW4gdGhlIGl0ZXJhdGl2ZSBzb2x2ZXIuXG4gKlxuICogQG1ldGhvZCBwcmVwQ29udGFjdHNcbiAqIEBwYXJhbSB7TnVtYmVyfSBkdFxuICovXG5Db250YWN0TWFuaWZvbGRUYWJsZS5wcm90b3R5cGUucHJlcENvbnRhY3RzID0gZnVuY3Rpb24gcHJlcENvbnRhY3RzKGR0KSB7XG4gICAgdmFyIG1hbmlmb2xkcyA9IHRoaXMubWFuaWZvbGRzO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBtYW5pZm9sZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIG1hbmlmb2xkID0gbWFuaWZvbGRzW2ldO1xuICAgICAgICBpZiAoIW1hbmlmb2xkKSBjb250aW51ZTtcbiAgICAgICAgdmFyIGNvbnRhY3RzID0gbWFuaWZvbGQuY29udGFjdHM7XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBsZW5qID0gY29udGFjdHMubGVuZ3RoOyBqIDwgbGVuajsgaisrKSB7XG4gICAgICAgICAgICB2YXIgY29udGFjdCA9IGNvbnRhY3RzW2pdO1xuICAgICAgICAgICAgaWYgKCFjb250YWN0KSBjb250aW51ZTtcbiAgICAgICAgICAgIGNvbnRhY3QudXBkYXRlKGR0KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogUmVzb2x2ZSBhbGwgY29udGFjdCBtYW5pZm9sZHMuXG4gKlxuICogQG1ldGhvZCByZXNvbHZlTWFuaWZvbGRzXG4gKi9cbkNvbnRhY3RNYW5pZm9sZFRhYmxlLnByb3RvdHlwZS5yZXNvbHZlTWFuaWZvbGRzID0gZnVuY3Rpb24gcmVzb2x2ZU1hbmlmb2xkcygpIHtcbiAgICB2YXIgbWFuaWZvbGRzID0gdGhpcy5tYW5pZm9sZHM7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG1hbmlmb2xkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgbWFuaWZvbGQgPSBtYW5pZm9sZHNbaV07XG4gICAgICAgIGlmICghbWFuaWZvbGQpIGNvbnRpbnVlO1xuICAgICAgICBtYW5pZm9sZC5yZXNvbHZlQ29udGFjdHMoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBDb250YWN0LCBhbHNvIGNyZWF0aW5nIGEgbmV3IE1hbmlmb2xkIGlmIG9uZSBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0IGZvciB0aGF0IHBhaXIuXG4gKlxuICogQG1ldGhvZCByZWdpc3RlckNvbnRhY3RcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqIEBwYXJhbSB7Q29sbGlzaW9uRGF0YX0gY29sbGlzaW9uRGF0YVxuICovXG5Db250YWN0TWFuaWZvbGRUYWJsZS5wcm90b3R5cGUucmVnaXN0ZXJDb250YWN0ID0gZnVuY3Rpb24gcmVnaXN0ZXJDb250YWN0KGJvZHlBLCBib2R5QiwgY29sbGlzaW9uRGF0YSkge1xuICAgIHZhciBsb3dJRDtcbiAgICB2YXIgaGlnaElEO1xuXG4gICAgaWYgKGJvZHlBLl9JRCA8IGJvZHlCLl9JRCkge1xuICAgICAgICBsb3dJRCA9IGJvZHlBLl9JRDtcbiAgICAgICAgaGlnaElEID0gYm9keUIuX0lEO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxvd0lEID0gYm9keUIuX0lEO1xuICAgICAgICBoaWdoSUQgPSBib2R5QS5fSUQ7XG4gICAgfVxuXG4gICAgdmFyIG1hbmlmb2xkcyA9IHRoaXMubWFuaWZvbGRzO1xuICAgIHZhciBjb2xsaXNpb25NYXRyaXggPSB0aGlzLmNvbGxpc2lvbk1hdHJpeDtcbiAgICB2YXIgbWFuaWZvbGQ7XG4gICAgaWYgKCFjb2xsaXNpb25NYXRyaXhbbG93SURdIHx8IGNvbGxpc2lvbk1hdHJpeFtsb3dJRF1baGlnaElEXSA9PSBudWxsKSB7XG4gICAgICAgIG1hbmlmb2xkID0gdGhpcy5hZGRNYW5pZm9sZChsb3dJRCwgaGlnaElELCBib2R5QSwgYm9keUIpO1xuICAgICAgICBtYW5pZm9sZC5hZGRDb250YWN0KGJvZHlBLCBib2R5QiwgY29sbGlzaW9uRGF0YSk7XG4gICAgICAgIGJvZHlBLmV2ZW50cy50cmlnZ2VyKCdjb2xsaXNpb246c3RhcnQnLCBtYW5pZm9sZCk7XG4gICAgICAgIGJvZHlCLmV2ZW50cy50cmlnZ2VyKCdjb2xsaXNpb246c3RhcnQnLCBtYW5pZm9sZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbWFuaWZvbGQgPSBtYW5pZm9sZHNbIGNvbGxpc2lvbk1hdHJpeFtsb3dJRF1baGlnaElEXSBdO1xuICAgICAgICBtYW5pZm9sZC5jb250YWlucyhjb2xsaXNpb25EYXRhKTtcbiAgICAgICAgbWFuaWZvbGQuYWRkQ29udGFjdChib2R5QSwgYm9keUIsIGNvbGxpc2lvbkRhdGEpO1xuICAgIH1cbn07XG5cbnZhciBUSFJFU0hPTEQgPSAxMDtcblxuLyoqXG4gKiBDbGFzcyB0byBrZWVwIHRyYWNrIG9mIENvbnRhY3QgcG9pbnRzLlxuICogQGNsYXNzIG1hbmlmb2xkXG4gKiBAcGFyYW0ge051bWJlcn0gbG93SWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBoaWdoSWRcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqL1xuZnVuY3Rpb24gTWFuaWZvbGQobG93SUQsIGhpZ2hJRCwgYm9keUEsIGJvZHlCKSB7XG4gICAgdGhpcy5sb3dJRCA9IGxvd0lEO1xuICAgIHRoaXMuaGlnaElEID0gaGlnaElEO1xuXG4gICAgdGhpcy5jb250YWN0cyA9IFtdO1xuICAgIHRoaXMubnVtQ29udGFjdHMgPSAwO1xuXG4gICAgdGhpcy5ib2R5QSA9IGJvZHlBO1xuICAgIHRoaXMuYm9keUIgPSBib2R5QjtcblxuICAgIHRoaXMubHJ1ID0gMDtcbn1cblxuLyoqXG4gKiBVc2VkIGJ5IE9iamVjdE1hbmFnZXIgdG8gcmVzZXQgdGhlIG9iamVjdCB3aXRoIGRpZmZlcmVudCBkYXRhLlxuICpcbiAqIEBtZXRob2QgcmVzZXRcbiAqIEBwYXJhbSB7T2JqZWN0W119IGFyZ3NcbiAqIEBjaGFpbmFibGVcbiAqL1xuTWFuaWZvbGQucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQobG93SUQsIGhpZ2hJRCwgYm9keUEsIGJvZHlCKSB7XG4gICAgdGhpcy5sb3dJRCA9IGxvd0lEO1xuICAgIHRoaXMuaGlnaElEID0gaGlnaElEO1xuXG4gICAgdGhpcy5jb250YWN0cyA9IFtdO1xuICAgIHRoaXMubnVtQ29udGFjdHMgPSAwO1xuXG4gICAgdGhpcy5ib2R5QSA9IGJvZHlBO1xuICAgIHRoaXMuYm9keUIgPSBib2R5QjtcblxuICAgIHRoaXMubHJ1ID0gMDtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgQ29udGFjdCBwb2ludCBhbmQgYWRkIGl0IHRvIHRoZSBNYW5pZm9sZC5cbiAqXG4gKiBAbWV0aG9kIGFkZENvbnRhY3RcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqIEBwYXJhbSB7Q29sbGlzaW9uRGF0YX0gY29sbGlzaW9uRGF0YVxuICovXG5NYW5pZm9sZC5wcm90b3R5cGUuYWRkQ29udGFjdCA9IGZ1bmN0aW9uIGFkZENvbnRhY3QoYm9keUEsIGJvZHlCLCBjb2xsaXNpb25EYXRhKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5scnU7XG4gICAgaWYgKHRoaXMuY29udGFjdHNbaW5kZXhdKSB0aGlzLnJlbW92ZUNvbnRhY3QodGhpcy5jb250YWN0c1tpbmRleF0sIGluZGV4KTtcbiAgICB0aGlzLmNvbnRhY3RzW2luZGV4XSA9IE9NUmVxdWVzdENvbnRhY3QoKS5yZXNldChib2R5QSwgYm9keUIsIGNvbGxpc2lvbkRhdGEpO1xuICAgIHRoaXMubHJ1ID0gKHRoaXMubHJ1ICsgMSkgJSA0O1xuICAgIHRoaXMubnVtQ29udGFjdHMrKztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuZCBmcmVlIGEgQ29udGFjdCBmb3IgbGF0ZXIgcmV1c2UuXG4gKlxuICogQG1ldGhvZCByZW1vdmVDb250YWN0XG4gKiBAcGFyYW0ge0NvbnRhY3R9IGNvbnRhY3RcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICovXG5NYW5pZm9sZC5wcm90b3R5cGUucmVtb3ZlQ29udGFjdCA9IGZ1bmN0aW9uIHJlbW92ZUNvbnRhY3QoY29udGFjdCwgaW5kZXgpIHtcbiAgICB0aGlzLmNvbnRhY3RzW2luZGV4XSA9IG51bGw7XG4gICAgdGhpcy5udW1Db250YWN0cy0tO1xuXG4gICAgT2JqZWN0TWFuYWdlci5mcmVlQ29sbGlzaW9uRGF0YShjb250YWN0LmRhdGEpO1xuICAgIGNvbnRhY3QuZGF0YSA9IG51bGw7XG4gICAgT01GcmVlQ29udGFjdChjb250YWN0KTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBDb250YWN0IGFscmVhZHkgZXhpc3RzIGZvciB0aGUgY29sbGlzaW9uIGRhdGEgd2l0aGluIGEgY2VydGFpbiB0b2xlcmFuY2UuXG4gKiBJZiBmb3VuZCwgcmVtb3ZlIHRoZSBDb250YWN0LlxuICpcbiAqIEBtZXRob2QgY29udGFpbnNcbiAqIEBwYXJhbSB7Q29sbGlzaW9uRGF0YX0gY29sbGlzaW9uRGF0YVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuTWFuaWZvbGQucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gY29udGFpbnMoY29sbGlzaW9uRGF0YSkge1xuICAgIHZhciB3QSA9IGNvbGxpc2lvbkRhdGEud29ybGRDb250YWN0QTtcbiAgICB2YXIgd0IgPSBjb2xsaXNpb25EYXRhLndvcmxkQ29udGFjdEI7XG5cbiAgICB2YXIgY29udGFjdHMgPSB0aGlzLmNvbnRhY3RzO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb250YWN0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgY29udGFjdCA9IGNvbnRhY3RzW2ldO1xuICAgICAgICBpZiAoIWNvbnRhY3QpIGNvbnRpbnVlO1xuICAgICAgICB2YXIgZGF0YSA9IGNvbnRhY3QuZGF0YTtcbiAgICAgICAgdmFyIGRpc3RBID0gVmVjMy5zdWJ0cmFjdChkYXRhLndvcmxkQ29udGFjdEEsIHdBLCBEUklGVEFfUkVHSVNURVIpLmxlbmd0aCgpO1xuICAgICAgICB2YXIgZGlzdEIgPSBWZWMzLnN1YnRyYWN0KGRhdGEud29ybGRDb250YWN0Qiwgd0IsIERSSUZUQl9SRUdJU1RFUikubGVuZ3RoKCk7XG5cbiAgICAgICAgaWYgKGRpc3RBIDwgVEhSRVNIT0xEIHx8IGRpc3RCIDwgVEhSRVNIT0xEKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUNvbnRhY3QoY29udGFjdCwgaSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIENvbnRhY3RzIHRoZSBsb2NhbCBwb2ludHMgb2Ygd2hpY2ggaGF2ZSBkcmlmdGVkIGFib3ZlIGEgY2VydGFpbiB0b2xlcmFuY2UuXG4gKiBSZXR1cm4gdHJ1ZSBvciBmYWxzZSB0byBpbmRpY2F0ZSB0aGF0IHRoZSBNYW5pZm9sZCBzdGlsbCBjb250YWlucyBhdCBsZWFzdCBvbmUgQ29udGFjdC5cbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICogQHJldHVybiB7Qm9vbGVhbn0gd2hldGhlciBvciBub3QgdGhlIG1hbmlmb2xkIHBlcnNpc3RzXG4gKi9cbk1hbmlmb2xkLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgdmFyIGNvbnRhY3RzID0gdGhpcy5jb250YWN0cztcbiAgICB2YXIgYm9keUEgPSB0aGlzLmJvZHlBO1xuICAgIHZhciBib2R5QiA9IHRoaXMuYm9keUI7XG5cbiAgICB2YXIgcG9zQSA9IGJvZHlBLnBvc2l0aW9uO1xuICAgIHZhciBwb3NCID0gYm9keUIucG9zaXRpb247XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29udGFjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGNvbnRhY3QgPSBjb250YWN0c1tpXTtcbiAgICAgICAgaWYgKCFjb250YWN0KSBjb250aW51ZTtcbiAgICAgICAgdmFyIGRhdGEgPSBjb250YWN0LmRhdGE7XG4gICAgICAgIHZhciBuID0gZGF0YS5ub3JtYWw7XG4gICAgICAgIHZhciByQSA9IGRhdGEubG9jYWxDb250YWN0QTtcbiAgICAgICAgdmFyIHJCID0gZGF0YS5sb2NhbENvbnRhY3RCO1xuXG4gICAgICAgIHZhciBjYWNoZWRfd0EgPSBkYXRhLndvcmxkQ29udGFjdEE7XG4gICAgICAgIHZhciBjYWNoZWRfd0IgPSBkYXRhLndvcmxkQ29udGFjdEI7XG5cbiAgICAgICAgdmFyIHdBID0gVmVjMy5hZGQocG9zQSwgckEsIFdBX1JFR0lTVEVSKTtcbiAgICAgICAgdmFyIHdCID0gVmVjMy5hZGQocG9zQiwgckIsIFdCX1JFR0lTVEVSKTtcblxuICAgICAgICB2YXIgbm90UGVuZXRyYXRpbmcgPSBWZWMzLmRvdChWZWMzLnN1YnRyYWN0KHdCLCB3QSwgUEVORVRSQVRJTkdfUkVHSVNURVIpLCBuKSA+IDA7XG5cbiAgICAgICAgdmFyIGRyaWZ0QSA9IFZlYzMuc3VidHJhY3QoY2FjaGVkX3dBLCB3QSwgRFJJRlRBX1JFR0lTVEVSKTtcbiAgICAgICAgdmFyIGRyaWZ0QiA9IFZlYzMuc3VidHJhY3QoY2FjaGVkX3dCLCB3QiwgRFJJRlRCX1JFR0lTVEVSKTtcblxuXG4gICAgICAgIGlmIChkcmlmdEEubGVuZ3RoKCkgPj0gVEhSRVNIT0xEIHx8IGRyaWZ0Qi5sZW5ndGgoKSA+PSBUSFJFU0hPTEQgfHwgbm90UGVuZXRyYXRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQ29udGFjdChjb250YWN0LCBpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLm51bUNvbnRhY3RzKSByZXR1cm4gdHJ1ZTtcbiAgICBlbHNlIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmVzb2x2ZSBhbGwgY29udGFjdHMuXG4gKlxuICogQG1ldGhvZCByZXNvbHZlQ29udGFjdHNcbiAqL1xuTWFuaWZvbGQucHJvdG90eXBlLnJlc29sdmVDb250YWN0cyA9IGZ1bmN0aW9uIHJlc29sdmVDb250YWN0cygpIHtcbiAgICB2YXIgY29udGFjdHMgPSB0aGlzLmNvbnRhY3RzO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb250YWN0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoIWNvbnRhY3RzW2ldKSBjb250aW51ZTtcbiAgICAgICAgY29udGFjdHNbaV0ucmVzb2x2ZSgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ2xhc3MgdG8gbWFpbnRhaW4gY29sbGlzaW9uIGRhdGEgYmV0d2VlbiB0d28gYm9kaWVzLlxuICogVGhlIGVuZCBvZiB0aGUgcmVzb2x2ZSBjaGFpbiwgYW5kIHdoZXJlIHRoZSBhY3R1YWwgaW1wdWxzZXMgYXJlIGFwcGxpZWQuXG4gKlxuICogQGNsYXNzIENvbnRhY3RcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqIEBwYXJhbSB7Q29sbGlzaW9uRGF0YX0gY29sbGlzaW9uRGF0YVxuICovXG5mdW5jdGlvbiBDb250YWN0KGJvZHlBLCBib2R5QiwgY29sbGlzaW9uRGF0YSkge1xuICAgIHRoaXMuYm9keUEgPSBib2R5QTtcbiAgICB0aGlzLmJvZHlCID0gYm9keUI7XG4gICAgdGhpcy5kYXRhID0gY29sbGlzaW9uRGF0YTtcblxuICAgIHRoaXMubm9ybWFsSW1wdWxzZSA9IDA7XG4gICAgdGhpcy50YW5nZW50SW1wdWxzZTEgPSAwO1xuICAgIHRoaXMudGFuZ2VudEltcHVsc2UyID0gMDtcblxuICAgIHRoaXMuaW1wdWxzZSA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5hbmdJbXB1bHNlQSA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5hbmdJbXB1bHNlQiA9IG5ldyBWZWMzKCk7XG5cbiAgICBpZiAoY29sbGlzaW9uRGF0YSkgdGhpcy5pbml0KCk7XG59XG5cbi8qKlxuICogVXNlZCBieSBPYmplY3RNYW5hZ2VyIHRvIHJlc2V0IHRoZSBvYmplY3Qgd2l0aCBkaWZmZXJlbnQgZGF0YS5cbiAqXG4gKiBAbWV0aG9kIHJlc2V0XG4gKiBAcGFyYW0ge09iamVjdFtdfSBhcmdzXG4gKiBAY2hhaW5hYmxlXG4gKi9cbkNvbnRhY3QucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoYm9keUEsIGJvZHlCLCBjb2xsaXNpb25EYXRhKSB7XG4gICAgdGhpcy5ib2R5QSA9IGJvZHlBO1xuICAgIHRoaXMuYm9keUIgPSBib2R5QjtcbiAgICB0aGlzLmRhdGEgPSBjb2xsaXNpb25EYXRhO1xuXG4gICAgdGhpcy5ub3JtYWxJbXB1bHNlID0gMDtcbiAgICB0aGlzLnRhbmdlbnRJbXB1bHNlMSA9IDA7XG4gICAgdGhpcy50YW5nZW50SW1wdWxzZTIgPSAwO1xuXG4gICAgdGhpcy5pbXB1bHNlLmNsZWFyKCk7XG4gICAgdGhpcy5hbmdJbXB1bHNlQS5jbGVhcigpO1xuICAgIHRoaXMuYW5nSW1wdWxzZUIuY2xlYXIoKTtcblxuICAgIHRoaXMuaW5pdCgpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEluaXRpYWxpemF0aW9uIG1ldGhvZCBjYWxsZWQgb24gaW5zdGFudGlhbnRpb24gb3IgcmVzZXQgb2YgdGhlIENvbnRhY3QuIFBlcmZvcm1zXG4gKiBwcmVjYWxjdWxhdGlvbnMgdGhhdCB3aWxsIG5vdCBjaGFuZ2Ugb3ZlciB0aGUgbGlmZSBvZiB0aGUgQ29udGFjdC5cbiAqXG4gKiBAbWV0aG9kIGluaXRcbiAqL1xuQ29udGFjdC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgdmFyIG4gPSBkYXRhLm5vcm1hbDtcbiAgICB2YXIgdDEgPSBuZXcgVmVjMygpO1xuICAgIGlmIChuLnggPj0gMC41NzczNSkge1xuICAgICAgICB0MS5zZXQobi55LCAtbi54LCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0MS5zZXQoMCwgbi56LCAtbi55KTtcbiAgICB9XG4gICAgdDEubm9ybWFsaXplKCk7XG4gICAgdmFyIHQyID0gVmVjMy5jcm9zcyhuLCB0MSwgbmV3IFZlYzMoKSk7XG5cbiAgICB0aGlzLnRhbmdlbnQxID0gdDE7XG4gICAgdGhpcy50YW5nZW50MiA9IHQyO1xuXG4gICAgdmFyIGJvZHlBID0gdGhpcy5ib2R5QTtcbiAgICB2YXIgYm9keUIgPSB0aGlzLmJvZHlCO1xuXG4gICAgdmFyIHJCb2R5QSA9IGRhdGEubG9jYWxDb250YWN0QTtcbiAgICB2YXIgckJvZHlCID0gZGF0YS5sb2NhbENvbnRhY3RCO1xuXG4gICAgdmFyIGludkVmZmVjdGl2ZU1hc3MgPSBib2R5QS5pbnZlcnNlTWFzcyArIGJvZHlCLmludmVyc2VNYXNzO1xuXG4gICAgdmFyIHIxbiA9IFZlYzMuY3Jvc3MockJvZHlBLCBuLCBSMV9SRUdJU1RFUik7XG4gICAgdmFyIHIybiA9IFZlYzMuY3Jvc3MockJvZHlCLCBuLCBSMl9SRUdJU1RFUik7XG4gICAgdGhpcy5lZmZOb3JtYWxNYXNzID0gMSAvIChpbnZFZmZlY3RpdmVNYXNzICtcbiAgICAgICAgVmVjMy5kb3QocjFuLCBib2R5QS5pbnZlcnNlSW5lcnRpYS52ZWN0b3JNdWx0aXBseShyMW4sIFZFQzFfUkVHSVNURVIpKSArXG4gICAgICAgIFZlYzMuZG90KHIybiwgYm9keUIuaW52ZXJzZUluZXJ0aWEudmVjdG9yTXVsdGlwbHkocjJuLCBWRUMxX1JFR0lTVEVSKSkpO1xuXG4gICAgdmFyIHIxdDEgPSBWZWMzLmNyb3NzKHJCb2R5QSwgdDEsIFIxX1JFR0lTVEVSKTtcbiAgICB2YXIgcjJ0MSA9IFZlYzMuY3Jvc3MockJvZHlCLCB0MSwgUjJfUkVHSVNURVIpO1xuICAgIHRoaXMuZWZmVGFuZ2VudGlhbE1hc3MxID0gMSAvIChpbnZFZmZlY3RpdmVNYXNzICtcbiAgICAgICAgVmVjMy5kb3QocjF0MSwgYm9keUEuaW52ZXJzZUluZXJ0aWEudmVjdG9yTXVsdGlwbHkocjF0MSwgVkVDMV9SRUdJU1RFUikpICtcbiAgICAgICAgIFZlYzMuZG90KHIydDEsIGJvZHlCLmludmVyc2VJbmVydGlhLnZlY3Rvck11bHRpcGx5KHIydDEsIFZFQzFfUkVHSVNURVIpKSk7XG5cbiAgICB2YXIgcjF0MiA9IFZlYzMuY3Jvc3MockJvZHlBLCB0MiwgUjFfUkVHSVNURVIpO1xuICAgIHZhciByMnQyID0gVmVjMy5jcm9zcyhyQm9keUIsIHQyLCBSMl9SRUdJU1RFUik7XG4gICAgdGhpcy5lZmZUYW5nZW50aWFsTWFzczIgPSAxIC8gKGludkVmZmVjdGl2ZU1hc3MgK1xuICAgICAgICBWZWMzLmRvdChyMXQyLCBib2R5QS5pbnZlcnNlSW5lcnRpYS52ZWN0b3JNdWx0aXBseShyMXQyLCBWRUMxX1JFR0lTVEVSKSkgK1xuICAgICAgICAgVmVjMy5kb3QocjJ0MiwgYm9keUIuaW52ZXJzZUluZXJ0aWEudmVjdG9yTXVsdGlwbHkocjJ0MiwgVkVDMV9SRUdJU1RFUikpKTtcblxuICAgIHRoaXMucmVzdGl0dXRpb24gPSBNYXRoLm1pbihib2R5QS5yZXN0aXR1dGlvbiwgYm9keUIucmVzdGl0dXRpb24pO1xuICAgIHRoaXMuZnJpY3Rpb24gPSBib2R5QS5mcmljdGlvbiAqIGJvZHlCLmZyaWN0aW9uO1xufTtcblxuLyoqXG4gKiBXYXJtIHN0YXJ0IHRoZSBDb250YWN0LCBwcmVwYXJlIGZvciB0aGUgaXRlcmF0aXZlIHNvbHZlciwgYW5kIHJlc2V0IGltcHVsc2VzLlxuICpcbiAqIEBtZXRob2QgdXBkYXRlXG4gKiBAcGFyYW0ge051bWJlcn0gZHRcbiAqL1xuQ29udGFjdC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGR0KSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgdmFyIGJvZHlBID0gdGhpcy5ib2R5QTtcbiAgICB2YXIgYm9keUIgPSB0aGlzLmJvZHlCO1xuXG4gICAgdmFyIHJCb2R5QSA9IGRhdGEubG9jYWxDb250YWN0QTtcbiAgICB2YXIgckJvZHlCID0gZGF0YS5sb2NhbENvbnRhY3RCO1xuXG4gICAgdmFyIG4gPSBkYXRhLm5vcm1hbDtcblxuICAgIHZhciB2YjEgPSBWZWMzLmFkZChib2R5QS52ZWxvY2l0eSwgVmVjMy5jcm9zcyhib2R5QS5hbmd1bGFyVmVsb2NpdHksIHJCb2R5QSwgV3hSX1JFR0lTVEVSKSwgVkIxX1JFR0lTVEVSKTtcbiAgICB2YXIgdmIyID0gVmVjMy5hZGQoYm9keUIudmVsb2NpdHksIFZlYzMuY3Jvc3MoYm9keUIuYW5ndWxhclZlbG9jaXR5LCByQm9keUIsIFd4Ul9SRUdJU1RFUiksIFZCMl9SRUdJU1RFUik7XG4gICAgdmFyIHJlbGF0aXZlVmVsb2NpdHkgPSB2YjIuc3VidHJhY3QodmIxKTtcbiAgICB2YXIgY29udGFjdFNwZWVkID0gVmVjMy5kb3QocmVsYXRpdmVWZWxvY2l0eSwgbik7XG5cbiAgICB2YXIgYmV0YSA9IDAuMTU7XG4gICAgdmFyIHNsb3AgPSAxLjU7XG4gICAgdmFyIHZlbG9jaXR5VG9sZXJhbmNlID0gMjAuMDtcblxuICAgIHZhciByZXN0aXR1dGlvbiA9IE1hdGguYWJzKGNvbnRhY3RTcGVlZCkgPCB2ZWxvY2l0eVRvbGVyYW5jZSA/IDAuMCA6IHRoaXMucmVzdGl0dXRpb247XG4gICAgdGhpcy52ZWxvY2l0eUJpYXMgPSAtYmV0YSAqIE1hdGgubWF4KGRhdGEucGVuZXRyYXRpb24gLSBzbG9wLCAwLjApIC8gZHQ7XG4gICAgdGhpcy52ZWxvY2l0eUJpYXMgKz0gcmVzdGl0dXRpb24gKiBjb250YWN0U3BlZWQ7XG5cbiAgICB2YXIgaW1wdWxzZSA9IHRoaXMuaW1wdWxzZS5zY2FsZSgwLjI1KTtcbiAgICB2YXIgYW5nSW1wdWxzZUEgPSB0aGlzLmFuZ0ltcHVsc2VBLnNjYWxlKDAuMjUpO1xuICAgIHZhciBhbmdJbXB1bHNlQiA9IHRoaXMuYW5nSW1wdWxzZUIuc2NhbGUoMC4yNSk7XG5cbiAgICBib2R5Qi5hcHBseUltcHVsc2UoaW1wdWxzZSk7XG4gICAgYm9keUIuYXBwbHlBbmd1bGFySW1wdWxzZShhbmdJbXB1bHNlQik7XG4gICAgaW1wdWxzZS5pbnZlcnQoKTtcbiAgICBib2R5QS5hcHBseUltcHVsc2UoaW1wdWxzZSk7XG4gICAgYm9keUEuYXBwbHlBbmd1bGFySW1wdWxzZShhbmdJbXB1bHNlQSk7XG5cbiAgICB0aGlzLm5vcm1hbEltcHVsc2UgPSAwO1xuICAgIHRoaXMudGFuZ2VudEltcHVsc2UxID0gMDtcbiAgICB0aGlzLnRhbmdlbnRJbXB1bHNlMiA9IDA7XG5cbiAgICBpbXB1bHNlLmNsZWFyKCk7XG4gICAgYW5nSW1wdWxzZUEuY2xlYXIoKTtcbiAgICBhbmdJbXB1bHNlQi5jbGVhcigpO1xufTtcblxuLyoqXG4gKiBBcHBseSBpbXB1bHNlcyB0byByZXNvbHZlIHRoZSBjb250YWN0IGFuZCBzaW11bGF0ZSBmcmljdGlvbi5cbiAqXG4gKiBAbWV0aG9kIHJlc29sdmVcbiAqL1xuQ29udGFjdC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUoKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgdmFyIGJvZHlBID0gdGhpcy5ib2R5QTtcbiAgICB2YXIgYm9keUIgPSB0aGlzLmJvZHlCO1xuXG4gICAgdmFyIHJCb2R5QSA9IGRhdGEubG9jYWxDb250YWN0QTtcbiAgICB2YXIgckJvZHlCID0gZGF0YS5sb2NhbENvbnRhY3RCO1xuXG4gICAgdmFyIG4gPSBkYXRhLm5vcm1hbDtcbiAgICB2YXIgdDEgPSB0aGlzLnRhbmdlbnQxO1xuICAgIHZhciB0MiA9IHRoaXMudGFuZ2VudDI7XG5cbiAgICB2YXIgdmIxID0gVmVjMy5hZGQoYm9keUEudmVsb2NpdHksIFZlYzMuY3Jvc3MoYm9keUEuYW5ndWxhclZlbG9jaXR5LCByQm9keUEsIFd4Ul9SRUdJU1RFUiksIFZCMV9SRUdJU1RFUik7XG4gICAgdmFyIHZiMiA9IFZlYzMuYWRkKGJvZHlCLnZlbG9jaXR5LCBWZWMzLmNyb3NzKGJvZHlCLmFuZ3VsYXJWZWxvY2l0eSwgckJvZHlCLCBXeFJfUkVHSVNURVIpLCBWQjJfUkVHSVNURVIpO1xuICAgIHZhciByZWxhdGl2ZVZlbG9jaXR5ID0gdmIyLnN1YnRyYWN0KHZiMSk7XG5cbiAgICB2YXIgbm9ybWFsTGFtYmRhID0gLShWZWMzLmRvdChyZWxhdGl2ZVZlbG9jaXR5LCBuKSArIHRoaXMudmVsb2NpdHlCaWFzKSAqIHRoaXMuZWZmTm9ybWFsTWFzcztcbiAgICB2YXIgbmV3Tm9ybWFsSW1wdWxzZSA9IE1hdGgubWF4KHRoaXMubm9ybWFsSW1wdWxzZSArIG5vcm1hbExhbWJkYSwgMCk7XG4gICAgbm9ybWFsTGFtYmRhID0gbmV3Tm9ybWFsSW1wdWxzZSAtIHRoaXMubm9ybWFsSW1wdWxzZTtcblxuICAgIHZhciBtYXhGcmljdGlvbiA9IHRoaXMuZnJpY3Rpb24gKiBuZXdOb3JtYWxJbXB1bHNlO1xuXG4gICAgdmFyIHRhbmdlbnRMYW1iZGExID0gLVZlYzMuZG90KHJlbGF0aXZlVmVsb2NpdHksIHQxKSAqIHRoaXMuZWZmVGFuZ2VudGlhbE1hc3MxO1xuICAgIHZhciBuZXdUYW5nZW50SW1wdWxzZTEgPSBjbGFtcCh0aGlzLnRhbmdlbnRJbXB1bHNlMSArIHRhbmdlbnRMYW1iZGExLCAtbWF4RnJpY3Rpb24sIG1heEZyaWN0aW9uKTtcbiAgICB0YW5nZW50TGFtYmRhMSA9IG5ld1RhbmdlbnRJbXB1bHNlMSAtIHRoaXMudGFuZ2VudEltcHVsc2UxO1xuXG4gICAgdmFyIHRhbmdlbnRMYW1iZGEyID0gLVZlYzMuZG90KHJlbGF0aXZlVmVsb2NpdHksIHQyKSAqIHRoaXMuZWZmVGFuZ2VudGlhbE1hc3MyO1xuICAgIHZhciBuZXdUYW5nZW50SW1wdWxzZTIgPSBjbGFtcCh0aGlzLnRhbmdlbnRJbXB1bHNlMiArIHRhbmdlbnRMYW1iZGEyLCAtbWF4RnJpY3Rpb24sIG1heEZyaWN0aW9uKTtcbiAgICB0YW5nZW50TGFtYmRhMiA9IG5ld1RhbmdlbnRJbXB1bHNlMiAtIHRoaXMudGFuZ2VudEltcHVsc2UyO1xuXG4gICAgdmFyIGltcHVsc2UgPSBWZWMzLnNjYWxlKG4sIG5vcm1hbExhbWJkYSwgTk9STUFMSU1QVUxTRV9SRUdJU1RFUik7XG4gICAgdmFyIHRhbmdlbnRJbXB1bHNlMSA9IFZlYzMuc2NhbGUodDEsIHRhbmdlbnRMYW1iZGExLCBUQU5HRU5USU1QVUxTRTFfUkVHSVNURVIpO1xuICAgIHZhciB0YW5nZW50SW1wdWxzZTIgPSBWZWMzLnNjYWxlKHQyLCB0YW5nZW50TGFtYmRhMiwgVEFOR0VOVElNUFVMU0UyX1JFR0lTVEVSKTtcblxuICAgIGltcHVsc2UuYWRkKHRhbmdlbnRJbXB1bHNlMSkuYWRkKHRhbmdlbnRJbXB1bHNlMik7XG5cbiAgICB2YXIgYW5nSW1wdWxzZUIgPSBWZWMzLmNyb3NzKHJCb2R5QiwgaW1wdWxzZSwgVkVDMV9SRUdJU1RFUik7XG4gICAgdmFyIGFuZ0ltcHVsc2VBID0gVmVjMy5jcm9zcyhyQm9keUEsIGltcHVsc2UsIFZFQzJfUkVHSVNURVIpLmludmVydCgpO1xuXG4gICAgYm9keUIuYXBwbHlJbXB1bHNlKGltcHVsc2UpO1xuICAgIGJvZHlCLmFwcGx5QW5ndWxhckltcHVsc2UoYW5nSW1wdWxzZUIpO1xuICAgIGltcHVsc2UuaW52ZXJ0KCk7XG4gICAgYm9keUEuYXBwbHlJbXB1bHNlKGltcHVsc2UpO1xuICAgIGJvZHlBLmFwcGx5QW5ndWxhckltcHVsc2UoYW5nSW1wdWxzZUEpO1xuXG4gICAgdGhpcy5ub3JtYWxJbXB1bHNlID0gbmV3Tm9ybWFsSW1wdWxzZTtcbiAgICB0aGlzLnRhbmdlbnRJbXB1bHNlMSA9IG5ld1RhbmdlbnRJbXB1bHNlMTtcbiAgICB0aGlzLnRhbmdlbnRJbXB1bHNlMiA9IG5ld1RhbmdlbnRJbXB1bHNlMjtcblxuICAgIHRoaXMuaW1wdWxzZS5hZGQoaW1wdWxzZSk7XG4gICAgdGhpcy5hbmdJbXB1bHNlQS5hZGQoYW5nSW1wdWxzZUEpO1xuICAgIHRoaXMuYW5nSW1wdWxzZUIuYWRkKGFuZ0ltcHVsc2VCKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udGFjdE1hbmlmb2xkVGFibGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBWZWMzID0gcmVxdWlyZSgnZmFtb3VzLW1hdGgnKS5WZWMzO1xudmFyIE9iamVjdE1hbmFnZXIgPSByZXF1aXJlKCdmYW1vdXMtdXRpbGl0aWVzJykuT2JqZWN0TWFuYWdlcjtcblxuT2JqZWN0TWFuYWdlci5yZWdpc3RlcignR0pLX0VQQVN1cHBvcnRQb2ludCcsIEdKS19FUEFTdXBwb3J0UG9pbnQpO1xudmFyIE9NUmVxdWVzdEdKS19FUEFTdXBwb3J0UG9pbnQgPSBPYmplY3RNYW5hZ2VyLnJlcXVlc3RHSktfRVBBU3VwcG9ydFBvaW50O1xudmFyIE9NUmVxdWVzdER5bmFtaWNHZW9tZXRyeSA9IE9iamVjdE1hbmFnZXIucmVxdWVzdER5bmFtaWNHZW9tZXRyeTtcbnZhciBPTUZyZWVHSktfRVBBU3VwcG9ydFBvaW50ID0gT2JqZWN0TWFuYWdlci5mcmVlR0pLX0VQQVN1cHBvcnRQb2ludDtcbnZhciBPTUZyZWVEeW5hbWljR2VvbWV0cnkgPSBPYmplY3RNYW5hZ2VyLmZyZWVEeW5hbWljR2VvbWV0cnk7XG52YXIgT01GcmVlRHluYW1pY0dlb21ldHJ5RmVhdHVyZSA9IE9iamVjdE1hbmFnZXIuZnJlZUR5bmFtaWNHZW9tZXRyeUZlYXR1cmU7XG5cbnZhciBQX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcbnZhciBWMF9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgVjFfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIFYyX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcblxudmFyIERJUkVDVElPTl9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG52YXIgSU5WRElSRUNUSU9OX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBTdXBwb3J0IHBvaW50IHRvIGJlIGFkZGVkIHRvIHRoZSBEeW5hbWljR2VvbWV0cnkuIFRoZSBwb2ludCBpbiBNaW5rb3dza2kgc3BhY2UgYXMgd2VsbCBhcyB0aGVcbiAqIG9yaWdpbmFsIHBhaXIuXG4gKlxuICogQGNsYXNzIEdKS19FUEFTdXBwb3J0UG9pbnRcbiAqIEBwYXJhbSB7VmVjM30gdmVydGV4XG4gKiBAcGFyYW0ge1ZlYzN9IHdvcmxkVmVydGV4QVxuICogQHBhcmFtIHtWZWMzfSB3b3JsZFZlcnRleEFCXG4gKi9cbmZ1bmN0aW9uIEdKS19FUEFTdXBwb3J0UG9pbnQodmVydGV4LCB3b3JsZFZlcnRleEEsIHdvcmxkVmVydGV4Qikge1xuICAgIHRoaXMudmVydGV4ID0gdmVydGV4O1xuICAgIHRoaXMud29ybGRWZXJ0ZXhBID0gd29ybGRWZXJ0ZXhBO1xuICAgIHRoaXMud29ybGRWZXJ0ZXhCID0gd29ybGRWZXJ0ZXhCO1xufVxuXG4vKipcbiAqIFVzZWQgYnkgT2JqZWN0TWFuYWdlciB0byByZXNldCB0aGUgb2JqZWN0IHdpdGggZGlmZmVyZW50IGRhdGEuXG4gKlxuICogQG1ldGhvZCByZXNldFxuICogQHBhcmFtIHtPYmplY3RbXX0gYXJnc1xuICogQGNoYWluYWJsZVxuICovXG5HSktfRVBBU3VwcG9ydFBvaW50LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KHZlcnRleCwgd29ybGRWZXJ0ZXhBLCB3b3JsZFZlcnRleEIpIHtcbiAgICB0aGlzLnZlcnRleCA9IHZlcnRleDtcbiAgICB0aGlzLndvcmxkVmVydGV4QSA9IHdvcmxkVmVydGV4QTtcbiAgICB0aGlzLndvcmxkVmVydGV4QiA9IHdvcmxkVmVydGV4QjtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBGcmVlIHRoZSBEeW5hbWljR2VvbXRldHJ5IGFuZCBhc3NvY2lhdGUgdmVydGljZXMgYW5kIGZlYXR1cmVzIGZvciBsYXRlciByZXVzZS5cbiAqXG4gKiBAbWV0aG9kIGZyZWVHSktfRVBBRHluYW1pY0dlb21ldHJ5XG4gKiBAcGFyYW0ge0R5bmFtaWNHZW9tZXRyeX0gZ2VvbWV0cnlcbiAqL1xuZnVuY3Rpb24gZnJlZUdKS19FUEFEeW5hbWljR2VvbWV0cnkoZ2VvbWV0cnkpIHtcbiAgICB2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcbiAgICB2YXIgaTtcbiAgICBpID0gdmVydGljZXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdmFyIHYgPSB2ZXJ0aWNlcy5wb3AoKTtcbiAgICAgICAgaWYgKHYgIT09IG51bGwpIE9NRnJlZUdKS19FUEFTdXBwb3J0UG9pbnQodik7XG4gICAgfVxuICAgIGdlb21ldHJ5Lm51bVZlcnRpY2VzID0gMDtcbiAgICB2YXIgZmVhdHVyZXMgPSBnZW9tZXRyeS5mZWF0dXJlcztcbiAgICBpID0gZmVhdHVyZXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdmFyIGYgPSBmZWF0dXJlcy5wb3AoKTtcbiAgICAgICAgaWYgKGYgIT09IG51bGwpIE9NRnJlZUR5bmFtaWNHZW9tZXRyeUZlYXR1cmUoZik7XG4gICAgfVxuICAgIGdlb21ldHJ5Lm51bUZlYXR1cmVzID0gMDtcbiAgICBPTUZyZWVEeW5hbWljR2VvbWV0cnkoZ2VvbWV0cnkpO1xufVxuXG4vKipcbiAqIEZpbmQgdGhlIHBvaW50IGluIE1pbmtvd3NraSBzcGFjZSBmdXJ0aGVzdCBpbiBhIGdpdmVuIGRpcmVjdGlvbiBmb3IgdHdvIGNvbnZleCBCb2RpZXMuXG4gKlxuICogQG1ldGhvZCBtaW5rb3dza2lTdXBwb3J0XG4gKiBAcGFyYW0ge0JvZHl9IGJvZHkxXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHkyXG4gKiBAcGFyYW0ge1ZlYzN9IGRpcmVjdGlvblxuICogQHJldHVybiB7R0pLX0VQQVN1cHBvcnRQb2ludH1cbiAqL1xuZnVuY3Rpb24gbWlua293c2tpU3VwcG9ydChib2R5MSwgYm9keTIsIGRpcmVjdGlvbikge1xuICAgIHZhciBpbnZlcnNlRGlyZWN0aW9uID0gVmVjMy5zY2FsZShkaXJlY3Rpb24sIC0xLCBJTlZESVJFQ1RJT05fUkVHSVNURVIpO1xuXG4gICAgdmFyIGZ1cnRoZXN0MSA9IGJvZHkxLnN1cHBvcnQoZGlyZWN0aW9uKTtcbiAgICB2YXIgZnVydGhlc3QyID0gYm9keTIuc3VwcG9ydChpbnZlcnNlRGlyZWN0aW9uKTtcblxuICAgIHZhciB3MSA9IFZlYzMuYWRkKGZ1cnRoZXN0MSwgYm9keTEucG9zaXRpb24sIG5ldyBWZWMzKCkpO1xuICAgIHZhciB3MiA9IFZlYzMuYWRkKGZ1cnRoZXN0MiwgYm9keTIucG9zaXRpb24sIG5ldyBWZWMzKCkpO1xuXG4gICAgLy8gVGhlIHZlcnRleCBpbiBNaW5rb3dza2kgc3BhY2UgYXMgd2VsbCBhcyB0aGUgb3JpZ2luYWwgcGFpciBpbiB3b3JsZCBzcGFjZVxuICAgIHJldHVybiBPTVJlcXVlc3RHSktfRVBBU3VwcG9ydFBvaW50KCkucmVzZXQoVmVjMy5zdWJ0cmFjdCh3MSwgdzIsIG5ldyBWZWMzKCkpLCB3MSwgdzIpO1xufVxuXG4vKipcbiAqIEdpbGJlcnQtSm9obnNvbi1LZWVydGhpIGNvbGxpc2lvbiBkZXRlY3Rpb24uIFJldHVybnMgYSBEeW5hbWljR2VvbWV0cnkgc2ltcGxleCBpZiB0aGUgYm9kaWVzIGFyZSBmb3VuZFxuICogdG8gaGF2ZSBjb2xsaWRlZCBvciBmYWxzZSBmb3Igbm8gY29sbHNpb24uXG4gKlxuICogQG1ldGhvZCBHSktcbiAqIHBhcmFtIHtCb2R5fSBib2R5MVxuICogcGFyYW0ge0JvZHl9IGJvZHkyXG4gKiBAcmV0dXJuIHtEeW5hbWljR2VvbWV0cnkgfCBCb29sZWFufVxuICovXG5mdW5jdGlvbiBHSksoYm9keTEsIGJvZHkyKSB7XG4gICAgdmFyIHN1cHBvcnQgPSBtaW5rb3dza2lTdXBwb3J0O1xuICAgIC8vIFVzZSBwMiAtIHAxIHRvIHNlZWQgdGhlIGluaXRpYWwgY2hvaWNlIG9mIGRpcmVjdGlvblxuICAgIHZhciBkaXJlY3Rpb24gPSBWZWMzLnN1YnRyYWN0KGJvZHkyLnBvc2l0aW9uLCBib2R5MS5wb3NpdGlvbiwgRElSRUNUSU9OX1JFR0lTVEVSKS5ub3JtYWxpemUoKTtcbiAgICB2YXIgc2ltcGxleCA9IE9NUmVxdWVzdER5bmFtaWNHZW9tZXRyeSgpO1xuICAgIHNpbXBsZXguYWRkVmVydGV4KHN1cHBvcnQoYm9keTEsIGJvZHkyLCBkaXJlY3Rpb24pKTtcbiAgICBkaXJlY3Rpb24uaW52ZXJ0KCk7XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIG1heEl0ZXJhdGlvbnMgPSAxZTM7XG4gICAgd2hpbGUoaSsrIDwgbWF4SXRlcmF0aW9ucykge1xuICAgICAgICBpZiAoZGlyZWN0aW9uLnggPT09IDAgJiYgZGlyZWN0aW9uLnkgPT09IDAgJiYgZGlyZWN0aW9uLnogPT09IDApIGJyZWFrO1xuICAgICAgICBzaW1wbGV4LmFkZFZlcnRleChzdXBwb3J0KGJvZHkxLCBib2R5MiwgZGlyZWN0aW9uKSk7XG4gICAgICAgIGlmIChWZWMzLmRvdChzaW1wbGV4LmdldExhc3RWZXJ0ZXgoKS52ZXJ0ZXgsIGRpcmVjdGlvbikgPCAwKSBicmVhaztcbiAgICAgICAgLy8gSWYgc2ltcGxleCBjb250YWlucyBvcmlnaW4sIHJldHVybiBmb3IgdXNlIGluIEVQQVxuICAgICAgICBpZiAoc2ltcGxleC5zaW1wbGV4Q29udGFpbnNPcmlnaW4oZGlyZWN0aW9uLCBPTUZyZWVHSktfRVBBU3VwcG9ydFBvaW50KSkgcmV0dXJuIHNpbXBsZXg7XG4gICAgfVxuICAgIGZyZWVHSktfRVBBRHluYW1pY0dlb21ldHJ5KHNpbXBsZXgpO1xuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBFeHBhbmRpbmcgUG9seXRvcGUgQWxnb3JpdGhtLS1wZW5ldHJhdGlvbiBkZXB0aCwgY29sbGlzaW9uIG5vcm1hbCwgYW5kIGNvbnRhY3QgcG9pbnRzLlxuICogUmV0dXJucyBhIENvbGxpc29uRGF0YSBvYmplY3QuXG4gKlxuICogQG1ldGhvZCBFUEFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keTFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keTJcbiAqIEBwYXJhbSB7RHluYW1pY0dlb21ldHJ5fSBwb2x5dG9wZVxuICogQHJldHVybiB7Q29sbGlzaW9uRGF0YX1cbiAqL1xuZnVuY3Rpb24gRVBBKGJvZHkxLCBib2R5MiwgcG9seXRvcGUpIHtcbiAgICB2YXIgc3VwcG9ydCA9IG1pbmtvd3NraVN1cHBvcnQ7XG4gICAgdmFyIGRlcHRoRXN0aW1hdGUgPSBJbmZpbml0eTtcblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbWF4SXRlcmF0aW9ucyA9IDFlMztcbiAgICB3aGlsZShpKysgPCBtYXhJdGVyYXRpb25zKSB7XG4gICAgICAgIHZhciBjbG9zZXN0ID0gcG9seXRvcGUuZ2V0RmVhdHVyZUNsb3Nlc3RUb09yaWdpbigpO1xuICAgICAgICBpZiAoY2xvc2VzdCA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBjbG9zZXN0Lm5vcm1hbDtcbiAgICAgICAgdmFyIHBvaW50ID0gc3VwcG9ydChib2R5MSwgYm9keTIsIGRpcmVjdGlvbik7XG4gICAgICAgIGRlcHRoRXN0aW1hdGUgPSBNYXRoLm1pbihkZXB0aEVzdGltYXRlLCBWZWMzLmRvdChwb2ludC52ZXJ0ZXgsIGRpcmVjdGlvbikpO1xuICAgICAgICBpZiAoZGVwdGhFc3RpbWF0ZSAtIGNsb3Nlc3QuZGlzdGFuY2UgPD0gMC4wMSkge1xuICAgICAgICAgICAgdmFyIHN1cHBvcnRBID0gcG9seXRvcGUudmVydGljZXNbY2xvc2VzdC52ZXJ0ZXhJbmRpY2VzWzBdXTtcbiAgICAgICAgICAgIHZhciBzdXBwb3J0QiA9IHBvbHl0b3BlLnZlcnRpY2VzW2Nsb3Nlc3QudmVydGV4SW5kaWNlc1sxXV07XG4gICAgICAgICAgICB2YXIgc3VwcG9ydEMgPSBwb2x5dG9wZS52ZXJ0aWNlc1tjbG9zZXN0LnZlcnRleEluZGljZXNbMl1dO1xuXG4gICAgICAgICAgICB2YXIgQSA9IHN1cHBvcnRBLnZlcnRleDtcbiAgICAgICAgICAgIHZhciBCID0gc3VwcG9ydEIudmVydGV4O1xuICAgICAgICAgICAgdmFyIEMgPSBzdXBwb3J0Qy52ZXJ0ZXg7XG4gICAgICAgICAgICB2YXIgUCA9IFZlYzMuc2NhbGUoZGlyZWN0aW9uLCBjbG9zZXN0LmRpc3RhbmNlLCBQX1JFR0lTVEVSKTtcblxuICAgICAgICAgICAgdmFyIFYwID0gVmVjMy5zdWJ0cmFjdChCLCBBLCBWMF9SRUdJU1RFUik7XG4gICAgICAgICAgICB2YXIgVjEgPSBWZWMzLnN1YnRyYWN0KEMsIEEsIFYxX1JFR0lTVEVSKTtcbiAgICAgICAgICAgIHZhciBWMiA9IFZlYzMuc3VidHJhY3QoUCwgQSwgVjJfUkVHSVNURVIpO1xuXG4gICAgICAgICAgICB2YXIgZDAwID0gVmVjMy5kb3QoVjAsIFYwKTtcbiAgICAgICAgICAgIHZhciBkMDEgPSBWZWMzLmRvdChWMCwgVjEpO1xuICAgICAgICAgICAgdmFyIGQxMSA9IFZlYzMuZG90KFYxLCBWMSk7XG4gICAgICAgICAgICB2YXIgZDIwID0gVmVjMy5kb3QoVjIsIFYwKTtcbiAgICAgICAgICAgIHZhciBkMjEgPSBWZWMzLmRvdChWMiwgVjEpO1xuICAgICAgICAgICAgdmFyIGRlbm9tID0gZDAwKmQxMSAtIGQwMSpkMDE7XG5cbiAgICAgICAgICAgIHZhciB2ID0gKGQxMSpkMjAgLSBkMDEqZDIxKSAvIGRlbm9tO1xuICAgICAgICAgICAgdmFyIHcgPSAoZDAwKmQyMSAtIGQwMSpkMjApIC8gZGVub207XG4gICAgICAgICAgICB2YXIgdSA9IDEuMCAtIHYgLSB3O1xuXG4gICAgICAgICAgICB2YXIgYm9keTFDb250YWN0ID0gICAgICBzdXBwb3J0QS53b3JsZFZlcnRleEEuc2NhbGUodSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYWRkKHN1cHBvcnRCLndvcmxkVmVydGV4QS5zY2FsZSh2KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYWRkKHN1cHBvcnRDLndvcmxkVmVydGV4QS5zY2FsZSh3KSk7XG5cbiAgICAgICAgICAgIHZhciBib2R5MkNvbnRhY3QgPSAgICAgIHN1cHBvcnRBLndvcmxkVmVydGV4Qi5zY2FsZSh1KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGQoc3VwcG9ydEIud29ybGRWZXJ0ZXhCLnNjYWxlKHYpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGQoc3VwcG9ydEMud29ybGRWZXJ0ZXhCLnNjYWxlKHcpKTtcblxuICAgICAgICAgICAgdmFyIGxvY2FsQm9keTFDb250YWN0ID0gVmVjMy5zdWJ0cmFjdChib2R5MUNvbnRhY3QsIGJvZHkxLnBvc2l0aW9uLCBuZXcgVmVjMygpKTtcbiAgICAgICAgICAgIHZhciBsb2NhbEJvZHkyQ29udGFjdCA9IFZlYzMuc3VidHJhY3QoYm9keTJDb250YWN0LCBib2R5Mi5wb3NpdGlvbiwgbmV3IFZlYzMoKSk7XG5cbiAgICAgICAgICAgIGZyZWVHSktfRVBBRHluYW1pY0dlb21ldHJ5KHBvbHl0b3BlKTtcbiAgICAgICAgICAgIE9NRnJlZUdKS19FUEFTdXBwb3J0UG9pbnQocG9pbnQpO1xuXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0TWFuYWdlci5yZXF1ZXN0Q29sbGlzaW9uRGF0YSgpLnJlc2V0KGNsb3Nlc3QuZGlzdGFuY2UsIGRpcmVjdGlvbiwgYm9keTFDb250YWN0LCBib2R5MkNvbnRhY3QsIGxvY2FsQm9keTFDb250YWN0LCBsb2NhbEJvZHkyQ29udGFjdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb2x5dG9wZS5hZGRWZXJ0ZXgocG9pbnQpO1xuICAgICAgICAgICAgcG9seXRvcGUucmVzaGFwZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignRVBBIGZhaWxlZCB0byB0ZXJtaW5hdGUgaW4gYWxsb3R0ZWQgaXRlcmF0aW9ucy4nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMuR0pLID0gR0pLO1xubW9kdWxlLmV4cG9ydHMuRVBBID0gRVBBO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQUFCQiA9IHJlcXVpcmUoJy4vQUFCQicpO1xuXG4vKipcbiAqIEBjb25zdCB7U3RyaW5nW119IEFYRVMgeCwgeSwgYW5kIHogYXhlc1xuICovXG52YXIgQVhFUyA9IFsneCcsICd5JywgJ3onXTtcblxuLyoqXG4gKiBQZXJzaXN0YW50IG9iamVjdCBtYWludGFpbmluZyBzb3J0ZWQgbGlzdHMgb2YgQUFCQiBlbmRwb2ludHMgdXNlZCBpbiBhIHN3ZWVwLWFuZC1wcnVuZSBicm9hZHBoYXNlLlxuICogVXNlZCB0byBhY2NlbGVyYXRlIGNvbGxpc2lvbiBkZXRlY3Rpb24uXG4gKiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N3ZWVwX2FuZF9wcnVuZVxuICpcbiAqIEBjbGFzcyBTd2VlcEFuZFBydW5lXG4gKiBAcGFyYW0ge0JvZHlbXX0gdGFyZ2V0c1xuICovXG5mdW5jdGlvbiBTd2VlcEFuZFBydW5lKHRhcmdldHMpIHtcbiAgICB0aGlzLl9zd2VlcFZvbHVtZXMgPSBbXTtcbiAgICB0aGlzLl9lbnRpdHlSZWdpc3RyeSA9IHt9O1xuICAgIHRoaXMuX2JvdW5kaW5nVm9sdW1lUmVnaXN0cnkgPSB7fTtcbiAgICB0aGlzLmVuZHBvaW50cyA9IHt4OiBbXSwgeTogW10sIHo6IFtdfTtcblxuICAgIHRoaXMub3ZlcmxhcHMgPSBbXTtcbiAgICB0aGlzLm92ZXJsYXBzTWF0cml4ID0ge307XG4gICAgdGhpcy5fSURQb29sID0gW107XG4gICAgdGFyZ2V0cyA9IHRhcmdldHMgfHwgW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuYWRkKHRhcmdldHNbaV0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBTdGFydCB0cmFja2luZyBhIGJvZHkgaW4gdGhlIGJyb2FkLXBoYXNlLlxuICpcbiAqIEBtZXRob2QgYWRkXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlcbiAqL1xuU3dlZXBBbmRQcnVuZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oYm9keSkge1xuICAgIHZhciBib3VuZGluZ1ZvbHVtZSA9IG5ldyBBQUJCKGJvZHkpO1xuICAgIHZhciBzd2VlcFZvbHVtZSA9IG5ldyBTd2VlcFZvbHVtZShib3VuZGluZ1ZvbHVtZSk7XG5cbiAgICB0aGlzLl9lbnRpdHlSZWdpc3RyeVtib2R5Ll9JRF0gPSBib2R5O1xuICAgIHRoaXMuX2JvdW5kaW5nVm9sdW1lUmVnaXN0cnlbYm9keS5fSURdID0gYm91bmRpbmdWb2x1bWU7XG4gICAgdGhpcy5fc3dlZXBWb2x1bWVzLnB1c2goc3dlZXBWb2x1bWUpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgIHZhciBheGlzID0gQVhFU1tpXTtcbiAgICAgICAgdGhpcy5lbmRwb2ludHNbYXhpc10ucHVzaChzd2VlcFZvbHVtZS5wb2ludHNbYXhpc11bMF0pO1xuICAgICAgICB0aGlzLmVuZHBvaW50c1theGlzXS5wdXNoKHN3ZWVwVm9sdW1lLnBvaW50c1theGlzXVsxXSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBTdG9wIHRyYWNraW5nIGEgYm9keSBpbiB0aGUgYnJvYWQtcGhhc2UuXG4gKlxuICogQG1ldGhvZCBhZGRcbiAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICovXG5Td2VlcEFuZFBydW5lLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoYm9keSkge1xuICAgIHRoaXMuX2VudGl0eVJlZ2lzdHJ5W2JvZHkuX0lEXSA9IG51bGw7XG4gICAgdGhpcy5fYm91bmRpbmdWb2x1bWVSZWdpc3RyeVtib2R5Ll9JRF0gPSBudWxsO1xuICAgIHZhciBpLCBsZW47XG4gICAgdmFyIGluZGV4O1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuX3N3ZWVwVm9sdW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAodGhpcy5fc3dlZXBWb2x1bWVzW2ldLl9JRCA9PT0gYm9keS5fSUQpIHtcbiAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3N3ZWVwVm9sdW1lcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHZhciBlbmRwb2ludHMgPSB0aGlzLmVuZHBvaW50cztcbiAgICB2YXIgcG9pbnQ7XG5cbiAgICB2YXIgeHMgPSBbXTtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBlbmRwb2ludHMueC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBwb2ludCA9IGVuZHBvaW50cy54W2ldO1xuICAgICAgICBpZiAocG9pbnQuX0lEICE9PSBib2R5Ll9JRCkgeHMucHVzaChwb2ludCk7XG4gICAgfVxuICAgIHZhciB5cyA9IFtdO1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IGVuZHBvaW50cy55Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHBvaW50ID0gZW5kcG9pbnRzLnlbaV07XG4gICAgICAgIGlmIChwb2ludC5fSUQgIT09IGJvZHkuX0lEKSB5cy5wdXNoKHBvaW50KTtcbiAgICB9XG4gICAgdmFyIHpzID0gW107XG4gICAgZm9yIChpID0gMCwgbGVuID0gZW5kcG9pbnRzLnoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcG9pbnQgPSBlbmRwb2ludHMueltpXTtcbiAgICAgICAgaWYgKHBvaW50Ll9JRCAhPT0gYm9keS5fSUQpIHpzLnB1c2gocG9pbnQpO1xuICAgIH1cbiAgICBlbmRwb2ludHMueCA9IHhzO1xuICAgIGVuZHBvaW50cy55ID0geXM7XG4gICAgZW5kcG9pbnRzLnogPSB6cztcbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSBlbmRwb2ludHMgb2YgdGhlIHRyYWNrZWQgQUFCQidzIGFuZCByZXNvcnQgdGhlIGVuZHBvaW50IGxpc3RzIGFjY29yZGluZ2x5LiBVc2VzIGFuIGluc2VydGlvbiBzb3J0LFxuICogd2hlcmUgc3dhcHMgZHVyaW5nIHRoZSBzb3J0IGFyZSB0YWtlbiB0byBzaWduaWZ5IGEgcG90ZW50aWFsIGNoYW5nZSBpbiBvdmVybGFwIHN0YXR1cyBmb3IgdGhlIHR3b1xuICogcmVsZXZhbnQgQUFCQidzLiBSZXR1cm5zIHBhaXJzIG9mIG92ZXJsYXBwaW5nIEFBQkIncy5cbiAqXG4gKiBAcGFyYW0gdXBkYXRlXG4gKiBAcmV0dXJuIHtQYXJ0aWNsZVtdW119XG4gKi9cblN3ZWVwQW5kUHJ1bmUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBfc3dlZXBWb2x1bWVzID0gdGhpcy5fc3dlZXBWb2x1bWVzO1xuICAgIHZhciBfZW50aXR5UmVnaXN0cnkgPSB0aGlzLl9lbnRpdHlSZWdpc3RyeTtcbiAgICB2YXIgX2JvdW5kaW5nVm9sdW1lUmVnaXN0cnkgPSB0aGlzLl9ib3VuZGluZ1ZvbHVtZVJlZ2lzdHJ5O1xuXG4gICAgdmFyIGksIGosIGssIGxlbjtcblxuICAgIGZvciAoaiA9IDAsIGxlbiA9IF9zd2VlcFZvbHVtZXMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgX3N3ZWVwVm9sdW1lc1tqXS51cGRhdGUoKTtcbiAgICB9XG5cbiAgICB2YXIgZW5kcG9pbnRzID0gdGhpcy5lbmRwb2ludHM7XG4gICAgdmFyIG92ZXJsYXBzID0gdGhpcy5vdmVybGFwcztcbiAgICB2YXIgb3ZlcmxhcHNNYXRyaXggPSB0aGlzLm92ZXJsYXBzTWF0cml4O1xuICAgIHZhciBfSURQb29sID0gdGhpcy5fSURQb29sO1xuXG4gICAgZm9yIChrID0gMDsgayA8IDM7IGsrKykge1xuICAgICAgICB2YXIgYXhpcyA9IEFYRVNba107XG4gICAgICAgIC8vIEluc2VydGlvbiBzb3J0OlxuICAgICAgICB2YXIgZW5kcG9pbnRBeGlzID0gZW5kcG9pbnRzW2F4aXNdO1xuICAgICAgICBmb3IgKGogPSAxLCBsZW4gPSBlbmRwb2ludEF4aXMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gZW5kcG9pbnRBeGlzW2pdO1xuICAgICAgICAgICAgdmFyIHZhbCA9IGN1cnJlbnQudmFsdWU7XG4gICAgICAgICAgICB2YXIgc3dhcDtcbiAgICAgICAgICAgIHZhciByb3c7XG4gICAgICAgICAgICB2YXIgaW5kZXg7XG4gICAgICAgICAgICB2YXIgbG93SUQ7XG4gICAgICAgICAgICB2YXIgaGlnaElEO1xuICAgICAgICAgICAgdmFyIGNJRDtcbiAgICAgICAgICAgIHZhciBzSUQ7XG5cbiAgICAgICAgICAgIGkgPSBqIC0gMTtcbiAgICAgICAgICAgIHdoaWxlIChpID49IDAgJiYgKHN3YXAgPSBlbmRwb2ludEF4aXNbaV0pLnZhbHVlID4gdmFsKSB7XG4gICAgICAgICAgICAgICAgLy8gQSBzd2FwIG9jY3VyZW5jZSBpbmRpY2F0ZXMgdGhhdCBjdXJyZW50IGFuZCBzd2FwIGVpdGhlciBqdXN0IHN0YXJ0ZWQgb3IganVzdCBzdG9wcGVkIG92ZXJsYXBwaW5nXG5cbiAgICAgICAgICAgICAgICBjSUQgPSBjdXJyZW50Ll9JRDtcbiAgICAgICAgICAgICAgICBzSUQgPSBzd2FwLl9JRDtcblxuICAgICAgICAgICAgICAgIGlmIChjSUQgPCBzSUQpIHtcbiAgICAgICAgICAgICAgICAgICAgbG93SUQgPSBjSUQ7XG4gICAgICAgICAgICAgICAgICAgIGhpZ2hJRCA9IHNJRDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb3dJRCA9IHNJRDtcbiAgICAgICAgICAgICAgICAgICAgaGlnaElEID0gY0lEO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmLCBmb3IgdGhpcyBheGlzLCBtaW4gcG9pbnQgb2YgY3VycmVudCBhbmQgbWF4IHBvaW50IG9mIHN3YXBcbiAgICAgICAgICAgICAgICBpZiAofmN1cnJlbnQuc2lkZSAmIHN3YXAuc2lkZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3cgb3ZlcmxhcHBpbmcgb24gdGhpcyBheGlzIC0+IHBvc3NpYmxlIG92ZXJsYXAsIGRvIGZ1bGwgQUFCQiBjaGVja1xuICAgICAgICAgICAgICAgICAgICBpZiAoQUFCQi5jaGVja092ZXJsYXAoX2JvdW5kaW5nVm9sdW1lUmVnaXN0cnlbY0lEXSwgX2JvdW5kaW5nVm9sdW1lUmVnaXN0cnlbc0lEXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdyA9IG92ZXJsYXBzTWF0cml4W2xvd0lEXSA9IG92ZXJsYXBzTWF0cml4W2xvd0lEXSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gcm93W2hpZ2hJRF0gPSBfSURQb29sLmxlbmd0aCA/IF9JRFBvb2wucG9wKCkgOiBvdmVybGFwcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGFwc1tpbmRleF0gPSBbX2VudGl0eVJlZ2lzdHJ5W2xvd0lEXSwgX2VudGl0eVJlZ2lzdHJ5W2hpZ2hJRF1dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gLy8gRWxzZSBpZiwgZm9yIHRoaXMgYXhpcywgbWF4IHBvaW50IG9mIGN1cnJlbnQgYW5kIG1pbiBwb2ludCBvZiBzd2FwXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50LnNpZGUgJiB+c3dhcC5zaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdyBub3Qgb3ZlcmxhcHBpbmcgb24gdGhpcyBheGlzIC0+IGRlZmluaXRlbHkgbm90IG92ZXJsYXBwaW5nXG4gICAgICAgICAgICAgICAgICAgIGlmICgocm93ID0gb3ZlcmxhcHNNYXRyaXhbbG93SURdKSAmJiByb3dbaGlnaElEXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHJvd1toaWdoSURdO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcHNbaW5kZXhdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd1toaWdoSURdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9JRFBvb2wucHVzaChpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRWxzZSBpZiBtYXggb2YgYm90aCBvciBtaW4gb2YgYm90aCwgc3RpbGwgb3ZlcmxhcHBpbmdcblxuICAgICAgICAgICAgICAgIGVuZHBvaW50QXhpc1tpICsgMV0gPSBzd2FwO1xuICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVuZHBvaW50QXhpc1tpICsgMV0gPSBjdXJyZW50O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG92ZXJsYXBzO1xufTtcblxuLyoqXG4gKiBPYmplY3QgdXNlZCB0byBhc3NvY2lhdGUgYW4gQUFCQiB3aXRoIGl0cyBlbmRwb2ludHMgaW4gdGhlIHNvcnRlZCBsaXN0cy5cbiAqXG4gKiBAY2xhc3MgU3dlZXBWb2x1bWVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBQUJCfSBib3VuZGluZ1ZvbHVtZVxuICovXG5mdW5jdGlvbiBTd2VlcFZvbHVtZShib3VuZGluZ1ZvbHVtZSkge1xuICAgIHRoaXMuX2JvdW5kaW5nVm9sdW1lID0gYm91bmRpbmdWb2x1bWU7XG4gICAgdGhpcy5fSUQgPSBib3VuZGluZ1ZvbHVtZS5fSUQ7XG4gICAgdGhpcy5wb2ludHMgPSB7XG4gICAgICAgIHg6IFt7X0lEOiBib3VuZGluZ1ZvbHVtZS5fSUQsIHNpZGU6IDAsIHZhbHVlOiBudWxsfSwge19JRDogYm91bmRpbmdWb2x1bWUuX0lELCBzaWRlOiAxLCB2YWx1ZTogbnVsbH1dLFxuICAgICAgICB5OiBbe19JRDogYm91bmRpbmdWb2x1bWUuX0lELCBzaWRlOiAwLCB2YWx1ZTogbnVsbH0sIHtfSUQ6IGJvdW5kaW5nVm9sdW1lLl9JRCwgc2lkZTogMSwgdmFsdWU6IG51bGx9XSxcbiAgICAgICAgejogW3tfSUQ6IGJvdW5kaW5nVm9sdW1lLl9JRCwgc2lkZTogMCwgdmFsdWU6IG51bGx9LCB7X0lEOiBib3VuZGluZ1ZvbHVtZS5fSUQsIHNpZGU6IDEsIHZhbHVlOiBudWxsfV1cbiAgICB9O1xuICAgIHRoaXMudXBkYXRlKCk7XG59XG5cbi8qKlxuICogVXBkYXRlIHRoZSBlbmRwb2ludHMgdG8gcmVmbGVjdCB0aGUgY3VycmVudCBsb2NhdGlvbiBvZiB0aGUgQUFCQi5cbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICovXG5Td2VlcFZvbHVtZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGJvdW5kaW5nVm9sdW1lID0gdGhpcy5fYm91bmRpbmdWb2x1bWU7XG4gICAgYm91bmRpbmdWb2x1bWUudXBkYXRlKCk7XG5cbiAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICB2YXIgYXhpcyA9IEFYRVNbaV07XG4gICAgICAgIHBvaW50c1theGlzXVswXS52YWx1ZSA9IGJvdW5kaW5nVm9sdW1lLnZlcnRpY2VzW2F4aXNdWzBdO1xuICAgICAgICBwb2ludHNbYXhpc11bMV0udmFsdWUgPSBib3VuZGluZ1ZvbHVtZS52ZXJ0aWNlc1theGlzXVsxXTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN3ZWVwQW5kUHJ1bmU7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBGb3JjZSA9IHJlcXVpcmUoJy4vRm9yY2UnKTtcbnZhciBWZWMzID0gcmVxdWlyZSgnZmFtb3VzLW1hdGgnKS5WZWMzO1xuXG52YXIgRk9SQ0VfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIFVzZSBkcmFnIHRvIG9wcG9zZSBtb21lbnR1bSBvZiBhIG1vdmluZyBvYmplY3RcbiAqXG4gKiBAY2xhc3MgRHJhZ1xuICogQGV4dGVuZHMgRm9yY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIERyYWcodGFyZ2V0cywgb3B0aW9ucykge1xuICAgIEZvcmNlLmNhbGwodGhpcywgdGFyZ2V0cywgb3B0aW9ucyk7XG59XG5cbkRyYWcucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGb3JjZS5wcm90b3R5cGUpO1xuRHJhZy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEcmFnO1xuXG4vKipcbiAqIFVzZWQgdG8gc2NhbGUgdmVsb2NpdHkgaW4gdGhlIGNvbXB1dGF0aW9uIG9mIHRoZSBkcmFnIGZvcmNlLlxuICpcbiAqIEBhdHRyaWJ1dGUgUVVBRFJBVElDXG4gKiBAdHlwZSBGdW5jdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHZcbiAqIEByZXR1cm4ge051bWJlcn0gdXNlZCB0byBzcXVhcmUgdGhlIG1hZ25pdHVkZSBvZiB0aGUgdmVsb2NpdHlcbiAqL1xuRHJhZy5RVUFEUkFUSUMgPSBmdW5jdGlvbiBRVUFEUkFUSUModikge1xuICAgIHJldHVybiB2KnY7XG59O1xuXG4vKipcbiAqIFVzZWQgdG8gc2NhbGUgdmVsb2NpdHkgaW4gdGhlIGNvbXB1dGF0aW9uIG9mIHRoZSBkcmFnIGZvcmNlLlxuICpcbiAqIEBhdHRyaWJ1dGUgTElORUFSXG4gKiBAdHlwZSBGdW5jdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHZcbiAqIEByZXR1cm4ge051bWJlcn0gc3RyZW5ndGggMSwgd2lsbCBub3Qgc2NhbGUgdGhlIHZlbG9jaXR5XG4gKi9cbkRyYWcuTElORUFSID0gZnVuY3Rpb24gTElORUFSKHYpIHtcbiAgICByZXR1cm4gdjtcbn07XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgRm9yY2UuIFNldHMgZGVmYXVsdHMgaWYgYSBwcm9wZXJ0eSB3YXMgbm90IGFscmVhZHkgc2V0LlxuICpcbiAqIEBtZXRob2QgaW5pdFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgaGFzaC5cbiAqL1xuRHJhZy5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubWF4ID0gdGhpcy5tYXggfHwgSW5maW5pdHk7XG4gICAgdGhpcy5zdHJlbmd0aCA9IHRoaXMuc3RyZW5ndGggfHwgMTtcbiAgICB0aGlzLnR5cGUgPSB0aGlzLnR5cGUgfHwgRHJhZy5MSU5FQVI7XG59O1xuXG4vKipcbiAqIEFwcGx5IHRoZSBmb3JjZS5cbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICovXG5EcmFnLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgdmFyIHRhcmdldHMgPSB0aGlzLnRhcmdldHM7XG4gICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cbiAgICB2YXIgZm9yY2UgPSBGT1JDRV9SRUdJU1RFUjtcblxuICAgIHZhciBtYXggPSB0aGlzLm1heDtcbiAgICB2YXIgc3RyZW5ndGggPSB0aGlzLnN0cmVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0YXJnZXRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSB0YXJnZXRzW2ldO1xuICAgICAgICB2YXIgdmVsb2NpdHkgPSB0YXJnZXQudmVsb2NpdHk7XG4gICAgICAgIHZhciB2ID0gdmVsb2NpdHkubGVuZ3RoKCk7XG4gICAgICAgIHZhciBpbnZWID0gdiA/IDEgLyB2IDogMDtcbiAgICAgICAgdmFyIG1hZ25pdHVkZSA9IC1zdHJlbmd0aCAqIHR5cGUodik7XG4gICAgICAgIFZlYzMuc2NhbGUodmVsb2NpdHksIChtYWduaXR1ZGUgPCAtbWF4ID8gLW1heCA6IG1hZ25pdHVkZSkgKiBpbnZWLCBmb3JjZSk7XG4gICAgICAgIHRhcmdldC5hcHBseUZvcmNlKGZvcmNlKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERyYWc7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBfSUQgPSAwO1xuLyoqXG4gKiBBYnN0cmFjdCBmb3JjZSBtYW5hZ2VyIHRvIGFwcGx5IGZvcmNlcyB0byB0YXJnZXRzLlxuICpcbiAqIEBjbGFzcyBGb3JjZVxuICogQHZpcnR1YWxcbiAqIEBwYXJhbSB7UGFydGljbGVbXX0gdGFyZ2V0cyBUaGUgdGFyZ2V0cyBvZiB0aGUgZm9yY2UuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBoYXNoLlxuICovXG5mdW5jdGlvbiBGb3JjZSh0YXJnZXRzLCBvcHRpb25zKSB7XG4gICAgaWYgKHRhcmdldHMpIHtcbiAgICAgICAgaWYgKHRhcmdldHMgaW5zdGFuY2VvZiBBcnJheSkgdGhpcy50YXJnZXRzID0gdGFyZ2V0cztcbiAgICAgICAgZWxzZSB0aGlzLnRhcmdldHMgPSBbdGFyZ2V0c107XG4gICAgfVxuICAgIGVsc2UgdGhpcy50YXJnZXRzID0gW107XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICB0aGlzLl9JRCA9IF9JRCsrO1xufVxuXG4vKipcbiAqIERlY29yYXRlcyB0aGUgRm9yY2Ugd2l0aCB0aGUgb3B0aW9ucyBvYmplY3QuXG4gKlxuICogQG1ldGhvZCBzZXRPcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBoYXNoLlxuICovXG5Gb3JjZS5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB0aGlzW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgdGhpcy5pbml0KG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBBZGQgYSB0YXJnZXQgb3IgdGFyZ2V0cyB0byB0aGUgRm9yY2UuXG4gKlxuICogQG1ldGhvZCBhZGRUYXJnZXRcbiAqIEBwYXJhbSB7UGFydGljbGV9IHRhcmdldCBUaGUgYm9keSB0byBiZWdpbiB0YXJnZXR0aW5nLlxuICovXG5Gb3JjZS5wcm90b3R5cGUuYWRkVGFyZ2V0ID0gZnVuY3Rpb24gYWRkVGFyZ2V0KHRhcmdldCkge1xuICAgIHRoaXMudGFyZ2V0cy5wdXNoKHRhcmdldCk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhIHRhcmdldCBvciB0YXJnZXRzIGZyb20gdGhlIEZvcmNlLlxuICpcbiAqIEBtZXRob2QgYWRkVGFyZ2V0XG4gKiBAcGFyYW0ge1BhcnRpY2xlfSB0YXJnZXQgVGhlIGJvZHkgdG8gc3RvcCB0YXJnZXR0aW5nLlxuICovXG5Gb3JjZS5wcm90b3R5cGUucmVtb3ZlVGFyZ2V0ID0gZnVuY3Rpb24gcmVtb3ZlVGFyZ2V0KHRhcmdldCkge1xuICAgIHZhciBpbmRleCA9IHRoaXMudGFyZ2V0cy5pbmRleE9mKHRhcmdldCk7XG4gICAgaWYgKGluZGV4IDwgMCkgcmV0dXJuO1xuICAgIHRoaXMudGFyZ2V0cy5zcGxpY2UoaW5kZXgsIDEpO1xufTtcblxuLyoqXG4gKiBNZXRob2QgaW52b2tlZCB1cG9uIGluc3RhbnRpYXRpb24gYW5kIHRoZSBzZXR0aW5nIG9mIG9wdGlvbnMuXG4gKlxuICogQG1ldGhvZCBpbml0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBoYXNoLlxuICovXG5Gb3JjZS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIGluaXQob3B0aW9ucykge307XG5cbi8qKlxuICogQXBwbHkgZm9yY2VzIG9uIGVhY2ggdGFyZ2V0LlxuICpcbiAqIEBtZXRob2QgdXBkYXRlXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZSBUaGUgY3VycmVudCB0aW1lIGluIHRoZSBwaHlzaWNzIGVuZ2luZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBkdCBUaGUgcGh5c2ljcyBlbmdpbmUgZnJhbWUgZGVsdGEuXG4gKi9cbkZvcmNlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUodGltZSwgZHQpIHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZvcmNlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRm9yY2UgPSByZXF1aXJlKCcuL0ZvcmNlJyk7XG52YXIgVmVjMyA9IHJlcXVpcmUoJ2ZhbW91cy1tYXRoJykuVmVjMztcblxudmFyIEZPUkNFX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBGb3JjZSB0aGF0IHB1bGxzIGFsbCBvYmplY3RzIGluIGEgZGlyZWN0aW9uIHdpdGggY29uc3RhbnQgYWNjZWxlcmF0aW9uXG4gKlxuICogQGNsYXNzIEdyYXZpdHkxRFxuICogQGV4dGVuZHMgRm9yY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIEdyYXZpdHkxRCh0YXJnZXRzLCBvcHRpb25zKSB7XG4gICAgRm9yY2UuY2FsbCh0aGlzLCB0YXJnZXRzLCBvcHRpb25zKTtcbn1cblxuR3Jhdml0eTFELnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRm9yY2UucHJvdG90eXBlKTtcbkdyYXZpdHkxRC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHcmF2aXR5MUQ7XG5cbi8qKlxuICogQGVudW0gZGlyZWN0aW9uc1xuICovXG5HcmF2aXR5MUQuRE9XTiAgICAgPSAwO1xuR3Jhdml0eTFELlVQICAgICAgID0gMTtcbkdyYXZpdHkxRC5MRUZUICAgICA9IDI7XG5HcmF2aXR5MUQuUklHSFQgICAgPSAzO1xuR3Jhdml0eTFELkZPUldBUkQgID0gNDtcbkdyYXZpdHkxRC5CQUNLV0FSRCA9IDU7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgRm9yY2UuIFNldHMgZGVmYXVsdHMgaWYgYSBwcm9wZXJ0eSB3YXMgbm90IGFscmVhZHkgc2V0LlxuICpcbiAqIEBtZXRob2QgaW5pdFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgaGFzaC5cbiAqL1xuR3Jhdml0eTFELnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMubWF4ID0gdGhpcy5tYXggfHwgSW5maW5pdHk7XG4gICAgaWYgKG9wdGlvbnMuYWNjZWxlcmF0aW9uKSB7XG4gICAgICAgIHRoaXMuc3RyZW5ndGggPSB0aGlzLmFjY2VsZXJhdGlvbi5sZW5ndGgoKTtcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSAtMTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgYWNjZWxlcmF0aW9uID0gdGhpcy5hY2NlbGVyYXRpb24gPSBuZXcgVmVjMygpO1xuICAgIHZhciBkaXJlY3Rpb24gPSB0aGlzLmRpcmVjdGlvbiA9IHRoaXMuZGlyZWN0aW9uIHx8IEdyYXZpdHkxRC5ET1dOO1xuICAgIHZhciBtYWduaXR1ZGUgPSB0aGlzLnN0cmVuZ3RoID0gdGhpcy5zdHJlbmd0aCB8fCAyMDA7XG4gICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgY2FzZSBHcmF2aXR5MUQuRE9XTjpcbiAgICAgICAgICAgIGFjY2VsZXJhdGlvbi5zZXQoMCwgbWFnbml0dWRlLCAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdyYXZpdHkxRC5VUDpcbiAgICAgICAgICAgIGFjY2VsZXJhdGlvbi5zZXQoMCwgLTEgKiBtYWduaXR1ZGUsIDApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR3Jhdml0eTFELkxFRlQ6XG4gICAgICAgICAgICBhY2NlbGVyYXRpb24uc2V0KC0xICogbWFnbml0dWRlLCAwLCAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdyYXZpdHkxRC5SSUdIVDpcbiAgICAgICAgICAgIGFjY2VsZXJhdGlvbi5zZXQobWFnbml0dWRlLCAwLCAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdyYXZpdHkxRC5GT1JXQVJEOlxuICAgICAgICAgICAgYWNjZWxlcmF0aW9uLnNldCgwLCAwLCAtMSAqIG1hZ25pdHVkZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHcmF2aXR5MUQuQkFDS1dBUkQ6XG4gICAgICAgICAgICBhY2NlbGVyYXRpb24uc2V0KDAsIDAsIG1hZ25pdHVkZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn07XG5cbi8qKlxuICogQXBwbHkgdGhlIGZvcmNlLlxuICpcbiAqIEBtZXRob2QgdXBkYXRlXG4gKi9cbkdyYXZpdHkxRC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRhcmdldHMgPSB0aGlzLnRhcmdldHM7XG5cbiAgICB2YXIgZm9yY2UgPSBGT1JDRV9SRUdJU1RFUjtcblxuICAgIHZhciBtYXggPSB0aGlzLm1heDtcbiAgICB2YXIgYWNjZWxlcmF0aW9uID0gdGhpcy5hY2NlbGVyYXRpb247XG4gICAgdmFyIGEgPSBhY2NlbGVyYXRpb24ubGVuZ3RoKCk7XG4gICAgdmFyIGludkEgPSBhID8gMSAvIGEgOiAwO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0YXJnZXRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSB0YXJnZXRzW2ldO1xuICAgICAgICB2YXIgbWFnbml0dWRlID0gYSAqIHRhcmdldC5tYXNzO1xuICAgICAgICBWZWMzLnNjYWxlKGFjY2VsZXJhdGlvbiwgKG1hZ25pdHVkZSA+IG1heCA/IG1heCA6IG1hZ25pdHVkZSkgKiBpbnZBLCBmb3JjZSk7XG4gICAgICAgIHRhcmdldC5hcHBseUZvcmNlKGZvcmNlKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdyYXZpdHkxRDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEZvcmNlID0gcmVxdWlyZSgnLi9Gb3JjZScpO1xudmFyIFZlYzMgPSByZXF1aXJlKCdmYW1vdXMtbWF0aCcpLlZlYzM7XG5cbnZhciBGT1JDRV9SRUdJU1RFUiA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogQW4gaW52ZXJzZSBzcXVhcmUgZm9yY2UgZGVwZW5kZW50IG9uIHRoZSBtYXNzZXMgb2YgdGhlIHNvdXJjZSBhbmQgdGFyZ2V0cy5cbiAqXG4gKiBAY2xhc3MgR3Jhdml0eTNEXG4gKiBAZXh0ZW5kcyBGb3JjZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gR3Jhdml0eTNEKHNvdXJjZSwgdGFyZ2V0cywgb3B0aW9ucykge1xuICAgIHRoaXMuc291cmNlID0gc291cmNlIHx8IG51bGw7XG4gICAgRm9yY2UuY2FsbCh0aGlzLCB0YXJnZXRzLCBvcHRpb25zKTtcbn1cblxuR3Jhdml0eTNELnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRm9yY2UucHJvdG90eXBlKTtcbkdyYXZpdHkzRC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHcmF2aXR5M0Q7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgRm9yY2UuIFNldHMgZGVmYXVsdHMgaWYgYSBwcm9wZXJ0eSB3YXMgbm90IGFscmVhZHkgc2V0LlxuICpcbiAqIEBtZXRob2QgaW5pdFxuICovXG5HcmF2aXR5M0QucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1heCA9IHRoaXMubWF4IHx8IEluZmluaXR5O1xuICAgIHRoaXMuc3RyZW5ndGggPSB0aGlzLnN0cmVuZ3RoIHx8IDIwMDtcbn07XG5cbi8qKlxuICogQXBwbHkgdGhlIGZvcmNlLlxuICpcbiAqIEBtZXRob2QgdXBkYXRlXG4gKi9cbkdyYXZpdHkzRC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNvdXJjZSA9IHRoaXMuc291cmNlO1xuICAgIHZhciB0YXJnZXRzID0gdGhpcy50YXJnZXRzO1xuXG4gICAgdmFyIGZvcmNlID0gRk9SQ0VfUkVHSVNURVI7XG5cbiAgICB2YXIgc3RyZW5ndGggPSB0aGlzLnN0cmVuZ3RoO1xuICAgIHZhciBtYXggPSB0aGlzLm1heDtcbiAgICB2YXIgYW5jaG9yID0gdGhpcy5hbmNob3IgfHwgc291cmNlLnBvc2l0aW9uO1xuICAgIHZhciBzb3VyY2VNYXNzID0gdGhpcy5hbmNob3IgPyAxIDogc291cmNlLm1hc3M7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRhcmdldHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IHRhcmdldHNbaV07XG4gICAgICAgIFZlYzMuc3VidHJhY3QoYW5jaG9yLCB0YXJnZXQucG9zaXRpb24sIGZvcmNlKTtcbiAgICAgICAgdmFyIGRpc3QgPSBmb3JjZS5sZW5ndGgoKTtcbiAgICAgICAgdmFyIGludkRpc3RhbmNlID0gZGlzdCA/IDEgLyBkaXN0IDogMDtcbiAgICAgICAgdmFyIG1hZ25pdHVkZSA9IHN0cmVuZ3RoICogc291cmNlTWFzcyAqIHRhcmdldC5tYXNzICogaW52RGlzdGFuY2UgKiBpbnZEaXN0YW5jZTtcbiAgICAgICAgaWYgKG1hZ25pdHVkZSA8IDApIHtcbiAgICAgICAgICAgIG1hZ25pdHVkZSA9IG1hZ25pdHVkZSA8IC1tYXggPyAtbWF4IDogbWFnbml0dWRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWFnbml0dWRlID0gbWFnbml0dWRlID4gbWF4ID8gbWF4IDogbWFnbml0dWRlO1xuICAgICAgICB9XG4gICAgICAgIGZvcmNlLnNjYWxlKG1hZ25pdHVkZSAqIGludkRpc3RhbmNlKTtcbiAgICAgICAgdGFyZ2V0LmFwcGx5Rm9yY2UoZm9yY2UpO1xuICAgICAgICBpZiAoc291cmNlKSBzb3VyY2UuYXBwbHlGb3JjZShmb3JjZS5pbnZlcnQoKSk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcmF2aXR5M0Q7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBGb3JjZSA9IHJlcXVpcmUoJy4vRm9yY2UnKTtcbnZhciBWZWMzID0gcmVxdWlyZSgnZmFtb3VzLW1hdGgnKS5WZWMzO1xuXG52YXIgVE9SUVVFX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBBIGJlaGF2aW9yIHRoYXQgc2xvd3MgYW5ndWxhciB2ZWxvY2l0eSBieSBhcHBseWluZyB0b3JxdWUuXG4gKlxuICogQGNsYXNzIFJvdGF0aW9uYWxEcmFnXG4gKiBAZXh0ZW5kcyBGb3JjZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgb3B0aW9ucyB0byBzZXQgb24gZHJhZ1xuICovXG5mdW5jdGlvbiBSb3RhdGlvbmFsRHJhZyh0YXJnZXRzLCBvcHRpb25zKSB7XG4gICAgRm9yY2UuY2FsbCh0aGlzLCB0YXJnZXRzLCBvcHRpb25zKTtcbn1cblxuUm90YXRpb25hbERyYWcucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGb3JjZS5wcm90b3R5cGUpO1xuUm90YXRpb25hbERyYWcucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUm90YXRpb25hbERyYWc7XG5cbi8qKlxuICogVXNlZCB0byBzY2FsZSBhbmd1bGFyIHZlbG9jaXR5IGluIHRoZSBjb21wdXRhdGlvbiBvZiB0aGUgZHJhZyB0b3JxdWUuXG4gKlxuICogQGF0dHJpYnV0ZSBRVUFEUkFUSUNcbiAqIEB0eXBlIEZ1bmN0aW9uXG4gKiBAcGFyYW0ge1ZlYzN9IG9tZWdhXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cblJvdGF0aW9uYWxEcmFnLlFVQURSQVRJQyA9IGZ1bmN0aW9uIFFVQURSQVRJQyhvbWVnYSkge1xuICAgIHJldHVybiBvbWVnYS5sZW5ndGgoKTtcbn07XG5cbi8qKlxuICogVXNlZCB0byBzY2FsZSBhbmd1bGFyIHZlbG9jaXR5IGluIHRoZSBjb21wdXRhdGlvbiBvZiB0aGUgZHJhZyB0b3JxdWUuXG4gKlxuICogQGF0dHJpYnV0ZSBMSU5FQVJcbiAqIEB0eXBlIEZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cblJvdGF0aW9uYWxEcmFnLkxJTkVBUiA9IGZ1bmN0aW9uIExJTkVBUigpIHtcbiAgICByZXR1cm4gMTtcbn07XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgRm9yY2UuIFNldHMgZGVmYXVsdHMgaWYgYSBwcm9wZXJ0eSB3YXMgbm90IGFscmVhZHkgc2V0LlxuICpcbiAqIEBtZXRob2QgaW5pdFxuICovXG5Sb3RhdGlvbmFsRHJhZy5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgdGhpcy5tYXggPSB0aGlzLm1heCB8fCBJbmZpbml0eTtcbiAgICB0aGlzLnN0cmVuZ3RoID0gdGhpcy5zdHJlbmd0aCB8fCAxO1xuICAgIHRoaXMudHlwZSA9IHRoaXMudHlwZSB8fCBSb3RhdGlvbmFsRHJhZy5MSU5FQVI7XG59O1xuXG4vKipcbiAqIEFkZHMgYSByb3RhdGlvbmFsIGRyYWcgZm9yY2UgdG8gYSBwaHlzaWNzIGJvZHkncyB0b3JxdWUgYWNjdW11bGF0b3IuXG4gKlxuICogQG1ldGhvZCB1cGRhdGVcbiAqL1xuUm90YXRpb25hbERyYWcucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICB2YXIgdGFyZ2V0cyA9IHRoaXMudGFyZ2V0cztcbiAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuICAgIHZhciB0b3JxdWUgPSBUT1JRVUVfUkVHSVNURVI7XG5cbiAgICB2YXIgbWF4ID0gdGhpcy5tYXg7XG4gICAgdmFyIHN0cmVuZ3RoID0gdGhpcy5zdHJlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGFyZ2V0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gdGFyZ2V0c1tpXTtcbiAgICAgICAgdmFyIG9tZWdhID0gdGFyZ2V0LmFuZ3VsYXJWZWxvY2l0eTtcbiAgICAgICAgdmFyIG1hZ25pdHVkZSA9IC1zdHJlbmd0aCAqIHR5cGUob21lZ2EpO1xuICAgICAgICBWZWMzLnNjYWxlKG9tZWdhLCBtYWduaXR1ZGUgPCAtbWF4ID8gLW1heCA6IG1hZ25pdHVkZSwgdG9ycXVlKTtcbiAgICAgICAgdGFyZ2V0LmFwcGx5VG9ycXVlKHRvcnF1ZSk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGlvbmFsRHJhZztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEZvcmNlID0gcmVxdWlyZSgnLi9Gb3JjZScpO1xudmFyIFF1YXRlcm5pb24gPSByZXF1aXJlKCdmYW1vdXMtbWF0aCcpLlF1YXRlcm5pb247XG52YXIgVmVjMyA9IHJlcXVpcmUoJ2ZhbW91cy1tYXRoJykuVmVjMztcbnZhciBNYXQzMyA9IHJlcXVpcmUoJ2ZhbW91cy1tYXRoJykuTWF0MzM7XG5cbnZhciBRX1JFR0lTVEVSID0gbmV3IFF1YXRlcm5pb24oKTtcbnZhciBEQU1QSU5HX1JFR0lTVEVSID0gbmV3IFZlYzMoKTtcbnZhciBYWVpfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIE1BVF9SRUdJU1RFUiA9IG5ldyBNYXQzMygpO1xuXG4vKiogQGNvbnN0IFBJICovXG52YXIgUEkgPSBNYXRoLlBJO1xuXG4vKipcbiAqIEEgc3ByaW5nLWxpa2UgYmVoYXZpb3IgdGhhdCBhdHRlbXB0cyB0byBlbmZvcmNlIGEgc3BlY2ZpYyBvcmllbnRhdGlvbiBieSBhcHBseWluZyB0b3JxdWUuXG4gKlxuICogQGNsYXNzIFJvdGF0aW9uYWxTcHJpbmdcbiAqIEBleHRlbmRzIEZvcmNlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBSb3RhdGlvbmFsU3ByaW5nKHNvdXJjZSwgdGFyZ2V0cywgb3B0aW9ucykge1xuICAgIHRoaXMuc291cmNlID0gc291cmNlIHx8IG51bGw7XG4gICAgRm9yY2UuY2FsbCh0aGlzLCB0YXJnZXRzLCBvcHRpb25zKTtcbn1cblxuUm90YXRpb25hbFNwcmluZy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEZvcmNlLnByb3RvdHlwZSk7XG5Sb3RhdGlvbmFsU3ByaW5nLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJvdGF0aW9uYWxTcHJpbmc7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgRm9yY2UuIFNldHMgZGVmYXVsdHMgaWYgYSBwcm9wZXJ0eSB3YXMgbm90IGFscmVhZHkgc2V0LlxuICpcbiAqIEBtZXRob2QgaW5pdFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgaGFzaC5cbiAqL1xuUm90YXRpb25hbFNwcmluZy5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIGluaXQob3B0aW9ucykge1xuICAgIGlmICghdGhpcy5zb3VyY2UpIHRoaXMuYW5jaG9yID0gdGhpcy5hbmNob3IgPyB0aGlzLmFuY2hvci5ub3JtYWxpemUoKSA6IG5ldyBRdWF0ZXJuaW9uKDEsMCwwLDApO1xuICAgIGlmIChvcHRpb25zLnN0aWZmbmVzcyB8fCBvcHRpb25zLmRhbXBpbmcpIHtcbiAgICAgICAgdGhpcy5zdGlmZm5lc3MgPSB0aGlzLnN0aWZmbmVzcyB8fCAxMDA7XG4gICAgICAgIHRoaXMuZGFtcGluZyA9IHRoaXMuZGFtcGluZyB8fCAwO1xuICAgICAgICB0aGlzLnBlcmlvZCA9IG51bGw7XG4gICAgICAgIHRoaXMuZGFtcGluZ1JhdGlvID0gbnVsbDtcbiAgICB9XG4gICAgZWxzZSBpZiAob3B0aW9ucy5wZXJpb2QgfHwgb3B0aW9ucy5kYW1waW5nUmF0aW8pIHtcbiAgICAgICAgdGhpcy5wZXJpb2QgPSB0aGlzLnBlcmlvZCB8fCAxO1xuICAgICAgICB0aGlzLmRhbXBpbmdSYXRpbyA9IHRoaXMuZGFtcGluZ1JhdGlvIHx8IDA7XG5cbiAgICAgICAgdGhpcy5zdGlmZm5lc3MgPSAyICogUEkgLyB0aGlzLnBlcmlvZDtcbiAgICAgICAgdGhpcy5zdGlmZm5lc3MgKj0gdGhpcy5zdGlmZm5lc3M7XG4gICAgICAgIHRoaXMuZGFtcGluZyA9IDQgKiBQSSAqIHRoaXMuZGFtcGluZ1JhdGlvIC8gdGhpcy5wZXJpb2Q7XG4gICAgfVxufTtcblxuLyoqXG4gKiBBZGRzIGEgdG9ycXVlIGZvcmNlIHRvIGEgcGh5c2ljcyBib2R5J3MgdG9ycXVlIGFjY3VtdWxhdG9yLlxuICpcbiAqIEBtZXRob2QgdXBkYXRlXG4gKi9cblJvdGF0aW9uYWxTcHJpbmcucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICB2YXIgc291cmNlID0gdGhpcy5zb3VyY2U7XG4gICAgdmFyIHRhcmdldHMgPSB0aGlzLnRhcmdldHM7XG5cbiAgICB2YXIgZGVsdGFRID0gUV9SRUdJU1RFUjtcbiAgICB2YXIgZGFtcGluZ1RvcnF1ZSA9IERBTVBJTkdfUkVHSVNURVI7XG4gICAgdmFyIFhZWiA9IFhZWl9SRUdJU1RFUjtcbiAgICB2YXIgZWZmSW5lcnRpYSA9IE1BVF9SRUdJU1RFUjtcblxuICAgIHZhciBtYXggPSB0aGlzLm1heDtcbiAgICB2YXIgc3RpZmZuZXNzID0gdGhpcy5zdGlmZm5lc3M7XG4gICAgdmFyIGRhbXBpbmcgPSB0aGlzLmRhbXBpbmc7XG4gICAgdmFyIGFuY2hvciA9IHRoaXMuYW5jaG9yIHx8IHNvdXJjZS5vcmllbnRhdGlvbjtcbiAgICB2YXIgaW52U291cmNlSW5lcnRpYSA9IHRoaXMuYW5jaG9yID8gbnVsbCA6IHNvdXJjZS5pbnZlcnNlSW5lcnRpYTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGFyZ2V0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gdGFyZ2V0c1tpXTtcbiAgICAgICAgdmFyIHEgPSB0YXJnZXQub3JpZW50YXRpb247XG4gICAgICAgIFF1YXRlcm5pb24uY29uanVnYXRlKHEsIGRlbHRhUSk7XG4gICAgICAgIGRlbHRhUS5tdWx0aXBseShhbmNob3IpO1xuXG4gICAgICAgIGlmIChkZWx0YVEudyA+PSAxKSBjb250aW51ZTtcbiAgICAgICAgdmFyIGhhbGZ0aGV0YSA9IE1hdGguYWNvcyhkZWx0YVEudyk7XG4gICAgICAgIHZhciBsZW5ndGggPSBNYXRoLnNxcnQoMSAtIGRlbHRhUS53ICogZGVsdGFRLncpO1xuXG4gICAgICAgIHZhciBkZWx0YU9tZWdhID0gWFlaLmNvcHkoZGVsdGFRKS5zY2FsZSgyICogaGFsZnRoZXRhIC8gbGVuZ3RoKTtcblxuICAgICAgICBkZWx0YU9tZWdhLnNjYWxlKHN0aWZmbmVzcyk7XG5cbiAgICAgICAgaWYgKGludlNvdXJjZUluZXJ0aWEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIE1hdDMzLmFkZChpbnZTb3VyY2VJbmVydGlhLCB0YXJnZXQuaW52ZXJzZUluZXJ0aWEsIGVmZkluZXJ0aWEpLmludmVyc2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIE1hdDMzLmludmVyc2UodGFyZ2V0LmludmVyc2VJbmVydGlhLCBlZmZJbmVydGlhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYW1waW5nICE9PSAwKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICAgICAgZGVsdGFPbWVnYS5hZGQoVmVjMy5zdWJ0cmFjdCh0YXJnZXQuYW5ndWxhclZlbG9jaXR5LCBzb3VyY2UuYW5ndWxhclZlbG9jaXR5LCBkYW1waW5nVG9ycXVlKS5zY2FsZSgtZGFtcGluZykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsdGFPbWVnYS5hZGQoVmVjMy5zY2FsZSh0YXJnZXQuYW5ndWxhclZlbG9jaXR5LCAtZGFtcGluZywgZGFtcGluZ1RvcnF1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRvcnF1ZSA9IGRlbHRhT21lZ2EuYXBwbHlNYXRyaXgoZWZmSW5lcnRpYSk7XG4gICAgICAgIHZhciBtYWduaXR1ZGUgPSB0b3JxdWUubGVuZ3RoKCk7XG5cbiAgICAgICAgaWYgKG1hZ25pdHVkZSA+IG1heCkgdG9ycXVlLnNjYWxlKG1heC9tYWduaXR1ZGUpO1xuXG4gICAgICAgIHRhcmdldC5hcHBseVRvcnF1ZSh0b3JxdWUpO1xuICAgICAgICBpZiAoc291cmNlKSBzb3VyY2UuYXBwbHlUb3JxdWUodG9ycXVlLmludmVydCgpKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJvdGF0aW9uYWxTcHJpbmc7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBGb3JjZSA9IHJlcXVpcmUoJy4vRm9yY2UnKTtcbnZhciBWZWMzID0gcmVxdWlyZSgnZmFtb3VzLW1hdGgnKS5WZWMzO1xuXG52YXIgRk9SQ0VfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xudmFyIERBTVBJTkdfUkVHSVNURVIgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIEEgZm9yY2UgdGhhdCBhY2NlbGVyYXRlcyBhIFBhcnRpY2xlIHRvd2FyZHMgYSBzcGVjaWZpYyBhbmNob3IgcG9pbnQuIENhbiBiZSBhbmNob3JlZCB0b1xuICogYSBWZWMzIG9yIGFub3RoZXIgc291cmNlIFBhcnRpY2xlLlxuICpcbiAqICBAY2xhc3MgU3ByaW5nXG4gKiAgQGV4dGVuZHMgRm9yY2VcbiAqICBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBvcHRpb25zIHRvIHNldCBvbiBkcmFnXG4gKi9cbmZ1bmN0aW9uIFNwcmluZyhzb3VyY2UsIHRhcmdldHMsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZSB8fCBudWxsO1xuICAgIEZvcmNlLmNhbGwodGhpcywgdGFyZ2V0cywgb3B0aW9ucyk7XG59XG5cblNwcmluZy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEZvcmNlLnByb3RvdHlwZSk7XG5TcHJpbmcucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ByaW5nO1xuXG4vKiogQGNvbnN0ICovXG52YXIgUEkgPSBNYXRoLlBJO1xuXG4vKipcbiAqIEEgRkVORSAoRmluaXRlbHkgRXh0ZW5zaWJsZSBOb25saW5lYXIgRWxhc3RpYykgc3ByaW5nIGZvcmNlXG4gKiAgICAgIHNlZTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GRU5FXG4gKiBAYXR0cmlidXRlIEZFTkVcbiAqIEB0eXBlIEZ1bmN0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gZGlzdCBjdXJyZW50IGRpc3RhbmNlIHRhcmdldCBpcyBmcm9tIHNvdXJjZSBib2R5XG4gKiBAcGFyYW0ge051bWJlcn0gck1heCBtYXhpbXVtIHJhbmdlIG9mIGluZmx1ZW5jZVxuICogQHJldHVybiB7TnVtYmVyfSB1bnNjYWxlZCBmb3JjZVxuICovXG5TcHJpbmcuRkVORSA9IGZ1bmN0aW9uKGRpc3QsIHJNYXgpIHtcbiAgICB2YXIgck1heFNtYWxsID0gck1heCAqIDAuOTk7XG4gICAgdmFyIHIgPSBNYXRoLm1heChNYXRoLm1pbihkaXN0LCByTWF4U21hbGwpLCAtck1heFNtYWxsKTtcbiAgICByZXR1cm4gciAvICgxIC0gciAqIHIvKHJNYXggKiByTWF4KSk7XG59O1xuXG4vKipcbiAqIEEgSG9va2VhbiBzcHJpbmcgZm9yY2UsIGxpbmVhciBpbiB0aGUgZGlzcGxhY2VtZW50XG4gKiAgICAgIHNlZTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ib29rZSdzX2xhd1xuICogQGF0dHJpYnV0ZSBIT09LRVxuICogQHR5cGUgRnVuY3Rpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBkaXN0IGN1cnJlbnQgZGlzdGFuY2UgdGFyZ2V0IGlzIGZyb20gc291cmNlIGJvZHlcbiAqIEByZXR1cm4ge051bWJlcn0gdW5zY2FsZWQgZm9yY2VcbiAqL1xuU3ByaW5nLkhPT0tFID0gZnVuY3Rpb24oZGlzdCkge1xuICAgIHJldHVybiBkaXN0O1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXplIHRoZSBGb3JjZS4gU2V0cyBkZWZhdWx0cyBpZiBhIHByb3BlcnR5IHdhcyBub3QgYWxyZWFkeSBzZXQuXG4gKlxuICogQG1ldGhvZCBpbml0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBoYXNoLlxuICovXG5TcHJpbmcucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5tYXggPSB0aGlzLm1heCB8fCBJbmZpbml0eTtcbiAgICB0aGlzLmxlbmd0aCA9IHRoaXMubGVuZ3RoIHx8IDA7XG4gICAgdGhpcy50eXBlID0gdGhpcy50eXBlIHx8IFNwcmluZy5IT09LRTtcbiAgICB0aGlzLm1heExlbmd0aCA9IHRoaXMubWF4TGVuZ3RoIHx8IEluZmluaXR5O1xuICAgIGlmIChvcHRpb25zLnN0aWZmbmVzcyB8fCBvcHRpb25zLmRhbXBpbmcpIHtcbiAgICAgICAgdGhpcy5zdGlmZm5lc3MgPSB0aGlzLnN0aWZmbmVzcyB8fCAxMDA7XG4gICAgICAgIHRoaXMuZGFtcGluZyA9IHRoaXMuZGFtcGluZyB8fCAwO1xuICAgICAgICB0aGlzLnBlcmlvZCA9IG51bGw7XG4gICAgICAgIHRoaXMuZGFtcGluZ1JhdGlvID0gbnVsbDtcbiAgICB9XG4gICAgZWxzZSBpZiAob3B0aW9ucy5wZXJpb2QgfHwgb3B0aW9ucy5kYW1waW5nUmF0aW8pIHtcbiAgICAgICAgdGhpcy5wZXJpb2QgPSB0aGlzLnBlcmlvZCB8fCAxO1xuICAgICAgICB0aGlzLmRhbXBpbmdSYXRpbyA9IHRoaXMuZGFtcGluZ1JhdGlvIHx8IDA7XG5cbiAgICAgICAgdGhpcy5zdGlmZm5lc3MgPSAyICogUEkgLyB0aGlzLnBlcmlvZDtcbiAgICAgICAgdGhpcy5zdGlmZm5lc3MgKj0gdGhpcy5zdGlmZm5lc3M7XG4gICAgICAgIHRoaXMuZGFtcGluZyA9IDQgKiBQSSAqIHRoaXMuZGFtcGluZ1JhdGlvIC8gdGhpcy5wZXJpb2Q7XG4gICAgfVxufTtcblxuLyoqXG4gKiBBcHBseSB0aGUgZm9yY2UuXG4gKlxuICogQG1ldGhvZCB1cGRhdGVcbiAqL1xuU3ByaW5nLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc291cmNlID0gdGhpcy5zb3VyY2U7XG4gICAgdmFyIHRhcmdldHMgPSB0aGlzLnRhcmdldHM7XG5cbiAgICB2YXIgZm9yY2UgPSBGT1JDRV9SRUdJU1RFUjtcbiAgICB2YXIgZGFtcGluZ0ZvcmNlID0gREFNUElOR19SRUdJU1RFUjtcblxuICAgIHZhciBtYXggPSB0aGlzLm1heDtcbiAgICB2YXIgc3RpZmZuZXNzID0gdGhpcy5zdGlmZm5lc3M7XG4gICAgdmFyIGRhbXBpbmcgPSB0aGlzLmRhbXBpbmc7XG4gICAgdmFyIHJlc3RMZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICB2YXIgbWF4TGVuZ3RoID0gdGhpcy5tYXhMZW5ndGg7XG4gICAgdmFyIGFuY2hvciA9IHRoaXMuYW5jaG9yIHx8IHNvdXJjZS5wb3NpdGlvbjtcbiAgICB2YXIgaW52U291cmNlTWFzcyA9IHRoaXMuYW5jaG9yID8gMCA6IHNvdXJjZS5pbnZlcnNlTWFzcztcbiAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0YXJnZXRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSB0YXJnZXRzW2ldO1xuICAgICAgICBWZWMzLnN1YnRyYWN0KGFuY2hvciwgdGFyZ2V0LnBvc2l0aW9uLCBmb3JjZSk7XG4gICAgICAgIHZhciBkaXN0ID0gZm9yY2UubGVuZ3RoKCk7XG4gICAgICAgIHZhciBzdHJldGNoID0gZGlzdCAtIHJlc3RMZW5ndGg7XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKHN0cmV0Y2gpIDwgMWUtNikgY29udGludWU7XG5cbiAgICAgICAgdmFyIGVmZk1hc3MgPSAxIC8gKHRhcmdldC5pbnZlcnNlTWFzcyArIGludlNvdXJjZU1hc3MpO1xuICAgICAgICBpZiAodGhpcy5wZXJpb2QgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0aWZmbmVzcyAqPSBlZmZNYXNzO1xuICAgICAgICAgICAgZGFtcGluZyAqPSBlZmZNYXNzO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yY2Uuc2NhbGUoc3RpZmZuZXNzICogdHlwZShzdHJldGNoLCBtYXhMZW5ndGgpIC8gc3RyZXRjaCk7XG5cbiAgICAgICAgaWYgKGRhbXBpbmcgIT09IDApIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBmb3JjZS5hZGQoVmVjMy5zdWJ0cmFjdCh0YXJnZXQudmVsb2NpdHksIHNvdXJjZS52ZWxvY2l0eSwgZGFtcGluZ0ZvcmNlKS5zY2FsZSgtZGFtcGluZykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yY2UuYWRkKFZlYzMuc2NhbGUodGFyZ2V0LnZlbG9jaXR5LCAtZGFtcGluZywgZGFtcGluZ0ZvcmNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWFnbml0dWRlID0gZm9yY2UubGVuZ3RoKCk7XG4gICAgICAgIHZhciBpbnZNYWcgPSBtYWduaXR1ZGUgPyAxIC8gbWFnbml0dWRlIDogMDtcblxuICAgICAgICBWZWMzLnNjYWxlKGZvcmNlLCAobWFnbml0dWRlID4gbWF4ID8gbWF4IDogbWFnbml0dWRlKSAqIGludk1hZywgZm9yY2UpO1xuXG4gICAgICAgIHRhcmdldC5hcHBseUZvcmNlKGZvcmNlKTtcbiAgICAgICAgaWYgKHNvdXJjZSkgc291cmNlLmFwcGx5Rm9yY2UoZm9yY2UuaW52ZXJ0KCkpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU3ByaW5nO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBQYXJ0aWNsZTogcmVxdWlyZSgnLi9ib2RpZXMvUGFydGljbGUnKSxcbiAgICBDb252ZXhCb2R5RmFjdG9yeTogcmVxdWlyZSgnLi9ib2RpZXMvQ29udmV4Qm9keUZhY3RvcnknKSxcbiAgICBCb3g6IHJlcXVpcmUoJy4vYm9kaWVzL0JveCcpLFxuICAgIFNwaGVyZTogcmVxdWlyZSgnLi9ib2RpZXMvU3BoZXJlJyksXG4gICAgV2FsbDogcmVxdWlyZSgnLi9ib2RpZXMvV2FsbCcpLFxuXG4gICAgQ29uc3RyYWludDogcmVxdWlyZSgnLi9jb25zdHJhaW50cy9Db25zdHJhaW50JyksXG4gICAgQW5nbGU6IHJlcXVpcmUoJy4vY29uc3RyYWludHMvQW5nbGUnKSxcbiAgICBDb2xsaXNpb246IHJlcXVpcmUoJy4vY29uc3RyYWludHMvQ29sbGlzaW9uJyksXG4gICAgRGlyZWN0aW9uOiByZXF1aXJlKCcuL2NvbnN0cmFpbnRzL0RpcmVjdGlvbicpLFxuICAgIERpc3RhbmNlOiByZXF1aXJlKCcuL2NvbnN0cmFpbnRzL0Rpc3RhbmNlJyksXG4gICAgQ3VydmU6IHJlcXVpcmUoJy4vY29uc3RyYWludHMvQ3VydmUnKSxcbiAgICBIaW5nZTogcmVxdWlyZSgnLi9jb25zdHJhaW50cy9IaW5nZScpLFxuICAgIFBvaW50MlBvaW50OiByZXF1aXJlKCcuL2NvbnN0cmFpbnRzL1BvaW50MlBvaW50JyksXG5cbiAgICBGb3JjZTogcmVxdWlyZSgnLi9mb3JjZXMvRm9yY2UnKSxcbiAgICBEcmFnOiByZXF1aXJlKCcuL2ZvcmNlcy9EcmFnJyksXG4gICAgUm90YXRpb25hbERyYWc6IHJlcXVpcmUoJy4vZm9yY2VzL1JvdGF0aW9uYWxEcmFnJyksXG4gICAgR3Jhdml0eTFEOiByZXF1aXJlKCcuL2ZvcmNlcy9HcmF2aXR5MUQnKSxcbiAgICBHcmF2aXR5M0Q6IHJlcXVpcmUoJy4vZm9yY2VzL0dyYXZpdHkzRCcpLFxuICAgIFNwcmluZzogcmVxdWlyZSgnLi9mb3JjZXMvU3ByaW5nJyksXG4gICAgUm90YXRpb25hbFNwcmluZzogcmVxdWlyZSgnLi9mb3JjZXMvUm90YXRpb25hbFNwcmluZycpLFxuXG4gICAgUGh5c2ljc0VuZ2luZTogcmVxdWlyZSgnLi9QaHlzaWNzRW5naW5lJyksXG4gICAgR2VvbWV0cnk6IHJlcXVpcmUoJy4vR2VvbWV0cnknKVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyk7XG52YXIgU2l6ZSA9IHJlcXVpcmUoJy4vU2l6ZScpO1xuXG52YXIgVFJBTlNGT1JNX1BST0NFU1NPUiA9IG5ldyBUcmFuc2Zvcm0oKTtcbnZhciBTSVpFX1BST0NFU1NPUiA9IG5ldyBTaXplKCk7XG5cbnZhciBJREVOVCA9IFtcbiAgICAxLCAwLCAwLCAwLFxuICAgIDAsIDEsIDAsIDAsXG4gICAgMCwgMCwgMSwgMCxcbiAgICAwLCAwLCAwLCAxXG5dO1xuXG52YXIgT05FUyA9IFsxLCAxLCAxXTtcbnZhciBRVUFUID0gWzAsIDAsIDAsIDFdO1xuXG4vKipcbiAqIE5vZGVzIGRlZmluZSBoaWVyYXJjaHkgYW5kIGdlb21ldHJpY2FsIHRyYW5zZm9ybWF0aW9ucy4gVGhleSBjYW4gYmUgbW92ZWRcbiAqICh0cmFuc2xhdGVkKSwgc2NhbGVkIGFuZCByb3RhdGVkLlxuICogXG4gKiBBIE5vZGUgaXMgZWl0aGVyIG1vdW50ZWQgb3IgdW5tb3VudGVkLiBVbm1vdW50ZWQgbm9kZXMgYXJlIGRldGFjaGVkIGZyb20gdGhlXG4gKiBzY2VuZSBncmFwaC4gVW5tb3VudGVkIG5vZGVzIGhhdmUgbm8gcGFyZW50IG5vZGUsIHdoaWxlIGVhY2ggbW91bnRlZCBub2RlIGhhc1xuICogZXhhY3RseSBvbmUgcGFyZW50LiBOb2RlcyBoYXZlIGFuIGFyYml0YXJ5IG51bWJlciBvZiBjaGlsZHJlbiwgd2hpY2ggY2FuIGJlXG4gKiBkeW5hbWljYWxseSBhZGRlZCB1c2luZyBAe0BsaW5rIGFkZENoaWxkfS5cbiAqXG4gKiBFYWNoIE5vZGVzIGhhdmUgYW4gYXJiaXRyYXJ5IG51bWJlciBvZiBgY29tcG9uZW50c2AuIFRob3NlIGNvbXBvbmVudHMgY2FuXG4gKiBzZW5kIGBkcmF3YCBjb21tYW5kcyB0byB0aGUgcmVuZGVyZXIgb3IgbXV0YXRlIHRoZSBub2RlIGl0c2VsZiwgaW4gd2hpY2ggY2FzZVxuICogdGhleSBkZWZpbmUgYmVoYXZpb3IgaW4gdGhlIG1vc3QgZXhwbGljaXQgd2F5LiBDb21wb25lbnRzIHRoYXQgc2VuZCBgZHJhd2BcbiAqIGNvbW1hbmRzIGFhcmUgY29uc2lkZXJlZCBgcmVuZGVyYWJsZXNgLiBGcm9tIHRoZSBub2RlJ3MgcGVyc3BlY3RpdmUsIHRoZXJlIGlzXG4gKiBubyBkaXN0aW5jdGlvbiBiZXR3ZWVuIG5vZGVzIHRoYXQgc2VuZCBkcmF3IGNvbW1hbmRzIGFuZCBub2RlcyB0aGF0IGRlZmluZVxuICogYmVoYXZpb3IuXG4gKlxuICogQmVjYXVzZSBvZiB0aGUgZmFjdCB0aGF0IE5vZGVzIHRoZW1zZWxmIGFyZSB2ZXJ5IHVub3BpbmlvdGVkICh0aGV5IGRvbid0XG4gKiBcInJlbmRlclwiIHRvIGFueXRoaW5nKSwgdGhleSBhcmUgb2Z0ZW4gYmVpbmcgc3ViY2xhc3NlZCBpbiBvcmRlciB0byBhZGQgZS5nLlxuICogY29tcG9uZW50cyBhdCBpbml0aWFsaXphdGlvbiB0byB0aGVtLiBCZWNhdXNlIG9mIHRoaXMgZmxleGliaWxpdHksIHRoZXkgbWlnaHRcbiAqIGFzIHdlbGwgaGF2ZSBiZWVuIGNhbGxlZCBgRW50aXRpZXNgLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBjcmVhdGUgdGhyZWUgZGV0YWNoZWQgKHVubW91bnRlZCkgbm9kZXNcbiAqIHZhciBwYXJlbnQgPSBuZXcgTm9kZSgpO1xuICogdmFyIGNoaWxkMSA9IG5ldyBOb2RlKCk7XG4gKiB2YXIgY2hpbGQyID0gbmV3IE5vZGUoKTtcbiAqXG4gKiAvLyBidWlsZCBhbiB1bm1vdW50ZWQgc3VidHJlZSAocGFyZW50IGlzIHN0aWxsIGRldGFjaGVkKVxuICogcGFyZW50LmFkZENoaWxkKGNoaWxkMSk7XG4gKiBwYXJlbnQuYWRkQ2hpbGQoY2hpbGQyKTtcbiAqXG4gKiAvLyBtb3VudCBwYXJlbnQgYnkgYWRkaW5nIGl0IHRvIHRoZSBjb250ZXh0XG4gKiB2YXIgY29udGV4dCA9IEZhbW91cy5jcmVhdGVDb250ZXh0KFwiYm9keVwiKTtcbiAqIGNvbnRleHQuYWRkQ2hpbGQocGFyZW50KTtcbiAqXG4gKiBAY2xhc3MgTm9kZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE5vZGUgKCkge1xuICAgIHRoaXMuX2NhbGN1bGF0ZWRWYWx1ZXMgPSB7XG4gICAgICAgIHRyYW5zZm9ybTogbmV3IEZsb2F0MzJBcnJheShJREVOVCksXG4gICAgICAgIHNpemU6IG5ldyBGbG9hdDMyQXJyYXkoMylcbiAgICB9O1xuXG4gICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX2luVXBkYXRlID0gZmFsc2U7XG5cbiAgICB0aGlzLl91cGRhdGVRdWV1ZSA9IFtdO1xuICAgIHRoaXMuX25leHRVcGRhdGVRdWV1ZSA9IFtdO1xuXG4gICAgdGhpcy5fZnJlZWRDb21wb25lbnRJbmRpY2llcyA9IFtdO1xuICAgIHRoaXMuX2NvbXBvbmVudHMgPSBbXTtcblxuICAgIHRoaXMuX2ZyZWVkQ2hpbGRJbmRpY2llcyA9IFtdO1xuICAgIHRoaXMuX2NoaWxkcmVuID0gW107XG5cbiAgICB0aGlzLl9wYXJlbnQgPSBudWxsO1xuICAgIHRoaXMuX2dsb2JhbFVwZGF0ZXIgPSBudWxsO1xuXG4gICAgdGhpcy52YWx1ZSA9IG5ldyBOb2RlLlNwZWMoKTtcbn1cblxuTm9kZS5SRUxBVElWRV9TSVpFID0gU2l6ZS5SRUxBVElWRTtcbk5vZGUuQUJTT0xVVEVfU0laRSA9IFNpemUuQUJTT0xVVEU7XG5Ob2RlLlJFTkRFUl9TSVpFID0gU2l6ZS5SRU5ERVI7XG5Ob2RlLkRFRkFVTFRfU0laRSA9IFNpemUuREVGQVVMVDtcblxuLyoqXG4gKiBBIE5vZGUgc3BlYyBob2xkcyB0aGUgXCJkYXRhXCIgYXNzb2NpYXRlZCB3aXRoIGEgTm9kZS5cbiAqXG4gKiBAcHJvcGVydHkge1N0cmluZ30gbG9jYXRpb24gcGF0aCB0byB0aGUgbm9kZSAoZS5nLiBcImJvZHkvMC8xXCIpXG4gKiBAcHJvcGVydHkge09iamVjdH0gc2hvd1N0YXRlXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IHNob3dTdGF0ZS5tb3VudGVkXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IHNob3dTdGF0ZS5zaG93blxuICogQHByb3BlcnR5IHtOdW1iZXJ9IHNob3dTdGF0ZS5vcGFjaXR5XG4gKiBAcHJvcGVydHkge09iamVjdH0gb2Zmc2V0c1xuICogQHByb3BlcnR5IHtGbG9hdDMyQXJyYXkuPE51bWJlcj59IG9mZnNldHMubW91bnRQb2ludFxuICogQHByb3BlcnR5IHtGbG9hdDMyQXJyYXkuPE51bWJlcj59IG9mZnNldHMuYWxpZ25cbiAqIEBwcm9wZXJ0eSB7RmxvYXQzMkFycmF5LjxOdW1iZXI+fSBvZmZzZXRzLm9yaWdpblxuICogQHByb3BlcnR5IHtPYmplY3R9IHZlY3RvcnNcbiAqIEBwcm9wZXJ0eSB7RmxvYXQzMkFycmF5LjxOdW1iZXI+fSB2ZWN0b3JzLnBvc2l0aW9uXG4gKiBAcHJvcGVydHkge0Zsb2F0MzJBcnJheS48TnVtYmVyPn0gdmVjdG9ycy5yb3RhdGlvblxuICogQHByb3BlcnR5IHtGbG9hdDMyQXJyYXkuPE51bWJlcj59IHZlY3RvcnMuc2NhbGVcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBzaXplXG4gKiBAcHJvcGVydHkge0Zsb2F0MzJBcnJheS48TnVtYmVyPn0gc2l6ZS5zaXplTW9kZVxuICogQHByb3BlcnR5IHtGbG9hdDMyQXJyYXkuPE51bWJlcj59IHNpemUucHJvcG9ydGlvbmFsXG4gKiBAcHJvcGVydHkge0Zsb2F0MzJBcnJheS48TnVtYmVyPn0gc2l6ZS5kaWZmZXJlbnRpYWxcbiAqIEBwcm9wZXJ0eSB7RmxvYXQzMkFycmF5LjxOdW1iZXI+fSBzaXplLmFic29sdXRlXG4gKiBAcHJvcGVydHkge0Zsb2F0MzJBcnJheS48TnVtYmVyPn0gc2l6ZS5yZW5kZXJcbiAqL1xuTm9kZS5TcGVjID0gZnVuY3Rpb24gU3BlYyAoKSB7XG4gICAgdGhpcy5sb2NhdGlvbiA9IG51bGw7XG4gICAgdGhpcy5zaG93U3RhdGUgPSB7XG4gICAgICAgIG1vdW50ZWQ6IGZhbHNlLFxuICAgICAgICBzaG93bjogZmFsc2UsXG4gICAgICAgIG9wYWNpdHk6IDFcbiAgICB9O1xuICAgIHRoaXMub2Zmc2V0cyA9IHtcbiAgICAgICAgbW91bnRQb2ludDogbmV3IEZsb2F0MzJBcnJheSgzKSxcbiAgICAgICAgYWxpZ246IG5ldyBGbG9hdDMyQXJyYXkoMyksXG4gICAgICAgIG9yaWdpbjogbmV3IEZsb2F0MzJBcnJheSgzKVxuICAgIH07XG4gICAgdGhpcy52ZWN0b3JzID0ge1xuICAgICAgICBwb3NpdGlvbjogbmV3IEZsb2F0MzJBcnJheSgzKSxcbiAgICAgICAgcm90YXRpb246IG5ldyBGbG9hdDMyQXJyYXkoUVVBVCksXG4gICAgICAgIHNjYWxlOiBuZXcgRmxvYXQzMkFycmF5KE9ORVMpXG4gICAgfTtcbiAgICB0aGlzLnNpemUgPSB7XG4gICAgICAgIHNpemVNb2RlOiBuZXcgRmxvYXQzMkFycmF5KFtTaXplLlJFTEFUSVZFLCBTaXplLlJFTEFUSVZFLCBTaXplLlJFTEFUSVZFXSksXG4gICAgICAgIHByb3BvcnRpb25hbDogbmV3IEZsb2F0MzJBcnJheShPTkVTKSxcbiAgICAgICAgZGlmZmVyZW50aWFsOiBuZXcgRmxvYXQzMkFycmF5KDMpLFxuICAgICAgICBhYnNvbHV0ZTogbmV3IEZsb2F0MzJBcnJheSgzKSxcbiAgICAgICAgcmVuZGVyOiBuZXcgRmxvYXQzMkFycmF5KDMpXG4gICAgfTtcbiAgICB0aGlzLlVJRXZlbnRzID0gW107XG59O1xuXG4vKipcbiAqIEBtZXRob2QgZ2V0Q29udGV4dFxuICogQGNoYWluYWJsZVxuICpcbiAqIEBkZXByZWNhdGVkIE5vZGUgY2FuIGJlIHVzZWQgZGlyZWN0bHkgaW5zdGVhZCFcbiAqIEByZXR1cm4ge05vZGV9IHRoaXNcbiAqL1xuTm9kZS5wcm90b3R5cGUuZ2V0Q29udGV4dCA9IGZ1bmN0aW9uIGdldENvbnRleHQgKCkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ05vZGUjZ2V0Q29udGV4dCBpcyBkZXByZWNhdGVkIVxcbicgK1xuICAgICAgICAnTm9kZXMgY2FuIGJlIHVzZWQgZGlyZWN0bHkhJ1xuICAgICk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgZ2V0RGlzcGF0Y2hcbiAqIEBjaGFpbmFibGVcbiAqXG4gKiBAZGVwcmVjYXRlZCBOb2RlIGNhbiBiZSB1c2VkIGRpcmVjdGx5IGluc3RlYWQhXG4gKiBAcmV0dXJuIHtOb2RlfSB0aGlzXG4gKi9cbk5vZGUucHJvdG90eXBlLmdldERpc3BhdGNoID0gZnVuY3Rpb24gZ2V0RGlzcGF0Y2ggKCkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ05vZGUjZ2V0RGlzcGF0Y2ggaXMgZGVwcmVjYXRlZCFcXG4nICtcbiAgICAgICAgJ0NvbXBvbmVudCBjb25zdHJ1Y3RvcnMgYWNjZXB0IGEgTm9kZSBpbnN0ZWFkIScgK1xuICAgICAgICAnVXNlIG5ldyBDb21wb25lbnQobm9kZSkgaW5zdGVhZCBvZiBuZXcgQ29tcG9uZW50KG5vZGUuZ2V0RGlzcGF0Y2goKSkhJ1xuICAgICk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgZ2V0UmVuZGVyUHJveHlcbiAqIEBjaGFpbmFibGVcbiAqXG4gKiBAZGVwcmVjYXRlZCBOb2RlIGNhbiBiZSB1c2VkIGRpcmVjdGx5IGluc3RlYWQhXG4gKiBAcmV0dXJuIHtOb2RlfSB0aGlzXG4gKi9cbk5vZGUucHJvdG90eXBlLmdldFJlbmRlclByb3h5ID0gZnVuY3Rpb24gZ2V0UmVuZGVyUHJveHkgKCkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ05vZGUjZ2V0UmVuZGVyUHJveHkgaXMgZGVwcmVjYXRlZCFcXG4nICtcbiAgICAgICAgJ1JlbmRlclByb3h5IGZ1bmN0aW9uYWxpdHkgaGFzIGJlZW4gbWVyZ2VkIGludG8gTm9kZSEnXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQG1ldGhvZCBnZXRSZW5kZXJQYXRoXG4gKiBAY2hhaW5hYmxlXG4gKlxuICogQGRlcHJlY2F0ZWQgVXNlICNnZXRMb2NhdGlvbigpXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHJlbmRlciBwYXRoXG4gKi9cbk5vZGUucHJvdG90eXBlLmdldFJlbmRlclBhdGggPSBmdW5jdGlvbiBnZXRSZW5kZXJQYXRoICgpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdOb2RlI2dldFJlbmRlclBhdGggaXMgZGVwcmVjYXRlZCFcXG4nICtcbiAgICAgICAgJ1VzZSBOb2RlI2dldExvY2F0aW9uIGluc3RlYWQhJ1xuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TG9jYXRpb24oKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBhZGRSZW5kZXJhYmxlXG4gKiBAY2hhaW5hYmxlXG4gKlxuICogQGRlcHJlY2F0ZWQgVXNlIGFkZENvbXBvbmVudFxuICogQHBhcmFtIHsqfSBjb21wb25lbnQgY29tcG9uZW50IHRvIGJlIGFkZGVkXG4gKiBAcmV0dXJuIHRoaXNcbiAqL1xuTm9kZS5wcm90b3R5cGUuYWRkUmVuZGVyYWJsZSA9IGZ1bmN0aW9uIGFkZFJlbmRlcmFibGUgKGNvbXBvbmVudCkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ05vZGUjYWRkUmVuZGVyYWJsZSBpcyBkZXByZWNhdGVkIVxcbicgK1xuICAgICAgICAndXNlIG5vZGUuYWRkQ29tcG9uZW50IGluc3RlYWQnXG4gICAgKTtcbiAgICB0aGlzLmFkZENvbXBvbmVudChjb21wb25lbnQpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIG5vZGUncyBsb2NhdGlvbiBpbiB0aGUgc2NlbmUgZ3JhcGggaGllcmFyY2h5LlxuICogQSBsb2NhdGlvbiBvZiBgYm9keS8wLzFgIGNhbiBiZSBpbnRlcnByZXRlZCBhcyB0aGUgZm9sbG93aW5nIHNjZW5lIGdyYXBoXG4gKiBoaWVyYXJjaHkgKGlnbm9yaW5nIHNpYmxpbmdzIG9mIGFuY2VzdG9ycyBhbmQgYWRkaXRpb25hbCBjaGlsZCBub2Rlcyk6XG4gKlxuICogYENvbnRleHQ6Ym9keWAgLT4gYE5vZGU6MGAgLT4gYE5vZGU6MWAsIHdoZXJlIGBOb2RlOjFgIGlzIHRoZSBub2RlIHRoZVxuICogYGdldExvY2F0aW9uYCBtZXRob2QgaGFzIGJlZW4gaW52b2tlZCBvbi5cbiAqXG4gKiBAbWV0aG9kIGdldExvY2F0aW9uXG4gKiBcbiAqIEByZXR1cm4ge1N0cmluZ30gbG9jYXRpb24gKHBhdGgpLCBlLmcuIGBib2R5LzAvMWBcbiAqL1xuTm9kZS5wcm90b3R5cGUuZ2V0TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRMb2NhdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUubG9jYXRpb247XG59O1xuXG4vKipcbiAqIEBhbGlhcyBnZXRJZFxuICovXG5Ob2RlLnByb3RvdHlwZS5nZXRJZCA9IE5vZGUucHJvdG90eXBlLmdldExvY2F0aW9uO1xuXG4vKipcbiAqIERpc3BhdGNoZXMgdGhlIGV2ZW50IG9uIHRoZSBub2RlIGJ5IHJlY3Vyc2l2ZWx5IHRyYXZlcnNpbmcgdGhlIHNjZW5lIGdyYXBoXG4gKiB1cHdhcmRzLlxuICpcbiAqIEBtZXRob2QgZW1pdFxuICogXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGV2ZW50ICAgRXZlbnQgdHlwZS5cbiAqIEBwYXJhbSAge09iamVjdH0gcGF5bG9hZCBFdmVudCBvYmplY3QgdG8gYmUgZGlzcGF0Y2hlZC5cbiAqL1xuTm9kZS5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQgKGV2ZW50LCBwYXlsb2FkKSB7XG4gICAgdmFyIHAgPSB0aGlzLmdldFBhcmVudCgpO1xuICAgIC8vIHRoZSBjb250ZXh0IGlzIGl0cyBvd24gYW5jZXN0b3JcbiAgICB3aGlsZSAocCAhPT0gKHAgPSBwLmdldFBhcmVudCgpKSk7XG4gICAgcC5nZXREaXNwYXRjaCgpLmRpc3BhdGNoKGV2ZW50LCBwYXlsb2FkKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8vIFRISVMgV0lMTCBCRSBERVBSSUNBVEVEXG5Ob2RlLnByb3RvdHlwZS5zZW5kRHJhd0NvbW1hbmQgPSBmdW5jdGlvbiBzZW5kRHJhd0NvbW1hbmQgKG1lc3NhZ2UpIHtcbiAgICB0aGlzLl9nbG9iYWxVcGRhdGVyLm1lc3NhZ2UobWVzc2FnZSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZXMgdGhlIE5vZGUsIGluY2x1ZGluZyBhbGwgcHJldmlvdXNseSBhZGRlZCBjb21wb25lbnRzLlxuICpcbiAqIEBtZXRob2QgZ2V0VmFsdWVcbiAqIFxuICogQHJldHVybiB7T2JqZWN0fSAgICAgU2VyaWFsaXplZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgbm9kZSwgaW5jbHVkaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzLlxuICovXG5Ob2RlLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uIGdldFZhbHVlICgpIHtcbiAgICB2YXIgbnVtYmVyT2ZDaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDtcbiAgICB2YXIgbnVtYmVyT2ZDb21wb25lbnRzID0gdGhpcy5fY29tcG9uZW50cy5sZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgdmFyIHZhbHVlID0ge1xuICAgICAgICBsb2NhdGlvbjogdGhpcy52YWx1ZS5sb2NhdGlvbixcbiAgICAgICAgc3BlYzogdGhpcy52YWx1ZSxcbiAgICAgICAgY29tcG9uZW50czogbmV3IEFycmF5KG51bWJlck9mQ29tcG9uZW50cyksXG4gICAgICAgIGNoaWxkcmVuOiBuZXcgQXJyYXkobnVtYmVyT2ZDaGlsZHJlbilcbiAgICB9O1xuXG4gICAgZm9yICg7IGkgPCBudW1iZXJPZkNoaWxkcmVuIDsgaSsrKVxuICAgICAgICB2YWx1ZS5jaGlsZHJlbltpXSA9IHRoaXMuX2NoaWxkcmVuW2ldLmdldFZhbHVlKCk7XG5cbiAgICBmb3IgKGkgPSAwIDsgaSA8IG51bWJlck9mQ29tcG9uZW50cyA7IGkrKylcbiAgICAgICAgaWYgKHRoaXMuX2NvbXBvbmVudHNbaV0uZ2V0VmFsdWUpXG4gICAgICAgICAgICB2YWx1ZS5jb21wb25lbnRzW2ldID0gdGhpcy5fY29tcG9uZW50c1tpXS5nZXRWYWx1ZSgpO1xuXG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqXG4gKiBTaW1pbGFyIHRvIEB7QGxpbmsgZ2V0VmFsdWV9LCBidXQgcmV0dXJucyB0aGUgYWN0dWFsIFwiY29tcHV0ZWRcIiB2YWx1ZS4gRS5nLlxuICogYSBwcm9wb3J0aW9uYWwgc2l6ZSBvZiAwLjUgbWlnaHQgcmVzb2x2ZSBpbnRvIGEgXCJjb21wdXRlZFwiIHNpemUgb2YgMjAwcHhcbiAqIChhc3N1bWluZyB0aGUgcGFyZW50IGhhcyBhIHdpZHRoIG9mIDQwMHB4KS5cbiAqXG4gKiBAbWV0aG9kIGdldENvbXB1dGVkVmFsdWVcbiAqIFxuICogQHJldHVybiB7T2JqZWN0fSAgICAgU2VyaWFsaXplZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgbm9kZSwgaW5jbHVkaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiwgZXhjbHVkaW5nIGNvbXBvbmVudHMuXG4gKi9cbk5vZGUucHJvdG90eXBlLmdldENvbXB1dGVkVmFsdWUgPSBmdW5jdGlvbiBnZXRDb21wdXRlZFZhbHVlICgpIHtcbiAgICB2YXIgbnVtYmVyT2ZDaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDtcblxuICAgIHZhciB2YWx1ZSA9IHtcbiAgICAgICAgbG9jYXRpb246IHRoaXMudmFsdWUubG9jYXRpb24sXG4gICAgICAgIGNvbXB1dGVkVmFsdWVzOiB0aGlzLl9jYWxjdWxhdGVkVmFsdWVzLFxuICAgICAgICBjaGlsZHJlbjogbmV3IEFycmF5KG51bWJlck9mQ2hpbGRyZW4pXG4gICAgfTtcblxuICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IG51bWJlck9mQ2hpbGRyZW4gOyBpKyspXG4gICAgICAgIHZhbHVlLmNoaWxkcmVuW2ldID0gdGhpcy5fY2hpbGRyZW5baV0uZ2V0Q29tcHV0ZWRWYWx1ZSgpO1xuXG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgYWxsIGNoaWxkcmVuIG9mIHRoZSBjdXJyZW50IG5vZGUuXG4gKlxuICogQG1ldGhvZCBnZXRDaGlsZHJlblxuICogXG4gKiBAcmV0dXJuIHtBcnJheS48Tm9kZT59ICAgQW4gYXJyYXkgb2YgY2hpbGRyZW4uXG4gKi9cbk5vZGUucHJvdG90eXBlLmdldENoaWxkcmVuID0gZnVuY3Rpb24gZ2V0Q2hpbGRyZW4gKCkge1xuICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbjtcbn07XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSBwYXJlbnQgb2YgdGhlIGN1cnJlbnQgbm9kZS4gVW5tb3VudGVkIG5vZGVzIGRvIG5vdCBoYXZlIGFcbiAqIHBhcmVudCBub2RlLlxuICpcbiAqIEBtZXRob2QgZ2V0UGFyZW50XG4gKiBcbiAqIEByZXR1cm4ge05vZGV9ICAgICAgIFBhcmVudCBub2RlLlxuICovXG5Ob2RlLnByb3RvdHlwZS5nZXRQYXJlbnQgPSBmdW5jdGlvbiBnZXRQYXJlbnQgKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXJlbnQ7XG59O1xuXG4vKipcbiAqIFNjaGVkdWxlcyB0aGUgQHtAbGluayB1cGRhdGV9IGZ1bmN0aW9uIG9mIHRoZSBub2RlIHRvIGJlIGludm9rZWQgb24gdGhlIG5leHRcbiAqIGZyYW1lIChpZiBubyB1cGRhdGUgZHVyaW5nIHRoaXMgZnJhbWUgaGFzIGJlZW4gc2NoZWR1bGVkIGFscmVhZHkpLlxuICogSWYgdGhlIG5vZGUgaXMgY3VycmVudGx5IGJlaW5nIHVwZGF0ZWQgKHdoaWNoIG1lYW5zIG9uZSBvZiB0aGUgcmVxdWVzdGVyc1xuICogaW52b2tlZCByZXF1ZXN0c1VwZGF0ZSB3aGlsZSBiZWluZyB1cGRhdGVkIGl0c2VsZiksIGFuIHVwZGF0ZSB3aWxsIGJlXG4gKiBzY2hlZHVsZWQgb24gdGhlIG5leHQgZnJhbWUuXG4gKlxuICogQG1ldGhvZCByZXF1ZXN0VXBkYXRlXG4gKiBcbiAqIEBwYXJhbSAge09iamVjdH0gcmVxdWVzdGVyICAgSWYgdGhlIHJlcXVlc3RlciBoYXMgYW4gYG9uVXBkYXRlYCBtZXRob2QsIGl0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbGwgYmUgaW52b2tlZCBkdXJpbmcgdGhlIG5leHQgdXBkYXRlIHBoYXNlIG9mXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBub2RlLlxuICovXG5Ob2RlLnByb3RvdHlwZS5yZXF1ZXN0VXBkYXRlID0gZnVuY3Rpb24gcmVxdWVzdFVwZGF0ZSAocmVxdWVzdGVyKSB7XG4gICAgaWYgKHRoaXMuX2luVXBkYXRlKSByZXR1cm4gdGhpcy5yZXF1ZXN0VXBkYXRlT25OZXh0VGljayhyZXF1ZXN0ZXIpO1xuICAgIHRoaXMuX3VwZGF0ZVF1ZXVlLnB1c2gocmVxdWVzdGVyKTtcbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHRoaXMuX3JlcXVlc3RVcGRhdGUoKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2NoZWR1bGVzIGFuIHVwZGF0ZSBvbiB0aGUgbmV4dCB0aWNrLiBTaW1pbGFyaWx5IHRvIEB7QGxpbmsgcmVxdWVzdFVwZGF0ZX0sXG4gKiBgcmVxdWVzdFVwZGF0ZU9uTmV4dFRpY2tgIHNjaGVkdWxlcyB0aGUgbm9kZSdzIGBvblVwZGF0ZWAgZnVuY3Rpb24gdG8gYmVcbiAqIGludm9rZWQgb24gdGhlIGZyYW1lIGFmdGVyIHRoZSBuZXh0IGludm9jYXRpb24gb24gdGhlIG5vZGUncyBvblVwZGF0ZSBmdW5jdGlvbi5cbiAqXG4gKiBAbWV0aG9kIHJlcXVlc3RVcGRhdGVPbk5leHRUaWNrXG4gKiBcbiAqIEBwYXJhbSAge09iamVjdH0gcmVxdWVzdGVyICAgSWYgdGhlIHJlcXVlc3RlciBoYXMgYW4gYG9uVXBkYXRlYCBtZXRob2QsIGl0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbGwgYmUgaW52b2tlZCBkdXJpbmcgdGhlIG5leHQgdXBkYXRlIHBoYXNlIG9mXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBub2RlLlxuICovXG5Ob2RlLnByb3RvdHlwZS5yZXF1ZXN0VXBkYXRlT25OZXh0VGljayA9IGZ1bmN0aW9uIHJlcXVlc3RVcGRhdGVPbk5leHRUaWNrIChyZXF1ZXN0ZXIpIHtcbiAgICB0aGlzLl9uZXh0VXBkYXRlUXVldWUucHVzaChyZXF1ZXN0ZXIpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBJZiB0aGUgY29udGV4dCBoYXMgYmVlbiBjcmVhdGVkIHVzaW5nIEB7QGxpbmsgRmFtb3VzLmNyZWF0ZUNvbnRleHR9LCB0aGVcbiAqIEB7QGxpbmsgRmFtb3VzfSBzaW5nbGV0b24gd2lsbCBiZSB0aGUgZ2xvYmFsIHVwZGF0ZXIuXG4gKlxuICogQG1ldGhvZCBnZXRVcGRhdGVyXG4gKiBcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGdsb2JhbCB1cGRhdGVyLlxuICovXG5Ob2RlLnByb3RvdHlwZS5nZXRVcGRhdGVyID0gZnVuY3Rpb24gZ2V0VXBkYXRlciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dsb2JhbFVwZGF0ZXI7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgbm9kZSBpcyBtb3VudGVkLiBVbm1vdW50ZWQgbm9kZXMgYXJlIGRldGFjaGVkIGZyb20gdGhlIHNjZW5lXG4gKiBncmFwaC5cbiAqXG4gKiBAbWV0aG9kIGlzTW91bnRlZFxuICogXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgICBCb29sZWFuIGluZGljYXRpbmcgd2VhdGhlciB0aGUgbm9kZSBpcyBtb3VudGVkIG9yIG5vdC5cbiAqL1xuTm9kZS5wcm90b3R5cGUuaXNNb3VudGVkID0gZnVuY3Rpb24gaXNNb3VudGVkICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZS5zaG93U3RhdGUubW91bnRlZDtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBub2RlIGlzIHZpc2libGUgKFwic2hvd25cIikuXG4gKlxuICogQG1ldGhvZCBpc1Nob3duXG4gKiBcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgIEJvb2xlYW4gaW5kaWNhdGluZyB3ZWF0aGVyIHRoZSBub2RlIGlzIHZpc2libGVcbiAqICAgICAgICAgICAgICAgICAgICAgIChcInNob3duXCIpIG9yIG5vdC5cbiAqL1xuTm9kZS5wcm90b3R5cGUuaXNTaG93biA9IGZ1bmN0aW9uIGlzU2hvd24gKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlLnNob3dTdGF0ZS5zaG93bjtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgbm9kZSdzIHJlbGF0aXZlIG9wYWNpdHkuXG4gKiBUaGUgb3BhY2l0eSBuZWVkcyB0byBiZSB3aXRoaW4gWzAsIDFdLCB3aGVyZSAwIGluZGljYXRlcyBhIGNvbXBsZXRlbHlcbiAqIHRyYW5zcGFyZW50LCB0aGVyZWZvcmUgaW52aXNpYmxlIG5vZGUsIHdoZXJlYXMgYW4gb3BhY2l0eSBvZiAxIG1lYW5zIHRoZVxuICogbm9kZSBpcyBjb21wbGV0ZWx5IHNvbGlkLlxuICpcbiAqIEBtZXRob2QgZ2V0T3BhY2l0eVxuICogXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgUmVsYXRpdmUgb3BhY2l0eSBvZiB0aGUgbm9kZS5cbiAqL1xuTm9kZS5wcm90b3R5cGUuZ2V0T3BhY2l0eSA9IGZ1bmN0aW9uIGdldE9wYWNpdHkgKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlLnNob3dTdGF0ZS5vcGFjaXR5O1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBub2RlJ3MgcHJldmlvdXNseSBzZXQgbW91bnQgcG9pbnQuXG4gKiBcbiAqIEBtZXRob2QgZ2V0TW91bnRQb2ludFxuICogXG4gKiBAcmV0dXJuIHtGbG9hdDMyQXJyYXl9ICAgQW4gYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBtb3VudCBwb2ludC5cbiAqL1xuTm9kZS5wcm90b3R5cGUuZ2V0TW91bnRQb2ludCA9IGZ1bmN0aW9uIGdldE1vdW50UG9pbnQgKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlLm9mZnNldHMubW91bnRQb2ludDtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgbm9kZSdzIHByZXZpb3VzbHkgc2V0IGFsaWduLlxuICogXG4gKiBAbWV0aG9kIGdldEFsaWduXG4gKiBcbiAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheX0gICBBbiBhcnJheSByZXByZXNlbnRpbmcgdGhlIGFsaWduLlxuICovXG5Ob2RlLnByb3RvdHlwZS5nZXRBbGlnbiA9IGZ1bmN0aW9uIGdldEFsaWduICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZS5vZmZzZXRzLmFsaWduO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBub2RlJ3MgcHJldmlvdXNseSBzZXQgb3JpZ2luLlxuICogXG4gKiBAbWV0aG9kIGdldE9yaWdpblxuICogXG4gKiBAcmV0dXJuIHtGbG9hdDMyQXJyYXl9ICAgQW4gYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBvcmlnaW4uXG4gKi9cbk5vZGUucHJvdG90eXBlLmdldE9yaWdpbiA9IGZ1bmN0aW9uIGdldE9yaWdpbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUub2Zmc2V0cy5vcmlnaW47XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgdGhlIG5vZGUncyBwcmV2aW91c2x5IHNldCBwb3NpdGlvbi5cbiAqXG4gKiBAbWV0aG9kIGdldFBvc2l0aW9uXG4gKiBcbiAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheX0gICBBbiBhcnJheSByZXByZXNlbnRpbmcgdGhlIHBvc2l0aW9uLlxuICovXG5Ob2RlLnByb3RvdHlwZS5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIGdldFBvc2l0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZS52ZWN0b3JzLnBvc2l0aW9uO1xufTtcblxuTm9kZS5wcm90b3R5cGUuZ2V0Um90YXRpb24gPSBmdW5jdGlvbiBnZXRSb3RhdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUudmVjdG9ycy5yb3RhdGlvbjtcbn07XG5cbk5vZGUucHJvdG90eXBlLmdldFNjYWxlID0gZnVuY3Rpb24gZ2V0U2NhbGUgKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlLnZlY3RvcnMuc2NhbGU7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5nZXRTaXplTW9kZSA9IGZ1bmN0aW9uIGdldFNpemVNb2RlICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZS5zaXplLnNpemVNb2RlO1xufTtcblxuTm9kZS5wcm90b3R5cGUuZ2V0UHJvcG9ydGlvbmFsU2l6ZSA9IGZ1bmN0aW9uIGdldFByb3BvcnRpb25hbFNpemUgKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlLnNpemUucHJvcG9ydGlvbmFsO1xufTtcblxuTm9kZS5wcm90b3R5cGUuZ2V0RGlmZmVyZW50aWFsU2l6ZSA9IGZ1bmN0aW9uIGdldERpZmZlcmVudGlhbFNpemUgKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlLnNpemUuZGlmZmVyZW50aWFsO1xufTtcblxuTm9kZS5wcm90b3R5cGUuZ2V0QWJzb2x1dGVTaXplID0gZnVuY3Rpb24gZ2V0QWJzb2x1dGVTaXplICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZS5zaXplLmFic29sdXRlO1xufTtcblxuTm9kZS5wcm90b3R5cGUuZ2V0UmVuZGVyU2l6ZSA9IGZ1bmN0aW9uIGdldFJlbmRlclNpemUgKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlLnNpemUucmVuZGVyO1xufTtcblxuTm9kZS5wcm90b3R5cGUuZ2V0U2l6ZSA9IGZ1bmN0aW9uIGdldFNpemUgKCkge1xuICAgIHJldHVybiB0aGlzLl9jYWxjdWxhdGVkVmFsdWVzLnNpemU7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5nZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiBnZXRUcmFuc2Zvcm0gKCkge1xuICAgIHJldHVybiB0aGlzLl9jYWxjdWxhdGVkVmFsdWVzLnRyYW5zZm9ybTtcbn07XG5cbk5vZGUucHJvdG90eXBlLmdldFVJRXZlbnRzID0gZnVuY3Rpb24gZ2V0VUlFdmVudHMgKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlLlVJRXZlbnRzO1xufTtcblxuTm9kZS5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbiBhZGRDaGlsZCAoY2hpbGQpIHtcbiAgICB2YXIgaW5kZXggPSBjaGlsZCA/IHRoaXMuX2NoaWxkcmVuLmluZGV4T2YoY2hpbGQpIDogLTE7XG4gICAgY2hpbGQgPSBjaGlsZCA/IGNoaWxkIDogbmV3IE5vZGUoKTtcblxuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgaW5kZXggPSB0aGlzLl9mcmVlZENoaWxkSW5kaWNpZXMubGVuZ3RoID8gdGhpcy5fZnJlZWRDaGlsZEluZGljaWVzLnBvcCgpIDogdGhpcy5fY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICB0aGlzLl9jaGlsZHJlbltpbmRleF0gPSBjaGlsZDtcblxuICAgICAgICBpZiAodGhpcy5pc01vdW50ZWQoKSAmJiBjaGlsZC5vbk1vdW50KSB7XG4gICAgICAgICAgICB2YXIgbXlJZCA9IHRoaXMuZ2V0SWQoKTtcbiAgICAgICAgICAgIHZhciBjaGlsZElkID0gbXlJZCArICcvJyArIGluZGV4O1xuICAgICAgICAgICAgY2hpbGQub25Nb3VudCh0aGlzLCBjaGlsZElkKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIGNoaWxkO1xufTtcblxuTm9kZS5wcm90b3R5cGUucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiByZW1vdmVDaGlsZCAoY2hpbGQpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLl9jaGlsZHJlbi5pbmRleE9mKGNoaWxkKTtcbiAgICB2YXIgYWRkZWQgPSBpbmRleCAhPT0gLTE7XG4gICAgaWYgKGFkZGVkKSB7XG4gICAgICAgIHRoaXMuX2ZyZWVkQ2hpbGRJbmRpY2llcy5wdXNoKGluZGV4KTtcblxuICAgICAgICBpZiAodGhpcy5pc01vdW50ZWQoKSAmJiBjaGlsZC5vbkRpc21vdW50KVxuICAgICAgICAgICAgY2hpbGQub25EaXNtb3VudCgpO1xuXG4gICAgICAgIHRoaXMuX2NoaWxkcmVuW2luZGV4XSA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBhZGRlZDtcbn07XG5cbi8qKlxuICogRWFjaCBjb21wb25lbnQgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSBwZXIgbm9kZS5cbiAqXG4gKiBAbWV0aG9kIGFkZENvbXBvbmVudFxuICogXG4gKiBAcGFyYW0ge09iamVjdH0gY29tcG9uZW50ICAgIEFuIGNvbXBvbmVudCB0byBiZSBhZGRlZC5cbiAqL1xuTm9kZS5wcm90b3R5cGUuYWRkQ29tcG9uZW50ID0gZnVuY3Rpb24gYWRkQ29tcG9uZW50IChjb21wb25lbnQpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLl9jb21wb25lbnRzLmluZGV4T2YoY29tcG9uZW50KTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgIGluZGV4ID0gdGhpcy5fZnJlZWRDb21wb25lbnRJbmRpY2llcy5sZW5ndGggPyB0aGlzLl9mcmVlZENvbXBvbmVudEluZGljaWVzLnBvcCgpIDogdGhpcy5fY29tcG9uZW50cy5sZW5ndGg7XG4gICAgICAgIHRoaXMuX2NvbXBvbmVudHNbaW5kZXhdID0gY29tcG9uZW50O1xuXG4gICAgICAgIGlmICh0aGlzLmlzTW91bnRlZCgpICYmIGNvbXBvbmVudC5vbk1vdW50KVxuICAgICAgICAgICAgY29tcG9uZW50Lm9uTW91bnQodGhpcywgaW5kZXgpO1xuXG4gICAgICAgIGlmICh0aGlzLmlzU2hvd24oKSAmJiBjb21wb25lbnQub25TaG93KVxuICAgICAgICAgICAgY29tcG9uZW50Lm9uU2hvdygpO1xuICAgIH1cblxuICAgIHJldHVybiBpbmRleDtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIHByZXZpb3VzbHkgdmlhIEB7QGxpbmsgYWRkQ29tcG9uZW50fSBhZGRlZCBjb21wb25lbnQuXG4gKlxuICogQG1ldGhvZCByZW1vdmVDb21wb25lbnRcbiAqIFxuICogQHBhcmFtICB7T2JqZWN0fSBjb21wb25lbnQgICBBbiBjb21wb25lbnQgdGhhdCBoYXMgcHJldmlvdXNseSBiZWVuIGFkZGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzaW5nIEB7QGxpbmsgYWRkQ29tcG9uZW50fS5cbiAqL1xuTm9kZS5wcm90b3R5cGUucmVtb3ZlQ29tcG9uZW50ID0gZnVuY3Rpb24gcmVtb3ZlQ29tcG9uZW50IChjb21wb25lbnQpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLl9jb21wb25lbnRzLmluZGV4T2YoY29tcG9uZW50KTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHRoaXMuX2ZyZWVkQ29tcG9uZW50SW5kaWNpZXMucHVzaChpbmRleCk7XG4gICAgICAgIGlmICh0aGlzLmlzU2hvd24oKSAmJiBjb21wb25lbnQub25IaWRlKVxuICAgICAgICAgICAgY29tcG9uZW50Lm9uSGlkZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLmlzTW91bnRlZCgpICYmIGNvbXBvbmVudC5vbkRpc21vdW50KVxuICAgICAgICAgICAgY29tcG9uZW50Lm9uRGlzbW91bnQoKTtcblxuICAgICAgICB0aGlzLl9jb21wb25lbnRzW2luZGV4XSA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjb21wb25lbnQ7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5hZGRVSUV2ZW50ID0gZnVuY3Rpb24gYWRkVUlFdmVudCAoZXZlbnROYW1lKSB7XG4gICAgdmFyIFVJRXZlbnRzID0gdGhpcy5nZXRVSUV2ZW50cygpO1xuICAgIHZhciBjb21wb25lbnRzID0gdGhpcy5fY29tcG9uZW50cztcbiAgICB2YXIgY29tcG9uZW50O1xuXG4gICAgdmFyIGFkZGVkID0gVUlFdmVudHMuaW5kZXhPZihldmVudE5hbWUpICE9PSAtMTtcbiAgICBpZiAoIWFkZGVkKSB7XG4gICAgICAgIFVJRXZlbnRzLnB1c2goZXZlbnROYW1lKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvbXBvbmVudHMubGVuZ3RoIDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICAgICAgY29tcG9uZW50ID0gY29tcG9uZW50c1tpXTtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQub25BZGRVSUV2ZW50KSBjb21wb25lbnQub25BZGRVSUV2ZW50KGV2ZW50TmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFkZGVkO1xufTtcblxuTm9kZS5wcm90b3R5cGUuX3JlcXVlc3RVcGRhdGUgPSBmdW5jdGlvbiBfcmVxdWVzdFVwZGF0ZSAoZm9yY2UpIHtcbiAgICBpZiAoZm9yY2UgfHwgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlICYmIHRoaXMuX2dsb2JhbFVwZGF0ZXIpKSB7XG4gICAgICAgIHRoaXMuX2dsb2JhbFVwZGF0ZXIucmVxdWVzdFVwZGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IHRydWU7XG4gICAgfVxufTtcblxuTm9kZS5wcm90b3R5cGUuX3ZlY09wdGlvbmFsU2V0ID0gZnVuY3Rpb24gX3ZlY09wdGlvbmFsU2V0ICh2ZWMsIGluZGV4LCB2YWwpIHtcbiAgICBpZiAodmFsICE9IG51bGwgJiYgdmVjW2luZGV4XSAhPT0gdmFsKSB7XG4gICAgICAgIHZlY1tpbmRleF0gPSB2YWw7XG4gICAgICAgIGlmICghdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSkgdGhpcy5fcmVxdWVzdFVwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuTm9kZS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3cgKCkge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgaXRlbXMgPSB0aGlzLl9jb21wb25lbnRzO1xuICAgIHZhciBsZW4gPSBpdGVtcy5sZW5ndGg7XG4gICAgdmFyIGl0ZW07XG5cbiAgICB0aGlzLnZhbHVlLnNob3dTdGF0ZS5zaG93biA9IHRydWU7XG5cbiAgICBmb3IgKDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgIGlmIChpdGVtICYmIGl0ZW0ub25TaG93KSBpdGVtLm9uU2hvdygpO1xuICAgIH1cblxuICAgIGkgPSAwO1xuICAgIGl0ZW1zID0gdGhpcy5fY2hpbGRyZW47XG4gICAgbGVuID0gaXRlbXMubGVuZ3RoO1xuXG4gICAgZm9yICg7IGkgPCBsZW4gOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLm9uUGFyZW50U2hvdykgaXRlbS5vblBhcmVudFNob3coKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gaGlkZSAoKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBpdGVtcyA9IHRoaXMuX2NvbXBvbmVudHM7XG4gICAgdmFyIGxlbiA9IGl0ZW1zLmxlbmd0aDtcbiAgICB2YXIgaXRlbTtcblxuICAgIHRoaXMudmFsdWUuc2hvd1N0YXRlLnNob3duID0gZmFsc2U7XG5cbiAgICBmb3IgKDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgIGlmIChpdGVtICYmIGl0ZW0ub25IaWRlKSBpdGVtLm9uSGlkZSgpO1xuICAgIH1cblxuICAgIGkgPSAwO1xuICAgIGl0ZW1zID0gdGhpcy5fY2hpbGRyZW47XG4gICAgbGVuID0gaXRlbXMubGVuZ3RoO1xuXG4gICAgZm9yICg7IGkgPCBsZW4gOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLm9uUGFyZW50SGlkZSkgaXRlbS5vblBhcmVudEhpZGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5zZXRBbGlnbiA9IGZ1bmN0aW9uIHNldEFsaWduICh4LCB5LCB6KSB7XG4gICAgdmFyIHZlYzMgPSB0aGlzLnZhbHVlLm9mZnNldHMuYWxpZ247XG4gICAgdmFyIHByb3BvZ2F0ZSA9IGZhbHNlO1xuXG4gICAgcHJvcG9nYXRlID0gdGhpcy5fdmVjT3B0aW9uYWxTZXQodmVjMywgMCwgeCkgfHwgcHJvcG9nYXRlO1xuICAgIHByb3BvZ2F0ZSA9IHRoaXMuX3ZlY09wdGlvbmFsU2V0KHZlYzMsIDEsIHkpIHx8IHByb3BvZ2F0ZTtcbiAgICBwcm9wb2dhdGUgPSB0aGlzLl92ZWNPcHRpb25hbFNldCh2ZWMzLCAyLCAoeiAtIDAuNSkpIHx8IHByb3BvZ2F0ZTtcblxuICAgIGlmIChwcm9wb2dhdGUpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGlzdCA9IHRoaXMuX2NvbXBvbmVudHM7XG4gICAgICAgIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgdmFyIGl0ZW07XG4gICAgICAgIHggPSB2ZWMzWzBdO1xuICAgICAgICB5ID0gdmVjM1sxXTtcbiAgICAgICAgeiA9IHZlYzNbMl07XG4gICAgICAgIGZvciAoOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgICAgICBpdGVtID0gbGlzdFtpXTtcbiAgICAgICAgICAgIGlmIChpdGVtICYmIGl0ZW0ub25BbGlnbkNoYW5nZSkgaXRlbS5vbkFsaWduQ2hhbmdlKHgsIHksIHopO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuTm9kZS5wcm90b3R5cGUuc2V0TW91bnRQb2ludCA9IGZ1bmN0aW9uIHNldE1vdW50UG9pbnQgKHgsIHksIHopIHtcbiAgICB2YXIgdmVjMyA9IHRoaXMudmFsdWUub2Zmc2V0cy5tb3VudFBvaW50O1xuICAgIHZhciBwcm9wb2dhdGUgPSBmYWxzZTtcblxuICAgIHByb3BvZ2F0ZSA9IHRoaXMuX3ZlY09wdGlvbmFsU2V0KHZlYzMsIDAsIHgpIHx8IHByb3BvZ2F0ZTtcbiAgICBwcm9wb2dhdGUgPSB0aGlzLl92ZWNPcHRpb25hbFNldCh2ZWMzLCAxLCB5KSB8fCBwcm9wb2dhdGU7XG4gICAgcHJvcG9nYXRlID0gdGhpcy5fdmVjT3B0aW9uYWxTZXQodmVjMywgMiwgKHogLSAwLjUpKSB8fCBwcm9wb2dhdGU7XG5cbiAgICBpZiAocHJvcG9nYXRlKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxpc3QgPSB0aGlzLl9jb21wb25lbnRzO1xuICAgICAgICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gICAgICAgIHZhciBpdGVtO1xuICAgICAgICB4ID0gdmVjM1swXTtcbiAgICAgICAgeSA9IHZlYzNbMV07XG4gICAgICAgIHogPSB2ZWMzWzJdO1xuICAgICAgICBmb3IgKDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICAgICAgaXRlbSA9IGxpc3RbaV07XG4gICAgICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLm9uTW91bnRQb2ludENoYW5nZSkgaXRlbS5vbk1vdW50UG9pbnRDaGFuZ2UoeCwgeSwgeik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5zZXRPcmlnaW4gPSBmdW5jdGlvbiBzZXRPcmlnaW4gKHgsIHksIHopIHtcbiAgICB2YXIgdmVjMyA9IHRoaXMudmFsdWUub2Zmc2V0cy5vcmlnaW47XG4gICAgdmFyIHByb3BvZ2F0ZSA9IGZhbHNlO1xuXG4gICAgcHJvcG9nYXRlID0gdGhpcy5fdmVjT3B0aW9uYWxTZXQodmVjMywgMCwgeCkgfHwgcHJvcG9nYXRlO1xuICAgIHByb3BvZ2F0ZSA9IHRoaXMuX3ZlY09wdGlvbmFsU2V0KHZlYzMsIDEsIHkpIHx8IHByb3BvZ2F0ZTtcbiAgICBwcm9wb2dhdGUgPSB0aGlzLl92ZWNPcHRpb25hbFNldCh2ZWMzLCAyLCAoeiAtIDAuNSkpIHx8IHByb3BvZ2F0ZTtcblxuICAgIGlmIChwcm9wb2dhdGUpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGlzdCA9IHRoaXMuX2NvbXBvbmVudHM7XG4gICAgICAgIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgdmFyIGl0ZW07XG4gICAgICAgIHggPSB2ZWMzWzBdO1xuICAgICAgICB5ID0gdmVjM1sxXTtcbiAgICAgICAgeiA9IHZlYzNbMl07XG4gICAgICAgIGZvciAoOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgICAgICBpdGVtID0gbGlzdFtpXTtcbiAgICAgICAgICAgIGlmIChpdGVtICYmIGl0ZW0ub25PcmlnaW5DaGFuZ2UpIGl0ZW0ub25PcmlnaW5DaGFuZ2UoeCwgeSwgeik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbk5vZGUucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24gc2V0UG9zaXRpb24gKHgsIHksIHopIHtcbiAgICB2YXIgdmVjMyA9IHRoaXMudmFsdWUudmVjdG9ycy5wb3NpdGlvbjtcbiAgICB2YXIgcHJvcG9nYXRlID0gZmFsc2U7XG5cbiAgICBwcm9wb2dhdGUgPSB0aGlzLl92ZWNPcHRpb25hbFNldCh2ZWMzLCAwLCB4KSB8fCBwcm9wb2dhdGU7XG4gICAgcHJvcG9nYXRlID0gdGhpcy5fdmVjT3B0aW9uYWxTZXQodmVjMywgMSwgeSkgfHwgcHJvcG9nYXRlO1xuICAgIHByb3BvZ2F0ZSA9IHRoaXMuX3ZlY09wdGlvbmFsU2V0KHZlYzMsIDIsIHopIHx8IHByb3BvZ2F0ZTtcblxuICAgIGlmIChwcm9wb2dhdGUpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGlzdCA9IHRoaXMuX2NvbXBvbmVudHM7XG4gICAgICAgIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgdmFyIGl0ZW07XG4gICAgICAgIHggPSB2ZWMzWzBdO1xuICAgICAgICB5ID0gdmVjM1sxXTtcbiAgICAgICAgeiA9IHZlYzNbMl07XG4gICAgICAgIGZvciAoOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgICAgICBpdGVtID0gbGlzdFtpXTtcbiAgICAgICAgICAgIGlmIChpdGVtICYmIGl0ZW0ub25Qb3NpdGlvbkNoYW5nZSkgaXRlbS5vblBvc2l0aW9uQ2hhbmdlKHgsIHksIHopO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5zZXRSb3RhdGlvbiA9IGZ1bmN0aW9uIHNldFJvdGF0aW9uICh4LCB5LCB6LCB3KSB7XG4gICAgdmFyIHF1YXQgPSB0aGlzLnZhbHVlLnZlY3RvcnMucm90YXRpb247XG4gICAgdmFyIHByb3BvZ2F0ZSA9IGZhbHNlO1xuICAgIHZhciBxeCwgcXksIHF6LCBxdztcblxuICAgIGlmICh3ICE9IG51bGwpIHtcbiAgICAgICAgcXggPSB4O1xuICAgICAgICBxeSA9IHk7XG4gICAgICAgIHF6ID0gejtcbiAgICAgICAgcXcgPSB3O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGh4ID0geCAqIDAuNTtcbiAgICAgICAgdmFyIGh5ID0geSAqIDAuNTtcbiAgICAgICAgdmFyIGh6ID0geiAqIDAuNTtcblxuICAgICAgICB2YXIgc3ggPSBNYXRoLnNpbihoeCk7XG4gICAgICAgIHZhciBzeSA9IE1hdGguc2luKGh5KTtcbiAgICAgICAgdmFyIHN6ID0gTWF0aC5zaW4oaHopO1xuICAgICAgICB2YXIgY3ggPSBNYXRoLmNvcyhoeCk7XG4gICAgICAgIHZhciBjeSA9IE1hdGguY29zKGh5KTtcbiAgICAgICAgdmFyIGN6ID0gTWF0aC5jb3MoaHopO1xuXG4gICAgICAgIHZhciBzeXN6ID0gc3kgKiBzejtcbiAgICAgICAgdmFyIGN5c3ogPSBjeSAqIHN6O1xuICAgICAgICB2YXIgc3ljeiA9IHN5ICogY3o7XG4gICAgICAgIHZhciBjeWN6ID0gY3kgKiBjejtcblxuICAgICAgICBxeCA9IHN4ICogY3ljeiArIGN4ICogc3lzejtcbiAgICAgICAgcXkgPSBjeCAqIHN5Y3ogLSBzeCAqIGN5c3o7XG4gICAgICAgIHF6ID0gY3ggKiBjeXN6ICsgc3ggKiBzeWN6O1xuICAgICAgICBxdyA9IGN4ICogY3ljeiAtIHN4ICogc3lzejtcbiAgICB9XG5cbiAgICBwcm9wb2dhdGUgPSB0aGlzLl92ZWNPcHRpb25hbFNldChxdWF0LCAwLCBxeCkgfHwgcHJvcG9nYXRlO1xuICAgIHByb3BvZ2F0ZSA9IHRoaXMuX3ZlY09wdGlvbmFsU2V0KHF1YXQsIDEsIHF5KSB8fCBwcm9wb2dhdGU7XG4gICAgcHJvcG9nYXRlID0gdGhpcy5fdmVjT3B0aW9uYWxTZXQocXVhdCwgMiwgcXopIHx8IHByb3BvZ2F0ZTtcbiAgICBwcm9wb2dhdGUgPSB0aGlzLl92ZWNPcHRpb25hbFNldChxdWF0LCAzLCBxdykgfHwgcHJvcG9nYXRlO1xuXG4gICAgaWYgKHByb3BvZ2F0ZSkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5fY29tcG9uZW50cztcbiAgICAgICAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgICAgICB2YXIgaXRlbTtcbiAgICAgICAgeCA9IHF1YXRbMF07XG4gICAgICAgIHkgPSBxdWF0WzFdO1xuICAgICAgICB6ID0gcXVhdFsyXTtcbiAgICAgICAgdyA9IHF1YXRbM107XG4gICAgICAgIGZvciAoOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgICAgICBpdGVtID0gbGlzdFtpXTtcbiAgICAgICAgICAgIGlmIChpdGVtICYmIGl0ZW0ub25Sb3RhdGlvbkNoYW5nZSkgaXRlbS5vblJvdGF0aW9uQ2hhbmdlKHgsIHksIHosIHcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuTm9kZS5wcm90b3R5cGUuc2V0U2NhbGUgPSBmdW5jdGlvbiBzZXRTY2FsZSAoeCwgeSwgeikge1xuICAgIHZhciB2ZWMzID0gdGhpcy52YWx1ZS52ZWN0b3JzLnNjYWxlO1xuICAgIHZhciBwcm9wb2dhdGUgPSBmYWxzZTtcblxuICAgIHByb3BvZ2F0ZSA9IHRoaXMuX3ZlY09wdGlvbmFsU2V0KHZlYzMsIDAsIHgpIHx8IHByb3BvZ2F0ZTtcbiAgICBwcm9wb2dhdGUgPSB0aGlzLl92ZWNPcHRpb25hbFNldCh2ZWMzLCAxLCB5KSB8fCBwcm9wb2dhdGU7XG4gICAgcHJvcG9nYXRlID0gdGhpcy5fdmVjT3B0aW9uYWxTZXQodmVjMywgMiwgeikgfHwgcHJvcG9nYXRlO1xuXG4gICAgaWYgKHByb3BvZ2F0ZSkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5fY29tcG9uZW50cztcbiAgICAgICAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgICAgICB2YXIgaXRlbTtcbiAgICAgICAgeCA9IHZlYzNbMF07XG4gICAgICAgIHkgPSB2ZWMzWzFdO1xuICAgICAgICB6ID0gdmVjM1syXTtcbiAgICAgICAgZm9yICg7IGkgPCBsZW4gOyBpKyspIHtcbiAgICAgICAgICAgIGl0ZW0gPSBsaXN0W2ldO1xuICAgICAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5vblNjYWxlQ2hhbmdlKSBpdGVtLm9uU2NhbGVDaGFuZ2UoeCwgeSwgeik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5zZXRPcGFjaXR5ID0gZnVuY3Rpb24gc2V0T3BhY2l0eSAodmFsKSB7XG4gICAgaWYgKHZhbCAhPSB0aGlzLnZhbHVlLnNob3dTdGF0ZS5vcGFjaXR5KSB7XG4gICAgICAgIHRoaXMudmFsdWUuc2hvd1N0YXRlLm9wYWNpdHkgPSB2YWw7XG4gICAgICAgIGlmICghdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSkgdGhpcy5fcmVxdWVzdFVwZGF0ZSgpO1xuXG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxpc3QgPSB0aGlzLl9jb21wb25lbnRzO1xuICAgICAgICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gICAgICAgIHZhciBpdGVtO1xuICAgICAgICBmb3IgKDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICAgICAgaXRlbSA9IGxpc3RbaV07XG4gICAgICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLm9uT3BhY2l0eUNoYW5nZSkgaXRlbS5vbk9wYWNpdHlDaGFuZ2UodmFsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgc2l6ZSBtb2RlIGJlaW5nIHVzZWQgZm9yIGRldGVybWluaW5nIHRoZSBub2RlcyBmaW5hbCB3aWR0aCwgaGVpZ2h0XG4gKiBhbmQgZGVwdGguXG4gKiBTaXplIG1vZGVzIGFyZSBhIHdheSB0byBkZWZpbmUgdGhlIHdheSB0aGUgbm9kZSdzIHNpemUgaXMgYmVpbmcgY2FsY3VsYXRlZC5cbiAqIFNpemUgbW9kZXMgYXJlIGVudW1zIHNldCBvbiB0aGUgQHtAbGluayBTaXplfSBjb25zdHJ1Y3RvciAoYW5kIGFsaWFzZWQgb25cbiAqIHRoZSBOb2RlKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogbm9kZS5zZXRTaXplTW9kZShOb2RlLlJFTEFUSVZFX1NJWkUsIE5vZGUuQUJTT0xVVEVfU0laRSwgTm9kZS5BQlNPTFVURV9TSVpFKTtcbiAqIC8vIEluc3RlYWQgb2YgbnVsbCwgYW55IHByb3BvcmlvbmFsIGhlaWdodCBvciBkZXB0aCBjYW4gYmUgcGFzc2VkIGluLCBzaW5jZVxuICogLy8gaXQgd291bGQgYmUgaWdub3JlZCBpbiBhbnkgY2FzZS5cbiAqIG5vZGUuc2V0UHJvcG9ydGlvbmFsU2l6ZSgwLjUsIG51bGwsIG51bGwpO1xuICogbm9kZS5zZXRBYnNvbHV0ZVNpemUobnVsbCwgMTAwLCAyMDApO1xuICpcbiAqIEBtZXRob2Qgc2V0U2l6ZU1vZGVcbiAqIFxuICogQHBhcmFtIHtTaXplTW9kZX0geCAgICBUaGUgc2l6ZSBtb2RlIGJlaW5nIHVzZWQgZm9yIGRldGVybWluaW5nIHRoZSBzaXplIGluXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIHggZGlyZWN0aW9uIChcIndpZHRoXCIpLlxuICogQHBhcmFtIHtTaXplTW9kZX0geSAgICBUaGUgc2l6ZSBtb2RlIGJlaW5nIHVzZWQgZm9yIGRldGVybWluaW5nIHRoZSBzaXplIGluXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIHkgZGlyZWN0aW9uIChcImhlaWdodFwiKS5cbiAqIEBwYXJhbSB7U2l6ZU1vZGV9IHogICAgVGhlIHNpemUgbW9kZSBiZWluZyB1c2VkIGZvciBkZXRlcm1pbmluZyB0aGUgc2l6ZSBpblxuICogICAgICAgICAgICAgICAgICAgICAgICB6IGRpcmVjdGlvbiAoXCJkZXB0aFwiKS5cbiAqL1xuTm9kZS5wcm90b3R5cGUuc2V0U2l6ZU1vZGUgPSBmdW5jdGlvbiBzZXRTaXplTW9kZSAoeCwgeSwgeikge1xuICAgIHZhciB2ZWMzID0gdGhpcy52YWx1ZS5zaXplLnNpemVNb2RlO1xuICAgIHZhciBwcm9wb2dhdGUgPSBmYWxzZTtcblxuICAgIHByb3BvZ2F0ZSA9IHRoaXMuX3ZlY09wdGlvbmFsU2V0KHZlYzMsIDAsIHgpIHx8IHByb3BvZ2F0ZTtcbiAgICBwcm9wb2dhdGUgPSB0aGlzLl92ZWNPcHRpb25hbFNldCh2ZWMzLCAxLCB5KSB8fCBwcm9wb2dhdGU7XG4gICAgcHJvcG9nYXRlID0gdGhpcy5fdmVjT3B0aW9uYWxTZXQodmVjMywgMiwgeikgfHwgcHJvcG9nYXRlO1xuXG4gICAgaWYgKHByb3BvZ2F0ZSkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5fY29tcG9uZW50cztcbiAgICAgICAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgICAgICB2YXIgaXRlbTtcbiAgICAgICAgeCA9IHZlYzNbMF07XG4gICAgICAgIHkgPSB2ZWMzWzFdO1xuICAgICAgICB6ID0gdmVjM1syXTtcbiAgICAgICAgZm9yICg7IGkgPCBsZW4gOyBpKyspIHtcbiAgICAgICAgICAgIGl0ZW0gPSBsaXN0W2ldO1xuICAgICAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5vblNpemVNb2RlQ2hhbmdlKSBpdGVtLm9uU2l6ZU1vZGVDaGFuZ2UoeCwgeSwgeik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEEgcHJvcG9ydGlvbmFsIHNpemUgZGVmaW5lcyB0aGUgbm9kZSdzIGRpbWVuc2lvbnMgcmVsYXRpdmUgdG8gaXRzIHBhcmVudHNcbiAqIGZpbmFsIHNpemUuXG4gKiBQcm9wb3J0aW9uYWwgc2l6ZXMgbmVlZCB0byBiZSB3aXRoaW4gdGhlIHJhbmdlIG9mIFswLCAxXS5cbiAqXG4gKiBAbWV0aG9kIHNldFByb3BvcnRpb25hbFNpemVcbiAqIFxuICogQHBhcmFtIHtOdW1iZXJ9IHggICAgeC1TaXplIGluIHBpeGVscyAoXCJ3aWR0aFwiKS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5ICAgIHktU2l6ZSBpbiBwaXhlbHMgKFwiaGVpZ2h0XCIpLlxuICogQHBhcmFtIHtOdW1iZXJ9IHogICAgei1TaXplIGluIHBpeGVscyAoXCJkZXB0aFwiKS5cbiAqL1xuTm9kZS5wcm90b3R5cGUuc2V0UHJvcG9ydGlvbmFsU2l6ZSA9IGZ1bmN0aW9uIHNldFByb3BvcnRpb25hbFNpemUgKHgsIHksIHopIHtcbiAgICB2YXIgdmVjMyA9IHRoaXMudmFsdWUuc2l6ZS5wcm9wb3J0aW9uYWw7XG4gICAgdmFyIHByb3BvZ2F0ZSA9IGZhbHNlO1xuXG4gICAgcHJvcG9nYXRlID0gdGhpcy5fdmVjT3B0aW9uYWxTZXQodmVjMywgMCwgeCkgfHwgcHJvcG9nYXRlO1xuICAgIHByb3BvZ2F0ZSA9IHRoaXMuX3ZlY09wdGlvbmFsU2V0KHZlYzMsIDEsIHkpIHx8IHByb3BvZ2F0ZTtcbiAgICBwcm9wb2dhdGUgPSB0aGlzLl92ZWNPcHRpb25hbFNldCh2ZWMzLCAyLCB6KSB8fCBwcm9wb2dhdGU7XG5cbiAgICBpZiAocHJvcG9nYXRlKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxpc3QgPSB0aGlzLl9jb21wb25lbnRzO1xuICAgICAgICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gICAgICAgIHZhciBpdGVtO1xuICAgICAgICB4ID0gdmVjM1swXTtcbiAgICAgICAgeSA9IHZlYzNbMV07XG4gICAgICAgIHogPSB2ZWMzWzJdO1xuICAgICAgICBmb3IgKDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICAgICAgaXRlbSA9IGxpc3RbaV07XG4gICAgICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLm9uUHJvcG9ydGlvbmFsU2l6ZUNoYW5nZSkgaXRlbS5vblByb3BvcnRpb25hbFNpemVDaGFuZ2UoeCwgeSwgeik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIERpZmZlcmVudGlhbCBzaXppbmcgY2FuIGJlIHVzZWQgdG8gYWRkIG9yIHN1YnRyYWN0IGFuIGFic29sdXRlIHNpemUgZnJvbSBhXG4gKiBvdGhlcndpc2UgcHJvcG9ydGlvbmFsbHkgc2l6ZWQgbm9kZS5cbiAqIEUuZy4gYSBkaWZmZXJlbnRpYWwgd2lkdGggb2YgYC0xMGAgYW5kIGEgcHJvcG9ydGlvbmFsIHdpZHRoIG9mIGAwLjVgIGlzXG4gKiBiZWluZyBpbnRlcnByZXRlZCBhcyBzZXR0aW5nIHRoZSBub2RlJ3Mgc2l6ZSB0byA1MCUgb2YgaXRzIHBhcmVudCdzIHdpZHRoXG4gKiAqbWludXMqIDEwIHBpeGVscy5cbiAqXG4gKiBAbWV0aG9kIHNldERpZmZlcmVudGlhbFNpemVcbiAqIFxuICogQHBhcmFtIHtOdW1iZXJ9IHggICAgeC1TaXplIHRvIGJlIGFkZGVkIHRvIHRoZSByZWxhdGl2ZWx5IHNpemVkIG5vZGUgaW5cbiAqICAgICAgICAgICAgICAgICAgICAgIHBpeGVscyAoXCJ3aWR0aFwiKS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5ICAgIHktU2l6ZSB0byBiZSBhZGRlZCB0byB0aGUgcmVsYXRpdmVseSBzaXplZCBub2RlIGluXG4gKiAgICAgICAgICAgICAgICAgICAgICBwaXhlbHMgKFwiaGVpZ2h0XCIpLlxuICogQHBhcmFtIHtOdW1iZXJ9IHogICAgei1TaXplIHRvIGJlIGFkZGVkIHRvIHRoZSByZWxhdGl2ZWx5IHNpemVkIG5vZGUgaW5cbiAqICAgICAgICAgICAgICAgICAgICAgIHBpeGVscyAoXCJkZXB0aFwiKS5cbiAqL1xuTm9kZS5wcm90b3R5cGUuc2V0RGlmZmVyZW50aWFsU2l6ZSA9IGZ1bmN0aW9uIHNldERpZmZlcmVudGlhbFNpemUgKHgsIHksIHopIHtcbiAgICB2YXIgdmVjMyA9IHRoaXMudmFsdWUuc2l6ZS5kaWZmZXJlbnRpYWw7XG4gICAgdmFyIHByb3BvZ2F0ZSA9IGZhbHNlO1xuXG4gICAgcHJvcG9nYXRlID0gdGhpcy5fdmVjT3B0aW9uYWxTZXQodmVjMywgMCwgeCkgfHwgcHJvcG9nYXRlO1xuICAgIHByb3BvZ2F0ZSA9IHRoaXMuX3ZlY09wdGlvbmFsU2V0KHZlYzMsIDEsIHkpIHx8IHByb3BvZ2F0ZTtcbiAgICBwcm9wb2dhdGUgPSB0aGlzLl92ZWNPcHRpb25hbFNldCh2ZWMzLCAyLCB6KSB8fCBwcm9wb2dhdGU7XG5cbiAgICBpZiAocHJvcG9nYXRlKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxpc3QgPSB0aGlzLl9jb21wb25lbnRzO1xuICAgICAgICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gICAgICAgIHZhciBpdGVtO1xuICAgICAgICB4ID0gdmVjM1swXTtcbiAgICAgICAgeSA9IHZlYzNbMV07XG4gICAgICAgIHogPSB2ZWMzWzJdO1xuICAgICAgICBmb3IgKDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICAgICAgaXRlbSA9IGxpc3RbaV07XG4gICAgICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLm9uRGlmZmVyZW50aWFsU2l6ZUNoYW5nZSkgaXRlbS5vbkRpZmZlcmVudGlhbFNpemVDaGFuZ2UoeCwgeSwgeik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIG5vZGVzIHNpemUgaW4gcGl4ZWxzLCBpbmRlcGVuZGVudCBvZiBpdHMgcGFyZW50LlxuICpcbiAqIEBtZXRob2Qgc2V0QWJzb2x1dGVTaXplXG4gKiBcbiAqIEBwYXJhbSB7TnVtYmVyfSB4ICAgIHgtU2l6ZSBpbiBwaXhlbHMgKFwid2lkdGhcIikuXG4gKiBAcGFyYW0ge051bWJlcn0geSAgICB5LVNpemUgaW4gcGl4ZWxzIChcImhlaWdodFwiKS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB6ICAgIHotU2l6ZSBpbiBwaXhlbHMgKFwiZGVwdGhcIikuXG4gKi9cbk5vZGUucHJvdG90eXBlLnNldEFic29sdXRlU2l6ZSA9IGZ1bmN0aW9uIHNldEFic29sdXRlU2l6ZSAoeCwgeSwgeikge1xuICAgIHZhciB2ZWMzID0gdGhpcy52YWx1ZS5zaXplLmFic29sdXRlO1xuICAgIHZhciBwcm9wb2dhdGUgPSBmYWxzZTtcblxuICAgIHByb3BvZ2F0ZSA9IHRoaXMuX3ZlY09wdGlvbmFsU2V0KHZlYzMsIDAsIHgpIHx8IHByb3BvZ2F0ZTtcbiAgICBwcm9wb2dhdGUgPSB0aGlzLl92ZWNPcHRpb25hbFNldCh2ZWMzLCAxLCB5KSB8fCBwcm9wb2dhdGU7XG4gICAgcHJvcG9nYXRlID0gdGhpcy5fdmVjT3B0aW9uYWxTZXQodmVjMywgMiwgeikgfHwgcHJvcG9nYXRlO1xuXG4gICAgaWYgKHByb3BvZ2F0ZSkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5fY29tcG9uZW50cztcbiAgICAgICAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgICAgICB2YXIgaXRlbTtcbiAgICAgICAgeCA9IHZlYzNbMF07XG4gICAgICAgIHkgPSB2ZWMzWzFdO1xuICAgICAgICB6ID0gdmVjM1syXTtcbiAgICAgICAgZm9yICg7IGkgPCBsZW4gOyBpKyspIHtcbiAgICAgICAgICAgIGl0ZW0gPSBsaXN0W2ldO1xuICAgICAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5vbkFic29sdXRlU2l6ZUNoYW5nZSkgaXRlbS5vbkFic29sdXRlU2l6ZUNoYW5nZSh4LCB5LCB6KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbk5vZGUucHJvdG90eXBlLl90cmFuc2Zvcm1DaGFuZ2VkID0gZnVuY3Rpb24gX3RyYW5zZm9ybUNoYW5nZWQgKHRyYW5zZm9ybSkge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgaXRlbXMgPSB0aGlzLl9jb21wb25lbnRzO1xuICAgIHZhciBsZW4gPSBpdGVtcy5sZW5ndGg7XG4gICAgdmFyIGl0ZW07XG5cbiAgICBmb3IgKDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgIGlmIChpdGVtICYmIGl0ZW0ub25UcmFuc2Zvcm1DaGFuZ2UpIGl0ZW0ub25UcmFuc2Zvcm1DaGFuZ2UodHJhbnNmb3JtKTtcbiAgICB9XG5cbiAgICBpID0gMDtcbiAgICBpdGVtcyA9IHRoaXMuX2NoaWxkcmVuO1xuICAgIGxlbiA9IGl0ZW1zLmxlbmd0aDtcblxuICAgIGZvciAoOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5vblBhcmVudFRyYW5zZm9ybUNoYW5nZSkgaXRlbS5vblBhcmVudFRyYW5zZm9ybUNoYW5nZSh0cmFuc2Zvcm0pO1xuICAgIH1cbn07XG5cbk5vZGUucHJvdG90eXBlLl9zaXplQ2hhbmdlZCA9IGZ1bmN0aW9uIF9zaXplQ2hhbmdlZCAoc2l6ZSkge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgaXRlbXMgPSB0aGlzLl9jb21wb25lbnRzO1xuICAgIHZhciBsZW4gPSBpdGVtcy5sZW5ndGg7XG4gICAgdmFyIGl0ZW07XG5cbiAgICBmb3IgKDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgIGlmIChpdGVtICYmIGl0ZW0ub25TaXplQ2hhbmdlKSBpdGVtLm9uU2l6ZUNoYW5nZShzaXplKTtcbiAgICB9XG5cbiAgICBpID0gMDtcbiAgICBpdGVtcyA9IHRoaXMuX2NoaWxkcmVuO1xuICAgIGxlbiA9IGl0ZW1zLmxlbmd0aDtcblxuICAgIGZvciAoOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5vblBhcmVudFNpemVDaGFuZ2UpIGl0ZW0ub25QYXJlbnRTaXplQ2hhbmdlKHNpemUpO1xuICAgIH1cbn07XG5cbi8vIERFUFJJQ0FURVxuTm9kZS5wcm90b3R5cGUuZ2V0RnJhbWUgPSBmdW5jdGlvbiBnZXRGcmFtZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dsb2JhbFVwZGF0ZXIuZ2V0RnJhbWUoKTtcbn07XG5cbi8qKlxuICogRW50ZXJzIHRoZSBub2RlJ3MgdXBkYXRlIHBoYXNlIHdoaWxlIHVwZGF0aW5nIGl0cyBvd24gc3BlYyBhbmQgdXBkYXRpbmcgaXRzIGNvbXBvbmVudHMuXG4gKlxuICogQG1ldGhvZCB1cGRhdGVcbiAqIFxuICogQHBhcmFtICB7TnVtYmVyfSB0aW1lICAgIGhpZ2gtcmVzb2x1dGlvbiB0aW1zdGFtcCwgdXN1YWxseSByZXRyaWV2ZWQgdXNpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAqL1xuTm9kZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlICh0aW1lKXtcbiAgICB0aGlzLl9pblVwZGF0ZSA9IHRydWU7XG4gICAgdmFyIG5leHRRdWV1ZSA9IHRoaXMuX25leHRVcGRhdGVRdWV1ZTtcbiAgICB2YXIgcXVldWUgPSB0aGlzLl91cGRhdGVRdWV1ZTtcbiAgICB2YXIgaXRlbTtcblxuICAgIHdoaWxlIChuZXh0UXVldWUubGVuZ3RoKSBxdWV1ZS51bnNoaWZ0KG5leHRRdWV1ZS5wb3AoKSk7XG5cbiAgICB3aGlsZSAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGl0ZW0gPSB0aGlzLl9jb21wb25lbnRzW3F1ZXVlLnNoaWZ0KCldO1xuICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLm9uVXBkYXRlKSBpdGVtLm9uVXBkYXRlKHRpbWUpO1xuICAgIH1cblxuICAgIHZhciBteVNpemUgPSB0aGlzLmdldFNpemUoKTtcbiAgICB2YXIgbXlUcmFuc2Zvcm0gPSB0aGlzLmdldFRyYW5zZm9ybSgpO1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpO1xuICAgIHZhciBwYXJlbnRTaXplID0gcGFyZW50LmdldFNpemUoKTtcbiAgICB2YXIgcGFyZW50VHJhbnNmb3JtID0gcGFyZW50LmdldFRyYW5zZm9ybSgpO1xuICAgIHZhciBzaXplQ2hhbmdlZCA9IFNJWkVfUFJPQ0VTU09SLmZyb21TcGVjV2l0aFBhcmVudChwYXJlbnRTaXplLCB0aGlzLnZhbHVlLCBteVNpemUpO1xuXG4gICAgdmFyIHRyYW5zZm9ybUNoYW5nZWQgPSBUUkFOU0ZPUk1fUFJPQ0VTU09SLmZyb21TcGVjV2l0aFBhcmVudChwYXJlbnRUcmFuc2Zvcm0sIHRoaXMudmFsdWUsIG15U2l6ZSwgcGFyZW50U2l6ZSwgbXlUcmFuc2Zvcm0pO1xuICAgIGlmICh0cmFuc2Zvcm1DaGFuZ2VkKSB0aGlzLl90cmFuc2Zvcm1DaGFuZ2VkKG15VHJhbnNmb3JtKTtcbiAgICBpZiAoc2l6ZUNoYW5nZWQpIHRoaXMuX3NpemVDaGFuZ2VkKG15U2l6ZSk7XG5cbiAgICB0aGlzLl9pblVwZGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLl9uZXh0VXBkYXRlUXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX2dsb2JhbFVwZGF0ZXIucmVxdWVzdFVwZGF0ZU9uTmV4dFRpY2sodGhpcyk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNNb3VudGVkKCkpIHtcbiAgICAgICAgLy8gbGFzdCB1cGRhdGVcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy52YWx1ZS5sb2NhdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuX2dsb2JhbFVwZGF0ZXIgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTW91bnRzIHRoZSBub2RlIGFuZCB0aGVyZWZvcmUgaXRzIHN1YnRyZWUgYnkgc2V0dGluZyBpdCBhcyBhIGNoaWxkIG9mIHRoZVxuICogcGFzc2VkIGluIHBhcmVudC5cbiAqXG4gKiBAbWV0aG9kIG1vdW50XG4gKiBcbiAqIEBwYXJhbSAge05vZGV9IHBhcmVudCAgICBwYXJlbnQgbm9kZVxuICogQHBhcmFtICB7U3RyaW5nfSBteUlkICAgIHBhdGggdG8gbm9kZSAoZS5nLiBgYm9keS8wLzFgKVxuICovXG5Ob2RlLnByb3RvdHlwZS5tb3VudCA9IGZ1bmN0aW9uIG1vdW50IChwYXJlbnQsIG15SWQpIHtcbiAgICBpZiAodGhpcy5pc01vdW50ZWQoKSkgcmV0dXJuO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGlzdCA9IHRoaXMuX2NvbXBvbmVudHM7XG4gICAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgIHZhciBpdGVtO1xuXG4gICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMuX2dsb2JhbFVwZGF0ZXIgPSBwYXJlbnQuZ2V0VXBkYXRlcigpO1xuICAgIHRoaXMudmFsdWUubG9jYXRpb24gPSBteUlkO1xuICAgIHRoaXMudmFsdWUuc2hvd1N0YXRlLm1vdW50ZWQgPSB0cnVlO1xuXG4gICAgZm9yICg7IGkgPCBsZW4gOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IGxpc3RbaV07XG4gICAgICAgIGlmIChpdGVtLm9uTW91bnQpIGl0ZW0ub25Nb3VudCh0aGlzLCBpKTtcbiAgICB9XG5cbiAgICBpID0gMDtcbiAgICBsaXN0ID0gdGhpcy5fY2hpbGRyZW47XG4gICAgbGVuID0gbGlzdC5sZW5ndGg7XG4gICAgZm9yICg7IGkgPCBsZW4gOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IGxpc3RbaV07XG4gICAgICAgIGlmIChpdGVtLm9uUGFyZW50TW91bnQpIGl0ZW0ub25QYXJlbnRNb3VudCh0aGlzLCBteUlkLCBpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSkgdGhpcy5fcmVxdWVzdFVwZGF0ZSh0cnVlKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRGlzbW91bnRzIChkZXRhY2hlcykgdGhlIG5vZGUgZnJvbSB0aGUgc2NlbmUgZ3JhcGggYnkgcmVtb3ZpbmcgaXQgYXMgYVxuICogY2hpbGQgb2YgaXRzIHBhcmVudC5cbiAqXG4gKiBAbWV0aG9kIGRpc21vdW50XG4gKi9cbk5vZGUucHJvdG90eXBlLmRpc21vdW50ID0gZnVuY3Rpb24gZGlzbW91bnQgKCkge1xuICAgIGlmICghdGhpcy5pc01vdW50ZWQoKSkgcmV0dXJuO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGlzdCA9IHRoaXMuX2NvbXBvbmVudHM7XG4gICAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgIHZhciBpdGVtO1xuXG4gICAgdGhpcy52YWx1ZS5zaG93U3RhdGUubW91bnRlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5fcGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xuXG4gICAgZm9yICg7IGkgPCBsZW4gOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IGxpc3RbaV07XG4gICAgICAgIGlmIChpdGVtLm9uRGlzbW91bnQpIGl0ZW0ub25EaXNtb3VudCgpO1xuICAgIH1cblxuICAgIGkgPSAwO1xuICAgIGxpc3QgPSB0aGlzLl9jaGlsZHJlbjtcbiAgICBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICBmb3IgKDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICBpdGVtID0gbGlzdFtpXTtcbiAgICAgICAgaWYgKGl0ZW0ub25QYXJlbnREaXNtb3VudCkgaXRlbS5vblBhcmVudERpc21vdW50KCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG4gICAgdGhpcy5fZ2xvYmFsVXBkYXRlciA9IG51bGw7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEZ1bmN0aW9uIHRvIGJlIGludm9rZWQgYnkgdGhlIHBhcmVudCBhcyBzb29uIGFzIHRoZSBwYXJlbnQgaXNcbiAqIGJlaW5nIG1vdW50ZWQuXG4gKlxuICogQG1ldGhvZCBvblBhcmVudE1vdW50XG4gKiBcbiAqIEBwYXJhbSAge05vZGV9IHBhcmVudCAgICAgICAgVGhlIHBhcmVudCBub2RlLlxuICogQHBhcmFtICB7U3RyaW5nfSBwYXJlbnRJZCAgICBUaGUgcGFyZW50IGlkIChwYXRoIHRvIHBhcmVudCkuXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGluZGV4ICAgICAgIElkIHRoZSBub2RlIHNob3VsZCBiZSBtb3VudGVkIHRvLlxuICovXG5Ob2RlLnByb3RvdHlwZS5vblBhcmVudE1vdW50ID0gZnVuY3Rpb24gb25QYXJlbnRNb3VudCAocGFyZW50LCBwYXJlbnRJZCwgaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5tb3VudChwYXJlbnQsIHBhcmVudElkICsgJy8nICsgaW5kZXgpO1xufTtcblxuLyoqXG4gKiBGdW5jdGlvbiB0byBiZSBpbnZva2VkIGJ5IHRoZSBwYXJlbnQgYXMgc29vbiBhcyB0aGUgcGFyZW50IGlzIGJlaW5nXG4gKiB1bm1vdW50ZWQuXG4gKlxuICogQG1ldGhvZCBvblBhcmVudERpc21vdW50XG4gKi9cbk5vZGUucHJvdG90eXBlLm9uUGFyZW50RGlzbW91bnQgPSBmdW5jdGlvbiBvblBhcmVudERpc21vdW50ICgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNtb3VudCgpO1xufTtcblxuLyoqXG4gKiBNZXRob2QgdG8gYmUgY2FsbGVkIGluIG9yZGVyIHRvIGRpc3BhdGNoIGFuIGV2ZW50IHRvIHRoZSBub2RlIGFuZCBhbGwgaXRzXG4gKiBjb21wb25lbnRzLiBOb3RlIHRoYXQgdGhpcyBkb2Vzbid0IHJlY3Vyc2UgdGhlIHN1YnRyZWUuXG4gKlxuICogQG1ldGhvZCByZWNlaXZlXG4gKiBcbiAqIEBwYXJhbSAge1N0cmluZ30gdHlwZSAgIFRoZSBldmVudCB0eXBlIChlLmcuIFwiY2xpY2tcIikuXG4gKiBAcGFyYW0gIHtPYmplY3R9IGV2ICAgICBUaGUgZXZlbnQgcGF5bG9hZCBvYmplY3QgdG8gYmUgZGlzcGF0Y2hlZC5cbiAqL1xuTm9kZS5wcm90b3R5cGUucmVjZWl2ZSA9IGZ1bmN0aW9uIHJlY2VpdmUgKHR5cGUsIGV2KSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsaXN0ID0gdGhpcy5fY29tcG9uZW50cztcbiAgICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gICAgdmFyIGl0ZW07XG4gICAgZm9yICg7IGkgPCBsZW4gOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IGxpc3RbaV07XG4gICAgICAgIGlmIChpdGVtICYmIGl0ZW0ub25SZWNlaXZlKSBpdGVtLm9uUmVjZWl2ZSh0eXBlLCBldik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuXG5Ob2RlLnByb3RvdHlwZS5fcmVxdWVzdFVwZGF0ZVdpdGhvdXRBcmdzID0gZnVuY3Rpb24gX3JlcXVlc3RVcGRhdGVXaXRob3V0QXJncyAoKSB7XG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5vblVwZGF0ZSA9IE5vZGUucHJvdG90eXBlLnVwZGF0ZTtcblxuTm9kZS5wcm90b3R5cGUub25QYXJlbnRTaG93ID0gTm9kZS5wcm90b3R5cGUuc2hvdztcblxuTm9kZS5wcm90b3R5cGUub25QYXJlbnRIaWRlID0gTm9kZS5wcm90b3R5cGUuaGlkZTtcblxuTm9kZS5wcm90b3R5cGUub25QYXJlbnRUcmFuc2Zvcm1DaGFuZ2UgPSBOb2RlLnByb3RvdHlwZS5fcmVxdWVzdFVwZGF0ZVdpdGhvdXRBcmdzO1xuXG5Ob2RlLnByb3RvdHlwZS5vblBhcmVudFNpemVDaGFuZ2UgPSBOb2RlLnByb3RvdHlwZS5fcmVxdWVzdFVwZGF0ZVdpdGhvdXRBcmdzO1xuXG5Ob2RlLnByb3RvdHlwZS5vblNob3cgPSBOb2RlLnByb3RvdHlwZS5zaG93O1xuXG5Ob2RlLnByb3RvdHlwZS5vbkhpZGUgPSBOb2RlLnByb3RvdHlwZS5oaWRlO1xuXG5Ob2RlLnByb3RvdHlwZS5vbk1vdW50ID0gTm9kZS5wcm90b3R5cGUubW91bnQ7XG5cbk5vZGUucHJvdG90eXBlLm9uRGlzbW91bnQgPSBOb2RlLnByb3RvdHlwZS5kaXNtb3VudDtcblxuTm9kZS5wcm90b3R5cGUub25SZWNlaXZlID0gTm9kZS5wcm90b3R5cGUucmVjZWl2ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBOb2RlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRWxlbWVudENhY2hlID0gcmVxdWlyZSgnLi9FbGVtZW50Q2FjaGUnKTtcbnZhciBtYXRoID0gcmVxdWlyZSgnLi9NYXRoJyk7XG52YXIgdmVuZG9yUHJlZml4ID0gcmVxdWlyZSgnLi9WZW5kb3JQcmVmaXgnKTtcbnZhciBldmVudE1hcCA9IHJlcXVpcmUoJy4vZXZlbnRzL0V2ZW50TWFwJyk7XG5cbnZhciBUUkFOU0ZPUk0gPSB2ZW5kb3JQcmVmaXgoJ3RyYW5zZm9ybScpO1xuXG4vKipcbiAqIERPTVJlbmRlcmVyIGlzIGEgY2xhc3MgcmVzcG9uc2libGUgZm9yIGFkZGluZyBlbGVtZW50c1xuICogdG8gdGhlIERPTSBhbmQgd3JpdGluZyB0byB0aG9zZSBlbGVtZW50cy5cbiAqIHRoZXJlIGlzIGEgRE9NUmVuZGVyZXIgcGVyIGNvbnRleHQsIHJlcHJlc2VudGVkIGFzIGFuXG4gKiBlbGVtZW50IGFuZCBhIHNlbGVjdG9yLiBJdCBpcyBpbnN0YW50aWF0ZWQgaW4gdGhlIFxuICogY29udGV4dCBjbGFzcy5cbiAqXG4gKiBAY2xhc3MgRE9NUmVuZGVyZXJcbiAqIFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gYW4gZWxlbWVudC5cbiAqIEBwYXJhbSB7U3RyaW5nfSB0aGUgc2VsZWN0b3Igb2YgdGhlIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0NvbXBvc2l0b3J9XG4gKi9cbmZ1bmN0aW9uIERPTVJlbmRlcmVyIChlbGVtZW50LCBzZWxlY3RvciwgY29tcG9zaXRvcikge1xuICAgIHRoaXMuX2NvbXBvc2l0b3IgPSBjb21wb3NpdG9yOyAvLyBhIHJlZmVyZW5jZSB0byB0aGUgY29tcG9zaXRvclxuXG4gICAgdGhpcy5fdGFyZ2V0ID0gbnVsbDsgLy8gYSByZWdpc3RlciBmb3IgaG9sZGluZyB0aGUgY3VycmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsZW1lbnQgdGhhdCB0aGUgUmVuZGVyZXIgaXMgb3BlcmF0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXBvblxuXG4gICAgdGhpcy5fcGFyZW50ID0gbnVsbDsgLy8gYSByZWdpc3RlciBmb3IgaG9sZGluZyB0aGUgcGFyZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2YgdGhlIHRhcmdldFxuXG4gICAgdGhpcy5fcGF0aCA9IG51bGw7IC8vIGEgcmVnaXN0ZXIgZm9yIGhvbGRpbmcgdGhlIHBhdGggb2YgdGhlIHRhcmdldFxuICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHJlZ2lzdGVyIG11c3QgYmUgc2V0IGZpcnN0LCBhbmQgdGhlblxuICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGlsZHJlbiwgdGFyZ2V0LCBhbmQgcGFyZW50IGFyZSBhbGwgbG9va2VkXG4gICAgICAgICAgICAgICAgICAgICAgIC8vIHVwIGZyb20gdGhhdC5cblxuICAgIHRoaXMuX2NoaWxkcmVuID0gW107IC8vIGEgcmVnaXN0ZXIgZm9yIGhvbGRpbmcgdGhlIGNoaWxkcmVuIG9mIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgdGFyZ2V0LlxuXG4gICAgdGhpcy5fcm9vdCA9IG5ldyBFbGVtZW50Q2FjaGUoZWxlbWVudCwgc2VsZWN0b3IpOyAvLyB0aGUgcm9vdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2YgdGhlIGRvbSB0cmVlIHRoYXQgdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVuZGVyZXIgaXMgcmVzcG9uc2libGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvclxuXG4gICAgdGhpcy5fYm91bmRUcmlnZ2VyRXZlbnQgPSB0aGlzLl90cmlnZ2VyRXZlbnQuYmluZCh0aGlzKTtcblxuICAgIHRoaXMuX3NlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgXG4gICAgdGhpcy5fZWxlbWVudHMgPSB7fTtcblxuICAgIHRoaXMuX2VsZW1lbnRzW3NlbGVjdG9yXSA9IHRoaXMuX3Jvb3Q7XG5cbiAgICB0aGlzLnBlcnNwZWN0aXZlVHJhbnNmb3JtID0gbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMV0pO1xuICAgIHRoaXMuX1ZQdHJhbnNmb3JtID0gbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMV0pO1xuXG4gICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnMgPSB7fTtcblxuICAgIHRoaXMuX3NpemUgPSBbbnVsbCwgbnVsbF07XG59XG5cbkRPTVJlbmRlcmVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihwYXRoLCB0eXBlLCBwcm9wZXJ0aWVzLCBwcmV2ZW50RGVmYXVsdCkge1xuICAgIGlmICghdGhpcy5fZXZlbnRMaXN0ZW5lcnNbdHlwZV0pIHtcbiAgICAgICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnNbdHlwZV0gPSB7fTtcbiAgICAgICAgaWYgKGV2ZW50TWFwW3R5cGVdWzFdKSB7XG4gICAgICAgICAgICAvLyBVc2UgZXZlbnQgZGVsZWdhdGlvblxuICAgICAgICAgICAgdGhpcy5fcm9vdC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgdGhpcy5fYm91bmRUcmlnZ2VyRXZlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRGlyZWN0bHkgbGluayBldmVudCBoYW5kbGVyIHRvIERPTSBlbGVtZW50XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50c1twYXRoXS5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgdGhpcy5fYm91bmRUcmlnZ2VyRXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnNbdHlwZV1bcGF0aF0gPSB7XG4gICAgICAgIHByZXZlbnREZWZhdWx0OiBwcmV2ZW50RGVmYXVsdFxuICAgIH07XG59O1xuXG5ET01SZW5kZXJlci5wcm90b3R5cGUuX3RyaWdnZXJFdmVudCA9IGZ1bmN0aW9uIF90cmlnZ2VyRXZlbnQoZXYpIHtcbiAgICB2YXIgZXZQYXRoID0gZXYucGF0aCA/IGV2LnBhdGggOiBfZ2V0UGF0aChldik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldlBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFldlBhdGhbaV0uZGF0YXNldCkgY29udGludWU7XG4gICAgICAgIHZhciBwYXRoID0gZXZQYXRoW2ldLmRhdGFzZXQuZmFQYXRoO1xuICAgICAgICBpZiAodGhpcy5fZXZlbnRMaXN0ZW5lcnNbZXYudHlwZV1bcGF0aF0pIHtcblxuICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fZXZlbnRMaXN0ZW5lcnNbZXYudHlwZV1bcGF0aF0ucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgRXZlbnRDb25zdHJ1Y3RvciA9IGV2ZW50TWFwW2V2LnR5cGVdWzBdO1xuICAgICAgICAgICAgdGhpcy5fY29tcG9zaXRvci5zZW5kRXZlbnQocGF0aCwgZXYudHlwZSwgbmV3IEV2ZW50Q29uc3RydWN0b3IoZXYpKTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5mdW5jdGlvbiBfZ2V0UGF0aCAoZXYpIHtcbiAgICB2YXIgcGF0aCA9IFtdO1xuICAgIHZhciBub2RlID0gZXYudGFyZ2V0O1xuICAgIHdoaWxlIChub2RlICE9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIHBhdGgucHVzaChub2RlKTtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG59XG5cbkRPTVJlbmRlcmVyLnByb3RvdHlwZS5nZXRTaXplID0gZnVuY3Rpb24gZ2V0U2l6ZSAoKSB7XG4gICAgdGhpcy5fc2l6ZVswXSA9IHRoaXMuX3Jvb3QuZWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICB0aGlzLl9zaXplWzFdID0gdGhpcy5fcm9vdC5lbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbn07XG5cbkRPTVJlbmRlcmVyLnByb3RvdHlwZS5fZ2V0U2l6ZSA9IERPTVJlbmRlcmVyLnByb3RvdHlwZS5nZXRTaXplO1xuXG5ET01SZW5kZXJlci5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIGRyYXcgKHJlbmRlclN0YXRlKSB7XG4gICAgaWYgKHJlbmRlclN0YXRlLnBlcnNwZWN0aXZlRGlydHkpIHtcbiAgICAgICAgdGhpcy5wZXJzcGVjdGl2ZURpcnR5ID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzBdID0gcmVuZGVyU3RhdGUucGVyc3BlY3RpdmVUcmFuc2Zvcm1bMF07XG4gICAgICAgIHRoaXMucGVyc3BlY3RpdmVUcmFuc2Zvcm1bMV0gPSByZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZVRyYW5zZm9ybVsxXTtcbiAgICAgICAgdGhpcy5wZXJzcGVjdGl2ZVRyYW5zZm9ybVsyXSA9IHJlbmRlclN0YXRlLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzJdO1xuICAgICAgICB0aGlzLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzNdID0gcmVuZGVyU3RhdGUucGVyc3BlY3RpdmVUcmFuc2Zvcm1bM107XG5cbiAgICAgICAgdGhpcy5wZXJzcGVjdGl2ZVRyYW5zZm9ybVs0XSA9IHJlbmRlclN0YXRlLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzRdO1xuICAgICAgICB0aGlzLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzVdID0gcmVuZGVyU3RhdGUucGVyc3BlY3RpdmVUcmFuc2Zvcm1bNV07XG4gICAgICAgIHRoaXMucGVyc3BlY3RpdmVUcmFuc2Zvcm1bNl0gPSByZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZVRyYW5zZm9ybVs2XTtcbiAgICAgICAgdGhpcy5wZXJzcGVjdGl2ZVRyYW5zZm9ybVs3XSA9IHJlbmRlclN0YXRlLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzddO1xuXG4gICAgICAgIHRoaXMucGVyc3BlY3RpdmVUcmFuc2Zvcm1bOF0gPSByZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZVRyYW5zZm9ybVs4XTtcbiAgICAgICAgdGhpcy5wZXJzcGVjdGl2ZVRyYW5zZm9ybVs5XSA9IHJlbmRlclN0YXRlLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzldO1xuICAgICAgICB0aGlzLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzEwXSA9IHJlbmRlclN0YXRlLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzEwXTtcbiAgICAgICAgdGhpcy5wZXJzcGVjdGl2ZVRyYW5zZm9ybVsxMV0gPSByZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZVRyYW5zZm9ybVsxMV07XG5cbiAgICAgICAgdGhpcy5wZXJzcGVjdGl2ZVRyYW5zZm9ybVsxMl0gPSByZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZVRyYW5zZm9ybVsxMl07XG4gICAgICAgIHRoaXMucGVyc3BlY3RpdmVUcmFuc2Zvcm1bMTNdID0gcmVuZGVyU3RhdGUucGVyc3BlY3RpdmVUcmFuc2Zvcm1bMTNdO1xuICAgICAgICB0aGlzLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzE0XSA9IHJlbmRlclN0YXRlLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzE0XTtcbiAgICAgICAgdGhpcy5wZXJzcGVjdGl2ZVRyYW5zZm9ybVsxNV0gPSByZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZVRyYW5zZm9ybVsxNV07XG4gICAgfVxuXG4gICAgaWYgKHJlbmRlclN0YXRlLnZpZXdEaXJ0eSB8fCByZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZURpcnR5KSB7XG4gICAgICAgIG1hdGgubXVsdGlwbHkodGhpcy5fVlB0cmFuc2Zvcm0sIHRoaXMucGVyc3BlY3RpdmVUcmFuc2Zvcm0sIHJlbmRlclN0YXRlLnZpZXdUcmFuc2Zvcm0pO1xuICAgICAgICB0aGlzLl9yb290LmVsZW1lbnQuc3R5bGVbVFJBTlNGT1JNXSA9IHRoaXMuX3N0cmluZ2lmeU1hdHJpeCh0aGlzLl9WUHRyYW5zZm9ybSk7XG4gICAgfVxufTtcblxuRE9NUmVuZGVyZXIucHJvdG90eXBlLl9hc3NlcnRQYXRoTG9hZGVkID0gZnVuY3Rpb24gX2Fzc2VyUGF0aExvYWRlZCAoKSB7XG4gICAgaWYgKCF0aGlzLl9wYXRoKSB0aHJvdyBuZXcgRXJyb3IoJ3BhdGggbm90IGxvYWRlZCcpO1xufTtcblxuRE9NUmVuZGVyZXIucHJvdG90eXBlLl9hc3NlcnRQYXJlbnRMb2FkZWQgPSBmdW5jdGlvbiBfYXNzZXJ0UGFyZW50TG9hZGVkICgpIHtcbiAgICBpZiAoIXRoaXMuX3BhcmVudCkgdGhyb3cgbmV3IEVycm9yKCdwYXJlbnQgbm90IGxvYWRlZCcpO1xufTtcblxuRE9NUmVuZGVyZXIucHJvdG90eXBlLl9hc3NlcnRDaGlsZHJlbkxvYWRlZCA9IGZ1bmN0aW9uIF9hc3NlcnRDaGlsZHJlbkxvYWRlZCAoKSB7XG4gICAgaWYgKCF0aGlzLl9jaGlsZHJlbikgdGhyb3cgbmV3IEVycm9yKCdjaGlsZHJlbiBub3QgbG9hZGVkJyk7XG59O1xuXG5ET01SZW5kZXJlci5wcm90b3R5cGUuZmluZFBhcmVudCA9IGZ1bmN0aW9uIGZpbmRQYXJlbnQgKCkge1xuICAgIHRoaXMuX2Fzc2VydFBhdGhMb2FkZWQoKTtcblxuICAgIHZhciBwYXRoID0gdGhpcy5fcGF0aDtcbiAgICB2YXIgcGFyZW50O1xuXG4gICAgd2hpbGUgKCFwYXJlbnQgJiYgcGF0aC5sZW5ndGgpIHtcbiAgICAgICAgcGF0aCA9IHBhdGguc3Vic3RyaW5nKDAsIHBhdGgubGFzdEluZGV4T2YoJy8nKSk7XG4gICAgICAgIHBhcmVudCA9IHRoaXMuX2VsZW1lbnRzW3BhdGhdO1xuICAgIH1cbiAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgcmV0dXJuIHBhcmVudDtcbn07XG5cbkRPTVJlbmRlcmVyLnByb3RvdHlwZS5maW5kQ2hpbGRyZW4gPSBmdW5jdGlvbiBmaW5kQ2hpbGRyZW4gKGFycmF5KSB7XG4gICAgdGhpcy5fYXNzZXJ0UGF0aExvYWRlZCgpO1xuICAgIFxuICAgIHZhciBwYXRoID0gdGhpcy5fcGF0aDtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuX2VsZW1lbnRzKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbjtcbiAgICBhcnJheSA9IGFycmF5ID8gYXJyYXkgOiB0aGlzLl9jaGlsZHJlbjtcblxuICAgIHRoaXMuX2NoaWxkcmVuLmxlbmd0aCA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IGtleXMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChrZXlzW2ldLmluZGV4T2YocGF0aCkgPT09IC0xIHx8IGtleXNbaV0gPT09IHBhdGgpIGtleXMuc3BsaWNlKGksIDEpO1xuICAgICAgICBlbHNlIGkrKztcbiAgICB9XG4gICAgdmFyIGN1cnJlbnRQYXRoO1xuICAgIHZhciBqID0gMDtcbiAgICBmb3IgKGkgPSAwIDsgaSA8IGtleXMubGVuZ3RoIDsgaSsrKSB7XG4gICAgICAgIGN1cnJlbnRQYXRoID0ga2V5c1tpXTtcbiAgICAgICAgZm9yIChqID0gMCA7IGogPCBrZXlzLmxlbmd0aCA7IGorKykge1xuICAgICAgICAgICAgaWYgKGkgIT09IGogJiYga2V5c1tqXS5pbmRleE9mKGN1cnJlbnRQYXRoKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBrZXlzLnNwbGljZShqLCAxKTtcbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChpID0gMCwgbGVuID0ga2V5cy5sZW5ndGggOyBpIDwgbGVuIDsgaSsrKVxuICAgICAgICBhcnJheVtpXSA9IHRoaXMuX2VsZW1lbnRzW2tleXNbaV1dO1xuXG4gICAgcmV0dXJuIGFycmF5O1xufTtcblxuRE9NUmVuZGVyZXIucHJvdG90eXBlLmZpbmRUYXJnZXQgPSBmdW5jdGlvbiBmaW5kVGFyZ2V0ICgpIHtcbiAgICB0aGlzLl90YXJnZXQgPSB0aGlzLl9lbGVtZW50c1t0aGlzLl9wYXRoXTtcbiAgICByZXR1cm4gdGhpcy5fdGFyZ2V0O1xufTtcblxuRE9NUmVuZGVyZXIucHJvdG90eXBlLmxvYWRQYXRoID0gZnVuY3Rpb24gbG9hZFBhdGggKHBhdGgpIHtcbiAgICB0aGlzLl9wYXRoID0gcGF0aDtcbiAgICByZXR1cm4gdGhpcy5fcGF0aDtcbn07XG5cbkRPTVJlbmRlcmVyLnByb3RvdHlwZS5pbnNlcnRFbCA9IGZ1bmN0aW9uIGluc2VydEVsICh0YWdOYW1lKSB7XG4gICAgaWYgKCF0aGlzLl90YXJnZXQgfHxcbiAgICAgICAgIHRoaXMuX3RhcmdldC5lbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIFxuICAgICAgICB0aGlzLmZpbmRQYXJlbnQoKTtcbiAgICAgICAgdGhpcy5maW5kQ2hpbGRyZW4oKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuX2Fzc2VydFBhcmVudExvYWRlZCgpO1xuICAgICAgICB0aGlzLl9hc3NlcnRDaGlsZHJlbkxvYWRlZCgpO1xuXG4gICAgICAgIGlmICh0aGlzLl90YXJnZXQpIHRoaXMuX3BhcmVudC5lbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuX3RhcmdldC5lbGVtZW50KTtcbiBcbiAgICAgICAgdGhpcy5fdGFyZ2V0ID0gbmV3IEVsZW1lbnRDYWNoZShkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpLCB0aGlzLl9wYXRoKTtcbiAgICAgICAgdGhpcy5fcGFyZW50LmVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fdGFyZ2V0LmVsZW1lbnQpO1xuICAgICAgICB0aGlzLl9lbGVtZW50c1t0aGlzLl9wYXRoXSA9IHRoaXMuX3RhcmdldDtcbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9jaGlsZHJlbi5sZW5ndGggOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXQuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9jaGlsZHJlbltpXS5lbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkRPTVJlbmRlcmVyLnByb3RvdHlwZS5fYXNzZXJ0VGFyZ2V0TG9hZGVkID0gZnVuY3Rpb24gX2Fzc2VydFRhcmdldExvYWRlZCAoKSB7XG4gICAgaWYgKCF0aGlzLl90YXJnZXQpIHRocm93IG5ldyBFcnJvcignTm8gdGFyZ2V0IGxvYWRlZCcpO1xufTtcblxuRE9NUmVuZGVyZXIucHJvdG90eXBlLnNldFByb3BlcnR5ID0gZnVuY3Rpb24gc2V0UHJvcGVydHkgKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5fYXNzZXJ0VGFyZ2V0TG9hZGVkKCk7XG4gICAgdGhpcy5fdGFyZ2V0LmVsZW1lbnQuc3R5bGVbbmFtZV0gPSB2YWx1ZTtcbn07XG5cbkRPTVJlbmRlcmVyLnByb3RvdHlwZS5zZXRTaXplID0gZnVuY3Rpb24gc2V0U2l6ZSAod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMuX2Fzc2VydFRhcmdldExvYWRlZCgpO1xuICAgIHRoaXMuX3RhcmdldC5lbGVtZW50LnN0eWxlLndpZHRoID0gKHdpZHRoID09PSB0cnVlKSA/ICcnIDogd2lkdGggKyAncHgnO1xuICAgIHRoaXMuX3RhcmdldC5lbGVtZW50LnN0eWxlLmhlaWdodCA9IChoZWlnaHQgPT09IHRydWUpID8gJycgOiBoZWlnaHQgKyAncHgnO1xufTtcblxuRE9NUmVuZGVyZXIucHJvdG90eXBlLnNldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIHNldEF0dHJpYnV0ZSAobmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLl9hc3NlcnRUYXJnZXRMb2FkZWQoKTtcbiAgICB0aGlzLl90YXJnZXQuZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xufTtcblxuRE9NUmVuZGVyZXIucHJvdG90eXBlLnNldENvbnRlbnQgPSBmdW5jdGlvbiBzZXRDb250ZW50IChjb250ZW50KSB7XG4gICAgdGhpcy5fYXNzZXJ0VGFyZ2V0TG9hZGVkKCk7XG4gICAgdGhpcy5maW5kQ2hpbGRyZW4oKTtcblxuICAgIC8vIFRPRE8gVGVtcG9yYXJ5IHNvbHV0aW9uXG4gICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoIDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX3RhcmdldC5lbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuX2NoaWxkcmVuW2ldLmVsZW1lbnQpO1xuICAgIH1cblxuICAgIHRoaXMuX3RhcmdldC5lbGVtZW50LmlubmVySFRNTCA9IGNvbnRlbnQ7XG5cbiAgICBmb3IgKHZhciBpID0gMCA7IGkgPCB0aGlzLl9jaGlsZHJlbi5sZW5ndGggOyBpKyspXG4gICAgICAgIHRoaXMuX3RhcmdldC5lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX2NoaWxkcmVuW2ldLmVsZW1lbnQpO1xufTtcblxuRE9NUmVuZGVyZXIucHJvdG90eXBlLnNldE1hdHJpeCA9IGZ1bmN0aW9uIHNldE1hdHJpeCAodHJhbnNmb3JtKSB7IFxuICAgIHRoaXMuX2Fzc2VydFRhcmdldExvYWRlZCgpO1xuICAgIHRoaXMuZmluZFBhcmVudCgpO1xuICAgIHZhciB3b3JsZFRyYW5zZm9ybSA9IHRoaXMuX3RhcmdldC53b3JsZFRyYW5zZm9ybTtcbiAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgaWYgKHRyYW5zZm9ybSlcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IDE2IDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICAgICAgY2hhbmdlZCA9IGNoYW5nZWQgPyBjaGFuZ2VkIDogd29ybGRUcmFuc2Zvcm1baV0gPT09IHRyYW5zZm9ybVtpXTtcbiAgICAgICAgICAgIHdvcmxkVHJhbnNmb3JtW2ldID0gdHJhbnNmb3JtW2ldO1xuICAgICAgICB9XG4gICAgZWxzZSBjaGFuZ2VkID0gdHJ1ZTtcblxuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgIG1hdGguaW52ZXJ0KHRoaXMuX3RhcmdldC5pbnZlcnRlZFBhcmVudCwgdGhpcy5fcGFyZW50LndvcmxkVHJhbnNmb3JtKTtcbiAgICAgICAgbWF0aC5tdWx0aXBseSh0aGlzLl90YXJnZXQuZmluYWxUcmFuc2Zvcm0sIHRoaXMuX3RhcmdldC5pbnZlcnRlZFBhcmVudCwgd29ybGRUcmFuc2Zvcm0pO1xuXG4gICAgICAgIC8vIFRPRE86IHRoaXMgaXMgYSB0ZW1wb3JhcnkgZml4IGZvciBkcmF3IGNvbW1hbmRzXG4gICAgICAgIC8vIGNvbWluZyBpbiBvdXQgb2Ygb3JkZXJcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5maW5kQ2hpbGRyZW4oW10pO1xuICAgICAgICB2YXIgcHJldmlvdXNQYXRoID0gdGhpcy5fcGF0aDtcbiAgICAgICAgdmFyIHByZXZpb3VzVGFyZ2V0ID0gdGhpcy5fdGFyZ2V0O1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2hpbGRyZW4ubGVuZ3RoIDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0ID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICB0aGlzLl9wYXRoID0gdGhpcy5fdGFyZ2V0LnBhdGg7XG4gICAgICAgICAgICB0aGlzLnNldE1hdHJpeCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BhdGggPSBwcmV2aW91c1BhdGg7XG4gICAgICAgIHRoaXMuX3RhcmdldCA9IHByZXZpb3VzVGFyZ2V0O1xuICAgIH1cblxuICAgIHRoaXMuX3RhcmdldC5lbGVtZW50LnN0eWxlW1RSQU5TRk9STV0gPSB0aGlzLl9zdHJpbmdpZnlNYXRyaXgodGhpcy5fdGFyZ2V0LmZpbmFsVHJhbnNmb3JtKTtcbn07XG5cbkRPTVJlbmRlcmVyLnByb3RvdHlwZS5hZGRDbGFzcyA9IGZ1bmN0aW9uIGFkZENsYXNzIChkb21DbGFzcykge1xuICAgIHRoaXMuX2Fzc2VydFRhcmdldExvYWRlZCgpO1xuICAgIHRoaXMuX3RhcmdldC5lbGVtZW50LmNsYXNzTGlzdC5hZGQoZG9tQ2xhc3MpO1xufTtcblxuRE9NUmVuZGVyZXIucHJvdG90eXBlLnJlbW92ZUNsYXNzID0gZnVuY3Rpb24gcmVtb3ZlQ2xhc3MgKGRvbUNsYXNzKSB7XG4gICAgdGhpcy5fYXNzZXJ0VGFyZ2V0TG9hZGVkKCk7XG4gICAgdGhpcy5fdGFyZ2V0LmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShkb21DbGFzcyk7XG59O1xuXG5ET01SZW5kZXJlci5wcm90b3R5cGUuX3N0cmluZ2lmeU1hdHJpeCA9IGZ1bmN0aW9uIF9zdHJpbmdpZnlNYXRyaXgobSkge1xuICAgIHZhciByID0gJ21hdHJpeDNkKCc7XG5cbiAgICByICs9IChtWzBdIDwgMC4wMDAwMDEgJiYgbVswXSA+IC0wLjAwMDAwMSkgPyAnMCwnIDogbVswXSArICcsJztcbiAgICByICs9IChtWzFdIDwgMC4wMDAwMDEgJiYgbVsxXSA+IC0wLjAwMDAwMSkgPyAnMCwnIDogbVsxXSArICcsJztcbiAgICByICs9IChtWzJdIDwgMC4wMDAwMDEgJiYgbVsyXSA+IC0wLjAwMDAwMSkgPyAnMCwnIDogbVsyXSArICcsJztcbiAgICByICs9IChtWzNdIDwgMC4wMDAwMDEgJiYgbVszXSA+IC0wLjAwMDAwMSkgPyAnMCwnIDogbVszXSArICcsJztcbiAgICByICs9IChtWzRdIDwgMC4wMDAwMDEgJiYgbVs0XSA+IC0wLjAwMDAwMSkgPyAnMCwnIDogbVs0XSArICcsJztcbiAgICByICs9IChtWzVdIDwgMC4wMDAwMDEgJiYgbVs1XSA+IC0wLjAwMDAwMSkgPyAnMCwnIDogbVs1XSArICcsJztcbiAgICByICs9IChtWzZdIDwgMC4wMDAwMDEgJiYgbVs2XSA+IC0wLjAwMDAwMSkgPyAnMCwnIDogbVs2XSArICcsJztcbiAgICByICs9IChtWzddIDwgMC4wMDAwMDEgJiYgbVs3XSA+IC0wLjAwMDAwMSkgPyAnMCwnIDogbVs3XSArICcsJztcbiAgICByICs9IChtWzhdIDwgMC4wMDAwMDEgJiYgbVs4XSA+IC0wLjAwMDAwMSkgPyAnMCwnIDogbVs4XSArICcsJztcbiAgICByICs9IChtWzldIDwgMC4wMDAwMDEgJiYgbVs5XSA+IC0wLjAwMDAwMSkgPyAnMCwnIDogbVs5XSArICcsJztcbiAgICByICs9IChtWzEwXSA8IDAuMDAwMDAxICYmIG1bMTBdID4gLTAuMDAwMDAxKSA/ICcwLCcgOiBtWzEwXSArICcsJztcbiAgICByICs9IChtWzExXSA8IDAuMDAwMDAxICYmIG1bMTFdID4gLTAuMDAwMDAxKSA/ICcwLCcgOiBtWzExXSArICcsJztcbiAgICByICs9IChtWzEyXSA8IDAuMDAwMDAxICYmIG1bMTJdID4gLTAuMDAwMDAxKSA/ICcwLCcgOiBtWzEyXSArICcsJztcbiAgICByICs9IChtWzEzXSA8IDAuMDAwMDAxICYmIG1bMTNdID4gLTAuMDAwMDAxKSA/ICcwLCcgOiBtWzEzXSArICcsJztcbiAgICByICs9IChtWzE0XSA8IDAuMDAwMDAxICYmIG1bMTRdID4gLTAuMDAwMDAxKSA/ICcwLCcgOiBtWzE0XSArICcsJztcblxuICAgIHIgKz0gbVsxNV0gKyAnKSc7XG4gICAgcmV0dXJuIHI7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERPTVJlbmRlcmVyO1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpZGVudCA9IFtcbiAgICAxLCAwLCAwLCAwLFxuICAgIDAsIDEsIDAsIDAsXG4gICAgMCwgMCwgMSwgMCxcbiAgICAwLCAwLCAwLCAxXG5dO1xuXG5mdW5jdGlvbiBFbGVtZW50Q2FjaGUgKGVsZW1lbnQsIHBhdGgpIHtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy53b3JsZFRyYW5zZm9ybSA9IG5ldyBGbG9hdDMyQXJyYXkoaWRlbnQpO1xuICAgIHRoaXMuaW52ZXJ0ZWRQYXJlbnQgPSBuZXcgRmxvYXQzMkFycmF5KGlkZW50KTtcbiAgICB0aGlzLmZpbmFsVHJhbnNmb3JtID0gbmV3IEZsb2F0MzJBcnJheShpZGVudCk7XG4gICAgdGhpcy5wb3N0UmVuZGVyU2l6ZSA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRWxlbWVudENhY2hlO1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGludmVydCAob3V0LCBhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV0sXG5cbiAgICAgICAgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwLFxuICAgICAgICBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTAsXG4gICAgICAgIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMCxcbiAgICAgICAgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExLFxuICAgICAgICBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTEsXG4gICAgICAgIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMixcbiAgICAgICAgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwLFxuICAgICAgICBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzAsXG4gICAgICAgIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMCxcbiAgICAgICAgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxLFxuICAgICAgICBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzEsXG4gICAgICAgIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMixcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gICAgICAgIGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcblxuICAgIGlmICghZGV0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBkZXQgPSAxLjAgLyBkZXQ7XG5cbiAgICBvdXRbMF0gPSAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldDtcbiAgICBvdXRbMV0gPSAoYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5KSAqIGRldDtcbiAgICBvdXRbMl0gPSAoYTMxICogYjA1IC0gYTMyICogYjA0ICsgYTMzICogYjAzKSAqIGRldDtcbiAgICBvdXRbM10gPSAoYTIyICogYjA0IC0gYTIxICogYjA1IC0gYTIzICogYjAzKSAqIGRldDtcbiAgICBvdXRbNF0gPSAoYTEyICogYjA4IC0gYTEwICogYjExIC0gYTEzICogYjA3KSAqIGRldDtcbiAgICBvdXRbNV0gPSAoYTAwICogYjExIC0gYTAyICogYjA4ICsgYTAzICogYjA3KSAqIGRldDtcbiAgICBvdXRbNl0gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcbiAgICBvdXRbN10gPSAoYTIwICogYjA1IC0gYTIyICogYjAyICsgYTIzICogYjAxKSAqIGRldDtcbiAgICBvdXRbOF0gPSAoYTEwICogYjEwIC0gYTExICogYjA4ICsgYTEzICogYjA2KSAqIGRldDtcbiAgICBvdXRbOV0gPSAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldDtcbiAgICBvdXRbMTBdID0gKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQ7XG4gICAgb3V0WzExXSA9IChhMjEgKiBiMDIgLSBhMjAgKiBiMDQgLSBhMjMgKiBiMDApICogZGV0O1xuICAgIG91dFsxMl0gPSAoYTExICogYjA3IC0gYTEwICogYjA5IC0gYTEyICogYjA2KSAqIGRldDtcbiAgICBvdXRbMTNdID0gKGEwMCAqIGIwOSAtIGEwMSAqIGIwNyArIGEwMiAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzE0XSA9IChhMzEgKiBiMDEgLSBhMzAgKiBiMDMgLSBhMzIgKiBiMDApICogZGV0O1xuICAgIG91dFsxNV0gPSAoYTIwICogYjAzIC0gYTIxICogYjAxICsgYTIyICogYjAwKSAqIGRldDtcblxuICAgIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIG11bHRpcGx5IChvdXQsIGEsIGIpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XSxcblxuICAgICAgICBiMCA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdLCBiMyA9IGJbM10sXG4gICAgICAgIGI0ID0gYls0XSwgYjUgPSBiWzVdLCBiNiA9IGJbNl0sIGI3ID0gYls3XSxcbiAgICAgICAgYjggPSBiWzhdLCBiOSA9IGJbOV0sIGIxMCA9IGJbMTBdLCBiMTEgPSBiWzExXSxcbiAgICAgICAgYjEyID0gYlsxMl0sIGIxMyA9IGJbMTNdLCBiMTQgPSBiWzE0XSwgYjE1ID0gYlsxNV07XG5cbiAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuICAgIHZhciBvdXQwLCBvdXQxLCBvdXQyLCBvdXQzO1xuXG4gICAgb3V0MCA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXQxID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dDIgPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0MyA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcblxuICAgIGNoYW5nZWQgPSBjaGFuZ2VkID9cbiAgICAgICAgICAgICAgY2hhbmdlZCA6IG91dDAgPT09IG91dFswXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0MSA9PT0gb3V0WzFdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQyID09PSBvdXRbMl0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dDMgPT09IG91dFszXTtcblxuICAgIG91dFswXSA9IG91dDA7XG4gICAgb3V0WzFdID0gb3V0MTtcbiAgICBvdXRbMl0gPSBvdXQyO1xuICAgIG91dFszXSA9IG91dDM7XG5cbiAgICBiMCA9IGI0OyBiMSA9IGI1OyBiMiA9IGI2OyBiMyA9IGI3O1xuICAgIG91dDAgPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0MSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXQyID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dDMgPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgICBjaGFuZ2VkID0gY2hhbmdlZCA/XG4gICAgICAgICAgICAgIGNoYW5nZWQgOiBvdXQwID09PSBvdXRbNF0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dDEgPT09IG91dFs1XSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0MiA9PT0gb3V0WzZdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQzID09PSBvdXRbN107XG5cbiAgICBvdXRbNF0gPSBvdXQwO1xuICAgIG91dFs1XSA9IG91dDE7XG4gICAgb3V0WzZdID0gb3V0MjtcbiAgICBvdXRbN10gPSBvdXQzO1xuXG4gICAgYjAgPSBiODsgYjEgPSBiOTsgYjIgPSBiMTA7IGIzID0gYjExO1xuICAgIG91dDAgPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0MSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXQyID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dDMgPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgICBjaGFuZ2VkID0gY2hhbmdlZCA/XG4gICAgICAgICAgICAgIGNoYW5nZWQgOiBvdXQwID09PSBvdXRbOF0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dDEgPT09IG91dFs5XSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0MiA9PT0gb3V0WzEwXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0MyA9PT0gb3V0WzExXTtcblxuICAgIG91dFs4XSA9IG91dDA7XG4gICAgb3V0WzldID0gb3V0MTtcbiAgICBvdXRbMTBdID0gb3V0MjtcbiAgICBvdXRbMTFdID0gb3V0MztcblxuICAgIGIwID0gYjEyOyBiMSA9IGIxMzsgYjIgPSBiMTQ7IGIzID0gYjE1O1xuICAgIG91dDAgPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0MSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXQyID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dDMgPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgICBjaGFuZ2VkID0gY2hhbmdlZCA/XG4gICAgICAgICAgICAgIGNoYW5nZWQgOiBvdXQwID09PSBvdXRbMTJdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQxID09PSBvdXRbMTNdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQyID09PSBvdXRbMTRdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQzID09PSBvdXRbMTVdO1xuXG4gICAgb3V0WzEyXSA9IG91dDA7XG4gICAgb3V0WzEzXSA9IG91dDE7XG4gICAgb3V0WzE0XSA9IG91dDI7XG4gICAgb3V0WzE1XSA9IG91dDM7XG5cbiAgICByZXR1cm4gb3V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBtdWx0aXBseTogbXVsdGlwbHksXG4gICAgaW52ZXJ0OiBpbnZlcnRcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBQUkVGSVhFUyA9IFsnJywgJy1tcy0nLCAnLXdlYmtpdC0nLCAnLW1vei0nLCAnLW8tJ107XG5cbi8qKlxuICogQSBoZWxwZXIgZnVuY3Rpb24gZm9yIGRldGVybWluaW5nIGlmIGEgQ1NTIHByb3BlcnR5XG4gKiBoYXMgYSB2ZW5kb3IgcHJlZml4LlxuICpcbiAqIEBtZXRob2QgdmVuZG9yUHJlZml4XG4gKiBAcHJpdmF0ZVxuICogXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAqL1xuZnVuY3Rpb24gdmVuZG9yUHJlZml4KHByb3BlcnR5KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBQUkVGSVhFUy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJlZml4ZWQgPSBQUkVGSVhFU1tpXSArIHByb3BlcnR5O1xuICAgICAgICBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlW3ByZWZpeGVkXSA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXhlZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcGVydHk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdmVuZG9yUHJlZml4O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVUlFdmVudCA9IHJlcXVpcmUoJy4vVUlFdmVudCcpO1xuXG5mdW5jdGlvbiBDb21wb3NpdGlvbkV2ZW50KGV2KSB7XG4gICAgLy8gW0NvbnN0cnVjdG9yKERPTVN0cmluZyB0eXBlQXJnLCBvcHRpb25hbCBDb21wb3NpdGlvbkV2ZW50SW5pdCBjb21wb3NpdGlvbkV2ZW50SW5pdERpY3QpXVxuICAgIC8vIGludGVyZmFjZSBDb21wb3NpdGlvbkV2ZW50IDogVUlFdmVudCB7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBET01TdHJpbmcgZGF0YTtcbiAgICAvLyB9O1xuXG4gICAgVUlFdmVudC5jYWxsKHRoaXMsIGV2KTtcbiAgICB0aGlzLmRhdGEgPSBldi5kYXRhO1xufVxuXG5Db21wb3NpdGlvbkV2ZW50LnByb3RvdHlwZSA9IFVJRXZlbnQucHJvdG90eXBlO1xuQ29tcG9zaXRpb25FdmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb21wb3NpdGlvbkV2ZW50O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvc2l0aW9uRXZlbnQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIEV2ZW50KGV2KSB7XG4gICAgLy8gW0NvbnN0cnVjdG9yKERPTVN0cmluZyB0eXBlLCBvcHRpb25hbCBFdmVudEluaXQgZXZlbnRJbml0RGljdCksXG4gICAgLy8gIEV4cG9zZWQ9V2luZG93LFdvcmtlcl1cbiAgICAvLyBpbnRlcmZhY2UgRXZlbnQge1xuICAgIC8vICAgcmVhZG9ubHkgYXR0cmlidXRlIERPTVN0cmluZyB0eXBlO1xuICAgIC8vICAgcmVhZG9ubHkgYXR0cmlidXRlIEV2ZW50VGFyZ2V0PyB0YXJnZXQ7XG4gICAgLy8gICByZWFkb25seSBhdHRyaWJ1dGUgRXZlbnRUYXJnZXQ/IGN1cnJlbnRUYXJnZXQ7XG5cbiAgICAvLyAgIGNvbnN0IHVuc2lnbmVkIHNob3J0IE5PTkUgPSAwO1xuICAgIC8vICAgY29uc3QgdW5zaWduZWQgc2hvcnQgQ0FQVFVSSU5HX1BIQVNFID0gMTtcbiAgICAvLyAgIGNvbnN0IHVuc2lnbmVkIHNob3J0IEFUX1RBUkdFVCA9IDI7XG4gICAgLy8gICBjb25zdCB1bnNpZ25lZCBzaG9ydCBCVUJCTElOR19QSEFTRSA9IDM7XG4gICAgLy8gICByZWFkb25seSBhdHRyaWJ1dGUgdW5zaWduZWQgc2hvcnQgZXZlbnRQaGFzZTtcblxuICAgIC8vICAgdm9pZCBzdG9wUHJvcGFnYXRpb24oKTtcbiAgICAvLyAgIHZvaWQgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cbiAgICAvLyAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBib29sZWFuIGJ1YmJsZXM7XG4gICAgLy8gICByZWFkb25seSBhdHRyaWJ1dGUgYm9vbGVhbiBjYW5jZWxhYmxlO1xuICAgIC8vICAgdm9pZCBwcmV2ZW50RGVmYXVsdCgpO1xuICAgIC8vICAgcmVhZG9ubHkgYXR0cmlidXRlIGJvb2xlYW4gZGVmYXVsdFByZXZlbnRlZDtcblxuICAgIC8vICAgW1VuZm9yZ2VhYmxlXSByZWFkb25seSBhdHRyaWJ1dGUgYm9vbGVhbiBpc1RydXN0ZWQ7XG4gICAgLy8gICByZWFkb25seSBhdHRyaWJ1dGUgRE9NVGltZVN0YW1wIHRpbWVTdGFtcDtcblxuICAgIC8vICAgdm9pZCBpbml0RXZlbnQoRE9NU3RyaW5nIHR5cGUsIGJvb2xlYW4gYnViYmxlcywgYm9vbGVhbiBjYW5jZWxhYmxlKTtcbiAgICAvLyB9O1xuXG4gICAgdGhpcy50eXBlID0gZXYudHlwZTtcbiAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSBldi5kZWZhdWx0UHJldmVudGVkO1xuICAgIHRoaXMuaXNUcnVzdGVkID0gZXYuaXNUcnVzdGVkO1xuICAgIHRoaXMudGltZVN0YW1wID0gZXYudGltZVN0YW1wO1xufVxuXG5FdmVudC5wcm90b3R5cGUucHJveHkgPSBmdW5jdGlvbiBwcm94eSAoZXYpIHtcbiAgICB0aGlzLnByb3RvdHlwZS5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIGV2KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDb21wb3NpdGlvbkV2ZW50ID0gcmVxdWlyZSgnLi9Db21wb3NpdGlvbkV2ZW50Jyk7XG52YXIgRXZlbnQgPSByZXF1aXJlKCcuL0V2ZW50Jyk7XG52YXIgRm9jdXNFdmVudCA9IHJlcXVpcmUoJy4vRm9jdXNFdmVudCcpO1xudmFyIElucHV0RXZlbnQgPSByZXF1aXJlKCcuL0lucHV0RXZlbnQnKTtcbnZhciBLZXlib2FyZEV2ZW50ID0gcmVxdWlyZSgnLi9LZXlib2FyZEV2ZW50Jyk7XG52YXIgTW91c2VFdmVudCA9IHJlcXVpcmUoJy4vTW91c2VFdmVudCcpO1xudmFyIFRvdWNoRXZlbnQgPSByZXF1aXJlKCcuL1RvdWNoRXZlbnQnKTtcbnZhciBVSUV2ZW50ID0gcmVxdWlyZSgnLi9VSUV2ZW50Jyk7XG52YXIgV2hlZWxFdmVudCA9IHJlcXVpcmUoJy4vV2hlZWxFdmVudCcpO1xuXG52YXIgRXZlbnRNYXAgPSB7XG4gICAgLy8gVUkgRXZlbnRzIChodHRwOi8vd3d3LnczLm9yZy9UUi91aWV2ZW50cy8pXG4gICAgJ2Fib3J0JzogW0V2ZW50LCBmYWxzZV0sXG4gICAgJ2JlZm9yZWlucHV0JzogW0lucHV0RXZlbnQsIHRydWVdLFxuICAgICdibHVyJzogW0ZvY3VzRXZlbnQsIGZhbHNlXSxcbiAgICAnY2xpY2snOiBbTW91c2VFdmVudCwgdHJ1ZV0sXG4gICAgJ2NvbXBvc2l0aW9uZW5kJzogW0NvbXBvc2l0aW9uRXZlbnQsIHRydWVdLFxuICAgICdjb21wb3NpdGlvbnN0YXJ0JzogW0NvbXBvc2l0aW9uRXZlbnQsIHRydWVdLFxuICAgICdjb21wb3NpdGlvbnVwZGF0ZSc6IFtDb21wb3NpdGlvbkV2ZW50LCB0cnVlXSxcbiAgICAnZGJsY2xpY2snOiBbTW91c2VFdmVudCwgdHJ1ZV0sXG4gICAgJ2ZvY3VzJzogW0ZvY3VzRXZlbnQsIGZhbHNlXSxcbiAgICAnZm9jdXNpbic6IFtGb2N1c0V2ZW50LCB0cnVlXSxcbiAgICAnZm9jdXNvdXQnOiBbRm9jdXNFdmVudCwgdHJ1ZV0sXG4gICAgJ2lucHV0JzogW0lucHV0RXZlbnQsIHRydWVdLFxuICAgICdrZXlkb3duJzogW0tleWJvYXJkRXZlbnQsIHRydWVdLFxuICAgICdrZXl1cCc6IFtLZXlib2FyZEV2ZW50LCB0cnVlXSxcbiAgICAnbG9hZCc6IFtFdmVudCwgZmFsc2VdLFxuICAgICdtb3VzZWRvd24nOiBbTW91c2VFdmVudCwgdHJ1ZV0sXG4gICAgJ21vdXNlZW50ZXInOiBbTW91c2VFdmVudCwgZmFsc2VdLFxuICAgICdtb3VzZWxlYXZlJzogW01vdXNlRXZlbnQsIGZhbHNlXSxcblxuICAgIC8vIGJ1YmJsZXMsIGJ1dCB3aWxsIGJlIHRyaWdnZXJlZCB2ZXJ5IGZyZXF1ZW50bHlcbiAgICAnbW91c2Vtb3ZlJzogW01vdXNlRXZlbnQsIGZhbHNlXSxcblxuICAgICdtb3VzZW91dCc6IFtNb3VzZUV2ZW50LCB0cnVlXSxcbiAgICAnbW91c2VvdmVyJzogW01vdXNlRXZlbnQsIHRydWVdLFxuICAgICdtb3VzZXVwJzogW01vdXNlRXZlbnQsIHRydWVdLFxuICAgICdyZXNpemUnOiBbVUlFdmVudCwgZmFsc2VdLFxuXG4gICAgLy8gbWlnaHQgYnViYmxlXG4gICAgJ3Njcm9sbCc6IFtVSUV2ZW50LCBmYWxzZV0sXG4gICAgXG4gICAgJ3NlbGVjdCc6IFtFdmVudCwgdHJ1ZV0sXG4gICAgJ3VubG9hZCc6IFtFdmVudCwgZmFsc2VdLFxuICAgICd3aGVlbCc6IFtXaGVlbEV2ZW50LCB0cnVlXSxcblxuICAgIC8vIFRvdWNoIEV2ZW50cyBFeHRlbnNpb24gKGh0dHA6Ly93d3cudzMub3JnL1RSL3RvdWNoLWV2ZW50cy1leHRlbnNpb25zLylcbiAgICAndG91Y2hjYW5jZWwnOiBbVG91Y2hFdmVudCwgdHJ1ZV0sXG4gICAgJ3RvdWNoZW5kJzogW1RvdWNoRXZlbnQsIHRydWVdLFxuICAgICd0b3VjaG1vdmUnOiBbVG91Y2hFdmVudCwgdHJ1ZV0sXG4gICAgJ3RvdWNoc3RhcnQnOiBbVG91Y2hFdmVudCwgdHJ1ZV0sXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50TWFwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVUlFdmVudCA9IHJlcXVpcmUoJy4vVUlFdmVudCcpO1xuXG5mdW5jdGlvbiBGb2N1c0V2ZW50KGV2KSB7XG4gICAgLy8gW0NvbnN0cnVjdG9yKERPTVN0cmluZyB0eXBlQXJnLCBvcHRpb25hbCBGb2N1c0V2ZW50SW5pdCBmb2N1c0V2ZW50SW5pdERpY3QpXVxuICAgIC8vIGludGVyZmFjZSBGb2N1c0V2ZW50IDogVUlFdmVudCB7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBFdmVudFRhcmdldD8gcmVsYXRlZFRhcmdldDtcbiAgICAvLyB9O1xuXG4gICAgVUlFdmVudC5jYWxsKHRoaXMsIGV2KTtcbn1cblxuRm9jdXNFdmVudC5wcm90b3R5cGUgPSBVSUV2ZW50LnByb3RvdHlwZTtcbkZvY3VzRXZlbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRm9jdXNFdmVudDtcblxubW9kdWxlLmV4cG9ydHMgPSBGb2N1c0V2ZW50O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVUlFdmVudCA9IHJlcXVpcmUoJy4vVUlFdmVudCcpO1xuXG5mdW5jdGlvbiBJbnB1dEV2ZW50KGV2KSB7XG4gICAgLy8gW0NvbnN0cnVjdG9yKERPTVN0cmluZyB0eXBlQXJnLCBvcHRpb25hbCBJbnB1dEV2ZW50SW5pdCBpbnB1dEV2ZW50SW5pdERpY3QpXVxuICAgIC8vIGludGVyZmFjZSBJbnB1dEV2ZW50IDogVUlFdmVudCB7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBET01TdHJpbmcgaW5wdXRUeXBlO1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgRE9NU3RyaW5nIGRhdGE7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBib29sZWFuICAgaXNDb21wb3Npbmc7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBSYW5nZSAgICAgdGFyZ2V0UmFuZ2U7XG4gICAgLy8gfTtcblxuICAgIFVJRXZlbnQuY2FsbCh0aGlzLCBldik7XG4gICAgdGhpcy5pbnB1dFR5cGUgPSBldi5pbnB1dFR5cGU7XG4gICAgdGhpcy5kYXRhID0gZXYuZGF0YTtcbiAgICB0aGlzLmlzQ29tcG9zaW5nID0gZXYuaXNDb21wb3Npbmc7XG4gICAgdGhpcy50YXJnZXRSYW5nZSA9IGV2LnRhcmdldFJhbmdlO1xufVxuXG5JbnB1dEV2ZW50LnByb3RvdHlwZSA9IFVJRXZlbnQucHJvdG90eXBlO1xuSW5wdXRFdmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbnB1dEV2ZW50O1xuXG5tb2R1bGUuZXhwb3J0cyA9IElucHV0RXZlbnQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBVSUV2ZW50ID0gcmVxdWlyZSgnLi9VSUV2ZW50Jyk7XG5cbmZ1bmN0aW9uIEtleWJvYXJkRXZlbnQoZXYpIHtcbiAgICAvLyBbQ29uc3RydWN0b3IoRE9NU3RyaW5nIHR5cGVBcmcsIG9wdGlvbmFsIEtleWJvYXJkRXZlbnRJbml0IGtleWJvYXJkRXZlbnRJbml0RGljdCldXG4gICAgLy8gaW50ZXJmYWNlIEtleWJvYXJkRXZlbnQgOiBVSUV2ZW50IHtcbiAgICAvLyAgICAgLy8gS2V5TG9jYXRpb25Db2RlXG4gICAgLy8gICAgIGNvbnN0IHVuc2lnbmVkIGxvbmcgRE9NX0tFWV9MT0NBVElPTl9TVEFOREFSRCA9IDB4MDA7XG4gICAgLy8gICAgIGNvbnN0IHVuc2lnbmVkIGxvbmcgRE9NX0tFWV9MT0NBVElPTl9MRUZUID0gMHgwMTtcbiAgICAvLyAgICAgY29uc3QgdW5zaWduZWQgbG9uZyBET01fS0VZX0xPQ0FUSU9OX1JJR0hUID0gMHgwMjtcbiAgICAvLyAgICAgY29uc3QgdW5zaWduZWQgbG9uZyBET01fS0VZX0xPQ0FUSU9OX05VTVBBRCA9IDB4MDM7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBET01TdHJpbmcgICAgIGtleTtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIERPTVN0cmluZyAgICAgY29kZTtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIHVuc2lnbmVkIGxvbmcgbG9jYXRpb247XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBib29sZWFuICAgICAgIGN0cmxLZXk7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBib29sZWFuICAgICAgIHNoaWZ0S2V5O1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgYm9vbGVhbiAgICAgICBhbHRLZXk7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBib29sZWFuICAgICAgIG1ldGFLZXk7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBib29sZWFuICAgICAgIHJlcGVhdDtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIGJvb2xlYW4gICAgICAgaXNDb21wb3Npbmc7XG4gICAgLy8gICAgIGJvb2xlYW4gZ2V0TW9kaWZpZXJTdGF0ZSAoRE9NU3RyaW5nIGtleUFyZyk7XG4gICAgLy8gfTtcbiAgICBcbiAgICBVSUV2ZW50LmNhbGwodGhpcywgZXYpO1xuICAgIHRoaXMuRE9NX0tFWV9MT0NBVElPTl9TVEFOREFSRCA9IDB4MDA7XG4gICAgdGhpcy5ET01fS0VZX0xPQ0FUSU9OX0xFRlQgPSAweDAxO1xuICAgIHRoaXMuRE9NX0tFWV9MT0NBVElPTl9SSUdIVCA9IDB4MDI7XG4gICAgdGhpcy5ET01fS0VZX0xPQ0FUSU9OX05VTVBBRCA9IDB4MDM7XG4gICAgdGhpcy5rZXkgPSBldi5rZXk7XG4gICAgdGhpcy5jb2RlID0gZXYuY29kZTtcbiAgICB0aGlzLmxvY2F0aW9uID0gZXYubG9jYXRpb247XG4gICAgdGhpcy5jdHJsS2V5ID0gZXYuY3RybEtleTtcbiAgICB0aGlzLnNoaWZ0S2V5ID0gZXYuc2hpZnRLZXk7XG4gICAgdGhpcy5hbHRLZXkgPSBldi5hbHRLZXk7XG4gICAgdGhpcy5tZXRhS2V5ID0gZXYubWV0YUtleTtcbiAgICB0aGlzLnJlcGVhdCA9IGV2LnJlcGVhdDtcbiAgICB0aGlzLmlzQ29tcG9zaW5nID0gZXYuaXNDb21wb3Npbmc7XG4gICAgdGhpcy5rZXlBcmcgPSBldi5rZXlBcmc7XG59XG5cbktleWJvYXJkRXZlbnQucHJvdG90eXBlID0gVUlFdmVudC5wcm90b3R5cGU7XG5LZXlib2FyZEV2ZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEtleWJvYXJkRXZlbnQ7XG5cbm1vZHVsZS5leHBvcnRzID0gS2V5Ym9hcmRFdmVudDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFVJRXZlbnQgPSByZXF1aXJlKCcuL1VJRXZlbnQnKTtcblxuZnVuY3Rpb24gTW91c2VFdmVudChldikge1xuICAgIC8vIFtDb25zdHJ1Y3RvcihET01TdHJpbmcgdHlwZUFyZywgb3B0aW9uYWwgTW91c2VFdmVudEluaXQgbW91c2VFdmVudEluaXREaWN0KV1cbiAgICAvLyBpbnRlcmZhY2UgTW91c2VFdmVudCA6IFVJRXZlbnQge1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgbG9uZyAgICAgICAgICAgc2NyZWVuWDtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIGxvbmcgICAgICAgICAgIHNjcmVlblk7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBsb25nICAgICAgICAgICBjbGllbnRYO1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgbG9uZyAgICAgICAgICAgY2xpZW50WTtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIGJvb2xlYW4gICAgICAgIGN0cmxLZXk7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBib29sZWFuICAgICAgICBzaGlmdEtleTtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIGJvb2xlYW4gICAgICAgIGFsdEtleTtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIGJvb2xlYW4gICAgICAgIG1ldGFLZXk7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBzaG9ydCAgICAgICAgICBidXR0b247XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBFdmVudFRhcmdldD8gICByZWxhdGVkVGFyZ2V0O1xuICAgIC8vICAgICAvLyBJbnRyb2R1Y2VkIGluIHRoaXMgc3BlY2lmaWNhdGlvblxuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgdW5zaWduZWQgc2hvcnQgYnV0dG9ucztcbiAgICAvLyAgICAgYm9vbGVhbiBnZXRNb2RpZmllclN0YXRlIChET01TdHJpbmcga2V5QXJnKTtcbiAgICAvLyB9O1xuXG4gICAgVUlFdmVudC5jYWxsKHRoaXMsIGV2KTtcbiAgICB0aGlzLnNjcmVlblggPSBldi5zY3JlZW5YO1xuICAgIHRoaXMuc2NyZWVuWCA9IGV2LnNjcmVlblg7XG4gICAgdGhpcy5zY3JlZW5ZID0gZXYuc2NyZWVuWTtcbiAgICB0aGlzLmNsaWVudFggPSBldi5jbGllbnRYO1xuICAgIHRoaXMuY2xpZW50WSA9IGV2LmNsaWVudFk7XG4gICAgdGhpcy5jdHJsS2V5ID0gZXYuY3RybEtleTtcbiAgICB0aGlzLnNoaWZ0S2V5ID0gZXYuc2hpZnRLZXk7XG4gICAgdGhpcy5hbHRLZXkgPSBldi5hbHRLZXk7XG4gICAgdGhpcy5tZXRhS2V5ID0gZXYubWV0YUtleTtcbiAgICB0aGlzLmJ1dHRvbiA9IGV2LmJ1dHRvbjtcbiAgICB0aGlzLmJ1dHRvbnMgPSBldi5idXR0b25zO1xufVxuXG5Nb3VzZUV2ZW50LnByb3RvdHlwZSA9IFVJRXZlbnQucHJvdG90eXBlO1xuTW91c2VFdmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNb3VzZUV2ZW50O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1vdXNlRXZlbnQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBVSUV2ZW50ID0gcmVxdWlyZSgnLi9VSUV2ZW50Jyk7XG5cbmZ1bmN0aW9uIFRvdWNoKHRvdWNoKSB7XG4gICAgLy8gaW50ZXJmYWNlIFRvdWNoIHtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIGxvbmcgICAgICAgIGlkZW50aWZpZXI7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBFdmVudFRhcmdldCB0YXJnZXQ7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBkb3VibGUgICAgICBzY3JlZW5YO1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgZG91YmxlICAgICAgc2NyZWVuWTtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIGRvdWJsZSAgICAgIGNsaWVudFg7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBkb3VibGUgICAgICBjbGllbnRZO1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgZG91YmxlICAgICAgcGFnZVg7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBkb3VibGUgICAgICBwYWdlWTtcbiAgICAvLyB9O1xuICAgIFxuICAgIHRoaXMuaWRlbnRpZmllciA9IHRvdWNoLmlkZW50aWZpZXI7XG4gICAgdGhpcy50YXJnZXQgPSB0b3VjaC50YXJnZXQ7XG4gICAgdGhpcy5zY3JlZW5YID0gdG91Y2guc2NyZWVuWDtcbiAgICB0aGlzLnNjcmVlblkgPSB0b3VjaC5zY3JlZW5ZO1xuICAgIHRoaXMuY2xpZW50WCA9IHRvdWNoLmNsaWVudFg7XG4gICAgdGhpcy5jbGllbnRZID0gdG91Y2guY2xpZW50WTtcbiAgICB0aGlzLnBhZ2VYID0gdG91Y2gucGFnZVg7XG4gICAgdGhpcy5wYWdlWSA9IHRvdWNoLnBhZ2VZO1xufVxuXG5mdW5jdGlvbiBjbG9uZVRvdWNoTGlzdCh0b3VjaExpc3QpIHtcbiAgICAvLyBpbnRlcmZhY2UgVG91Y2hMaXN0IHtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIHVuc2lnbmVkIGxvbmcgbGVuZ3RoO1xuICAgIC8vICAgICBnZXR0ZXIgVG91Y2g/IGl0ZW0gKHVuc2lnbmVkIGxvbmcgaW5kZXgpO1xuICAgIC8vIH07XG4gICAgXG4gICAgdmFyIHRvdWNoTGlzdEFycmF5ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3VjaExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdG91Y2hMaXN0QXJyYXlbaV0gPSBuZXcgVG91Y2godG91Y2hMaXN0W2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvdWNoTGlzdEFycmF5O1xufVxuXG5mdW5jdGlvbiBUb3VjaEV2ZW50KGV2KSB7XG4gICAgLy8gaW50ZXJmYWNlIFRvdWNoRXZlbnQgOiBVSUV2ZW50IHtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIFRvdWNoTGlzdCB0b3VjaGVzO1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgVG91Y2hMaXN0IHRhcmdldFRvdWNoZXM7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBUb3VjaExpc3QgY2hhbmdlZFRvdWNoZXM7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBib29sZWFuICAgYWx0S2V5O1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgYm9vbGVhbiAgIG1ldGFLZXk7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBib29sZWFuICAgY3RybEtleTtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIGJvb2xlYW4gICBzaGlmdEtleTtcbiAgICAvLyB9O1xuXG4gICAgVUlFdmVudC5jYWxsKHRoaXMsIGV2KTtcbiAgICB0aGlzLnRvdWNoZXMgPSBjbG9uZVRvdWNoTGlzdChldi50b3VjaGVzKTtcbiAgICB0aGlzLnRhcmdldFRvdWNoZXMgPSBjbG9uZVRvdWNoTGlzdChldi50YXJnZXRUb3VjaGVzKTtcbiAgICB0aGlzLmNoYW5nZWRUb3VjaGVzID0gY2xvbmVUb3VjaExpc3QoZXYuY2hhbmdlZFRvdWNoZXMpO1xuICAgIHRoaXMuYWx0S2V5ID0gZXYuYWx0S2V5O1xuICAgIHRoaXMubWV0YUtleSA9IGV2Lm1ldGFLZXk7XG4gICAgdGhpcy5jdHJsS2V5ID0gZXYuY3RybEtleTtcbiAgICB0aGlzLnNoaWZ0S2V5ID0gZXYuc2hpZnRLZXk7XG59XG5cblxuVG91Y2hFdmVudC5wcm90b3R5cGUgPSBVSUV2ZW50LnByb3RvdHlwZTtcblRvdWNoRXZlbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVG91Y2hFdmVudDtcblxubW9kdWxlLmV4cG9ydHMgPSBUb3VjaEV2ZW50O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnQgPSByZXF1aXJlKCcuL0V2ZW50Jyk7XG5cbmZ1bmN0aW9uIFVJRXZlbnQoZXYpIHtcbiAgICAvLyBbQ29uc3RydWN0b3IoRE9NU3RyaW5nIHR5cGUsIG9wdGlvbmFsIFVJRXZlbnRJbml0IGV2ZW50SW5pdERpY3QpXVxuICAgIC8vIGludGVyZmFjZSBVSUV2ZW50IDogRXZlbnQge1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgV2luZG93PyB2aWV3O1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgbG9uZyAgICBkZXRhaWw7XG4gICAgLy8gfTtcblxuICAgIEV2ZW50LmNhbGwodGhpcywgZXYpO1xuICAgIHRoaXMuZGV0YWlsID0gZXYuZGV0YWlsO1xufVxuXG5VSUV2ZW50LnByb3RvdHlwZSA9IEV2ZW50LnByb3RvdHlwZTtcblVJRXZlbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVUlFdmVudDtcblxubW9kdWxlLmV4cG9ydHMgPSBVSUV2ZW50O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgTW91c2VFdmVudCA9IHJlcXVpcmUoJy4vTW91c2VFdmVudCcpO1xuXG5mdW5jdGlvbiBXaGVlbEV2ZW50KGV2KSB7XG4gICAgLy8gW0NvbnN0cnVjdG9yKERPTVN0cmluZyB0eXBlQXJnLCBvcHRpb25hbCBXaGVlbEV2ZW50SW5pdCB3aGVlbEV2ZW50SW5pdERpY3QpXVxuICAgIC8vIGludGVyZmFjZSBXaGVlbEV2ZW50IDogTW91c2VFdmVudCB7XG4gICAgLy8gICAgIC8vIERlbHRhTW9kZUNvZGVcbiAgICAvLyAgICAgY29uc3QgdW5zaWduZWQgbG9uZyBET01fREVMVEFfUElYRUwgPSAweDAwO1xuICAgIC8vICAgICBjb25zdCB1bnNpZ25lZCBsb25nIERPTV9ERUxUQV9MSU5FID0gMHgwMTtcbiAgICAvLyAgICAgY29uc3QgdW5zaWduZWQgbG9uZyBET01fREVMVEFfUEFHRSA9IDB4MDI7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBkb3VibGUgICAgICAgIGRlbHRhWDtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIGRvdWJsZSAgICAgICAgZGVsdGFZO1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgZG91YmxlICAgICAgICBkZWx0YVo7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSB1bnNpZ25lZCBsb25nIGRlbHRhTW9kZTtcbiAgICAvLyB9O1xuXG4gICAgTW91c2VFdmVudC5jYWxsKHRoaXMsIGV2KTtcbiAgICB0aGlzLkRPTV9ERUxUQV9QSVhFTCA9IDB4MDA7XG4gICAgdGhpcy5ET01fREVMVEFfTElORSA9IDB4MDE7XG4gICAgdGhpcy5ET01fREVMVEFfUEFHRSA9IDB4MDI7XG4gICAgdGhpcy5kZWx0YVggPSBldi5kZWx0YVg7XG4gICAgdGhpcy5kZWx0YVkgPSBldi5kZWx0YVk7XG4gICAgdGhpcy5kZWx0YVogPSBldi5kZWx0YVo7XG4gICAgdGhpcy5kZWx0YU1vZGUgPSBldi5kZWx0YU1vZGU7XG59XG5cbldoZWVsRXZlbnQucHJvdG90eXBlID0gTW91c2VFdmVudC5wcm90b3R5cGU7XG5XaGVlbEV2ZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFdoZWVsRXZlbnQ7XG5cbm1vZHVsZS5leHBvcnRzID0gV2hlZWxFdmVudDtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgQ29tcG9zaXRpb25FdmVudDogcmVxdWlyZSgnLi9Db21wb3NpdGlvbkV2ZW50JyksXG4gICAgRXZlbnQ6IHJlcXVpcmUoJy4vRXZlbnQnKSxcbiAgICBFdmVudE1hcDogcmVxdWlyZSgnLi9FdmVudE1hcCcpLFxuICAgIEZvY3VzRXZlbnQ6IHJlcXVpcmUoJy4vRm9jdXNFdmVudCcpLFxuICAgIElucHV0RXZlbnQ6IHJlcXVpcmUoJy4vSW5wdXRFdmVudCcpLFxuICAgIEtleWJvYXJkRXZlbnQ6IHJlcXVpcmUoJy4vS2V5Ym9hcmRFdmVudCcpLFxuICAgIE1vdXNlRXZlbnQ6IHJlcXVpcmUoJy4vTW91c2VFdmVudCcpLFxuICAgIFRvdWNoRXZlbnQ6IHJlcXVpcmUoJy4vVG91Y2hFdmVudCcpLFxuICAgIFVJRXZlbnQ6IHJlcXVpcmUoJy4vVUlFdmVudCcpLFxuICAgIFdoZWVsRXZlbnQ6IHJlcXVpcmUoJy4vV2hlZWxFdmVudCcpXG59O1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIERPTVJlbmRlcmVyOiByZXF1aXJlKCcuL0RPTVJlbmRlcmVyJyksXG4gICAgRWxlbWVudENhY2hlOiByZXF1aXJlKCcuL0VsZW1lbnRDYWNoZScpLFxuICAgIEV2ZW50czogcmVxdWlyZSgnLi9ldmVudHMnKSxcbiAgICBNYXRoOiByZXF1aXJlKCcuL01hdGgnKSxcbiAgICBWZW5kb3JQcmVmaXg6IHJlcXVpcmUoJy4vVmVuZG9yUHJlZml4Jylcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZW9tZXRyeSA9IHJlcXVpcmUoJy4vR2VvbWV0cnknKTtcblxuLyoqXG4gKiBEeW5hbWljR2VvbWV0cnkgaXMgYSBjb21wb25lbnQgdGhhdCBkZWZpbmVzIHRoZSBkYXRhIHRoYXQgc2hvdWxkXG4gKiAgIGJlIGRyYXduIHRvIHRoZSB3ZWJHTCBjYW52YXMuIE1hbmFnZXMgdmVydGV4IGRhdGEgYW5kIGF0dHJpYnV0ZXMuXG4gKlxuICogQGNsYXNzIER5bmFtaWNHZW9tZXRyeVxuICogQGNvbnN0cnVjdG9yXG4gKiBcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIGluc3RhbnRpYXRpb24gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBEeW5hbWljR2VvbWV0cnkob3B0aW9ucykge1xuICAgIEdlb21ldHJ5LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgICB0aGlzLnNwZWMuZHluYW1pYyA9IHRydWU7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGF0dHJpYnV0ZSB2YWx1ZXMgdXNlZCB0byBkcmF3IHRoZSBEeW5hbWljR2VvbWV0cnkuXG4gKlxuICogQGNsYXNzIER5bmFtaWNHZW9tZXRyeVxuICogQGNvbnN0cnVjdG9yXG4gKiBcbiAqIEByZXR1cm4ge09iamVjdH0gZmxhdHRlbmVkIGxlbmd0aCBvZiB0aGUgdmVydGV4IHBvc2l0aW9ucyBhdHRyaWJ1dGVcbiAqIGluIHRoZSBnZW9tZXRyeS5cbiAqL1xuRHluYW1pY0dlb21ldHJ5LnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbiBnZXRMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VmVydGV4UG9zaXRpb25zKCkubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBidWZmZXIgb2JqZWN0IGJhc2VkIG9uIGJ1ZmZlciBuYW1lLiBUaHJvd3MgZXJyb3JcbiAqIGlmIGJ1ZmZlck5hbWUgaXMgbm90IHByb3ZpZGVkLlxuICpcbiAqIEBtZXRob2QgZ2V0VmVydGV4QnVmZmVyXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGJ1ZmZlck5hbWUgTmFtZSBvZiB2ZXJ0ZXhCdWZmZXIgdG8gYmUgcmV0cmlldmVkLlxuICogQHJldHVybiB7T2JqZWN0fSB2YWx1ZSBvZiBidWZmZXIgd2l0aCBjb3JyZXNwb25kaW5nIGJ1ZmZlck5hbWUuXG4gKi9cbkR5bmFtaWNHZW9tZXRyeS5wcm90b3R5cGUuZ2V0VmVydGV4QnVmZmVyID0gZnVuY3Rpb24gZ2V0VmVydGV4QnVmZmVyKGJ1ZmZlck5hbWUpIHtcbiAgICBpZiAoISBidWZmZXJOYW1lKSB0aHJvdyAnZ2V0VmVydGV4QnVmZmVyIHJlcXVpcmVzIGEgbmFtZSc7XG5cbiAgICB2YXIgaWR4ID0gdGhpcy5zcGVjLmJ1ZmZlck5hbWVzLmluZGV4T2YoYnVmZmVyTmFtZSk7XG4gICAgaWYgKGlkeCA9PT0gLTEpIHRocm93ICdidWZmZXIgZG9lcyBub3QgZXhpc3QnO1xuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5zcGVjLmJ1ZmZlclZhbHVlc1tpZHhdO1xuICAgIH1cbn07XG5cbi8qKlxuICogU2V0cyBhIHZlcnRleCBidWZmZXIgd2l0aCBnaXZlbiBuYW1lIHRvIGlucHV0IHZhbHVlLiBSZWdpc3RlcnMgYSBuZXcgXG4gKiBidWZmZXIgaWYgb25lIGRvZXMgbm90IGV4aXN0IHdpdGggZ2l2ZW4gbmFtZS5cbiAqIFxuICogQG1ldGhvZCBzZXRWZXJ0ZXhCdWZmZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBidWZmZXJOYW1lIE5hbWUgb2YgdmVydGV4QnVmZmVyIHRvIGJlIHNldC5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlIElucHV0IGRhdGEgdG8gZmlsbCB0YXJnZXQgYnVmZmVyLlxuICogQHBhcmFtIHtOdW1iZXJ9IHNpemUgVmVjdG9yIHNpemUgb2YgaW5wdXQgYnVmZmVyIGRhdGEuXG4gKiBAcmV0dXJuIHtPYmplY3R9IGN1cnJlbnQgZ2VvbWV0cnkuXG4gKi9cbkR5bmFtaWNHZW9tZXRyeS5wcm90b3R5cGUuc2V0VmVydGV4QnVmZmVyID0gZnVuY3Rpb24gc2V0VmVydGV4QnVmZmVyKGJ1ZmZlck5hbWUsIHZhbHVlLCBzaXplKSB7XG4gICAgdmFyIGlkeCA9IHRoaXMuc3BlYy5idWZmZXJOYW1lcy5pbmRleE9mKGJ1ZmZlck5hbWUpO1xuXG4gICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgICAgaWR4ID0gdGhpcy5zcGVjLmJ1ZmZlck5hbWVzLnB1c2goYnVmZmVyTmFtZSkgLSAxO1xuICAgIH1cblxuICAgIHRoaXMuc3BlYy5idWZmZXJWYWx1ZXNbaWR4XSA9IHZhbHVlIHx8IFtdO1xuICAgIHRoaXMuc3BlYy5idWZmZXJTcGFjaW5nc1tpZHhdID0gc2l6ZSB8fCB0aGlzLkRFRkFVTFRfQlVGRkVSX1NJWkU7XG5cbiAgICBpZiAodGhpcy5zcGVjLmludmFsaWRhdGlvbnMuaW5kZXhPZihpZHgpID09PSAtMSkge1xuICAgICAgICB0aGlzLnNwZWMuaW52YWxpZGF0aW9ucy5wdXNoKGlkeCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENvcGllcyBhbmQgc2V0cyBhbGwgYnVmZmVycyBmcm9tIGFub3RoZXIgZ2VvbWV0cnkgaW5zdGFuY2UuXG4gKlxuICogQG1ldGhvZCBmcm9tR2VvbWV0cnlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZ2VvbWV0cnkgR2VvbWV0cnkgaW5zdGFuY2UgdG8gY29weSBidWZmZXJzIGZyb20uXG4gKiBAcmV0dXJuIHtPYmplY3R9IGN1cnJlbnQgZ2VvbWV0cnkuXG4gKi9cbkR5bmFtaWNHZW9tZXRyeS5wcm90b3R5cGUuZnJvbUdlb21ldHJ5ID0gZnVuY3Rpb24gZnJvbUdlb21ldHJ5KGdlb21ldHJ5KSB7XG4gICAgdmFyIGxlbiA9IGdlb21ldHJ5LnNwZWMuYnVmZmVyTmFtZXMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdGhpcy5zZXRWZXJ0ZXhCdWZmZXIoXG4gICAgICAgICAgICBnZW9tZXRyeS5zcGVjLmJ1ZmZlck5hbWVzW2ldLFxuICAgICAgICAgICAgZ2VvbWV0cnkuc3BlYy5idWZmZXJWYWx1ZXNbaV0sXG4gICAgICAgICAgICBnZW9tZXRyeS5zcGVjLmJ1ZmZlclNwYWNpbmdzW2ldXG4gICAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiAgU2V0IHRoZSBwb3NpdGlvbnMgb2YgdGhlIHZlcnRpY2VzIGluIHRoaXMgZ2VvbWV0cnkuXG4gKiBcbiAqICBAbWV0aG9kIHNldFZlcnRleFBvc2l0aW9uc1xuICogIEBwYXJhbSB7QXJyYXl9IHZhbHVlIE5ldyB2YWx1ZSBmb3IgdmVydGV4IHBvc2l0aW9uIGJ1ZmZlclxuICogIEByZXR1cm4ge09iamVjdH0gY3VycmVudCBnZW9tZXRyeS5cbiAqL1xuRHluYW1pY0dlb21ldHJ5LnByb3RvdHlwZS5zZXRWZXJ0ZXhQb3NpdGlvbnMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRWZXJ0ZXhCdWZmZXIoJ3BvcycsIHZhbHVlLCAzKTtcbn07XG5cbi8qKlxuICogIFNldCB0aGUgbm9ybWFscyBvbiB0aGlzIGdlb21ldHJ5LlxuICogXG4gKiAgQG1ldGhvZCBzZXROb3JtYWxzXG4gKiAgQHBhcmFtIHtBcnJheX0gdmFsdWUgVmFsdWUgdG8gc2V0IG5vcm1hbCBidWZmZXIgdG8uXG4gKiAgQHJldHVybiB7T2JqZWN0fSBjdXJyZW50IGdlb21ldHJ5LlxuICovXG5EeW5hbWljR2VvbWV0cnkucHJvdG90eXBlLnNldE5vcm1hbHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRWZXJ0ZXhCdWZmZXIoJ25vcm1hbHMnLCB2YWx1ZSwgMyk7XG59O1xuXG4vKipcbiAqICBTZXQgdGhlIHRleHR1cmUgY29vcmRpbmF0ZXMgb24gdGhpcyBnZW9tZXRyeS5cbiAqIFxuICogIEBtZXRob2Qgc2V0VGV4dHVyZUNvb3Jkc1xuICogIEBwYXJhbSB7QXJyYXl9IHZhbHVlIE5ldyB2YWx1ZSBmb3IgdGV4dHVyZSBjb29yZGluYXRlcyBidWZmZXIuXG4gKiAgQHJldHVybiB7T2JqZWN0fSBjdXJyZW50IGdlb21ldHJ5LlxuICovXG5EeW5hbWljR2VvbWV0cnkucHJvdG90eXBlLnNldFRleHR1cmVDb29yZHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRWZXJ0ZXhCdWZmZXIoJ3RleENvb3JkJywgdmFsdWUsIDIpO1xufTtcblxuLyoqXG4gKiAgU2V0IHRoZSB0ZXh0dXJlIGNvb3JkaW5hdGVzIG9uIHRoaXMgZ2VvbWV0cnkuXG4gKiAgQG1ldGhvZCBzZXRUZXh0dXJlQ29vcmRzXG4gKiAgQHBhcmFtIHtBcnJheX0gdmFsdWUgTmV3IHZhbHVlIGZvciBpbmRleCBidWZmZXJcbiAqICBAcmV0dXJuIHtPYmplY3R9IGN1cnJlbnQgZ2VvbWV0cnkuXG4gKi9cbkR5bmFtaWNHZW9tZXRyeS5wcm90b3R5cGUuc2V0SW5kaWNlcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnNldFZlcnRleEJ1ZmZlcignaW5kaWNlcycsIHZhbHVlLCAxKTtcbn07XG5cbi8qKlxuICogIFNldCB0aGUgV2ViR0wgZHJhd2luZyBwcmltaXRpdmUgZm9yIHRoaXMgZ2VvbWV0cnkuXG4gKiAgQG1ldGhvZCBzZXREcmF3VHlwZVxuICogIEBwYXJhbSB7U3RyaW5nfSB0eXBlIE5ldyBkcmF3aW5nIHByaW1pdGl2ZSBmb3IgZ2VvbWV0cnlcbiAqICBAcmV0dXJuIHtPYmplY3R9IGN1cnJlbnQgZ2VvbWV0cnkuXG4gKi9cbkR5bmFtaWNHZW9tZXRyeS5wcm90b3R5cGUuc2V0RHJhd1R5cGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLnNwZWMudHlwZSA9IHZhbHVlLnRvVXBwZXJDYXNlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlICdwb3MnIHZlcnRleCBidWZmZXIgb2YgdGhlIGdlb21ldHJ5LlxuICogQG1ldGhvZCBnZXRWZXJ0ZXhQb3NpdGlvbnNcbiAqIEByZXR1cm4ge0FycmF5fSBWZXJ0ZXggYnVmZmVyLlxuICovXG5EeW5hbWljR2VvbWV0cnkucHJvdG90eXBlLmdldFZlcnRleFBvc2l0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRWZXJ0ZXhCdWZmZXIoJ3BvcycpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSAnbm9ybWFsJyB2ZXJ0ZXggYnVmZmVyIG9mIHRoZSBnZW9tZXRyeS5cbiAqIEBtZXRob2QgZ2V0Tm9ybWFsc1xuICogQHJldHVybiB7QXJyYXl9IFZlcnRleCBCdWZmZXIuXG4gKi9cbkR5bmFtaWNHZW9tZXRyeS5wcm90b3R5cGUuZ2V0Tm9ybWFscyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRWZXJ0ZXhCdWZmZXIoJ25vcm1hbHMnKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgJ3RleHR1cmVDb29yZCcgdmVydGV4IGJ1ZmZlciBvZiB0aGUgZ2VvbWV0cnkuXG4gKiBAbWV0aG9kIGdldFRleHR1cmVDb29yZHNcbiAqIEByZXR1cm4ge0FycmF5fSBWZXJ0ZXggQnVmZmVyLlxuICovXG5EeW5hbWljR2VvbWV0cnkucHJvdG90eXBlLmdldFRleHR1cmVDb29yZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VmVydGV4QnVmZmVyKCd0ZXhDb29yZCcpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEeW5hbWljR2VvbWV0cnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZW9tZXRyeUlkcyA9IDA7XG5cbi8vIFdlYkdMIGRyYXdpbmcgcHJpbWl0aXZlcyBtYXAuIFRoaXMgaXMgZ2VuZXJhdGVkIGluIGdlb21ldHJ5IHRvIFxuLy8gYXZvaWQgY2hyb21lIGRlb3B0aW1pemF0aW9ucyBpbiBXZWJHTFJlbmRlcmVyIGRyYXcgZnVuY3Rpb24uXG4vLyBUT0RPOiByZXR1cm4gZHJhdyB0eXBlIGRhdGEgcmV0cmVpdmFsIHRvIFdlYkdMUmVuZGVyZXIuXG5cbnZhciBEUkFXX1RZUEVTID0ge1xuICAgIFBPSU5UUzogMCxcbiAgICBMSU5FUzogMSxcbiAgICBMSU5FX0xPT1A6IDIsXG4gICAgTElORV9TVFJJUDogMyxcbiAgICBUUklBTkdMRVM6IDQsXG4gICAgVFJJQU5HTEVfU1RSSVA6IDUsXG4gICAgVFJJQU5HTEVfRkFOOiA2XG59O1xuXG4vKipcbiAqIEdlb21ldHJ5IGlzIGEgY29tcG9uZW50IHRoYXQgZGVmaW5lcyB0aGUgZGF0YSB0aGF0IHNob3VsZFxuICogYmUgZHJhd24gdG8gdGhlIHdlYkdMIGNhbnZhcy4gTWFuYWdlcyB2ZXJ0ZXggZGF0YSBhbmQgYXR0cmlidXRlcy5cbiAqXG4gKiBAY2xhc3MgR2VvbWV0cnlcbiAqIEBjb25zdHJ1Y3RvclxuICogXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBJbnN0YW50aWF0aW9uIG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIEdlb21ldHJ5KG9wdGlvbnMpIHtcbiAgICB0aGlzLmlkID0gR2VvbWV0cnlJZHMrKztcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuREVGQVVMVF9CVUZGRVJfU0laRSA9IDM7XG5cbiAgICB0aGlzLnNwZWMgPSB7XG4gICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICBkeW5hbWljOiBmYWxzZSxcbiAgICAgICAgdHlwZTogRFJBV19UWVBFU1sodGhpcy5vcHRpb25zLnR5cGUgPyB0aGlzLm9wdGlvbnMudHlwZS50b1VwcGVyQ2FzZSgpIDogJ1RSSUFOR0xFUycpXSxcbiAgICAgICAgYnVmZmVyTmFtZXM6IFtdLFxuICAgICAgICBidWZmZXJWYWx1ZXM6IFtdLFxuICAgICAgICBidWZmZXJTcGFjaW5nczogW10sXG4gICAgICAgIGludmFsaWRhdGlvbnM6IFtdXG4gICAgfTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuYnVmZmVycykge1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5vcHRpb25zLmJ1ZmZlcnMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjspIHtcbiAgICAgICAgICAgIHRoaXMuc3BlYy5idWZmZXJOYW1lcy5wdXNoKHRoaXMub3B0aW9ucy5idWZmZXJzW2ldLm5hbWUpO1xuICAgICAgICAgICAgdGhpcy5zcGVjLmJ1ZmZlclZhbHVlcy5wdXNoKHRoaXMub3B0aW9ucy5idWZmZXJzW2ldLmRhdGEpO1xuICAgICAgICAgICAgdGhpcy5zcGVjLmJ1ZmZlclNwYWNpbmdzLnB1c2godGhpcy5vcHRpb25zLmJ1ZmZlcnNbaV0uc2l6ZSB8fCB0aGlzLkRFRkFVTFRfQlVGRkVSX1NJWkUpO1xuICAgICAgICAgICAgdGhpcy5zcGVjLmludmFsaWRhdGlvbnMucHVzaChpKyspO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdlb21ldHJ5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVmVjMyA9IHJlcXVpcmUoJ2ZhbW91cy1tYXRoJykuVmVjMztcbnZhciBWZWMyID0gcmVxdWlyZSgnZmFtb3VzLW1hdGgnKS5WZWMyO1xuXG52YXIgb3V0cHV0cyA9IFtcbiAgICBuZXcgVmVjMygpLFxuICAgIG5ldyBWZWMzKCksXG4gICAgbmV3IFZlYzMoKSxcbiAgICBuZXcgVmVjMigpLFxuICAgIG5ldyBWZWMyKClcbl07XG5cbi8qKlxuICogQSBoZWxwZXIgb2JqZWN0IHVzZWQgdG8gY2FsY3VsYXRlIGJ1ZmZlcnMgZm9yIGNvbXBsaWNhdGVkIGdlb21ldHJpZXMuXG4gKiBUYWlsb3JlZCBmb3IgdGhlIFdlYkdMUmVuZGVyZXIsIHVzZWQgYnkgbW9zdCBwcmltaXRpdmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBjbGFzcyBHZW9tZXRyeUhlbHBlclxuICovXG52YXIgR2VvbWV0cnlIZWxwZXIgPSB7fTtcblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgaXRlcmF0ZXMgdGhyb3VnaCB2ZXJ0aWNhbCBhbmQgaG9yaXpvbnRhbCBzbGljZXNcbiAqIGJhc2VkIG9uIGlucHV0IGRldGFpbCwgYW5kIGdlbmVyYXRlcyB2ZXJ0aWNlcyBhbmQgaW5kaWNlcyBmb3IgZWFjaFxuICogc3ViZGl2aXNpb24uXG4gKlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBnZW5lcmF0ZVBhcmFtZXRyaWNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZGV0YWlsWCBBbW91bnQgb2Ygc2xpY2VzIHRvIGl0ZXJhdGUgdGhyb3VnaC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBkZXRhaWxZIEFtb3VudCBvZiBzdGFja3MgdG8gaXRlcmF0ZSB0aHJvdWdoLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBGdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHZlcnRleCBwb3NpdGlvbnMgYXQgZWFjaCBwb2ludC5cbiAqIFxuICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgY29udGFpbmluZyBnZW5lcmF0ZWQgdmVydGljZXMgYW5kIGluZGljZXMuXG4gKi9cbkdlb21ldHJ5SGVscGVyLmdlbmVyYXRlUGFyYW1ldHJpYyA9IGZ1bmN0aW9uIGdlbmVyYXRlUGFyYW1ldHJpYyhkZXRhaWxYLCBkZXRhaWxZLCBmdW5jKSB7XG4gICAgdmFyIHZlcnRpY2VzID0gW10sXG4gICAgICAgIGksIHRoZXRhLCBwaGksIHJlc3VsdCwgajtcblxuICAgIC8vIFdlIG11c3Qgd3JhcCBhcm91bmQgc2xpZ2h0bHkgbW9yZSB0aGFuIG9uY2UgZm9yIHV2IGNvb3JkaW5hdGVzIHRvIGxvb2sgY29ycmVjdC5cblxuICAgIHZhciBYcmFuZ2UgPSBNYXRoLlBJICsgKE1hdGguUEkgLyAoZGV0YWlsWCAtIDEpKTtcbiAgICB2YXIgb3V0ID0gW107XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgZGV0YWlsWCArIDE7IGkrKykge1xuICAgICAgICB0aGV0YSA9IGkgKiBYcmFuZ2UgLyBkZXRhaWxYO1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgZGV0YWlsWTsgaisrKSB7XG4gICAgICAgICAgICBwaGkgPSBqICogMi4wICogWHJhbmdlIC8gZGV0YWlsWTtcbiAgICAgICAgICAgIGZ1bmModGhldGEsIHBoaSwgb3V0KTtcbiAgICAgICAgICAgIHZlcnRpY2VzLnB1c2gob3V0WzBdLCBvdXRbMV0sIG91dFsyXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaW5kaWNlcyA9IFtdLFxuICAgICAgICB2ID0gMCxcbiAgICAgICAgbmV4dDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZGV0YWlsWDsgaSsrKSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBkZXRhaWxZOyBqKyspIHtcbiAgICAgICAgICAgIG5leHQgPSAoaiArIDEpICUgZGV0YWlsWTtcbiAgICAgICAgICAgIGluZGljZXMucHVzaCh2ICsgaiwgdiArIGogKyBkZXRhaWxZLCB2ICsgbmV4dCk7XG4gICAgICAgICAgICBpbmRpY2VzLnB1c2godiArIG5leHQsIHYgKyBqICsgZGV0YWlsWSwgdiArIG5leHQgKyBkZXRhaWxZKTtcbiAgICAgICAgfVxuICAgICAgICB2ICs9IGRldGFpbFk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmVydGljZXM6IHZlcnRpY2VzLFxuICAgICAgICBpbmRpY2VzOiBpbmRpY2VzXG4gICAgfTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIG5vcm1hbHMgYmVsb25naW5nIHRvIGVhY2ggZmFjZSBvZiBhIGdlb21ldHJ5LiAgXG4gKiBBc3N1bWVzIGNsb2Nrd2lzZSBkZWNsYXJhdGlvbiBvZiB2ZXJ0aWNlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGNvbXB1dGVOb3JtYWxzXG4gKlxuICogQHBhcmFtIHtBcnJheX0gdmVydGljZXMgVmVydGljZXMgb2YgYWxsIHBvaW50cyBvbiB0aGUgZ2VvbWV0cnkuXG4gKiBAcGFyYW0ge0FycmF5fSBpbmRpY2VzIEluZGljZXMgZGVjbGFyaW5nIGZhY2VzIG9mIGdlb21ldHJ5LlxuICogQHBhcmFtIHtBcnJheX0gb3V0IEFycmF5IHRvIGJlIGZpbGxlZCBhbmQgcmV0dXJuZWQuXG4gKiBcbiAqIEByZXR1cm4ge0FycmF5fSBDYWxjdWxhdGVkIGZhY2Ugbm9ybWFscy5cbiAqL1xuR2VvbWV0cnlIZWxwZXIuY29tcHV0ZU5vcm1hbHMgPSBmdW5jdGlvbiBjb21wdXRlTm9ybWFscyh2ZXJ0aWNlcywgaW5kaWNlcywgb3V0KSB7XG4gICAgdmFyIG5vcm1hbHMgPSBvdXQgfHwgW107XG4gICAgdmFyIHZlcnRleFRocmVlO1xuICAgIHZhciB2ZXJ0ZXhUd287XG4gICAgdmFyIHZlcnRleE9uZTtcbiAgICB2YXIgaW5kZXhPbmU7XG4gICAgdmFyIGluZGV4VHdvO1xuICAgIHZhciBpbmRleFRocmVlO1xuICAgIHZhciBzdGFydDtcbiAgICB2YXIgZW5kO1xuICAgIHZhciBub3JtYWw7XG4gICAgdmFyIGo7XG4gICAgdmFyIGxlbiA9IGluZGljZXMubGVuZ3RoIC8gMztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaiA9IGkgKiAzO1xuICAgICAgICBpbmRleFR3byA9IGluZGljZXNbaiArIDBdICogMztcbiAgICAgICAgaW5kZXhPbmUgPSBpbmRpY2VzW2ogKyAxXSAqIDM7XG4gICAgICAgIGluZGV4VGhyZWUgPSBpbmRpY2VzW2ogKyAyXSAqIDM7XG5cbiAgICAgICAgb3V0cHV0c1swXS5zZXQodmVydGljZXNbaW5kZXhPbmVdLCB2ZXJ0aWNlc1tpbmRleE9uZSArIDFdLCB2ZXJ0aWNlc1tpbmRleE9uZSArIDJdKTtcbiAgICAgICAgb3V0cHV0c1sxXS5zZXQodmVydGljZXNbaW5kZXhUd29dLCB2ZXJ0aWNlc1tpbmRleFR3byArIDFdLCB2ZXJ0aWNlc1tpbmRleFR3byArIDJdKTtcbiAgICAgICAgb3V0cHV0c1syXS5zZXQodmVydGljZXNbaW5kZXhUaHJlZV0sIHZlcnRpY2VzW2luZGV4VGhyZWUgKyAxXSwgdmVydGljZXNbaW5kZXhUaHJlZSArIDJdKTtcblxuICAgICAgICBub3JtYWwgPSBvdXRwdXRzWzJdLnN1YnRyYWN0KG91dHB1dHNbMF0pLmNyb3NzKG91dHB1dHNbMV0uc3VidHJhY3Qob3V0cHV0c1swXSkpO1xuICAgICAgICBub3JtYWwgPSBub3JtYWwubm9ybWFsaXplKCkudG9BcnJheSgpO1xuXG4gICAgICAgIG5vcm1hbHNbaW5kZXhPbmUgKyAwXSA9IG5vcm1hbFswXTtcbiAgICAgICAgbm9ybWFsc1tpbmRleE9uZSArIDFdID0gbm9ybWFsWzFdO1xuICAgICAgICBub3JtYWxzW2luZGV4T25lICsgMl0gPSBub3JtYWxbMl07XG5cbiAgICAgICAgbm9ybWFsc1tpbmRleFR3byArIDBdID0gbm9ybWFsWzBdO1xuICAgICAgICBub3JtYWxzW2luZGV4VHdvICsgMV0gPSBub3JtYWxbMV07XG4gICAgICAgIG5vcm1hbHNbaW5kZXhUd28gKyAyXSA9IG5vcm1hbFsyXTtcblxuICAgICAgICBub3JtYWxzW2luZGV4VGhyZWUgKyAwXSA9IG5vcm1hbFswXTtcbiAgICAgICAgbm9ybWFsc1tpbmRleFRocmVlICsgMV0gPSBub3JtYWxbMV07XG4gICAgICAgIG5vcm1hbHNbaW5kZXhUaHJlZSArIDJdID0gbm9ybWFsWzJdO1xuICAgIH1cblxuICAgIHJldHVybiBub3JtYWxzO1xufTtcblxuLyoqXG4gKiBEaXZpZGVzIGFsbCBpbnNlcnRlZCB0cmlhbmdsZXMgaW50byBmb3VyIHN1Yi10cmlhbmdsZXMuIEFsdGVycyB0aGVcbiAqIHBhc3NlZCBpbiBhcnJheXMuXG4gKlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBzdWJkaXZpZGVcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBpbmRpY2VzIEluZGljZXMgZGVjbGFyaW5nIGZhY2VzIG9mIGdlb21ldHJ5XG4gKiBAcGFyYW0ge0FycmF5fSB2ZXJ0aWNlcyBWZXJ0aWNlcyBvZiBhbGwgcG9pbnRzIG9uIHRoZSBnZW9tZXRyeVxuICogQHBhcmFtIHtBcnJheX0gdGV4dXR1cmVDb29yZHMgVGV4dHVyZSBjb29yZGluYXRlcyBvZiBhbGwgcG9pbnRzIG9uIHRoZSBnZW9tZXRyeVxuICogXG4gKi9cbkdlb21ldHJ5SGVscGVyLnN1YmRpdmlkZSA9IGZ1bmN0aW9uIHN1YmRpdmlkZShpbmRpY2VzLCB2ZXJ0aWNlcywgdGV4dHVyZUNvb3Jkcykge1xuICAgIHZhciB0cmlhbmdsZUluZGV4ID0gaW5kaWNlcy5sZW5ndGggLyAzLFxuICAgICAgICBhYmMsXG4gICAgICAgIGZhY2UsXG4gICAgICAgIGksIGosIGssIHBvcywgdGV4O1xuXG4gICAgd2hpbGUgKHRyaWFuZ2xlSW5kZXgtLSkge1xuICAgICAgICBmYWNlID0gaW5kaWNlcy5zbGljZSh0cmlhbmdsZUluZGV4ICogMywgdHJpYW5nbGVJbmRleCAqIDMgKyAzKTtcblxuICAgICAgICBwb3MgPSBmYWNlLm1hcChmdW5jdGlvbih2ZXJ0SW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMyh2ZXJ0aWNlc1t2ZXJ0SW5kZXggKiAzXSwgdmVydGljZXNbdmVydEluZGV4ICogMyArIDFdLCB2ZXJ0aWNlc1t2ZXJ0SW5kZXggKiAzICsgMl0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdmVydGljZXMucHVzaC5hcHBseSh2ZXJ0aWNlcywgVmVjMy5zY2FsZShWZWMzLmFkZChwb3NbMF0sIHBvc1sxXSwgb3V0cHV0c1swXSksIDAuNSwgb3V0cHV0c1sxXSkudG9BcnJheSgpKTtcbiAgICAgICAgdmVydGljZXMucHVzaC5hcHBseSh2ZXJ0aWNlcywgVmVjMy5zY2FsZShWZWMzLmFkZChwb3NbMV0sIHBvc1syXSwgb3V0cHV0c1swXSksIDAuNSwgb3V0cHV0c1sxXSkudG9BcnJheSgpKTtcbiAgICAgICAgdmVydGljZXMucHVzaC5hcHBseSh2ZXJ0aWNlcywgVmVjMy5zY2FsZShWZWMzLmFkZChwb3NbMF0sIHBvc1syXSwgb3V0cHV0c1swXSksIDAuNSwgb3V0cHV0c1sxXSkudG9BcnJheSgpKTtcblxuICAgICAgICBpZiAodGV4dHVyZUNvb3Jkcykge1xuICAgICAgICAgICAgdGV4ID0gZmFjZS5tYXAoZnVuY3Rpb24odmVydEluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMyKHRleHR1cmVDb29yZHNbdmVydEluZGV4ICogMl0sIHRleHR1cmVDb29yZHNbdmVydEluZGV4ICogMiArIDFdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGV4dHVyZUNvb3Jkcy5wdXNoLmFwcGx5KHRleHR1cmVDb29yZHMsIFZlYzIuc2NhbGUoVmVjMi5hZGQodGV4WzBdLCB0ZXhbMV0sIG91dHB1dHNbM10pLCAwLjUsIG91dHB1dHNbNF0pLnRvQXJyYXkoKSk7XG4gICAgICAgICAgICB0ZXh0dXJlQ29vcmRzLnB1c2guYXBwbHkodGV4dHVyZUNvb3JkcywgVmVjMi5zY2FsZShWZWMyLmFkZCh0ZXhbMV0sIHRleFsyXSwgb3V0cHV0c1szXSksIDAuNSwgb3V0cHV0c1s0XSkudG9BcnJheSgpKTtcbiAgICAgICAgICAgIHRleHR1cmVDb29yZHMucHVzaC5hcHBseSh0ZXh0dXJlQ29vcmRzLCBWZWMyLnNjYWxlKFZlYzIuYWRkKHRleFswXSwgdGV4WzJdLCBvdXRwdXRzWzNdKSwgMC41LCBvdXRwdXRzWzRdKS50b0FycmF5KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaSA9IHZlcnRpY2VzLmxlbmd0aCAtIDMsIGogPSBpICsgMSwgayA9IGkgKyAyO1xuICAgICAgICBpbmRpY2VzLnB1c2goaSwgaiwgayk7XG4gICAgICAgIGluZGljZXMucHVzaChmYWNlWzBdLCBpLCBrKTtcbiAgICAgICAgaW5kaWNlcy5wdXNoKGksIGZhY2VbMV0sIGopO1xuICAgICAgICBpbmRpY2VzW3RyaWFuZ2xlSW5kZXhdID0gaztcbiAgICAgICAgaW5kaWNlc1t0cmlhbmdsZUluZGV4ICsgMV0gPSBqO1xuICAgICAgICBpbmRpY2VzW3RyaWFuZ2xlSW5kZXggKyAyXSA9IGZhY2VbMl07XG4gICAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGVzIGR1cGxpY2F0ZSBvZiB2ZXJ0aWNlcyB0aGF0IGFyZSBzaGFyZWQgYmV0d2VlbiBmYWNlcy5cbiAqIEFsdGVycyB0aGUgaW5wdXQgdmVydGV4IGFuZCBpbmRleCBhcnJheXMuXG4gKlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBnZXRVbmlxdWVGYWNlc1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHZlcnRpY2VzIFZlcnRpY2VzIG9mIGFsbCBwb2ludHMgb24gdGhlIGdlb21ldHJ5XG4gKiBAcGFyYW0ge0FycmF5fSBpbmRpY2VzIEluZGljZXMgZGVjbGFyaW5nIGZhY2VzIG9mIGdlb21ldHJ5XG4gKiBcbiAqL1xuR2VvbWV0cnlIZWxwZXIuZ2V0VW5pcXVlRmFjZXMgPSBmdW5jdGlvbiBnZXRVbmlxdWVGYWNlcyh2ZXJ0aWNlcywgaW5kaWNlcykge1xuICAgIHZhciB0cmlhbmdsZUluZGV4ID0gaW5kaWNlcy5sZW5ndGggLyAzLFxuICAgICAgICByZWdpc3RlcmVkID0gW10sXG4gICAgICAgIGluZGV4O1xuXG4gICAgd2hpbGUgKHRyaWFuZ2xlSW5kZXgtLSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuXG4gICAgICAgICAgICBpbmRleCA9IGluZGljZXNbdHJpYW5nbGVJbmRleCAqIDMgKyBpXTtcblxuICAgICAgICAgICAgaWYgKHJlZ2lzdGVyZWRbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgdmVydGljZXMucHVzaCh2ZXJ0aWNlc1tpbmRleCAqIDNdLCB2ZXJ0aWNlc1tpbmRleCAqIDMgKyAxXSwgdmVydGljZXNbaW5kZXggKiAzICsgMl0pO1xuICAgICAgICAgICAgICAgIGluZGljZXNbdHJpYW5nbGVJbmRleCAqIDMgKyBpXSA9IHZlcnRpY2VzLmxlbmd0aCAvIDMgLSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWdpc3RlcmVkW2luZGV4XSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIERpdmlkZXMgYWxsIGluc2VydGVkIHRyaWFuZ2xlcyBpbnRvIGZvdXIgc3ViLXRyaWFuZ2xlcyB3aGlsZSBtYWludGFpbmluZ1xuICogYSByYWRpdXMgb2Ygb25lLiBBbHRlcnMgdGhlIHBhc3NlZCBpbiBhcnJheXMuXG4gKlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBzdWJkaXZpZGVcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB2ZXJ0aWNlcyBWZXJ0aWNlcyBvZiBhbGwgcG9pbnRzIG9uIHRoZSBnZW9tZXRyeVxuICogQHBhcmFtIHtBcnJheX0gaW5kaWNlcyBJbmRpY2VzIGRlY2xhcmluZyBmYWNlcyBvZiBnZW9tZXRyeVxuICogXG4gKi9cbkdlb21ldHJ5SGVscGVyLnN1YmRpdmlkZVNwaGVyb2lkID0gZnVuY3Rpb24gc3ViZGl2aWRlU3BoZXJvaWQodmVydGljZXMsIGluZGljZXMpIHtcbiAgICB2YXIgdHJpYW5nbGVJbmRleCA9IGluZGljZXMubGVuZ3RoIC8gMyxcbiAgICAgICAgYWJjLFxuICAgICAgICBmYWNlLFxuICAgICAgICBpLCBqLCBrO1xuXG4gICAgd2hpbGUgKHRyaWFuZ2xlSW5kZXgtLSkge1xuICAgICAgICBmYWNlID0gaW5kaWNlcy5zbGljZSh0cmlhbmdsZUluZGV4ICogMywgdHJpYW5nbGVJbmRleCAqIDMgKyAzKTtcbiAgICAgICAgYWJjID0gZmFjZS5tYXAoZnVuY3Rpb24odmVydEluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlYzModmVydGljZXNbdmVydEluZGV4ICogM10sIHZlcnRpY2VzW3ZlcnRJbmRleCAqIDMgKyAxXSwgdmVydGljZXNbdmVydEluZGV4ICogMyArIDJdKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmVydGljZXMucHVzaC5hcHBseSh2ZXJ0aWNlcywgVmVjMy5ub3JtYWxpemUoVmVjMy5hZGQoYWJjWzBdLCBhYmNbMV0sIG91dHB1dHNbMF0pLCBvdXRwdXRzWzFdKS50b0FycmF5KCkpO1xuICAgICAgICB2ZXJ0aWNlcy5wdXNoLmFwcGx5KHZlcnRpY2VzLCBWZWMzLm5vcm1hbGl6ZShWZWMzLmFkZChhYmNbMV0sIGFiY1syXSwgb3V0cHV0c1swXSksIG91dHB1dHNbMV0pLnRvQXJyYXkoKSk7XG4gICAgICAgIHZlcnRpY2VzLnB1c2guYXBwbHkodmVydGljZXMsIFZlYzMubm9ybWFsaXplKFZlYzMuYWRkKGFiY1swXSwgYWJjWzJdLCBvdXRwdXRzWzBdKSwgb3V0cHV0c1sxXSkudG9BcnJheSgpKTtcblxuICAgICAgICBpID0gdmVydGljZXMubGVuZ3RoIC8gMyAtIDMsIGogPSBpICsgMSwgayA9IGkgKyAyO1xuXG4gICAgICAgIGluZGljZXMucHVzaChpLCBqLCBrKTtcbiAgICAgICAgaW5kaWNlcy5wdXNoKGZhY2VbMF0sIGksIGspO1xuICAgICAgICBpbmRpY2VzLnB1c2goaSwgZmFjZVsxXSwgaik7XG4gICAgICAgIGluZGljZXNbdHJpYW5nbGVJbmRleCAqIDNdID0gaztcbiAgICAgICAgaW5kaWNlc1t0cmlhbmdsZUluZGV4ICogMyArIDFdID0gajtcbiAgICAgICAgaW5kaWNlc1t0cmlhbmdsZUluZGV4ICogMyArIDJdID0gZmFjZVsyXTtcbiAgICB9XG59O1xuXG4vKipcbiAqIERpdmlkZXMgYWxsIGluc2VydGVkIHRyaWFuZ2xlcyBpbnRvIGZvdXIgc3ViLXRyaWFuZ2xlcyB3aGlsZSBtYWludGFpbmluZ1xuICogYSByYWRpdXMgb2Ygb25lLiBBbHRlcnMgdGhlIHBhc3NlZCBpbiBhcnJheXMuXG4gKlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBnZXRTcGhlcm9pZE5vcm1hbHNcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB2ZXJ0aWNlcyBWZXJ0aWNlcyBvZiBhbGwgcG9pbnRzIG9uIHRoZSBnZW9tZXRyeVxuICogQHBhcmFtIHtBcnJheX0gb3V0IE9wdGlvbmFsIGFycmF5IHRvIGJlIGZpbGxlZCB3aXRoIHJlc3VsdGluZyBub3JtYWxzLlxuICogXG4gKiBAcmV0dXJuIHtBcnJheX0gbmV3IGxpc3Qgb2YgY2FsY3VsYXRlZCBub3JtYWxzLlxuICovXG5HZW9tZXRyeUhlbHBlci5nZXRTcGhlcm9pZE5vcm1hbHMgPSBmdW5jdGlvbiBnZXRTcGhlcm9pZE5vcm1hbHModmVydGljZXMsIG91dCkge1xuICAgIHZhciBvdXQgPSBvdXQgfHwgW107XG4gICAgdmFyIGxlbmd0aCA9IHZlcnRpY2VzLmxlbmd0aCAvIDM7XG4gICAgdmFyIG5vcm1hbGl6ZWQ7XG5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbm9ybWFsaXplZCA9IG5ldyBWZWMzKFxuICAgICAgICAgICAgdmVydGljZXNbaSAqIDMgKyAwXSxcbiAgICAgICAgICAgIHZlcnRpY2VzW2kgKiAzICsgMV0sXG4gICAgICAgICAgICB2ZXJ0aWNlc1tpICogMyArIDJdXG4gICAgICAgICkubm9ybWFsaXplKCkudG9BcnJheSgpO1xuXG4gICAgICAgIG91dFtpICogMyArIDBdID0gbm9ybWFsaXplZFswXTtcbiAgICAgICAgb3V0W2kgKiAzICsgMV0gPSBub3JtYWxpemVkWzFdO1xuICAgICAgICBvdXRbaSAqIDMgKyAyXSA9IG5vcm1hbGl6ZWRbMl07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0ZXh0dXJlIGNvb3JkaW5hdGVzIGZvciBzcGhlcm9pZCBwcmltaXRpdmVzIGJhc2VkIG9uXG4gKiBpbnB1dCB2ZXJ0aWNlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGdldFNwaGVyb2lkVVZcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB2ZXJ0aWNlcyBWZXJ0aWNlcyBvZiBhbGwgcG9pbnRzIG9uIHRoZSBnZW9tZXRyeVxuICogQHBhcmFtIHtBcnJheX0gb3V0IE9wdGlvbmFsIGFycmF5IHRvIGJlIGZpbGxlZCB3aXRoIHJlc3VsdGluZyB0ZXh0dXJlIGNvb3JkaW5hdGVzLlxuICogXG4gKiBAcmV0dXJuIHtBcnJheX0gbmV3IGxpc3Qgb2YgY2FsY3VsYXRlZCB0ZXh0dXJlIGNvb3JkaW5hdGVzXG4gKi9cbkdlb21ldHJ5SGVscGVyLmdldFNwaGVyb2lkVVYgPSBmdW5jdGlvbiBnZXRTcGhlcm9pZFVWKHZlcnRpY2VzLCBvdXQpIHtcbiAgICB2YXIgb3V0ID0gb3V0IHx8IFtdO1xuICAgIHZhciBsZW5ndGggPSB2ZXJ0aWNlcy5sZW5ndGggLyAzO1xuICAgIHZhciB2ZXJ0ZXg7XG5cbiAgICB2YXIgdXYgPSBbXTtcblxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2ZXJ0ZXggPSBvdXRwdXRzWzBdLnNldChcbiAgICAgICAgICAgIHZlcnRpY2VzW2kgKiAzXSxcbiAgICAgICAgICAgIHZlcnRpY2VzW2kgKiAzICsgMV0sXG4gICAgICAgICAgICB2ZXJ0aWNlc1tpICogMyArIDJdXG4gICAgICAgIClcbiAgICAgICAgLm5vcm1hbGl6ZSgpXG4gICAgICAgIC50b0FycmF5KCk7XG5cbiAgICAgICAgdXZbMF0gPSB0aGlzLmdldEF6aW11dGgodmVydGV4KSAqIDAuNSAvIE1hdGguUEkgKyAwLjU7XG4gICAgICAgIHV2WzFdID0gdGhpcy5nZXRBbHRpdHVkZSh2ZXJ0ZXgpIC8gTWF0aC5QSSArIDAuNTtcblxuICAgICAgICBvdXQucHVzaC5hcHBseShvdXQsIHV2KTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGFuZCBub3JtYWxpemVzIGEgbGlzdCBvZiB2ZXJ0aWNlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIG5vcm1hbGl6ZUFsbFxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHZlcnRpY2VzIFZlcnRpY2VzIG9mIGFsbCBwb2ludHMgb24gdGhlIGdlb21ldHJ5XG4gKiBAcGFyYW0ge0FycmF5fSBvdXQgT3B0aW9uYWwgYXJyYXkgdG8gYmUgZmlsbGVkIHdpdGggcmVzdWx0aW5nIG5vcm1hbGl6ZWQgdmVjdG9ycy5cbiAqIFxuICogQHJldHVybiB7QXJyYXl9IG5ldyBsaXN0IG9mIG5vcm1hbGl6ZWQgdmVydGljZXNcbiAqL1xuR2VvbWV0cnlIZWxwZXIubm9ybWFsaXplQWxsID0gZnVuY3Rpb24gbm9ybWFsaXplQWxsKHZlcnRpY2VzLCBvdXQpIHtcbiAgICB2YXIgb3V0ID0gb3V0IHx8IFtdO1xuICAgIHZhciB2ZXJ0ZXg7XG4gICAgdmFyIGxlbiA9IHZlcnRpY2VzLmxlbmd0aCAvIDM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KG91dCwgbmV3IFZlYzModmVydGljZXNbaSAqIDNdLCB2ZXJ0aWNlc1tpICogMyArIDFdLCB2ZXJ0aWNlc1tpICogMyArIDJdKS5ub3JtYWxpemUoKS50b0FycmF5KCkpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZXMgYSBzZXQgb2YgdmVydGljZXMgdG8gbW9kZWwgc3BhY2UuXG4gKlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBub3JtYWxpemVWZXJ0aWNlc1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHZlcnRpY2VzIFZlcnRpY2VzIG9mIGFsbCBwb2ludHMgb24gdGhlIGdlb21ldHJ5XG4gKiBAcGFyYW0ge0FycmF5fSBvdXQgT3B0aW9uYWwgYXJyYXkgdG8gYmUgZmlsbGVkIHdpdGggbW9kZWwgc3BhY2UgcG9zaXRpb24gdmVjdG9ycy5cbiAqIFxuICogQHJldHVybiB7QXJyYXl9IE91dHB1dCB2ZXJ0aWNlcy5cbiAqL1xuR2VvbWV0cnlIZWxwZXIubm9ybWFsaXplVmVydGljZXMgPSBmdW5jdGlvbiBub3JtYWxpemVWZXJ0aWNlcyh2ZXJ0aWNlcywgb3V0KSB7XG4gICAgdmFyIG91dCA9IG91dCB8fCBbXTtcbiAgICB2YXIgbGVuID0gdmVydGljZXMubGVuZ3RoIC8gMztcbiAgICB2YXIgdmVjdG9ycyA9IFtdO1xuICAgIHZhciBtaW5YO1xuICAgIHZhciBtYXhYO1xuICAgIHZhciBtaW5ZO1xuICAgIHZhciBtYXhZO1xuICAgIHZhciBtaW5aO1xuICAgIHZhciBtYXhaO1xuICAgIHZhciB2O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2ID0gdmVjdG9yc1tpXSA9IG5ldyBWZWMzKFxuICAgICAgICAgICAgdmVydGljZXNbaSAqIDNdLFxuICAgICAgICAgICAgdmVydGljZXNbaSAqIDMgKyAxXSxcbiAgICAgICAgICAgIHZlcnRpY2VzW2kgKiAzICsgMl1cbiAgICAgICAgKTtcblxuICAgICAgICBpZiAobWluWCA9PSBudWxsIHx8IHYueCA8IG1pblgpIG1pblggPSB2Lng7XG4gICAgICAgIGlmIChtYXhYID09IG51bGwgfHwgdi54ID4gbWF4WCkgbWF4WCA9IHYueDtcblxuICAgICAgICBpZiAobWluWSA9PSBudWxsIHx8IHYueSA8IG1pblkpIG1pblkgPSB2Lnk7XG4gICAgICAgIGlmIChtYXhZID09IG51bGwgfHwgdi55ID4gbWF4WSkgbWF4WSA9IHYueTtcblxuICAgICAgICBpZiAobWluWiA9PSBudWxsIHx8IHYueiA8IG1pblopIG1pblogPSB2Lno7XG4gICAgICAgIGlmIChtYXhaID09IG51bGwgfHwgdi56ID4gbWF4WikgbWF4WiA9IHYuejtcbiAgICB9O1xuXG4gICAgdmFyIHRyYW5zbGF0aW9uID0gbmV3IFZlYzMoXG4gICAgICAgIGdldFRyYW5zbGF0aW9uRmFjdG9yKG1heFgsIG1pblgpLFxuICAgICAgICBnZXRUcmFuc2xhdGlvbkZhY3RvcihtYXhZLCBtaW5ZKSxcbiAgICAgICAgZ2V0VHJhbnNsYXRpb25GYWN0b3IobWF4WiwgbWluWilcbiAgICApO1xuXG4gICAgdmFyIHNjYWxlID0gTWF0aC5taW4oXG4gICAgICAgIGdldFNjYWxlRmFjdG9yKG1heFggKyB0cmFuc2xhdGlvbi54LCBtaW5YICsgdHJhbnNsYXRpb24ueCksXG4gICAgICAgIGdldFNjYWxlRmFjdG9yKG1heFkgKyB0cmFuc2xhdGlvbi55LCBtaW5ZICsgdHJhbnNsYXRpb24ueSksXG4gICAgICAgIGdldFNjYWxlRmFjdG9yKG1heFogKyB0cmFuc2xhdGlvbi56LCBtaW5aICsgdHJhbnNsYXRpb24ueilcbiAgICApO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG91dC5wdXNoLmFwcGx5KG91dCwgdmVjdG9yc1tpXS5hZGQodHJhbnNsYXRpb24pLnNjYWxlKHNjYWxlKS50b0FycmF5KCkpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgdHJhbnNsYXRpb24gYW1vdW50IGZvciBhIGdpdmVuIGF4aXMgdG8gbm9ybWFsaXplIG1vZGVsIGNvb3JkaW5hdGVzLlxuICpcbiAqIEBtZXRob2QgZ2V0VHJhbnNsYXRpb25GYWN0b3JcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1heCBNYXhpbXVtIHBvc2l0aW9uIHZhbHVlIG9mIGdpdmVuIGF4aXMgb24gdGhlIG1vZGVsLlxuICogQHBhcmFtIHtOdW1iZXJ9IG1pbiBNaW5pbXVtIHBvc2l0aW9uIHZhbHVlIG9mIGdpdmVuIGF4aXMgb24gdGhlIG1vZGVsLlxuICpcbiAqIEByZXR1cm4ge051bWJlcn0gTnVtYmVyIGJ5IHdoaWNoIHRoZSBnaXZlbiBheGlzIHNob3VsZCBiZSB0cmFuc2xhdGVkIGZvciBhbGwgdmVydGljZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFRyYW5zbGF0aW9uRmFjdG9yKG1heCwgbWluKSB7XG4gICAgcmV0dXJuIC0obWluICsgKG1heCAtIG1pbikgLyAyKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHNjYWxlIGFtb3VudCBmb3IgYSBnaXZlbiBheGlzIHRvIG5vcm1hbGl6ZSBtb2RlbCBjb29yZGluYXRlcy5cbiAqXG4gKiBAbWV0aG9kIGdldFNjYWxlRmFjdG9yXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXggTWF4aW11bSBzY2FsZSB2YWx1ZSBvZiBnaXZlbiBheGlzIG9uIHRoZSBtb2RlbC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBtaW4gTWluaW11bSBzY2FsZSB2YWx1ZSBvZiBnaXZlbiBheGlzIG9uIHRoZSBtb2RlbC5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IE51bWJlciBieSB3aGljaCB0aGUgZ2l2ZW4gYXhpcyBzaG91bGQgYmUgc2NhbGVkIGZvciBhbGwgdmVydGljZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFNjYWxlRmFjdG9yKG1heCwgbWluKSB7XG4gICAgcmV0dXJuIDEgLyAoKG1heCAtIG1pbikgLyAyKTtcbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgYXppbXV0aCwgb3IgYW5nbGUgYWJvdmUgdGhlIFhZIHBsYW5lLCBvZiBhIGdpdmVuIHZlY3Rvci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGdldEF6aW11dGhcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB2IFZlcnRleCB0byByZXRyZWl2ZSBhemltdXRoIGZyb20uXG4gKiBcbiAqIEByZXR1cm4ge051bWJlcn0gQXppbXV0aCB2YWx1ZSBpbiByYWRpYW5zLiBcbiAqL1xuR2VvbWV0cnlIZWxwZXIuZ2V0QXppbXV0aCA9IGZ1bmN0aW9uIGF6aW11dGgodikge1xuICAgIHJldHVybiBNYXRoLmF0YW4yKHZbMl0sIC12WzBdKTtcbn07XG5cbi8qKlxuICogRmluZHMgdGhlIGFsdGl0dWRlLCBvciBhbmdsZSBhYm92ZSB0aGUgWFogcGxhbmUsIG9mIGEgZ2l2ZW4gdmVjdG9yLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZ2V0QWx0aXR1ZGVcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB2IFZlcnRleCB0byByZXRyZWl2ZSBhbHRpdHVkZSBmcm9tLlxuICogXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IEFsdGl0dWRlIHZhbHVlIGluIHJhZGlhbnMuIFxuICovXG5HZW9tZXRyeUhlbHBlci5nZXRBbHRpdHVkZSA9IGZ1bmN0aW9uIGFsdGl0dWRlKHYpIHtcbiAgICByZXR1cm4gTWF0aC5hdGFuMigtdlsxXSwgTWF0aC5zcXJ0KCh2WzBdICogdlswXSkgKyAodlsyXSAqIHZbMl0pKSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgbGlzdCBvZiBpbmRpY2VzIGZyb20gJ3RyaWFuZ2xlJyB0byAnbGluZScgZm9ybWF0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgdHJpYW5nbGVzVG9MaW5lc1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGluZGljZXMgSW5kaWNlcyBvZiBhbGwgZmFjZXMgb24gdGhlIGdlb21ldHJ5XG4gKiBcbiAqIEByZXR1cm4ge0FycmF5fSBuZXcgbGlzdCBvZiBsaW5lLWZvcm1hdHRlZCBpbmRpY2VzXG4gKi9cbkdlb21ldHJ5SGVscGVyLnRyaWFuZ2xlc1RvTGluZXMgPSBmdW5jdGlvbiB0cmlhbmdsZVRvTGluZXMoaW5kaWNlcywgb3V0KSB7XG4gICAgdmFyIG51bVZlY3RvcnMgPSBpbmRpY2VzLmxlbmd0aCAvIDM7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIHZhciBmYWNlO1xuICAgIHZhciBqO1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG51bVZlY3RvcnM7IGkrKykge1xuICAgICAgICBvdXQucHVzaChpbmRpY2VzW2kgKyAwXSwgaW5kaWNlc1tpICsgMV0pO1xuICAgICAgICBvdXQucHVzaChpbmRpY2VzW2kgKyAxXSwgaW5kaWNlc1tpICsgMl0pO1xuICAgICAgICBvdXQucHVzaChpbmRpY2VzW2kgKyAyXSwgaW5kaWNlc1tpICsgMF0pO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdlb21ldHJ5SGVscGVyO1xuIiwidmFyIGxvYWRVUkwgICAgICAgID0gcmVxdWlyZSgnZmFtb3VzLXV0aWxpdGllcycpLmxvYWRVUkw7XG52YXIgR2VvbWV0cnlIZWxwZXIgPSByZXF1aXJlKCcuL0dlb21ldHJ5SGVscGVyJyk7XG5cbi8qXG4gKiBBIHNpbmdsZXRvbiBvYmplY3QgdGhhdCB0YWtlcyB0aGF0IG1ha2VzIHJlcXVlc3RzXG4gKiBmb3IgT0JKIGZpbGVzIGFuZCByZXR1cm5zIHRoZSBmb3JtYXR0ZWQgZGF0YSBhc1xuICogYW4gYXJndW1lbnQgdG8gYSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAY2xhc3MgT0JKTG9hZGVyXG4gKi9cblxudmFyIE9CSkxvYWRlciA9IHtcbiAgICBjYWNoZWQ6IHt9LFxuICAgIHJlcXVlc3RzOiB7fVxufTtcblxuLypcbiAqIFRha2VzIGEgcGF0aCB0byBkZXNpcmVkIG9iaiBmaWxlIGFuZCBtYWtlcyBhbiBYTUxIdHRwIHJlcXVlc3RcbiAqIGlmIHRoZSByZXNvdXJjZSBpcyBub3QgY2FjaGVkLiBTZXRzIHVwIHRoZSAnb25yZXNwb25zZScgZnVuY3Rpb25cbiAqIGFzIGEgY2FsbGJhY2sgZm9yIGZvcm1hdHRpbmcgYW5kIGNhbGxiYWNrIGludm9jYXRpb24uXG4gKlxuICogQG1ldGhvZCBsb2FkXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybCBVUkwgb2YgZGVzaXJlZCBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIEZ1bmN0aW9uIHRvIGJlIGZpcmVkIHVwb24gc3VjY2Vzc2Z1bCBmb3JtYXR0aW5nIG9mIG9ialxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBoYXNoIHRvIHRoYXQgY2FuIGFmZmVjdCB0aGUgb3V0cHV0IG9mIHRoZSBPQkpcbiAqIHZlcnRpY2VzLlxuICovXG5PQkpMb2FkZXIubG9hZCA9IGZ1bmN0aW9uIGxvYWQodXJsLCBjYiwgb3B0aW9ucykge1xuICAgIGlmICghIHRoaXMuY2FjaGVkW3VybF0pIHtcbiAgICAgICAgaWYoISB0aGlzLnJlcXVlc3RzW3VybF0pIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdHNbdXJsXSA9IFtjYl07XG4gICAgICAgICAgICBsb2FkVVJMKFxuICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICB0aGlzLl9vbnN1Y2Nlc3MuYmluZChcbiAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdHNbdXJsXS5wdXNoKGNiKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNiKHRoaXMuY2FjaGVkW3VybF0pO1xuICAgIH1cbn07XG5cbi8qXG4gKiBGaXJlZCBvbiByZXNwb25zZSBmcm9tIHNlcnZlciBmb3IgT0JKIGFzc2V0LiAgRm9ybWF0cyB0aGVcbiAqIHJldHVybmVkIHN0cmluZyBhbmQgc3RvcmVzIHRoZSBidWZmZXIgZGF0YSBpbiBjYWNoZS5cbiAqIEludm9rZXMgYWxsIHF1ZXVlZCBjYWxsYmFja3MgYmVmb3JlIGNsZWFyaW5nIHRoZW0uXG4gKlxuICogQG1ldGhvZCBfb25zdWNjZXNzXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBVUkwgb2YgcmVxdWVzdGVkIG9ialxuICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSBkZXRlcm1pbmluZyB3aGV0aGVyIG9yIG5vdCB0byBtYW51YWxseSBjYWxjdWxhdGUgbm9ybWFsc1xuICogQHBhcmFtIHtTdHJpbmd9IGNvbnRlbnQgb2YgdGhlIHNlcnZlciByZXNwb25zZVxuICovXG5PQkpMb2FkZXIuX29uc3VjY2VzcyA9IGZ1bmN0aW9uIF9vbnN1Y2Nlc3ModXJsLCBvcHRpb25zLCB0ZXh0KSB7XG4gICAgdmFyIGJ1ZmZlcnMgPSBmb3JtYXQuY2FsbCh0aGlzLCB0ZXh0LCBvcHRpb25zIHx8IHt9KTtcbiAgICB0aGlzLmNhY2hlZFt1cmxdID0gYnVmZmVycztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yZXF1ZXN0c1t1cmxdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdHNbdXJsXVtpXShidWZmZXJzKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlcXVlc3RzW3VybF0gPSBudWxsO1xufTtcblxuLypcbiAqIFRha2VzIHJhdyBzdHJpbmcgZm9ybWF0IG9mIG9iaiBhbmQgY29udmVydHMgaXQgdG8gYSBqYXZhc2NyaXB0XG4gKiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBidWZmZXJzIG5lZWRlZCB0byBkcmF3IHRoZSBnZW9tZXRyeS5cbiAqXG4gKiBAbWV0aG9kIGZvcm1hdFxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmF3IG9iaiBkYXRhIGluIHRleHQgZm9ybWF0XG4gKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIGRldGVybWluaW5nIHdoZXRoZXIgb3Igbm90IHRvIG1hbnVhbGx5IGNhbGN1bGF0ZSBub3JtYWxzXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSB2ZXJ0ZXggYnVmZmVyIGRhdGFcbiAqL1xuZnVuY3Rpb24gZm9ybWF0KHRleHQsIG9wdGlvbnMpIHtcbiAgICB2YXIgdGV4dCA9IHNhbml0aXplKHRleHQpO1xuXG4gICAgdmFyIGxpbmVzID0gdGV4dC5zcGxpdCgnXFxuJyk7XG5cbiAgICB2YXIgZmFjZVRleENvb3JkcyA9IFtdO1xuICAgIHZhciBmYWNlVmVydGljZXMgPSBbXTtcbiAgICB2YXIgZmFjZU5vcm1hbHMgPSBbXTtcblxuICAgIHZhciBub3JtYWxzID0gW107XG4gICAgdmFyIHRleENvb3JkcyA9IFtdO1xuICAgIHZhciB2ZXJ0aWNlcyA9IFtdO1xuXG4gICAgdmFyIGkxLCBpMiwgaTMsIGk0O1xuICAgIHZhciBzcGxpdDtcbiAgICB2YXIgbGluZTtcblxuICAgIHZhciBsZW5ndGggPSBsaW5lcy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxpbmUgPSBsaW5lc1tpXTtcbiAgICAgICAgc3BsaXQgPSBsaW5lc1tpXS5zcGxpdCgnICcpO1xuXG4gICAgICAgIC8vIEhhbmRsZSB2ZXJ0ZXggcG9zaXRpb25zXG5cbiAgICAgICAgaWYgKGxpbmUuaW5kZXhPZigndiAnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHZlcnRpY2VzLnB1c2goW1xuICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoc3BsaXRbMV0pLFxuICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoc3BsaXRbMl0pLFxuICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoc3BsaXRbM10pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZSB0ZXh0dXJlIGNvb3JkaW5hdGVzXG5cbiAgICAgICAgZWxzZSBpZihsaW5lLmluZGV4T2YoJ3Z0ICcpICE9PSAtMSkge1xuICAgICAgICAgICAgdGV4Q29vcmRzLnB1c2goW1xuICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoc3BsaXRbMV0pLFxuICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoc3BsaXRbMl0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZSB2ZXJ0ZXggbm9ybWFsc1xuXG4gICAgICAgIGVsc2UgaWYgKGxpbmUuaW5kZXhPZigndm4gJykgIT09IC0xKSB7XG4gICAgICAgICAgICBub3JtYWxzLnB1c2goW1xuICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoc3BsaXRbMV0pLFxuICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoc3BsaXRbMl0pLFxuICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoc3BsaXRbM10pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZSBmYWNlXG5cbiAgICAgICAgZWxzZSBpZiAobGluZS5pbmRleE9mKCdmICcpICE9PSAtMSkge1xuXG4gICAgICAgICAgICAvLyBWZXJ0ZXgsIE5vcm1hbFxuXG4gICAgICAgICAgICBpZiAoc3BsaXRbMV0uaW5kZXhPZignLy8nKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpMSA9IHNwbGl0WzFdLnNwbGl0KCcvLycpO1xuICAgICAgICAgICAgICAgIGkyID0gc3BsaXRbMl0uc3BsaXQoJy8vJyk7XG4gICAgICAgICAgICAgICAgaTMgPSBzcGxpdFszXS5zcGxpdCgnLy8nKTtcblxuICAgICAgICAgICAgICAgIGZhY2VWZXJ0aWNlcy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChpMVswXSkgLSAxLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGkyWzBdKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoaTNbMF0pIC0gMVxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIGZhY2VOb3JtYWxzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGkxWzFdKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoaTJbMV0pIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChpM1sxXSkgLSAxXG4gICAgICAgICAgICAgICAgXSk7XG5cbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgcXVhZFxuXG4gICAgICAgICAgICAgICAgaWYgKHNwbGl0WzRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGk0ID0gc3BsaXRbNF0uc3BsaXQoJy8vJyk7XG4gICAgICAgICAgICAgICAgICAgIGZhY2VWZXJ0aWNlcy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoaTFbMF0pIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoaTNbMF0pIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoaTRbMF0pIC0gMVxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgZmFjZU5vcm1hbHMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGkxWzJdKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGkzWzJdKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGk0WzJdKSAtIDFcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBWZXJ0ZXgsIFRleENvb3JkLCBOb3JtYWxcblxuICAgICAgICAgICAgZWxzZSBpZiAoc3BsaXRbMV0uaW5kZXhPZignLycpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGkxID0gc3BsaXRbMV0uc3BsaXQoJy8nKTtcbiAgICAgICAgICAgICAgICBpMiA9IHNwbGl0WzJdLnNwbGl0KCcvJyk7XG4gICAgICAgICAgICAgICAgaTMgPSBzcGxpdFszXS5zcGxpdCgnLycpO1xuXG4gICAgICAgICAgICAgICAgZmFjZVZlcnRpY2VzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGkxWzBdKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoaTJbMF0pIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChpM1swXSkgLSAxXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgZmFjZVRleENvb3Jkcy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChpMVsxXSkgLSAxLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGkyWzFdKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoaTNbMV0pIC0gMVxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIGZhY2VOb3JtYWxzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGkxWzJdKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoaTJbMl0pIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChpM1syXSkgLSAxXG4gICAgICAgICAgICAgICAgXSk7XG5cbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgUXVhZFxuXG4gICAgICAgICAgICAgICAgaWYgKHNwbGl0WzRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGk0ID0gc3BsaXRbNF0uc3BsaXQoJy8nKTtcblxuICAgICAgICAgICAgICAgICAgICBmYWNlVmVydGljZXMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGkxWzBdKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGkzWzBdKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGk0WzBdKSAtIDFcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgIGZhY2VUZXhDb29yZHMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGkxWzFdKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGkzWzFdKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGk0WzFdKSAtIDFcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgIGZhY2VOb3JtYWxzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChpMVsyXSkgLSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChpM1syXSkgLSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChpNFsyXSkgLSAxXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVmVydGV4XG5cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZhY2VWZXJ0aWNlcy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChzcGxpdFsxXSkgLSAxLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHNwbGl0WzJdKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoc3BsaXRbM10pIC0gMVxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIGZhY2VUZXhDb29yZHMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoc3BsaXRbMV0pIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChzcGxpdFsyXSkgLSAxLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHNwbGl0WzNdKSAtIDFcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICBmYWNlTm9ybWFscy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChzcGxpdFsxXSkgLSAxLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHNwbGl0WzJdKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoc3BsaXRbM10pIC0gMVxuICAgICAgICAgICAgICAgIF0pO1xuXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIFF1YWRcblxuICAgICAgICAgICAgICAgIGlmIChzcGxpdFs0XSkge1xuICAgICAgICAgICAgICAgICAgICBmYWNlVmVydGljZXMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHNwbGl0WzFdKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHNwbGl0WzNdKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHNwbGl0WzRdKSAtIDFcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgIGZhY2VUZXhDb29yZHMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHNwbGl0WzFdKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHNwbGl0WzNdKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHNwbGl0WzRdKSAtIDFcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgIGZhY2VOb3JtYWxzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChzcGxpdFsxXSkgLSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChzcGxpdFszXSkgLSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChzcGxpdFs0XSkgLSAxXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjYWNoZWQgPSBjYWNoZVZlcnRpY2VzKFxuICAgICAgICB2ZXJ0aWNlcyxcbiAgICAgICAgbm9ybWFscyxcbiAgICAgICAgdGV4Q29vcmRzLFxuICAgICAgICBmYWNlVmVydGljZXMsXG4gICAgICAgIGZhY2VOb3JtYWxzLFxuICAgICAgICBmYWNlVGV4Q29vcmRzXG4gICAgKTtcblxuXG4gICAgY2FjaGVkLnZlcnRpY2VzID0gZmxhdHRlbihjYWNoZWQudmVydGljZXMpO1xuICAgIGNhY2hlZC5ub3JtYWxzID0gZmxhdHRlbihjYWNoZWQubm9ybWFscyk7XG4gICAgY2FjaGVkLnRleENvb3JkcyA9IGZsYXR0ZW4oY2FjaGVkLnRleENvb3Jkcyk7XG4gICAgY2FjaGVkLmluZGljZXMgPSBmbGF0dGVuKGNhY2hlZC5pbmRpY2VzKTtcblxuICAgIGlmIChvcHRpb25zLm5vcm1hbGl6ZSkge1xuICAgICAgICBjYWNoZWQudmVydGljZXMgPSBHZW9tZXRyeUhlbHBlci5ub3JtYWxpemVWZXJ0aWNlcyhcbiAgICAgICAgICAgIGNhY2hlZC52ZXJ0aWNlc1xuICAgICAgICApO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmNvbXB1dGVOb3JtYWxzKSB7XG4gICAgICAgIGNhY2hlZC5ub3JtYWxzID0gR2VvbWV0cnlIZWxwZXIuY29tcHV0ZU5vcm1hbHMoXG4gICAgICAgICAgICBjYWNoZWQudmVydGljZXMsXG4gICAgICAgICAgICBjYWNoZWQuaW5kaWNlc1xuICAgICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHZlcnRpY2VzOiBjYWNoZWQudmVydGljZXMsXG4gICAgICAgIG5vcm1hbHM6IGNhY2hlZC5ub3JtYWxzLFxuICAgICAgICB0ZXh0dXJlQ29vcmRzOiBjYWNoZWQudGV4Q29vcmRzLFxuICAgICAgICBpbmRpY2VzOiBjYWNoZWQuaW5kaWNlc1xuICAgIH07XG59O1xuXG4vKlxuICogUmVwbGFjZXMgYWxsIGRvdWJsZSBzcGFjZXMgd2l0aCBzaW5nbGUgc3BhY2VzIGFuZCByZW1vdmVzXG4gKiBhbGwgdHJhaWxpbmcgc3BhY2VzIGZyb20gbGluZXMgb2YgYSBnaXZlbiBzdHJpbmcuXG4gKlxuICogQG1ldGhvZCBzYW5pdGl6ZVxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBTdHJpbmcgdG8gYmUgc2FuaXRpemVkLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gc2FuaXRpemVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gc2FuaXRpemUodGV4dCkge1xuICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoLyArKD89ICkvZywnJykucmVwbGFjZSgvXFxzKyQvZywgJycpO1xufVxuXG4vKlxuICogVGFrZXMgYSBnaXZlbiBwb29sIG9mIGF0dHJpYnV0ZXMgYW5kIGZhY2UgZGVmaW5pdGlvbnNcbiAqIGFuZCByZW1vdmVzIGFsbCBkdXBsaWNhdGUgdmVydGljZXMuXG4gKlxuICogQG1ldGhvZCBjYWNoZVZlcnRpY2VzXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHYgUG9vbCBvZiB2ZXJ0aWNlcyB1c2VkIGluIGZhY2UgZGVjbGFyYXRpb25zLlxuICogQHBhcmFtIHtBcnJheX0gbiBQb29sIG9mIG5vcm1hbHMgdXNlZCBpbiBmYWNlIGRlY2xhcmF0aW9ucy5cbiAqIEBwYXJhbSB7QXJyYXl9IHQgUG9vbCBvZiB0ZXh0dXJlQ29vcmRzIHVzZWQgaW4gZmFjZSBkZWNsYXJhdGlvbnMuXG4gKiBAcGFyYW0ge0FycmF5fSBmdiBWZXJ0ZXggcG9zaXRpb25zIGF0IGVhY2ggZmFjZSBpbiB0aGUgT0JKLlxuICogQHBhcmFtIHtBcnJheX0gZm4gTm9ybWFscyBhdCBlYWNoIGZhY2UgaW4gdGhlIE9CSi5cbiAqIEBwYXJhbSB7QXJyYXl9IGZ0IFRleHR1cmUgY29vcmRpbmF0ZXMgYXQgZWFjaCBmYWNlIGluIHRoZSBPQkouXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgdmVydGljZXMsIHRleHR1cmVDb29yZGluYXRlcyBhbmRcbiAqIG5vcm1hbHMgb2YgdGhlIE9CSi5cbiAqL1xuZnVuY3Rpb24gY2FjaGVWZXJ0aWNlcyh2LCBuLCB0LCBmdiwgZm4sIGZ0KSB7XG4gICAgdmFyIG91dE5vcm1hbHMgPSBbXTtcbiAgICB2YXIgb3V0UG9zID0gW107XG4gICAgdmFyIG91dFRleENvb3JkID0gW107XG4gICAgdmFyIG91dEluZGljZXMgPSBbXTtcblxuICAgIHZhciB2ZXJ0ZXhDYWNoZSA9IHt9O1xuXG4gICAgdmFyIHBvc2l0aW9uSW5kZXg7XG4gICAgdmFyIG5vcm1hbEluZGV4O1xuICAgIHZhciB0ZXhDb29yZEluZGV4O1xuXG4gICAgdmFyIGN1cnJlbnRJbmRleCA9IDA7XG4gICAgdmFyIGZ2TGVuZ3RoID0gZnYubGVuZ3RoO1xuICAgIHZhciBmbkxlbmd0aCA9IGZuLmxlbmd0aDtcbiAgICB2YXIgZnRMZW5ndGggPSBmdC5sZW5ndGg7XG4gICAgdmFyIGZhY2VMZW5ndGg7XG4gICAgdmFyIGluZGV4O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmdkxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG91dEluZGljZXNbaV0gPSBbXTtcbiAgICAgICAgZmFjZUxlbmd0aCA9IGZ2W2ldLmxlbmd0aDtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZhY2VMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKGZ0TGVuZ3RoKSB0ZXhDb29yZEluZGV4ID0gZnRbaV1bal07XG4gICAgICAgICAgICBpZiAoZm5MZW5ndGgpIG5vcm1hbEluZGV4ICAgPSBmbltpXVtqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25JbmRleCA9IGZ2W2ldW2pdO1xuXG4gICAgICAgICAgICBpbmRleCA9IHZlcnRleENhY2hlW3Bvc2l0aW9uSW5kZXggKyAnLCcgKyBub3JtYWxJbmRleCArICcsJyArIHRleENvb3JkSW5kZXhdO1xuXG4gICAgICAgICAgICBpZihpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBjdXJyZW50SW5kZXgrKztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0UG9zLnB1c2godltwb3NpdGlvbkluZGV4XSk7XG4gICAgICAgICAgICAgICAgaWYgKGZuTGVuZ3RoKSBvdXROb3JtYWxzLnB1c2gobltub3JtYWxJbmRleF0pO1xuICAgICAgICAgICAgICAgIGlmIChmdExlbmd0aCkgb3V0VGV4Q29vcmQucHVzaCh0W3RleENvb3JkSW5kZXhdKTtcblxuICAgICAgICAgICAgICAgIHZlcnRleENhY2hlW3Bvc2l0aW9uSW5kZXggKyAnLCcgKyBub3JtYWxJbmRleCArICcsJyArIHRleENvb3JkSW5kZXhdID0gaW5kZXg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG91dEluZGljZXNbaV0ucHVzaChpbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB2ZXJ0aWNlczogb3V0UG9zLFxuICAgICAgICBub3JtYWxzOiBvdXROb3JtYWxzLFxuICAgICAgICB0ZXhDb29yZHM6IG91dFRleENvb3JkLFxuICAgICAgICBpbmRpY2VzOiBvdXRJbmRpY2VzXG4gICAgfVxufVxuXG4vKlxuICogRmxhdHRlbnMgYW4gYXJyYXkgb2YgYXJyYXlzLiBOb3QgcmVjdXJzaXZlLiBBc3N1bWVzXG4gKiBhbGwgY2hpbGRyZW4gYXJlIGFycmF5cy5cbiAqXG4gKiBAbWV0aG9kIGZsYXR0ZW5cbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyIElucHV0IGFycmF5IHRvIGJlIGZsYXR0ZW5lZC5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheX0gRmxhdHRlbmVkIHZlcnNpb24gb2YgaW5wdXQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW4oYXJyKSB7XG4gICAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgdmFyIG91dCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBvdXQucHVzaC5hcHBseShvdXQsIGFycltpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBPQkpMb2FkZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIEJveDogcmVxdWlyZSgnLi9wcmltaXRpdmVzL0JveCcpLFxuICAgIENpcmNsZTogcmVxdWlyZSgnLi9wcmltaXRpdmVzL0NpcmNsZScpLFxuICAgIEN5bGluZGVyOiByZXF1aXJlKCcuL3ByaW1pdGl2ZXMvQ3lsaW5kZXInKSxcbiAgICBHZW9kZXNpY1NwaGVyZTogcmVxdWlyZSgnLi9wcmltaXRpdmVzL0dlb2Rlc2ljU3BoZXJlJyksXG4gICAgSWNvc2FoZWRyb246IHJlcXVpcmUoJy4vcHJpbWl0aXZlcy9JY29zYWhlZHJvbicpLFxuICAgIFBhcmFtZXRyaWNDb25lOiByZXF1aXJlKCcuL3ByaW1pdGl2ZXMvUGFyYW1ldHJpY0NvbmUnKSxcbiAgICBQbGFuZTogcmVxdWlyZSgnLi9wcmltaXRpdmVzL1BsYW5lJyksXG4gICAgU3BoZXJlOiByZXF1aXJlKCcuL3ByaW1pdGl2ZXMvU3BoZXJlJyksXG4gICAgVGV0cmFoZWRyb246IHJlcXVpcmUoJy4vcHJpbWl0aXZlcy9UZXRyYWhlZHJvbicpLFxuICAgIFRvcnVzOiByZXF1aXJlKCcuL3ByaW1pdGl2ZXMvVG9ydXMnKSxcbiAgICBUcmlhbmdsZTogcmVxdWlyZSgnLi9wcmltaXRpdmVzL1RyaWFuZ2xlJyksXG4gICAgR2VvbWV0cnlIZWxwZXI6IHJlcXVpcmUoJy4vR2VvbWV0cnlIZWxwZXInKSxcbiAgICBEeW5hbWljR2VvbWV0cnk6IHJlcXVpcmUoJy4vRHluYW1pY0dlb21ldHJ5JyksXG4gICAgR2VvbWV0cnk6IHJlcXVpcmUoJy4vR2VvbWV0cnknKSxcbiAgICBPQkpMb2FkZXI6IHJlcXVpcmUoJy4vT0JKTG9hZGVyJyksXG59OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdlb21ldHJ5ID0gcmVxdWlyZSgnLi4vR2VvbWV0cnknKTtcblxuZnVuY3Rpb24gcGlja09jdGFudChpKSB7XG4gICAgcmV0dXJuIFsoaSAmIDEpICogMiAtIDEsIChpICYgMikgLSAxLCAoaSAmIDQpIC8gMiAtIDFdO1xufVxuXG52YXIgYm94RGF0YSA9IFtcbiAgICBbMCwgNCwgMiwgNiwgLTEsIDAsIDBdLCBcbiAgICBbMSwgMywgNSwgNywgKzEsIDAsIDBdLFxuICAgIFswLCAxLCA0LCA1LCAwLCAtMSwgMF0sXG4gICAgWzIsIDYsIDMsIDcsIDAsICsxLCAwXSxcbiAgICBbMCwgMiwgMSwgMywgMCwgMCwgLTFdLFxuICAgIFs0LCA1LCA2LCA3LCAwLCAwLCArMV1cbl07XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgbmV3IHN0YXRpYyBnZW9tZXRyeSwgd2hpY2ggaXMgcGFzc2VkXG4gKiBjdXN0b20gYnVmZmVyIGRhdGEuXG4gKlxuICogQGNsYXNzIEJveEdlb21ldHJ5XG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBQYXJhbWV0ZXJzIHRoYXQgYWx0ZXIgdGhlXG4gKiB2ZXJ0ZXggYnVmZmVycyBvZiB0aGUgZ2VuZXJhdGVkIGdlb21ldHJ5LlxuICogXG4gKiBAcmV0dXJuIHtPYmplY3R9IGNvbnN0cnVjdGVkIGdlb21ldHJ5XG4gKi9cbmZ1bmN0aW9uIEJveEdlb21ldHJ5KG9wdGlvbnMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB2YXIgdmVydGljZXMgICAgICA9IFtdO1xuICAgIHZhciB0ZXh0dXJlQ29vcmRzID0gW107XG4gICAgdmFyIG5vcm1hbHMgICAgICAgPSBbXTtcbiAgICB2YXIgaW5kaWNlcyAgICAgICA9IFtdO1xuXG4gICAgdmFyIGRhdGE7XG4gICAgdmFyIGQ7XG4gICAgdmFyIHY7XG4gICAgdmFyIGk7XG4gICAgdmFyIGo7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgYm94RGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBkYXRhID0gYm94RGF0YVtpXSwgdiA9IGkgKiA0O1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgICAgICBkID0gZGF0YVtqXTtcbiAgICAgICAgICAgIHZhciBvY3RhbnQgPSBwaWNrT2N0YW50KGQpO1xuICAgICAgICAgICAgdmVydGljZXMucHVzaChvY3RhbnRbMF0sIG9jdGFudFsxXSwgb2N0YW50WzJdKTtcbiAgICAgICAgICAgIHRleHR1cmVDb29yZHMucHVzaChqICYgMSwgKGogJiAyKSAvIDIpO1xuICAgICAgICAgICAgbm9ybWFscy5wdXNoKGRhdGFbNF0sIGRhdGFbNV0sIGRhdGFbNl0pO1xuICAgICAgICB9XG4gICAgICAgIGluZGljZXMucHVzaCh2LCB2ICsgMSwgdiArIDIpO1xuICAgICAgICBpbmRpY2VzLnB1c2godiArIDIsIHYgKyAxLCB2ICsgMyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBHZW9tZXRyeSh7XG4gICAgICAgIGJ1ZmZlcnM6IFtcbiAgICAgICAgICAgIHsgbmFtZTogJ3BvcycsIGRhdGE6IHZlcnRpY2VzIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICd0ZXhDb29yZCcsIGRhdGE6IHRleHR1cmVDb29yZHMsIHNpemU6IDIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ25vcm1hbHMnLCBkYXRhOiBub3JtYWxzIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdpbmRpY2VzJywgZGF0YTogaW5kaWNlcywgc2l6ZTogMSB9XG4gICAgICAgIF1cbiAgICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQm94R2VvbWV0cnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZW9tZXRyeSAgICAgICA9IHJlcXVpcmUoJy4uL0dlb21ldHJ5Jyk7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgbmV3IHN0YXRpYyBnZW9tZXRyeSwgd2hpY2ggaXMgcGFzc2VkXG4gKiBjdXN0b20gYnVmZmVyIGRhdGEuXG4gKlxuICogQGNsYXNzIENpcmNsZVxuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgUGFyYW1ldGVycyB0aGF0IGFsdGVyIHRoZVxuICogdmVydGV4IGJ1ZmZlcnMgb2YgdGhlIGdlbmVyYXRlZCBnZW9tZXRyeS5cbiAqIFxuICogQHJldHVybiB7T2JqZWN0fSBjb25zdHJ1Y3RlZCBnZW9tZXRyeVxuICovXG5mdW5jdGlvbiBDaXJjbGUgKG9wdGlvbnMpIHtcbiAgICB2YXIgb3B0aW9ucyAgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBkZXRhaWwgICA9IG9wdGlvbnMuZGV0YWlsIHx8IDMwO1xuICAgIHZhciBidWZmZXJzICA9IGdldEJ1ZmZlcnMoZGV0YWlsKTtcblxuICAgIHJldHVybiBuZXcgR2VvbWV0cnkoe1xuICAgICAgICB0eXBlOiAnVFJJQU5HTEVfRkFOJyxcbiAgICAgICAgYnVmZmVyczogW1xuICAgICAgICAgICAgeyBuYW1lOiAncG9zJywgZGF0YTogYnVmZmVycy52ZXJ0aWNlcyB9LFxuICAgICAgICAgICAgeyBuYW1lOiAndGV4Q29vcmQnLCBkYXRhOiBidWZmZXJzLnRleHR1cmVDb29yZHMsIHNpemU6IDIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ25vcm1hbHMnLCBkYXRhOiBidWZmZXJzLm5vcm1hbHMgfVxuICAgICAgICBdXG4gICAgfSk7XG59XG4gICAgXG4vKipcbiAqIENhbGN1bGF0ZXMgYW5kIHJldHVybnMgYWxsIHZlcnRleCBwb3NpdGlvbnMsIHRleHR1cmVcbiAqIGNvb3JkaW5hdGVzIGFuZCBub3JtYWxzIG9mIHRoZSBjaXJjbGUgcHJpbWl0aXZlLlxuICpcbiAqIEBtZXRob2QgZ2V0QnVmZmVyc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZXRhaWwgQW1vdW50IG9mIGRldGFpbCB0aGF0IGRldGVybWluZXMgaG93IG1hbnlcbiAqIHZlcnRpY2VzIGFyZSBjcmVhdGVkIGFuZCB3aGVyZSB0aGV5IGFyZSBwbGFjZWRcbiAqIFxuICogQHJldHVybiB7T2JqZWN0fSBjb25zdHJ1Y3RlZCBnZW9tZXRyeVxuICovXG5mdW5jdGlvbiBnZXRCdWZmZXJzKGRldGFpbCkge1xuICAgIHZhciB0aGV0YSA9IDA7XG4gICAgdmFyIHg7XG4gICAgdmFyIHk7XG4gICAgdmFyIGluZGV4ID0gZGV0YWlsICsgMTtcbiAgICB2YXIgbmV4dFRoZXRhO1xuICAgIHZhciB2ZXJ0aWNlcyAgICAgID0gWzAsIDAsIDBdO1xuICAgIHZhciBub3JtYWxzICAgICAgID0gWzAsIDAsIDFdO1xuICAgIHZhciB0ZXh0dXJlQ29vcmRzID0gWzAuNSwgMC41XTtcblxuICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgIHRoZXRhID0gaW5kZXggLyBkZXRhaWwgKiBNYXRoLlBJICogMjtcblxuICAgICAgICB4ID0gTWF0aC5jb3ModGhldGEpLCB5ID0gTWF0aC5zaW4odGhldGEpO1xuICAgICAgICB2ZXJ0aWNlcy51bnNoaWZ0KHgsIHksIDApO1xuICAgICAgICBub3JtYWxzLnVuc2hpZnQoMCwgMCwgMSk7XG4gICAgICAgIHRleHR1cmVDb29yZHMudW5zaGlmdCgwLjUgKyB4ICogMC41LCAwLjUgKyAteSAqIDAuNSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmVydGljZXM6IHZlcnRpY2VzLFxuICAgICAgICBub3JtYWxzOiBub3JtYWxzLFxuICAgICAgICB0ZXh0dXJlQ29vcmRzOiB0ZXh0dXJlQ29vcmRzXG4gICAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDaXJjbGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZW9tZXRyeSAgICAgICA9IHJlcXVpcmUoJy4uL0dlb21ldHJ5Jyk7XG52YXIgR2VvbWV0cnlIZWxwZXIgPSByZXF1aXJlKCcuLi9HZW9tZXRyeUhlbHBlcicpO1xuXG4vKipcbiAqIFRoaXMgY2xhc3MgY3JlYXRlcyBhIG5ldyBnZW9tZXRyeSBpbnN0YW5jZSBhbmQgc2V0c1xuICogaXRzIHZlcnRleCBwb3NpdGlvbnMsIHRleHR1cmUgY29vcmRpbmF0ZXMsIG5vcm1hbHMsXG4gKiBhbmQgaW5kaWNlcyB0byBiYXNlZCBvbiB0aGUgcHJpbWl0aXZlLlxuICpcbiAqIEBjbGFzcyBDeWxpbmRlclxuICogQGNvbnN0cnVjdG9yXG4gKiBcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFBhcmFtZXRlcnMgdGhhdCBhbHRlciB0aGVcbiAqIHZlcnRleCBidWZmZXJzIG9mIHRoZSBnZW5lcmF0ZWQgZ2VvbWV0cnkuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBjb25zdHJ1Y3RlZCBnZW9tZXRyeVxuICovXG5mdW5jdGlvbiBDeWxpbmRlciAob3B0aW9ucykge1xuICAgIHZhciBvcHRpb25zICA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIHJhZGl1cyAgID0gb3B0aW9ucy5yYWRpdXMgfHwgMTtcbiAgICB2YXIgZGV0YWlsICAgPSBvcHRpb25zLmRldGFpbCB8fCAxNTtcbiAgICB2YXIgYnVmZmVycztcblxuICAgIGJ1ZmZlcnMgPSBHZW9tZXRyeUhlbHBlci5nZW5lcmF0ZVBhcmFtZXRyaWMoXG4gICAgICAgIDEsXG4gICAgICAgIGRldGFpbCxcbiAgICAgICAgQ3lsaW5kZXIuZ2VuZXJhdG9yLmJpbmQobnVsbCwgcmFkaXVzKVxuICAgICk7XG5cbiAgICByZXR1cm4gbmV3IEdlb21ldHJ5KHtcbiAgICAgICAgYnVmZmVyczogW1xuICAgICAgICAgICAgeyBuYW1lOiAncG9zJywgZGF0YTogYnVmZmVycy52ZXJ0aWNlcyB9LFxuICAgICAgICAgICAgeyBuYW1lOiAndGV4Q29vcmQnLCBkYXRhOiBHZW9tZXRyeUhlbHBlci5nZXRTcGhlcm9pZFVWKGJ1ZmZlcnMudmVydGljZXMpLCBzaXplOiAyIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdub3JtYWxzJywgZGF0YTogR2VvbWV0cnlIZWxwZXIuY29tcHV0ZU5vcm1hbHMoYnVmZmVycy52ZXJ0aWNlcywgYnVmZmVycy5pbmRpY2VzKSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnaW5kaWNlcycsIGRhdGE6IGJ1ZmZlcnMuaW5kaWNlcywgc2l6ZTogMSB9XG4gICAgICAgIF1cbiAgICB9KTtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiB1c2VkIGluIGl0ZXJhdGl2ZSBjb25zdHJ1Y3Rpb24gb2YgcGFyYW1ldHJpYyBwcmltaXRpdmUuXG4gKlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBnZW5lcmF0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSByIEN5bGluZGVyIHJhZGl1cy5cbiAqIEBwYXJhbSB7TnVtYmVyfSB1IExvbmdpdHVkYWwgcHJvZ3Jlc3MgZnJvbSAwIHRvIFBJLlxuICogQHBhcmFtIHtOdW1iZXJ9IHYgTGF0aXR1ZGFsIHByb2dyZXNzIGZyb20gMCB0byBQSS5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheX0geCwgeSBhbmQgeiBjb29yZGluYXRlIG9mIGdlb21ldHJ5LlxuICovXG5DeWxpbmRlci5nZW5lcmF0b3IgPSBmdW5jdGlvbiBnZW5lcmF0b3IociwgdSwgdiwgcG9zKSB7XG4gICAgcG9zWzBdID0gciAqIE1hdGguY29zKHYpO1xuICAgIHBvc1sxXSA9IHIgKiAoLTEgKyB1IC8gTWF0aC5QSSAqIDIpO1xuICAgIHBvc1syXSA9IHIgKiBNYXRoLnNpbih2KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDeWxpbmRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdlb21ldHJ5ICAgICAgID0gcmVxdWlyZSgnLi4vR2VvbWV0cnknKTtcbnZhciBHZW9tZXRyeUhlbHBlciA9IHJlcXVpcmUoJy4uL0dlb21ldHJ5SGVscGVyJyk7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgbmV3IHN0YXRpYyBnZW9tZXRyeSwgd2hpY2ggaXMgcGFzc2VkXG4gKiBjdXN0b20gYnVmZmVyIGRhdGEuXG4gKlxuICogQGNsYXNzIEdlb2Rlc2ljU3BoZXJlXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBQYXJhbWV0ZXJzIHRoYXQgYWx0ZXIgdGhlXG4gKiB2ZXJ0ZXggYnVmZmVycyBvZiB0aGUgZ2VuZXJhdGVkIGdlb21ldHJ5LlxuICogXG4gKiBAcmV0dXJuIHtPYmplY3R9IGNvbnN0cnVjdGVkIGdlb21ldHJ5XG4gKi9cbmZ1bmN0aW9uIEdlb2Rlc2ljU3BoZXJlIChvcHRpb25zKSB7XG4gICAgdmFyIHQgPSAoMSArIE1hdGguc3FydCg1KSkgKiAwLjU7XG5cbiAgICB2YXIgdmVydGljZXMgPSBbXG4gICAgICAgIC0gMSwgIHQsICAwLCAgICAxLCAgdCwgIDAsICAgLSAxLCAtIHQsICAwLCAgICAxLCAtIHQsICAwLFxuICAgICAgICAgMCwgLSAxLCAtdCwgICAgMCwgIDEsIC10LCAgICAwLCAtIDEsICAgdCwgICAgMCwgIDEsICAgdCxcbiAgICAgICAgIHQsICAwLCAgIDEsICAgIHQsICAwLCAtMSwgICAtIHQsICAwLCAgIDEsICAgLSB0LCAgMCwgLTFcbiAgICBdO1xuICAgIHZhciBpbmRpY2VzID0gW1xuICAgICAgICAwLCAgNSwgMTEsICAgIDAsICAxLCAgNSwgICAgMCwgIDcsICAxLCAgICAwLCAxMCwgIDcsICAgIDAsIDExLCAxMCxcbiAgICAgICAgMSwgIDksICA1LCAgICA1LCAgNCwgMTEsICAgIDExLCAyLCAxMCwgICAxMCwgIDYsICA3LCAgICA3LCAgOCwgIDEsXG4gICAgICAgIDMsICA0LCAgOSwgICAgMywgIDIsICA0LCAgICAzLCAgNiwgIDIsICAgIDMsICA4LCAgNiwgICAgMywgIDksICA4LFxuICAgICAgICA0LCAgNSwgIDksICAgIDIsIDExLCAgNCwgICAgNiwgMTAsICAyLCAgICA4LCAgNywgIDYsICAgIDksICAxLCAgOFxuICAgIF07XG5cbiAgICB2ZXJ0aWNlcyA9IEdlb21ldHJ5SGVscGVyLm5vcm1hbGl6ZUFsbCh2ZXJ0aWNlcyk7XG5cbiAgICB2YXIgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGRldGFpbCAgPSBvcHRpb25zLmRldGFpbCB8fCAzO1xuXG4gICAgd2hpbGUoLS1kZXRhaWwpIEdlb21ldHJ5SGVscGVyLnN1YmRpdmlkZVNwaGVyb2lkKHZlcnRpY2VzLCBpbmRpY2VzKTtcbiAgICBHZW9tZXRyeUhlbHBlci5nZXRVbmlxdWVGYWNlcyh2ZXJ0aWNlcywgaW5kaWNlcyk7XG5cbiAgICB2YXIgbm9ybWFscyAgICAgICA9IEdlb21ldHJ5SGVscGVyLmNvbXB1dGVOb3JtYWxzKHZlcnRpY2VzLCBpbmRpY2VzKTtcbiAgICB2YXIgdGV4dHVyZUNvb3JkcyA9IEdlb21ldHJ5SGVscGVyLmdldFNwaGVyb2lkVVYodmVydGljZXMpO1xuXG4gICAgcmV0dXJuIG5ldyBHZW9tZXRyeSh7XG4gICAgICAgIGJ1ZmZlcnM6IFtcbiAgICAgICAgICAgIHsgbmFtZTogJ3BvcycsIGRhdGE6IHZlcnRpY2VzIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICd0ZXhDb29yZCcsIGRhdGE6IHRleHR1cmVDb29yZHMsIHNpemU6IDIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ25vcm1hbHMnLCBkYXRhOiBub3JtYWxzIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdpbmRpY2VzJywgZGF0YTogaW5kaWNlcywgc2l6ZTogMSB9XG4gICAgICAgIF1cbiAgICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBHZW9kZXNpY1NwaGVyZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdlb21ldHJ5ID0gcmVxdWlyZSgnLi4vR2VvbWV0cnknKTtcbnZhciBHZW9tZXRyeUhlbHBlciA9IHJlcXVpcmUoJy4uL0dlb21ldHJ5SGVscGVyJyk7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgbmV3IHN0YXRpYyBnZW9tZXRyeSwgd2hpY2ggaXMgcGFzc2VkXG4gKiBjdXN0b20gYnVmZmVyIGRhdGEuXG4gKlxuICogQGNsYXNzIEljb3NhaGVkcm9uXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBQYXJhbWV0ZXJzIHRoYXQgYWx0ZXIgdGhlXG4gKiB2ZXJ0ZXggYnVmZmVycyBvZiB0aGUgZ2VuZXJhdGVkIGdlb21ldHJ5LlxuICogXG4gKiBAcmV0dXJuIHtPYmplY3R9IGNvbnN0cnVjdGVkIGdlb21ldHJ5XG4gKi9cbmZ1bmN0aW9uIEljb3NhaGVkcm9uKCkge1xuICAgIHZhciB0ID0gKCAxICsgTWF0aC5zcXJ0KCA1ICkgKSAvIDI7XG5cbiAgICB2YXIgZ2VvbWV0cnk7XG4gICAgdmFyIGRldGFpbDtcbiAgICB2YXIgdmVydGljZXMgPSBbXG4gICAgICAgIC0gMSwgICB0LCAgMCwgICAgMSwgIHQsICAwLCAgIC0gMSwgLSB0LCAgMCwgICAgMSwgLSB0LCAgMCxcbiAgICAgICAgICAwLCAtIDEsIC10LCAgICAwLCAgMSwgLXQsICAgICAwLCAtIDEsICB0LCAgICAwLCAgIDEsICB0LFxuICAgICAgICAgIHQsICAgMCwgIDEsICAgIHQsICAwLCAtMSwgICAtIHQsICAgMCwgIDEsICAtIHQsICAgMCwgLTFcbiAgICBdO1xuICAgIHZhciBpbmRpY2VzID0gW1xuICAgICAgICAwLCAgNSwgMTEsICAgIDAsICAxLCAgNSwgICAgMCwgIDcsICAxLCAgICAwLCAxMCwgIDcsICAgIDAsIDExLCAxMCxcbiAgICAgICAgMSwgIDksICA1LCAgICA1LCAgNCwgMTEsICAgIDExLCAyLCAxMCwgICAxMCwgIDYsICA3LCAgICA3LCAgOCwgIDEsXG4gICAgICAgIDMsICA0LCAgOSwgICAgMywgIDIsICA0LCAgICAzLCAgNiwgIDIsICAgIDMsICA4LCAgNiwgICAgMywgIDksICA4LFxuICAgICAgICA0LCAgNSwgIDksICAgIDIsIDExLCAgNCwgICAgNiwgMTAsICAyLCAgICA4LCAgNywgIDYsICAgIDksICAxLCAgOFxuICAgIF07XG5cbiAgICBHZW9tZXRyeUhlbHBlci5nZXRVbmlxdWVGYWNlcyh2ZXJ0aWNlcywgaW5kaWNlcyk7XG5cbiAgICB2YXIgbm9ybWFscyAgICAgICA9IEdlb21ldHJ5SGVscGVyLmNvbXB1dGVOb3JtYWxzKHZlcnRpY2VzLCBpbmRpY2VzKTtcbiAgICB2YXIgdGV4dHVyZUNvb3JkcyA9IEdlb21ldHJ5SGVscGVyLmdldFNwaGVyb2lkVVYodmVydGljZXMpO1xuXG4gICAgdmVydGljZXMgICAgICA9IEdlb21ldHJ5SGVscGVyLm5vcm1hbGl6ZUFsbCh2ZXJ0aWNlcyk7XG5cbiAgICByZXR1cm4gbmV3IEdlb21ldHJ5KHtcbiAgICAgICAgYnVmZmVyczogW1xuICAgICAgICAgICAgeyBuYW1lOiAncG9zJywgZGF0YTogdmVydGljZXMgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ3RleENvb3JkJywgZGF0YTogdGV4dHVyZUNvb3Jkcywgc2l6ZTogMiB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnbm9ybWFscycsIGRhdGE6IG5vcm1hbHMgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2luZGljZXMnLCBkYXRhOiBpbmRpY2VzLCBzaXplOiAxIH1cbiAgICAgICAgXVxuICAgIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEljb3NhaGVkcm9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2VvbWV0cnkgPSByZXF1aXJlKCcuLi9HZW9tZXRyeScpO1xudmFyIEdlb21ldHJ5SGVscGVyID0gcmVxdWlyZSgnLi4vR2VvbWV0cnlIZWxwZXInKTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSBuZXcgc3RhdGljIGdlb21ldHJ5LCB3aGljaCBpcyBwYXNzZWRcbiAqIGN1c3RvbSBidWZmZXIgZGF0YS5cbiAqXG4gKiBAY2xhc3MgUGFyYW1ldHJpY0NvbmVcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFBhcmFtZXRlcnMgdGhhdCBhbHRlciB0aGVcbiAqIHZlcnRleCBidWZmZXJzIG9mIHRoZSBnZW5lcmF0ZWQgZ2VvbWV0cnkuXG4gKiBcbiAqIEByZXR1cm4ge09iamVjdH0gY29uc3RydWN0ZWQgZ2VvbWV0cnlcbiAqL1xuZnVuY3Rpb24gUGFyYW1ldHJpY0NvbmUgKG9wdGlvbnMpIHtcbiAgICB2YXIgb3B0aW9ucyAgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBkZXRhaWwgICA9IG9wdGlvbnMuZGV0YWlsIHx8IDE1O1xuICAgIHZhciByYWRpdXMgICA9IG9wdGlvbnMucmFkaXVzIHx8IDEgLyBNYXRoLlBJO1xuXG4gICAgdmFyIGJ1ZmZlcnMgPSBHZW9tZXRyeUhlbHBlci5nZW5lcmF0ZVBhcmFtZXRyaWMoXG4gICAgICAgIGRldGFpbCxcbiAgICAgICAgZGV0YWlsLFxuICAgICAgICBQYXJhbWV0cmljQ29uZS5nZW5lcmF0b3IuYmluZChudWxsLCByYWRpdXMpXG4gICAgKTtcblxuICAgIHJldHVybiBuZXcgR2VvbWV0cnkoe1xuICAgICAgICBidWZmZXJzOiBbXG4gICAgICAgICAgICB7IG5hbWU6ICdwb3MnLCBkYXRhOiBidWZmZXJzLnZlcnRpY2VzIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICd0ZXhDb29yZCcsIGRhdGE6IEdlb21ldHJ5SGVscGVyLmdldFNwaGVyb2lkVVYoYnVmZmVycy52ZXJ0aWNlcyksIHNpemU6IDIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ25vcm1hbHMnLCBkYXRhOiBHZW9tZXRyeUhlbHBlci5jb21wdXRlTm9ybWFscyhidWZmZXJzLnZlcnRpY2VzLCBidWZmZXJzLmluZGljZXMpIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdpbmRpY2VzJywgZGF0YTogYnVmZmVycy5pbmRpY2VzLCBzaXplOiAxIH1cbiAgICAgICAgXVxuICAgIH0pO1xufVxuXG4vKipcbiAqIGZ1bmN0aW9uIHVzZWQgaW4gaXRlcmF0aXZlIGNvbnN0cnVjdGlvbiBvZiBwYXJhbWV0cmljIHByaW1pdGl2ZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGdlbmVyYXRvclxuICogQHBhcmFtIHtOdW1iZXJ9IHIgQ29uZSBSYWRpdXMuXG4gKiBAcGFyYW0ge051bWJlcn0gdSBMb25naXR1ZGFsIHByb2dyZXNzIGZyb20gMCB0byBQSS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB2IExhdGl0dWRhbCBwcm9ncmVzcyBmcm9tIDAgdG8gUEkuXG4gKiBAcmV0dXJuIHtBcnJheX0geCwgeSBhbmQgeiBjb29yZGluYXRlIG9mIGdlb21ldHJ5LlxuICovXG5cblBhcmFtZXRyaWNDb25lLmdlbmVyYXRvciA9IGZ1bmN0aW9uIGdlbmVyYXRvcihyLCB1LCB2LCBwb3MpIHtcbiAgICBwb3NbMF0gPSByICogdSAqIE1hdGguc2luKHYpO1xuICAgIHBvc1sxXSA9IC1yICogdSAqIE1hdGguY29zKHYpO1xuICAgIHBvc1syXSA9IC11O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcmFtZXRyaWNDb25lO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2VvbWV0cnkgPSByZXF1aXJlKCcuLi9HZW9tZXRyeScpO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIG5ldyBzdGF0aWMgZ2VvbWV0cnksIHdoaWNoIGlzIHBhc3NlZFxuICogY3VzdG9tIGJ1ZmZlciBkYXRhLlxuICpcbiAqIEBjbGFzcyBQbGFuZVxuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgUGFyYW1ldGVycyB0aGF0IGFsdGVyIHRoZVxuICogdmVydGV4IGJ1ZmZlcnMgb2YgdGhlIGdlbmVyYXRlZCBnZW9tZXRyeS5cbiAqIFxuICogQHJldHVybiB7T2JqZWN0fSBjb25zdHJ1Y3RlZCBnZW9tZXRyeVxuICovXG5mdW5jdGlvbiBQbGFuZShvcHRpb25zKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBkZXRhaWxYID0gb3B0aW9ucy5kZXRhaWxYIHx8IG9wdGlvbnMuZGV0YWlsIHx8IDE7XG4gICAgdmFyIGRldGFpbFkgPSBvcHRpb25zLmRldGFpbFkgfHwgb3B0aW9ucy5kZXRhaWwgfHwgMTtcblxuICAgIHZhciB2ZXJ0aWNlcyAgICAgID0gW107XG4gICAgdmFyIHRleHR1cmVDb29yZHMgPSBbXTtcbiAgICB2YXIgbm9ybWFscyAgICAgICA9IFtdO1xuICAgIHZhciBpbmRpY2VzICAgICAgID0gW107XG5cbiAgICBmb3IgKHZhciB5ID0gMDsgeSA8PSBkZXRhaWxZOyB5KyspIHtcbiAgICAgICAgdmFyIHQgPSB5IC8gZGV0YWlsWTtcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPD0gZGV0YWlsWDsgeCsrKSB7XG4gICAgICAgICAgICB2YXIgcyA9IHggLyBkZXRhaWxYO1xuICAgICAgICAgICAgdmVydGljZXMucHVzaCgyLiAqIChzIC0gLjUpLCAyICogKHQgLSAuNSksIDApO1xuICAgICAgICAgICAgdGV4dHVyZUNvb3Jkcy5wdXNoKHMsIDEgLSB0KTtcbiAgICAgICAgICAgIG5vcm1hbHMucHVzaCgwLCAwLCAxKTtcbiAgICAgICAgICAgIGlmICh4IDwgZGV0YWlsWCAmJiB5IDwgZGV0YWlsWSkge1xuICAgICAgICAgICAgICAgIHZhciBpID0geCArIHkgKiAoZGV0YWlsWCArIDEpO1xuICAgICAgICAgICAgICAgIGluZGljZXMucHVzaChpLCBpICsgMSwgaSArIGRldGFpbFggKyAxKTtcbiAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goaSArIGRldGFpbFggKyAxLCBpICsgMSwgaSArIGRldGFpbFggKyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gbmV3IEdlb21ldHJ5KHtcbiAgICAgICAgYnVmZmVyczogW1xuICAgICAgICAgICAgeyBuYW1lOiAncG9zJywgZGF0YTogdmVydGljZXMgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ3RleENvb3JkJywgZGF0YTogdGV4dHVyZUNvb3Jkcywgc2l6ZTogMiB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnbm9ybWFscycsIGRhdGE6IG5vcm1hbHMgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2luZGljZXMnLCBkYXRhOiBpbmRpY2VzLCBzaXplOiAxIH1cbiAgICAgICAgXVxuICAgIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQbGFuZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdlb21ldHJ5ID0gcmVxdWlyZSgnLi4vR2VvbWV0cnknKTtcbnZhciBHZW9tZXRyeUhlbHBlciA9IHJlcXVpcmUoJy4uL0dlb21ldHJ5SGVscGVyJyk7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgbmV3IHN0YXRpYyBnZW9tZXRyeSwgd2hpY2ggaXMgcGFzc2VkXG4gKiBjdXN0b20gYnVmZmVyIGRhdGEuXG4gKlxuICogQGNsYXNzIFBhcmFtZXRyaWNTcGhlcmVcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFBhcmFtZXRlcnMgdGhhdCBhbHRlciB0aGVcbiAqIHZlcnRleCBidWZmZXJzIG9mIHRoZSBnZW5lcmF0ZWQgZ2VvbWV0cnkuXG4gKiBcbiAqIEByZXR1cm4ge09iamVjdH0gY29uc3RydWN0ZWQgZ2VvbWV0cnlcbiAqL1xuZnVuY3Rpb24gUGFyYW1ldHJpY1NwaGVyZSAob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBkZXRhaWwgPSBvcHRpb25zLmRldGFpbCB8fCAxMDtcbiAgICB2YXIgZGV0YWlsWCA9IG9wdGlvbnMuZGV0YWlsWCB8fCBkZXRhaWw7ICAgIFxuICAgIHZhciBkZXRhaWxZID0gb3B0aW9ucy5kZXRhaWxZIHx8IGRldGFpbDtcblxuICAgIHZhciBidWZmZXJzID0gR2VvbWV0cnlIZWxwZXIuZ2VuZXJhdGVQYXJhbWV0cmljKFxuICAgICAgICAgIGRldGFpbFgsXG4gICAgICAgICAgZGV0YWlsWSxcbiAgICAgICAgICBQYXJhbWV0cmljU3BoZXJlLmdlbmVyYXRvclxuICAgICk7XG5cbiAgICBHZW9tZXRyeUhlbHBlci5nZXRVbmlxdWVGYWNlcyhidWZmZXJzLnZlcnRpY2VzLCBidWZmZXJzLmluZGljZXMpO1xuXG4gICAgcmV0dXJuIG5ldyBHZW9tZXRyeSh7XG4gICAgICAgIGJ1ZmZlcnM6IFtcbiAgICAgICAgICAgIHsgbmFtZTogJ3BvcycsIGRhdGE6IGJ1ZmZlcnMudmVydGljZXMgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ3RleENvb3JkJywgZGF0YTogR2VvbWV0cnlIZWxwZXIuZ2V0U3BoZXJvaWRVVihidWZmZXJzLnZlcnRpY2VzKSwgc2l6ZTogMiB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnbm9ybWFscycsIGRhdGE6IEdlb21ldHJ5SGVscGVyLmdldFNwaGVyb2lkTm9ybWFscyhidWZmZXJzLnZlcnRpY2VzKSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnaW5kaWNlcycsIGRhdGE6IGJ1ZmZlcnMuaW5kaWNlcywgc2l6ZTogMSB9XG4gICAgICAgIF1cbiAgICB9KTtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiB1c2VkIGluIGl0ZXJhdGl2ZSBjb25zdHJ1Y3Rpb24gb2YgcGFyYW1ldHJpYyBwcmltaXRpdmUuXG4gKlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBnZW5lcmF0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB1IExvbmdpdHVkYWwgcHJvZ3Jlc3MgZnJvbSAwIHRvIFBJLlxuICogQHBhcmFtIHtOdW1iZXJ9IHYgTGF0aXR1ZGFsIHByb2dyZXNzIGZyb20gMCB0byBQSS5cbiAqIEByZXR1cm4ge0FycmF5fSB4LCB5IGFuZCB6IGNvb3JkaW5hdGVzIG9mIGdlb21ldHJ5XG4gKi9cblBhcmFtZXRyaWNTcGhlcmUuZ2VuZXJhdG9yID0gZnVuY3Rpb24gZ2VuZXJhdG9yKHUsIHYsIHBvcykge1xuICAgIHZhciB4ID0gTWF0aC5zaW4odSkgKiBNYXRoLmNvcyh2KTtcbiAgICB2YXIgeSA9IE1hdGguY29zKHUpO1xuICAgIHZhciB6ID0gLU1hdGguc2luKHUpICogTWF0aC5zaW4odik7XG5cbiAgICBwb3NbMF0gPSB4O1xuICAgIHBvc1sxXSA9IHk7XG4gICAgcG9zWzJdID0gejtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUGFyYW1ldHJpY1NwaGVyZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdlb21ldHJ5ID0gcmVxdWlyZSgnLi4vR2VvbWV0cnknKTtcbnZhciBHZW9tZXRyeUhlbHBlciA9IHJlcXVpcmUoJy4uL0dlb21ldHJ5SGVscGVyJyk7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBnZW5lcmF0ZXMgY3VzdG9tIGJ1ZmZlcnMgYW5kIHBhc3NlcyB0aGVtIHRvXG4gKiBhIG5ldyBzdGF0aWMgZ2VvbWV0cnksIHdoaWNoIGlzIHJldHVybmVkIHRvIHRoZSB1c2VyLlxuICpcbiAqIEBjbGFzcyBUZXRyYWhlZHJvblxuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgUGFyYW1ldGVycyB0aGF0IGFsdGVyIHRoZVxuICogdmVydGV4IGJ1ZmZlcnMgb2YgdGhlIGdlbmVyYXRlZCBnZW9tZXRyeS5cbiAqIFxuICogQHJldHVybiB7T2JqZWN0fSBjb25zdHJ1Y3RlZCBnZW9tZXRyeVxuICovXG5mdW5jdGlvbiBUZXRyYWhlZHJvbihvcHRpb25zKSB7XG4gICAgdmFyIHRleHR1cmVDb29yZHMgPSBbXTtcbiAgICB2YXIgbm9ybWFscyA9IFtdO1xuICAgIHZhciBnZW9tZXRyeTtcbiAgICB2YXIgZGV0YWlsO1xuICAgIHZhciBpO1xuICAgIHZhciB0ID0gTWF0aC5zcXJ0KDMpO1xuICAgIFxuICAgIHZhciB2ZXJ0aWNlcyA9IFtcbiAgICAgICAgLy8gQmFjayBcbiAgICAgICAgIDEsIC0xLCAtMSAvIHQsXG4gICAgICAgIC0xLCAtMSwgLTEgLyB0LFxuICAgICAgICAgMCwgIDEsICAwLFxuICAgICAgICBcbiAgICAgICAgLy8gUmlnaHRcbiAgICAgICAgIDAsICAxLCAgMCxcbiAgICAgICAgIDAsIC0xLCB0IC0gMSAvIHQsXG4gICAgICAgICAxLCAtMSwgLTEgLyB0LFxuXG4gICAgICAgIC8vIExlZnRcbiAgICAgICAgIDAsICAxLCAgMCxcbiAgICAgICAgLTEsIC0xLCAtMSAvIHQsXG4gICAgICAgICAwLCAtMSwgIHQgLSAxIC8gdCxcblxuICAgICAgICAvLyBCb3R0b21cbiAgICAgICAgIDAsIC0xLCAgdCAtIDEgLyB0LFxuICAgICAgICAtMSwgLTEsIC0xIC8gdCxcbiAgICAgICAgIDEsIC0xLCAtMSAvIHQsXG4gICAgXTtcblxuICAgIHZhciBpbmRpY2VzID0gW1xuICAgICAgICAwLCAxLCAyLFxuICAgICAgICAzLCA0LCA1LFxuICAgICAgICA2LCA3LCA4LFxuICAgICAgICA5LCAxMCwgMTEsXG4gICAgXTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgdGV4dHVyZUNvb3Jkcy5wdXNoKFxuICAgICAgICAgICAgMC4wLCAwLjAsXG4gICAgICAgICAgICAwLjUsIDEuMCxcbiAgICAgICAgICAgIDEuMCwgMC4wXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgb3B0aW9ucyAgICAgICA9IG9wdGlvbnMgfHwge307XG5cbiAgICB3aGlsZSgtLWRldGFpbCkgR2VvbWV0cnlIZWxwZXIuc3ViZGl2aWRlKGluZGljZXMsIHZlcnRpY2VzLCB0ZXh0dXJlQ29vcmRzKTtcbiAgICBub3JtYWxzICAgICAgID0gR2VvbWV0cnlIZWxwZXIuY29tcHV0ZU5vcm1hbHModmVydGljZXMsIGluZGljZXMpO1xuXG4gICAgcmV0dXJuIG5ldyBHZW9tZXRyeSh7XG4gICAgICAgIGJ1ZmZlcnM6IFtcbiAgICAgICAgICAgIHsgbmFtZTogJ3BvcycsIGRhdGE6IHZlcnRpY2VzIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICd0ZXhDb29yZCcsIGRhdGE6IHRleHR1cmVDb29yZHMsIHNpemU6IDIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ25vcm1hbHMnLCBkYXRhOiBub3JtYWxzIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdpbmRpY2VzJywgZGF0YTogaW5kaWNlcywgc2l6ZTogMSB9XG4gICAgICAgIF1cbiAgICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUZXRyYWhlZHJvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdlb21ldHJ5ID0gcmVxdWlyZSgnLi4vR2VvbWV0cnknKTtcbnZhciBHZW9tZXRyeUhlbHBlciA9IHJlcXVpcmUoJy4uL0dlb21ldHJ5SGVscGVyJyk7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgbmV3IHN0YXRpYyBnZW9tZXRyeSwgd2hpY2ggaXMgcGFzc2VkXG4gKiBjdXN0b20gYnVmZmVyIGRhdGEuXG4gKlxuICogQGNsYXNzIFRvcnVzXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBQYXJhbWV0ZXJzIHRoYXQgYWx0ZXIgdGhlXG4gKiB2ZXJ0ZXggYnVmZmVycyBvZiB0aGUgZ2VuZXJhdGVkIGdlb21ldHJ5LlxuICogXG4gKiBAcmV0dXJuIHtPYmplY3R9IGNvbnN0cnVjdGVkIGdlb21ldHJ5XG4gKi9cblxuZnVuY3Rpb24gVG9ydXMob3B0aW9ucykge1xuICAgIHZhciBvcHRpb25zICA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGRldGFpbCAgID0gb3B0aW9ucy5kZXRhaWwgfHwgMzA7XG4gICAgdmFyIGhvbGVSYWRpdXMgPSBvcHRpb25zLmhvbGVSYWRpdXMgfHwgMC44MDtcbiAgICB2YXIgdHViZVJhZGl1cyA9IG9wdGlvbnMudHViZVJhZGl1cyB8fCAwLjIwO1xuXG4gICAgdmFyIGJ1ZmZlcnMgPSBHZW9tZXRyeUhlbHBlci5nZW5lcmF0ZVBhcmFtZXRyaWMoXG4gICAgICAgIGRldGFpbCxcbiAgICAgICAgZGV0YWlsLFxuICAgICAgICBUb3J1cy5nZW5lcmF0b3IuYmluZChudWxsLCBob2xlUmFkaXVzLCB0dWJlUmFkaXVzKVxuICAgICk7XG5cbiAgICByZXR1cm4gbmV3IEdlb21ldHJ5KHtcbiAgICAgICAgYnVmZmVyczogW1xuICAgICAgICAgICAgeyBuYW1lOiAncG9zJywgZGF0YTogYnVmZmVycy52ZXJ0aWNlcyB9LFxuICAgICAgICAgICAgeyBuYW1lOiAndGV4Q29vcmQnLCBkYXRhOiBHZW9tZXRyeUhlbHBlci5nZXRTcGhlcm9pZFVWKGJ1ZmZlcnMudmVydGljZXMpLCBzaXplOiAyIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdub3JtYWxzJywgZGF0YTogR2VvbWV0cnlIZWxwZXIuY29tcHV0ZU5vcm1hbHMoYnVmZmVycy52ZXJ0aWNlcywgYnVmZmVycy5pbmRpY2VzKSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnaW5kaWNlcycsIGRhdGE6IGJ1ZmZlcnMuaW5kaWNlcywgc2l6ZTogMSB9XG4gICAgICAgIF1cbiAgICB9KTtcbn1cblxuLyoqXG4gKiBmdW5jdGlvbiB1c2VkIGluIGl0ZXJhdGl2ZSBjb25zdHJ1Y3Rpb24gb2YgcGFyYW1ldHJpYyBwcmltaXRpdmUuXG4gKlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBnZW5lcmF0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBjIFJhZGl1cyBvZiBpbm5lciBob2xlLlxuICogQHBhcmFtIHtOdW1iZXJ9IGEgUmFkaXVzIG9mIHR1YmUuXG4gKiBAcGFyYW0ge051bWJlcn0gdSBMb25naXR1ZGFsIHByb2dyZXNzIGZyb20gMCB0byBQSS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB2IExhdGl0dWRhbCBwcm9ncmVzcyBmcm9tIDAgdG8gUEkuXG4gKiBAcmV0dXJuIHtBcnJheX0geCwgeSBhbmQgeiBjb29yZGluYXRlIG9mIHRoZSB2ZXJ0ZXguXG4gKi9cblRvcnVzLmdlbmVyYXRvciA9IGZ1bmN0aW9uIGdlbmVyYXRvcihjLCBhLCB1LCB2LCBwb3MpIHtcbiAgICBwb3NbMF0gPSAoYyArIGEgKiBNYXRoLmNvcygyICogdikpICogTWF0aC5zaW4oMiAqIHUpO1xuICAgIHBvc1sxXSA9IC0oYyArIGEgKiBNYXRoLmNvcygyICogdikpICogTWF0aC5jb3MoMiAqIHUpO1xuICAgIHBvc1syXSA9IGEgKiBNYXRoLnNpbigyICogdik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVG9ydXM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZW9tZXRyeSAgICAgICA9IHJlcXVpcmUoJy4uL0dlb21ldHJ5Jyk7XG52YXIgR2VvbWV0cnlIZWxwZXIgPSByZXF1aXJlKCcuLi9HZW9tZXRyeUhlbHBlcicpO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIG5ldyBzdGF0aWMgZ2VvbWV0cnksIHdoaWNoIGlzIHBhc3NlZFxuICogY3VzdG9tIGJ1ZmZlciBkYXRhLlxuICpcbiAqIEBjbGFzcyBUcmlhbmdsZVxuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgUGFyYW1ldGVycyB0aGF0IGFsdGVyIHRoZVxuICogdmVydGV4IGJ1ZmZlcnMgb2YgdGhlIGdlbmVyYXRlZCBnZW9tZXRyeS5cbiAqIFxuICogQHJldHVybiB7T2JqZWN0fSBjb25zdHJ1Y3RlZCBnZW9tZXRyeVxuICovXG5mdW5jdGlvbiBUcmlhbmdsZSAob3B0aW9ucykge1xuICAgIHZhciBvcHRpb25zICA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGRldGFpbCAgID0gb3B0aW9ucy5kZXRhaWwgfHwgMTtcbiAgICB2YXIgbm9ybWFscyAgPSBbXTtcbiAgICB2YXIgdGV4dHVyZUNvb3JkcyA9IFtcbiAgICAgICAgMC4wLCAwLjAsXG4gICAgICAgIDAuNSwgMS4wLFxuICAgICAgICAxLjAsIDAuMFxuICAgIF07XG4gICAgdmFyIGluZGljZXMgID0gW1xuICAgICAgICAwLCAxLCAyXG4gICAgXTtcbiAgICB2YXIgdmVydGljZXMgPSBbXG4gICAgICAgIC0xLCAgMSwgMCxcbiAgICAgICAgIDAsIC0xLCAwLFxuICAgICAgICAgMSwgIDEsIDBcbiAgICBdO1xuXG4gICAgd2hpbGUoLS1kZXRhaWwpIEdlb21ldHJ5SGVscGVyLnN1YmRpdmlkZShpbmRpY2VzLCB2ZXJ0aWNlcywgdGV4dHVyZUNvb3Jkcyk7XG4gICAgbm9ybWFscyAgICAgICA9IEdlb21ldHJ5SGVscGVyLmNvbXB1dGVOb3JtYWxzKHZlcnRpY2VzLCBpbmRpY2VzKTtcblxuICAgIHJldHVybiBuZXcgR2VvbWV0cnkoe1xuICAgICAgICBidWZmZXJzOiBbXG4gICAgICAgICAgICB7IG5hbWU6ICdwb3MnLCBkYXRhOiB2ZXJ0aWNlcyB9LFxuICAgICAgICAgICAgeyBuYW1lOiAndGV4Q29vcmQnLCBkYXRhOiB0ZXh0dXJlQ29vcmRzLCBzaXplOiAyIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdub3JtYWxzJywgZGF0YTogbm9ybWFscyB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnaW5kaWNlcycsIGRhdGE6IGluZGljZXMsIHNpemU6IDEgfVxuICAgICAgICBdXG4gICAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVHJpYW5nbGU7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IG5vb3BcblxuZnVuY3Rpb24gbm9vcCgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ1lvdSBzaG91bGQgYnVuZGxlIHlvdXIgY29kZSAnICtcbiAgICAgICd1c2luZyBgZ2xzbGlmeWAgYXMgYSB0cmFuc2Zvcm0uJ1xuICApXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHByb2dyYW1pZnlcblxuZnVuY3Rpb24gcHJvZ3JhbWlmeSh2ZXJ0ZXgsIGZyYWdtZW50LCB1bmlmb3JtcywgYXR0cmlidXRlcykge1xuICByZXR1cm4ge1xuICAgIHZlcnRleDogdmVydGV4LCBcbiAgICBmcmFnbWVudDogZnJhZ21lbnQsXG4gICAgdW5pZm9ybXM6IHVuaWZvcm1zLCBcbiAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzXG4gIH07XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBnbHNsaWZ5ID0gcmVxdWlyZShcImdsc2xpZnlcIik7XG52YXIgc2hhZGVycyA9IHJlcXVpcmUoXCJnbHNsaWZ5L3NpbXBsZS1hZGFwdGVyLmpzXCIpKFwiXFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG5tYXQzIGFfeF9nZXROb3JtYWxNYXRyaXgoaW4gbWF0NCB0KSB7XFxuICBtYXQzIG1hdE5vcm07XFxuICBtYXQ0IGEgPSB0O1xcbiAgZmxvYXQgYTAwID0gYVswXVswXSwgYTAxID0gYVswXVsxXSwgYTAyID0gYVswXVsyXSwgYTAzID0gYVswXVszXSwgYTEwID0gYVsxXVswXSwgYTExID0gYVsxXVsxXSwgYTEyID0gYVsxXVsyXSwgYTEzID0gYVsxXVszXSwgYTIwID0gYVsyXVswXSwgYTIxID0gYVsyXVsxXSwgYTIyID0gYVsyXVsyXSwgYTIzID0gYVsyXVszXSwgYTMwID0gYVszXVswXSwgYTMxID0gYVszXVsxXSwgYTMyID0gYVszXVsyXSwgYTMzID0gYVszXVszXSwgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwLCBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTAsIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMCwgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExLCBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTEsIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMiwgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwLCBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzAsIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMCwgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxLCBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzEsIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMiwgZGV0ID0gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xcbiAgZGV0ID0gMS4wIC8gZGV0O1xcbiAgbWF0Tm9ybVswXVswXSA9IChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0O1xcbiAgbWF0Tm9ybVswXVsxXSA9IChhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcpICogZGV0O1xcbiAgbWF0Tm9ybVswXVsyXSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xcbiAgbWF0Tm9ybVsxXVswXSA9IChhMDIgKiBiMTAgLSBhMDEgKiBiMTEgLSBhMDMgKiBiMDkpICogZGV0O1xcbiAgbWF0Tm9ybVsxXVsxXSA9IChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0O1xcbiAgbWF0Tm9ybVsxXVsyXSA9IChhMDEgKiBiMDggLSBhMDAgKiBiMTAgLSBhMDMgKiBiMDYpICogZGV0O1xcbiAgbWF0Tm9ybVsyXVswXSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xcbiAgbWF0Tm9ybVsyXVsxXSA9IChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0O1xcbiAgbWF0Tm9ybVsyXVsyXSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0O1xcbiAgcmV0dXJuIG1hdE5vcm07XFxufVxcbmZsb2F0IGJfeF9pbnZlcnNlKGZsb2F0IG0pIHtcXG4gIHJldHVybiAxLjAgLyBtO1xcbn1cXG5tYXQyIGJfeF9pbnZlcnNlKG1hdDIgbSkge1xcbiAgcmV0dXJuIG1hdDIobVsxXVsxXSwgLW1bMF1bMV0sIC1tWzFdWzBdLCBtWzBdWzBdKSAvIChtWzBdWzBdICogbVsxXVsxXSAtIG1bMF1bMV0gKiBtWzFdWzBdKTtcXG59XFxubWF0MyBiX3hfaW52ZXJzZShtYXQzIG0pIHtcXG4gIGZsb2F0IGEwMCA9IG1bMF1bMF0sIGEwMSA9IG1bMF1bMV0sIGEwMiA9IG1bMF1bMl07XFxuICBmbG9hdCBhMTAgPSBtWzFdWzBdLCBhMTEgPSBtWzFdWzFdLCBhMTIgPSBtWzFdWzJdO1xcbiAgZmxvYXQgYTIwID0gbVsyXVswXSwgYTIxID0gbVsyXVsxXSwgYTIyID0gbVsyXVsyXTtcXG4gIGZsb2F0IGIwMSA9IGEyMiAqIGExMSAtIGExMiAqIGEyMTtcXG4gIGZsb2F0IGIxMSA9IC1hMjIgKiBhMTAgKyBhMTIgKiBhMjA7XFxuICBmbG9hdCBiMjEgPSBhMjEgKiBhMTAgLSBhMTEgKiBhMjA7XFxuICBmbG9hdCBkZXQgPSBhMDAgKiBiMDEgKyBhMDEgKiBiMTEgKyBhMDIgKiBiMjE7XFxuICByZXR1cm4gbWF0MyhiMDEsICgtYTIyICogYTAxICsgYTAyICogYTIxKSwgKGExMiAqIGEwMSAtIGEwMiAqIGExMSksIGIxMSwgKGEyMiAqIGEwMCAtIGEwMiAqIGEyMCksICgtYTEyICogYTAwICsgYTAyICogYTEwKSwgYjIxLCAoLWEyMSAqIGEwMCArIGEwMSAqIGEyMCksIChhMTEgKiBhMDAgLSBhMDEgKiBhMTApKSAvIGRldDtcXG59XFxubWF0NCBiX3hfaW52ZXJzZShtYXQ0IG0pIHtcXG4gIGZsb2F0IGEwMCA9IG1bMF1bMF0sIGEwMSA9IG1bMF1bMV0sIGEwMiA9IG1bMF1bMl0sIGEwMyA9IG1bMF1bM10sIGExMCA9IG1bMV1bMF0sIGExMSA9IG1bMV1bMV0sIGExMiA9IG1bMV1bMl0sIGExMyA9IG1bMV1bM10sIGEyMCA9IG1bMl1bMF0sIGEyMSA9IG1bMl1bMV0sIGEyMiA9IG1bMl1bMl0sIGEyMyA9IG1bMl1bM10sIGEzMCA9IG1bM11bMF0sIGEzMSA9IG1bM11bMV0sIGEzMiA9IG1bM11bMl0sIGEzMyA9IG1bM11bM10sIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMCwgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwLCBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTAsIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMSwgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExLCBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTIsIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMCwgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwLCBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzAsIGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMSwgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxLCBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzIsIGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcXG4gIHJldHVybiBtYXQ0KGExMSAqIGIxMSAtIGExMiAqIGIxMCArIGExMyAqIGIwOSwgYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5LCBhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMsIGEyMiAqIGIwNCAtIGEyMSAqIGIwNSAtIGEyMyAqIGIwMywgYTEyICogYjA4IC0gYTEwICogYjExIC0gYTEzICogYjA3LCBhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcsIGEzMiAqIGIwMiAtIGEzMCAqIGIwNSAtIGEzMyAqIGIwMSwgYTIwICogYjA1IC0gYTIyICogYjAyICsgYTIzICogYjAxLCBhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYsIGEwMSAqIGIwOCAtIGEwMCAqIGIxMCAtIGEwMyAqIGIwNiwgYTMwICogYjA0IC0gYTMxICogYjAyICsgYTMzICogYjAwLCBhMjEgKiBiMDIgLSBhMjAgKiBiMDQgLSBhMjMgKiBiMDAsIGExMSAqIGIwNyAtIGExMCAqIGIwOSAtIGExMiAqIGIwNiwgYTAwICogYjA5IC0gYTAxICogYjA3ICsgYTAyICogYjA2LCBhMzEgKiBiMDEgLSBhMzAgKiBiMDMgLSBhMzIgKiBiMDAsIGEyMCAqIGIwMyAtIGEyMSAqIGIwMSArIGEyMiAqIGIwMCkgLyBkZXQ7XFxufVxcbmZsb2F0IGNfeF90cmFuc3Bvc2UoZmxvYXQgbSkge1xcbiAgcmV0dXJuIG07XFxufVxcbm1hdDIgY194X3RyYW5zcG9zZShtYXQyIG0pIHtcXG4gIHJldHVybiBtYXQyKG1bMF1bMF0sIG1bMV1bMF0sIG1bMF1bMV0sIG1bMV1bMV0pO1xcbn1cXG5tYXQzIGNfeF90cmFuc3Bvc2UobWF0MyBtKSB7XFxuICByZXR1cm4gbWF0MyhtWzBdWzBdLCBtWzFdWzBdLCBtWzJdWzBdLCBtWzBdWzFdLCBtWzFdWzFdLCBtWzJdWzFdLCBtWzBdWzJdLCBtWzFdWzJdLCBtWzJdWzJdKTtcXG59XFxubWF0NCBjX3hfdHJhbnNwb3NlKG1hdDQgbSkge1xcbiAgcmV0dXJuIG1hdDQobVswXVswXSwgbVsxXVswXSwgbVsyXVswXSwgbVszXVswXSwgbVswXVsxXSwgbVsxXVsxXSwgbVsyXVsxXSwgbVszXVsxXSwgbVswXVsyXSwgbVsxXVsyXSwgbVsyXVsyXSwgbVszXVsyXSwgbVswXVszXSwgbVsxXVszXSwgbVsyXVszXSwgbVszXVszXSk7XFxufVxcbnZlYzQgYXBwbHlUcmFuc2Zvcm0odmVjNCBwb3MpIHtcXG4gIG1hdDQgTVZNYXRyaXggPSB2aWV3ICogdHJhbnNmb3JtO1xcbiAgcG9zLnggKz0gMS4wO1xcbiAgcG9zLnkgLT0gMS4wO1xcbiAgcG9zLnh5eiAqPSBzaXplICogMC41O1xcbiAgcG9zLnkgKj0gLTEuMDtcXG4gIHZfUG9zaXRpb24gPSAoTVZNYXRyaXggKiBwb3MpLnh5ejtcXG4gIHZfRXllVmVjdG9yID0gKHJlc29sdXRpb24gKiAwLjUpIC0gdl9Qb3NpdGlvbjtcXG4gIE1WTWF0cml4WzBdWzFdICo9IC0xLjA7XFxuICBNVk1hdHJpeFsxXVsxXSAqPSAtMS4wO1xcbiAgTVZNYXRyaXhbMl1bMV0gKj0gLTEuMDtcXG4gIE1WTWF0cml4WzNdWzFdICo9IC0xLjA7XFxuICBtYXQ0IE1WUE1hdHJpeCA9IHBlcnNwZWN0aXZlICogTVZNYXRyaXg7XFxuICBwb3MgPSBNVlBNYXRyaXggKiBwb3M7XFxuICBwb3MueCAvPSAocmVzb2x1dGlvbi54ICogMC41KTtcXG4gIHBvcy55IC89IChyZXNvbHV0aW9uLnkgKiAwLjUpO1xcbiAgcG9zLnggLT0gMS4wO1xcbiAgcG9zLnkgKz0gMS4wO1xcbiAgcG9zLnogKj0gLTAuMDAwMDE7XFxuICByZXR1cm4gcG9zO1xcbn1cXG4jdmVydF9kZWZpbml0aW9uc1xcblxcbnZlYzMgY2FsY3VsYXRlT2Zmc2V0KHZlYzMgSUQpIHtcXG4gIFxcbiAgI3ZlcnRfYXBwbGljYXRpb25zXFxuICByZXR1cm4gdmVjMygwLjApO1xcbn1cXG52b2lkIG1haW4oKSB7XFxuICBnbF9Qb2ludFNpemUgPSAxMC4wO1xcbiAgdmVjMyBpbnZlcnRlZE5vcm1hbHMgPSBub3JtYWxzO1xcbiAgaW52ZXJ0ZWROb3JtYWxzLnkgKj0gLTEuMDtcXG4gIHZfTm9ybWFsID0gY194X3RyYW5zcG9zZShtYXQzKGJfeF9pbnZlcnNlKHRyYW5zZm9ybSkpKSAqIGludmVydGVkTm9ybWFscztcXG4gIHZfVGV4dHVyZUNvb3JkaW5hdGUgPSB0ZXhDb29yZDtcXG4gIHZlYzMgb2Zmc2V0UG9zID0gcG9zICsgY2FsY3VsYXRlT2Zmc2V0KHBvc2l0aW9uT2Zmc2V0KTtcXG4gIGdsX1Bvc2l0aW9uID0gYXBwbHlUcmFuc2Zvcm0odmVjNChvZmZzZXRQb3MsIDEuMCkpO1xcbn1cIiwgXCJcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbiNmbG9hdF9kZWZpbml0aW9uc1xcblxcbmZsb2F0IGFfeF9hcHBseU1hdGVyaWFsKGZsb2F0IElEKSB7XFxuICBcXG4gICNmbG9hdF9hcHBsaWNhdGlvbnNcXG4gIHJldHVybiAxLjtcXG59XFxuI3ZlY19kZWZpbml0aW9uc1xcblxcbnZlYzMgYV94X2FwcGx5TWF0ZXJpYWwodmVjMyBJRCkge1xcbiAgXFxuICAjdmVjX2FwcGxpY2F0aW9uc1xcbiAgcmV0dXJuIHZlYzMoLjUpO1xcbn1cXG52ZWMzIGJfeF9hcHBseUxpZ2h0KGluIHZlYzMgbWF0ZXJpYWwpIHtcXG4gIGludCBudW1MaWdodHMgPSBpbnQodV9OdW1MaWdodHMpO1xcbiAgdmVjMyBhbWJpZW50Q29sb3IgPSB1X0FtYmllbnRMaWdodCAqIG1hdGVyaWFsO1xcbiAgdmVjMyBub3JtYWwgPSBub3JtYWxpemUodl9Ob3JtYWwpO1xcbiAgdmVjMyBleWVWZWN0b3IgPSBub3JtYWxpemUodl9FeWVWZWN0b3IpO1xcbiAgdmVjMyBzcGVjdWxhciA9IHZlYzMoMC4wKTtcXG4gIHZlYzMgZGlmZnVzZSA9IHZlYzMoMC4wKTtcXG4gIGZvcihpbnQgaSA9IDA7IGkgPCA0OyBpKyspIHtcXG4gICAgaWYoaSA+PSBudW1MaWdodHMpXFxuICAgICAgYnJlYWs7XFxuICAgIHZlYzMgbGlnaHREaXJlY3Rpb24gPSBub3JtYWxpemUodV9MaWdodFBvc2l0aW9uW2ldLnh5eiAtIHZfUG9zaXRpb24pO1xcbiAgICBmbG9hdCBsYW1iZXJ0aWFuID0gbWF4KGRvdChsaWdodERpcmVjdGlvbiwgbm9ybWFsKSwgMC4wKTtcXG4gICAgaWYobGFtYmVydGlhbiA+IDAuMCkge1xcbiAgICAgIGRpZmZ1c2UgKz0gdV9MaWdodENvbG9yW2ldLnJnYiAqIG1hdGVyaWFsICogbGFtYmVydGlhbjtcXG4gICAgfVxcbiAgICBpZihnbG9zc2luZXNzID4gMC4wKSB7XFxuICAgICAgdmVjMyBoYWxmVmVjdG9yID0gbm9ybWFsaXplKGxpZ2h0RGlyZWN0aW9uICsgZXllVmVjdG9yKTtcXG4gICAgICBmbG9hdCBzcGVjdWxhciA9IHBvdyhtYXgoZG90KGhhbGZWZWN0b3IsIG5vcm1hbCksIDAuMCksIGdsb3NzaW5lc3MpO1xcbiAgICAgIGRpZmZ1c2UgKz0gdV9MaWdodENvbG9yW2ldLnJnYiAqIHNwZWN1bGFyO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gYW1iaWVudENvbG9yICsgZGlmZnVzZTtcXG59XFxudm9pZCBtYWluKCkge1xcbiAgdmVjMyBtYXRlcmlhbCA9IGJhc2VDb2xvci5yID49IDAuMCA/IGJhc2VDb2xvciA6IGFfeF9hcHBseU1hdGVyaWFsKGJhc2VDb2xvcik7XFxuICBib29sIGxpZ2h0c0VuYWJsZWQgPSAodV9GbGF0U2hhZGluZyA9PSAwLjApICYmICh1X051bUxpZ2h0cyA+IDAuMCB8fCBsZW5ndGgodV9BbWJpZW50TGlnaHQpID4gMC4wKTtcXG4gIHZlYzMgY29sb3IgPSBsaWdodHNFbmFibGVkID8gYl94X2FwcGx5TGlnaHQobWF0ZXJpYWwpIDogbWF0ZXJpYWw7XFxuICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLCBvcGFjaXR5KTtcXG59XCIsIFtdLCBbXSk7XG5tb2R1bGUuZXhwb3J0cyA9IHNoYWRlcnM7IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEJ1ZmZlciBpcyBhIHByaXZhdGUgY2xhc3MgdGhhdCB3cmFwcyB0aGUgdmVydGV4IGRhdGEgdGhhdCBkZWZpbmVzXG4gKiB0aGUgdGhlIHBvaW50cyBvZiB0aGUgdHJpYW5nbGVzIHRoYXQgd2ViZ2wgZHJhd3MuIEVhY2ggYnVmZmVyIFxuICogbWFwcyB0byBvbmUgYXR0cmlidXRlIG9mIGEgbWVzaC5cbiAqIFxuICogQGNsYXNzIEJ1ZmZlclxuICogQGNvbnN0cnVjdG9yXG4gKiBcbiAqIEBwYXJhbSB7TnVtYmVyfSB0YXJnZXQgVGhlIGJpbmQgdGFyZ2V0IG9mIHRoZSBidWZmZXIgdG8gdXBkYXRlOiBBUlJBWV9CVUZGRVIgb3IgRUxFTUVOVF9BUlJBWV9CVUZGRVJcbiAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlIEFycmF5IHR5cGUgdG8gYmUgdXNlZCBpbiBjYWxscyB0byBnbC5idWZmZXJEYXRhLlxuICogQHBhcmFtIHtXZWJHTENvbnRleHR9IGdsIFRoZSBXZWJHTCBjb250ZXh0IHRoYXQgdGhlIGJ1ZmZlciBpcyBob3N0ZWQgYnkuXG4gKiBcbiAqL1xuZnVuY3Rpb24gQnVmZmVyKHRhcmdldCwgdHlwZSwgZ2wpIHtcbiAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICB0aGlzLmdsID0gZ2w7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIFdlYkdMIGJ1ZmZlciBpZiBvbmUgZG9lcyBub3QgeWV0IGV4aXN0IGFuZCBiaW5kcyB0aGUgYnVmZmVyIHRvXG4gKiB0byB0aGUgY29udGV4dC4gIFJ1bnMgYnVmZmVyRGF0YSB3aXRoIGFwcHJvcHJpYXRlIGRhdGEuXG4gKiBcbiAqIEBtZXRob2Qgc3ViRGF0YVxuICogXG4gKi9cbkJ1ZmZlci5wcm90b3R5cGUuc3ViRGF0YSA9IGZ1bmN0aW9uIHN1YkRhdGEoKSB7XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICB2YXIgZGF0YSA9IFtdO1xuXG4gICAgLy8gdG8gcHJldmVudCBhZ2FpbnN0IG1heGltdW0gY2FsbC1zdGFjayBpc3N1ZS5cbiAgICBmb3IgKHZhciBpID0gMCwgY2h1bmsgPSAxMDAwMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkgKz0gY2h1bmspXG4gICAgICAgIGRhdGEgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KGRhdGEsIHRoaXMuZGF0YS5zbGljZShpLCBpICsgY2h1bmspKTtcblxuICAgIHRoaXMuYnVmZmVyID0gdGhpcy5idWZmZXIgfHwgZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgZ2wuYmluZEJ1ZmZlcih0aGlzLnRhcmdldCwgdGhpcy5idWZmZXIpO1xuICAgIGdsLmJ1ZmZlckRhdGEodGhpcy50YXJnZXQsIG5ldyB0aGlzLnR5cGUoZGF0YSksIGdsLlNUQVRJQ19EUkFXKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgSU5ESUNFUyA9ICdpbmRpY2VzJztcblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJy4vQnVmZmVyJyk7XG5cbi8qKlxuICogQnVmZmVyUmVnaXN0cnkgaXMgYSBjbGFzcyB0aGF0IG1hbmFnZXMgYWxsb2NhdGlvbiBvZiBidWZmZXJzIHRvXG4gKiBpbnB1dCBnZW9tZXRyaWVzLlxuICogXG4gKiBAY2xhc3MgQnVmZmVyUmVnaXN0cnlcbiAqIEBjb25zdHJ1Y3RvclxuICogXG4gKiBAcGFyYW0ge1dlYkdMQ29udGV4dH0gY29udGV4dCBXZWJHTCBkcmF3aW5nIGNvbnRleHQgdG8gYmUgcGFzc2VkIHRvIGJ1ZmZlcnMuXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlclJlZ2lzdHJ5KGNvbnRleHQpIHtcbiAgICB0aGlzLmdsID0gY29udGV4dDtcblxuICAgIHRoaXMucmVnaXN0cnkgPSB7fTtcbiAgICB0aGlzLl9keW5hbWljQnVmZmVycyA9IFtdO1xuICAgIHRoaXMuX3N0YXRpY0J1ZmZlcnMgPSBbXTtcbiAgICBcbiAgICB0aGlzLl9hcnJheUJ1ZmZlck1heCA9IDMwMDAwO1xuICAgIHRoaXMuX2VsZW1lbnRCdWZmZXJNYXggPSAzMDAwMDtcbn1cblxuLyoqXG4gKiBCaW5kcyBhbmQgZmlsbHMgYWxsIHRoZSB2ZXJ0ZXggZGF0YSBpbnRvIHdlYmdsIGJ1ZmZlcnMuICBXaWxsIHJldXNlIGJ1ZmZlcnMgaWZcbiAqIHBvc3NpYmxlLiAgUG9wdWxhdGVzIHJlZ2lzdHJ5IHdpdGggdGhlIG5hbWUgb2YgdGhlIGJ1ZmZlciwgdGhlIFdlYkdMIGJ1ZmZlclxuICogb2JqZWN0LCBzcGFjaW5nIG9mIHRoZSBhdHRyaWJ1dGUsIHRoZSBhdHRyaWJ1dGUncyBvZmZzZXQgd2l0aGluIHRoZSBidWZmZXIsIFxuICogYW5kIGZpbmFsbHkgdGhlIGxlbmd0aCBvZiB0aGUgYnVmZmVyLiAgVGhpcyBpbmZvcm1hdGlvbiBpcyBsYXRlciBhY2Nlc3NlZCBieVxuICogdGhlIHJvb3QgdG8gZHJhdyB0aGUgYnVmZmVycy5cbiAqXG4gKiBAbWV0aG9kIGFsbG9jYXRlXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGdlb21ldHJ5SWQgSWQgb2YgdGhlIGdlb21ldHJ5IGluc3RhbmNlIHRoYXQgaG9sZHMgdGhlIGJ1ZmZlcnMuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBLZXkgb2YgdGhlIGlucHV0IGJ1ZmZlciBpbiB0aGUgZ2VvbWV0cnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZSBGbGF0IGFycmF5IGNvbnRhaW5pbmcgaW5wdXQgZGF0YSBmb3IgYnVmZmVyLlxuICogQHBhcmFtIHtOdW1iZXJ9IHNwYWNpbmcgVGhlIHNwYWNpbmcsIG9yIGl0ZW1TaXplLCBvZiB0aGUgaW5wdXQgYnVmZmVyLlxuICogQHBhcmFtIHtCb29sZWFufSBkeW5hbWljIEJvb2xlYW4gZGVub3Rpbmcgd2hldGhlciBhIGdlb21ldHJ5IGlzIGR5bmFtaWMgb3Igc3RhdGljLlxuICovXG5CdWZmZXJSZWdpc3RyeS5wcm90b3R5cGUuYWxsb2NhdGUgPSBmdW5jdGlvbiBhbGxvY2F0ZShnZW9tZXRyeUlkLCBuYW1lLCB2YWx1ZSwgc3BhY2luZywgZHluYW1pYykge1xuICAgIHZhciB2ZXJ0ZXhCdWZmZXJzID0gdGhpcy5yZWdpc3RyeVtnZW9tZXRyeUlkXSB8fCAodGhpcy5yZWdpc3RyeVtnZW9tZXRyeUlkXSA9IHsga2V5czogW10sIHZhbHVlczogW10sIHNwYWNpbmc6IFtdLCBvZmZzZXQ6IFtdLCBsZW5ndGg6IFtdIH0pO1xuXG4gICAgdmFyIGogPSB2ZXJ0ZXhCdWZmZXJzLmtleXMuaW5kZXhPZihuYW1lKTtcbiAgICB2YXIgaXNJbmRleCA9IG5hbWUgPT09IElORElDRVM7XG4gICAgdmFyIGJ1ZmZlckZvdW5kID0gZmFsc2U7XG4gICAgdmFyIG5ld09mZnNldDtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICB2YXIgbGVuZ3RoO1xuICAgIHZhciBidWZmZXI7XG4gICAgdmFyIGs7XG5cbiAgICBpZiAoaiA9PT0gLTEpIHtcbiAgICAgICAgaiA9IHZlcnRleEJ1ZmZlcnMua2V5cy5sZW5ndGg7XG4gICAgICAgIGxlbmd0aCA9IGlzSW5kZXggPyB2YWx1ZS5sZW5ndGggOiBNYXRoLmZsb29yKHZhbHVlLmxlbmd0aCAvIHNwYWNpbmcpO1xuXG4gICAgICAgIGlmIChkeW5hbWljKSB7XG5cbiAgICAgICAgICAgIC8vIFVzZSBhIHByZXZpb3VzbHkgY3JlYXRlZCBidWZmZXIgaWYgYXZhaWxhYmxlLlxuXG4gICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgdGhpcy5fc3RhdGljQnVmZmVycy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChpc0luZGV4ID09PSB0aGlzLl9zdGF0aWNCdWZmZXJzW2tdLmlzSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3T2Zmc2V0ID0gdGhpcy5fc3RhdGljQnVmZmVyc1trXS5vZmZzZXQgKyB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoIWlzSW5kZXggJiYgbmV3T2Zmc2V0IDwgdGhpcy5fYXJyYXlCdWZmZXJNYXgpIHx8IChpc0luZGV4ICYmIG5ld09mZnNldCA8IHRoaXMuX2VsZW1lbnRCdWZmZXJNYXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSB0aGlzLl9zdGF0aWNCdWZmZXJzW2tdLmJ1ZmZlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX3N0YXRpY0J1ZmZlcnNba10ub2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhdGljQnVmZmVyc1trXS5vZmZzZXQgKz0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBzdGF0aWMgYnVmZmVyIGluIG5vbmUgd2VyZSBmb3VuZC5cblxuICAgICAgICAgICAgaWYgKCFidWZmZXJGb3VuZCkge1xuICAgICAgICAgICAgICAgIGJ1ZmZlciA9IG5ldyBCdWZmZXIoXG4gICAgICAgICAgICAgICAgICAgIGlzSW5kZXggPyB0aGlzLmdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSIDogdGhpcy5nbC5BUlJBWV9CVUZGRVIsXG4gICAgICAgICAgICAgICAgICAgIGlzSW5kZXggPyBVaW50MTZBcnJheSA6IEZsb2F0MzJBcnJheSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nbFxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0aWNCdWZmZXJzLnB1c2goeyBidWZmZXI6IGJ1ZmZlciwgb2Zmc2V0OiB2YWx1ZS5sZW5ndGgsIGlzSW5kZXg6IGlzSW5kZXggfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIEZvciBkeW5hbWljIGdlb21ldHJpZXMsIGFsd2F5cyBjcmVhdGUgbmV3IGJ1ZmZlci5cblxuICAgICAgICAgICAgYnVmZmVyID0gbmV3IEJ1ZmZlcihcbiAgICAgICAgICAgICAgICBpc0luZGV4ID8gdGhpcy5nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiA6IHRoaXMuZ2wuQVJSQVlfQlVGRkVSLFxuICAgICAgICAgICAgICAgIGlzSW5kZXggPyBVaW50MTZBcnJheSA6IEZsb2F0MzJBcnJheSxcbiAgICAgICAgICAgICAgICB0aGlzLmdsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB0aGlzLl9keW5hbWljQnVmZmVycy5wdXNoKHsgYnVmZmVyOiBidWZmZXIsIG9mZnNldDogdmFsdWUubGVuZ3RoIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSByZWdpc3RyeSBmb3IgdGhlIHNwZWMgd2l0aCBidWZmZXIgaW5mb3JtYXRpb24uXG5cbiAgICAgICAgdmVydGV4QnVmZmVycy5rZXlzLnB1c2gobmFtZSk7XG4gICAgICAgIHZlcnRleEJ1ZmZlcnMudmFsdWVzLnB1c2goYnVmZmVyKTtcbiAgICAgICAgdmVydGV4QnVmZmVycy5zcGFjaW5nLnB1c2goc3BhY2luZyk7XG4gICAgICAgIHZlcnRleEJ1ZmZlcnMub2Zmc2V0LnB1c2gob2Zmc2V0KTtcbiAgICAgICAgdmVydGV4QnVmZmVycy5sZW5ndGgucHVzaChsZW5ndGgpO1xuICAgIH1cbiAgICBcbiAgICB2YXIgbGVuID0gdmFsdWUubGVuZ3RoO1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgICAgdmVydGV4QnVmZmVycy52YWx1ZXNbal0uZGF0YVtvZmZzZXQgKyBrXSA9IHZhbHVlW2tdO1xuICAgIH1cbiAgICB2ZXJ0ZXhCdWZmZXJzLnZhbHVlc1tqXS5zdWJEYXRhKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlclJlZ2lzdHJ5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBHZW5lcmF0ZXMgYSBjaGVja2VyYm9hcmQgcGF0dGVybiB0byBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgdGV4dHVyZVxuLy8gd2hpbGUgYW4gaW1hZ2UgbG9hZHMgb3ZlciB0aGUgbmV0d29yay5cblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvbnRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGNvbnRleHQuY2FudmFzLndpZHRoID0gY29udGV4dC5jYW52YXMuaGVpZ2h0ID0gMTI4O1xuICAgIGZvciAodmFyIHkgPSAwOyB5IDwgY29udGV4dC5jYW52YXMuaGVpZ2h0OyB5ICs9IDE2KSB7XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgY29udGV4dC5jYW52YXMud2lkdGg7IHggKz0gMTYpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gKHggXiB5KSAmIDE2ID8gJyNGRkYnIDogJyNEREQnO1xuICAgICAgICAgICAgY29udGV4dC5maWxsUmVjdCh4LCB5LCAxNiwgMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBjb250ZXh0LmNhbnZhcztcbn0pKCk7XG4iLCIvKipcbiAqIFRha2VzIHRoZSBvcmlnaW5hbCByZW5kZXJpbmcgY29udGV4dHMnIGNvbXBpbGVyIGZ1bmN0aW9uXG4gKiBhbmQgYXVnbWVudHMgaXQgd2l0aCBhZGRlZCBmdW5jdGlvbmFsaXR5IGZvciBwYXJzaW5nIGFuZFxuICogZGlzcGxheWluZyBlcnJvcnMuXG4gKlxuICogQG1ldGhvZCBkZWJ1Z1xuICpcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBEZWJ1ZygpIHtcbiAgICByZXR1cm4gX2F1Z21lbnRGdW5jdGlvbihcbiAgICAgICAgdGhpcy5nbC5jb21waWxlU2hhZGVyLFxuICAgICAgICBmdW5jdGlvbihzaGFkZXIpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCB0aGlzLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgICAgICAgICAgICAgIHZhciBlcnJvcnMgPSB0aGlzLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKTtcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTaGFkZXJTb3VyY2Uoc2hhZGVyKTtcbiAgICAgICAgICAgICAgICBfcHJvY2Vzc0Vycm9ycyhlcnJvcnMsIHNvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xufVxuXG4vKipcbiAqIFRha2VzIGEgZnVuY3Rpb24sIGtlZXBzIHRoZSByZWZlcmVuY2UgYW5kIHJlcGxhY2VzIGl0IGJ5IGEgY2xvc3VyZSB0aGF0XG4gKiBleGVjdXRlcyB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gYW5kIHRoZSBwcm92aWRlZCBjYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gQ2FsbGJhY2tcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBfYXVnbWVudEZ1bmN0aW9uKGZ1bmMsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVzID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbn1cblxuLyoqXG4gKiBQYXJzZXMgZXJyb3JzIGFuZCBmYWlsZWQgc291cmNlIGNvZGUgZnJvbSBzaGFkZXJzIGluIG9yZGVyXG4gKiB0byBidWlsZCBkaXNwbGF5YWJsZSBlcnJvciBibG9ja3MuXG4gKiBJbnNwaXJlZCBieSBKYXVtZSBTYW5jaGV6IEVsaWFzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBFcnJvcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBTb3VyY2VcbiAqL1xuZnVuY3Rpb24gX3Byb2Nlc3NFcnJvcnMoZXJyb3JzLCBzb3VyY2UpIHtcblxuICAgIHZhciBjc3MgPSAnYm9keSxodG1se2JhY2tncm91bmQ6I2UzZTNlMztmb250LWZhbWlseTptb25hY28sbW9ub3NwYWNlO2ZvbnQtc2l6ZToxNHB4O2xpbmUtaGVpZ2h0OjEuN2VtfSdcbiAgICAgICAgICAgICsgJyNzaGFkZXJSZXBvcnR7bGVmdDowO3RvcDowO3JpZ2h0OjA7Ym94LXNpemluZzpib3JkZXItYm94O3Bvc2l0aW9uOmFic29sdXRlO3otaW5kZXg6MTAwMDtjb2xvcjonXG4gICAgICAgICAgICArICcjMjIyO3BhZGRpbmc6MTVweDt3aGl0ZS1zcGFjZTpub3JtYWw7bGlzdC1zdHlsZS10eXBlOm5vbmU7bWFyZ2luOjUwcHggYXV0bzttYXgtd2lkdGg6MTIwMHB4fSdcbiAgICAgICAgICAgICsgJyNzaGFkZXJSZXBvcnQgbGl7YmFja2dyb3VuZC1jb2xvcjojZmZmO21hcmdpbjoxM3B4IDA7Ym94LXNoYWRvdzowIDFweCAycHggcmdiYSgwLDAsMCwuMTUpOydcbiAgICAgICAgICAgICsgJ3BhZGRpbmc6MjBweCAzMHB4O2JvcmRlci1yYWRpdXM6MnB4O2JvcmRlci1sZWZ0OjIwcHggc29saWQgI2UwMTExMX1zcGFue2NvbG9yOiNlMDExMTE7J1xuICAgICAgICAgICAgKyAndGV4dC1kZWNvcmF0aW9uOnVuZGVybGluZTtmb250LXdlaWdodDo3MDB9I3NoYWRlclJlcG9ydCBsaSBwe3BhZGRpbmc6MDttYXJnaW46MH0nXG4gICAgICAgICAgICArICcjc2hhZGVyUmVwb3J0IGxpOm50aC1jaGlsZChldmVuKXtiYWNrZ3JvdW5kLWNvbG9yOiNmNGY0ZjR9J1xuICAgICAgICAgICAgKyAnI3NoYWRlclJlcG9ydCBsaSBwOmZpcnN0LWNoaWxke21hcmdpbi1ib3R0b206MTBweDtjb2xvcjojNjY2fSc7XG5cbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQoZWwpO1xuICAgIGVsLnRleHRDb250ZW50ID0gY3NzO1xuXG4gICAgdmFyIHJlcG9ydCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyk7XG4gICAgcmVwb3J0LnNldEF0dHJpYnV0ZSgnaWQnLCAnc2hhZGVyUmVwb3J0Jyk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChyZXBvcnQpO1xuXG4gICAgdmFyIHJlID0gL0VSUk9SOiBbXFxkXSs6KFtcXGRdKyk6ICguKykvZ21pO1xuICAgIHZhciBsaW5lcyA9IHNvdXJjZS5zcGxpdCgnXFxuJyk7XG5cbiAgICB2YXIgbTtcbiAgICB3aGlsZSAoKG0gPSByZS5leGVjKGVycm9ycykpICE9IG51bGwpIHtcbiAgICAgICAgaWYgKG0uaW5kZXggPT09IHJlLmxhc3RJbmRleCkgcmUubGFzdEluZGV4Kys7XG4gICAgICAgIHZhciBsaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gICAgICAgIHZhciBjb2RlID0gJzxwPjxzcGFuPkVSUk9SPC9zcGFuPiBcIicgKyBtWzJdICsgJ1wiIGluIGxpbmUgJyArIG1bMV0gKyAnPC9wPidcbiAgICAgICAgY29kZSArPSAnPHA+PGI+JyArIGxpbmVzW21bMV0gLSAxXS5yZXBsYWNlKC9eWyBcXHRdKy9nLCAnJykgKyAnPC9iPjwvcD4nO1xuICAgICAgICBsaS5pbm5lckhUTUwgPSBjb2RlO1xuICAgICAgICByZXBvcnQuYXBwZW5kQ2hpbGQobGkpO1xuICAgIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFV0aWxpdHkgPSByZXF1aXJlKCdmYW1vdXMtdXRpbGl0aWVzJyk7XG5cbnZhciB2ZXJ0ZXhXcmFwcGVyID0gcmVxdWlyZSgnZmFtb3VzLXdlYmdsLXNoYWRlcnMnKS52ZXJ0ZXg7XG52YXIgZnJhZ21lbnRXcmFwcGVyID0gcmVxdWlyZSgnZmFtb3VzLXdlYmdsLXNoYWRlcnMnKS5mcmFnbWVudDtcbnZhciBEZWJ1ZyA9IHJlcXVpcmUoJy4vRGVidWcnKTtcblxudmFyIFZFUlRFWF9TSEFERVIgPSAzNTYzMztcbnZhciBGUkFHTUVOVF9TSEFERVIgPSAzNTYzMjtcbnZhciBpZGVudGl0eU1hdHJpeCA9IFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxXTtcblxudmFyIGhlYWRlciA9ICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4nO1xuXG52YXIgVFlQRVMgPSB7XG4gICAgdW5kZWZpbmVkOiAnZmxvYXQgJyxcbiAgICAxOiAnZmxvYXQgJyxcbiAgICAyOiAndmVjMiAnLFxuICAgIDM6ICd2ZWMzICcsXG4gICAgNDogJ3ZlYzQgJyxcbiAgICAxNjogJ21hdDQgJ1xufTtcblxudmFyIGlucHV0VHlwZXMgPSB7XG4gICAgYmFzZUNvbG9yOiAndmVjMycsXG4gICAgbm9ybWFsOiAndmVjMycsXG4gICAgZ2xvc3NpbmVzczogJ2Zsb2F0JyxcbiAgICBtZXRhbG5lc3M6ICdmbG9hdCcsXG4gICAgcG9zaXRpb25PZmZzZXQ6ICd2ZXJ0J1xufTtcblxudmFyIG1hc2tzID0gIHtcbiAgICB2ZXJ0OiAxLFxuICAgIHZlYzM6IDIsXG4gICAgZmxvYXQ6IDRcbn07XG5cbi8qKlxuICogVW5pZm9ybSBrZXlzIGFuZCB2YWx1ZXNcbiAqL1xudmFyIHVuaWZvcm1zID0gVXRpbGl0eS5rZXlWYWx1ZVRvQXJyYXlzKHtcbiAgICBwZXJzcGVjdGl2ZTogaWRlbnRpdHlNYXRyaXgsXG4gICAgdmlldzogaWRlbnRpdHlNYXRyaXgsXG4gICAgcmVzb2x1dGlvbjogWzAsIDAsIDBdLFxuICAgIHRyYW5zZm9ybTogaWRlbnRpdHlNYXRyaXgsXG4gICAgc2l6ZTogWzEsIDEsIDFdLFxuICAgIHRpbWU6IFswXSxcbiAgICBvcGFjaXR5OiBbMV0sXG4gICAgbWV0YWxuZXNzOiBbMF0sXG4gICAgZ2xvc3NpbmVzczogWzBdLFxuICAgIGJhc2VDb2xvcjogWzEsIDEsIDFdLFxuICAgIG5vcm1hbDogWzEsIDEsIDFdLFxuICAgIHBvc2l0aW9uT2Zmc2V0OiBbMCwgMCwgMF0sXG4gICAgdV9MaWdodFBvc2l0aW9uOiBpZGVudGl0eU1hdHJpeCxcbiAgICB1X0xpZ2h0Q29sb3I6IGlkZW50aXR5TWF0cml4LFxuICAgIHVfQW1iaWVudExpZ2h0OiBbMCwgMCwgMF0sXG4gICAgdV9GbGF0U2hhZGluZzogWzBdLFxuICAgIHVfTnVtTGlnaHRzOiBbMF1cbn0pO1xuXG4vKipcbiAqIEF0dHJpYnV0ZXMga2V5cyBhbmQgdmFsdWVzXG4gKi9cbnZhciBhdHRyaWJ1dGVzID0gVXRpbGl0eS5rZXlWYWx1ZVRvQXJyYXlzKHtcbiAgICBwb3M6IFswLCAwLCAwXSxcbiAgICB0ZXhDb29yZDogWzAsIDBdLFxuICAgIG5vcm1hbHM6IFswLCAwLCAwXVxufSk7XG5cbi8qKlxuICogVmFyeWluZ3Mga2V5cyBhbmQgdmFsdWVzXG4gKi9cbnZhciB2YXJ5aW5ncyA9IFV0aWxpdHkua2V5VmFsdWVUb0FycmF5cyh7XG4gICAgdl9UZXh0dXJlQ29vcmRpbmF0ZTogWzAsIDBdLFxuICAgIHZfTm9ybWFsOiBbMCwgMCwgMF0sXG4gICAgdl9Qb3NpdGlvbjogWzAsIDAsIDBdLFxuICAgIHZfRXllVmVjdG9yOiBbMCwgMCwgMF1cbn0pO1xuXG4vKipcbiAqIEEgY2xhc3MgdGhhdCBoYW5kbGVzIGludGVyYWN0aW9ucyB3aXRoIHRoZSBXZWJHTCBzaGFkZXIgcHJvZ3JhbVxuICogdXNlZCBieSBhIHNwZWNpZmljIGNvbnRleHQuICBJdCBtYW5hZ2VzIGNyZWF0aW9uIG9mIHRoZSBzaGFkZXIgcHJvZ3JhbVxuICogYW5kIHRoZSBhdHRhY2hlZCB2ZXJ0ZXggYW5kIGZyYWdtZW50IHNoYWRlcnMuICBJdCBpcyBhbHNvIGluIGNoYXJnZSBvZlxuICogcGFzc2luZyBhbGwgdW5pZm9ybXMgdG8gdGhlIFdlYkdMQ29udGV4dC5cbiAqXG4gKiBAY2xhc3MgUHJvZ3JhbVxuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtXZWJHTF9Db250ZXh0fSBnbCBDb250ZXh0IHRvIGJlIHVzZWQgdG8gY3JlYXRlIHRoZSBzaGFkZXIgcHJvZ3JhbS5cbiAqL1xuZnVuY3Rpb24gUHJvZ3JhbShnbCwgb3B0aW9ucykge1xuICAgIHRoaXMuZ2wgPSBnbDtcbiAgICB0aGlzLnRleHR1cmVTbG90cyA9IDE7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHRoaXMucmVnaXN0ZXJlZE1hdGVyaWFscyA9IHt9O1xuICAgIHRoaXMuZmxhZ2dlZFVuaWZvcm1zID0gW107XG4gICAgdGhpcy5jYWNoZWRVbmlmb3JtcyAgPSB7fTtcblxuICAgIHRoaXMuZGVmaW5pdGlvblZlYyA9IFtdO1xuICAgIHRoaXMuZGVmaW5pdGlvbkZsb2F0ID0gW107XG4gICAgdGhpcy5hcHBsaWNhdGlvblZlYyA9IFtdO1xuICAgIHRoaXMuYXBwbGljYXRpb25GbG9hdCA9IFtdO1xuICAgIHRoaXMuYXBwbGljYXRpb25WZXJ0ID0gW107XG4gICAgdGhpcy5kZWZpbml0aW9uVmVydCA9IFtdO1xuXG4gICAgdGhpcy5yZXNldFByb2dyYW0oKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBtYXRlcmlhbCBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQgdG9cbiAqIHRoZSBzaGFkZXIgcHJvZ3JhbS5cbiAqXG4gKiBAbWV0aG9kIHJlZ2lzdGVyTWF0ZXJpYWxcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBOYW1lIG9mIHRhcmdldCBpbnB1dCBvZiBtYXRlcmlhbC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXRlcmlhbCBDb21waWxlZCBtYXRlcmlhbCBvYmplY3QgYmVpbmcgdmVyaWZpZWQuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IHByb2dyYW0uXG4gKi9cblByb2dyYW0ucHJvdG90eXBlLnJlZ2lzdGVyTWF0ZXJpYWwgPSBmdW5jdGlvbiByZWdpc3Rlck1hdGVyaWFsKG5hbWUsIG1hdGVyaWFsKSB7XG4gICAgdmFyIGNvbXBpbGVkID0gbWF0ZXJpYWw7XG4gICAgdmFyIHR5cGUgPSBpbnB1dFR5cGVzW25hbWVdO1xuICAgIHZhciBtYXNrID0gbWFza3NbdHlwZV07XG5cbiAgICBpZiAoKHRoaXMucmVnaXN0ZXJlZE1hdGVyaWFsc1ttYXRlcmlhbC5faWRdICYgbWFzaykgPT09IG1hc2spIHJldHVybjtcblxuICAgIGZvciAodmFyIGsgaW4gY29tcGlsZWQudW5pZm9ybXMpIHtcbiAgICAgICAgaWYgKHVuaWZvcm1zLmtleXMuaW5kZXhPZihrKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHVuaWZvcm1zLmtleXMucHVzaChrKTtcbiAgICAgICAgICAgIHVuaWZvcm1zLnZhbHVlcy5wdXNoKGNvbXBpbGVkLnVuaWZvcm1zW2tdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGsgaW4gY29tcGlsZWQudmFyeWluZ3MpIHtcbiAgICAgICAgaWYgKHZhcnlpbmdzLmtleXMuaW5kZXhPZihrKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHZhcnlpbmdzLmtleXMucHVzaChrKTtcbiAgICAgICAgICAgIHZhcnlpbmdzLnZhbHVlcy5wdXNoKGNvbXBpbGVkLnZhcnlpbmdzW2tdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGsgaW4gY29tcGlsZWQuYXR0cmlidXRlcykge1xuICAgICAgICBpZiAoYXR0cmlidXRlcy5rZXlzLmluZGV4T2YoaykgPT09IC0xKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzLmtleXMucHVzaChrKTtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMudmFsdWVzLnB1c2goY29tcGlsZWQuYXR0cmlidXRlc1trXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnJlZ2lzdGVyZWRNYXRlcmlhbHNbbWF0ZXJpYWwuX2lkXSB8PSBtYXNrO1xuXG4gICAgaWYgKHR5cGUgPT0gJ2Zsb2F0Jykge1xuICAgICAgICB0aGlzLmRlZmluaXRpb25GbG9hdC5wdXNoKG1hdGVyaWFsLmRlZmluZXMpO1xuICAgICAgICB0aGlzLmRlZmluaXRpb25GbG9hdC5wdXNoKCdmbG9hdCBmYV8nICsgbWF0ZXJpYWwuX2lkICsgJygpIHtcXG4gJyAgKyBjb21waWxlZC5nbHNsICsgJyBcXG59Jyk7XG4gICAgICAgIHRoaXMuYXBwbGljYXRpb25GbG9hdC5wdXNoKCdpZiAoaW50KGFicyhJRCkpID09ICcgKyBtYXRlcmlhbC5faWQgKyAnKSByZXR1cm4gZmFfJyArIG1hdGVyaWFsLl9pZCAgKyAnKCk7Jyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT0gJ3ZlYzMnKSB7XG4gICAgICAgIHRoaXMuZGVmaW5pdGlvblZlYy5wdXNoKG1hdGVyaWFsLmRlZmluZXMpO1xuICAgICAgICB0aGlzLmRlZmluaXRpb25WZWMucHVzaCgndmVjMyBmYV8nICsgbWF0ZXJpYWwuX2lkICsgJygpIHtcXG4gJyAgKyBjb21waWxlZC5nbHNsICsgJyBcXG59Jyk7XG4gICAgICAgIHRoaXMuYXBwbGljYXRpb25WZWMucHVzaCgnaWYgKGludChhYnMoSUQueCkpID09ICcgKyBtYXRlcmlhbC5faWQgKyAnKSByZXR1cm4gZmFfJyArIG1hdGVyaWFsLl9pZCArICcoKTsnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PSAndmVydCcpIHtcbiAgICAgICAgdGhpcy5kZWZpbml0aW9uVmVydC5wdXNoKG1hdGVyaWFsLmRlZmluZXMpO1xuICAgICAgICB0aGlzLmRlZmluaXRpb25WZXJ0LnB1c2goJ3ZlYzMgZmFfJyArIG1hdGVyaWFsLl9pZCArICcoKSB7XFxuICcgICsgY29tcGlsZWQuZ2xzbCArICcgXFxufScpO1xuICAgICAgICB0aGlzLmFwcGxpY2F0aW9uVmVydC5wdXNoKCdpZiAoaW50KGFicyhJRC54KSkgPT0gJyArIG1hdGVyaWFsLl9pZCArICcpIHJldHVybiBmYV8nICsgbWF0ZXJpYWwuX2lkICsgJygpOycpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnJlc2V0UHJvZ3JhbSgpO1xufTtcblxuLyoqXG4gKiBDbGVhcnMgYWxsIGNhY2hlZCB1bmlmb3JtcyBhbmQgYXR0cmlidXRlIGxvY2F0aW9ucy4gIEFzc2VtYmxlc1xuICogbmV3IGZyYWdtZW50IGFuZCB2ZXJ0ZXggc2hhZGVycyBhbmQgYmFzZWQgb24gbWF0ZXJpYWwgZnJvbVxuICogY3VycmVudGx5IHJlZ2lzdGVyZWQgbWF0ZXJpYWxzLiAgQXR0YWNoZXMgc2FpZCBzaGFkZXJzIHRvIG5ld1xuICogc2hhZGVyIHByb2dyYW0gYW5kIHVwb24gc3VjY2VzcyBsaW5rcyBwcm9ncmFtIHRvIHRoZSBXZWJHTFxuICogY29udGV4dC5cbiAqXG4gKiBAbWV0aG9kIHJlc2V0UHJvZ3JhbVxuICpcbiAqIEByZXR1cm4ge1Byb2dyYW19IEN1cnJlbnQgcHJvZ3JhbS5cbiAqL1xuUHJvZ3JhbS5wcm90b3R5cGUucmVzZXRQcm9ncmFtID0gZnVuY3Rpb24gcmVzZXRQcm9ncmFtKCkge1xuICAgIHZhciB2c0NodW5rRGVmaW5lcyA9IFtdO1xuICAgIHZhciB2c0NodW5rQXBwbGllcyA9IFtdO1xuICAgIHZhciBmc0NodW5rRGVmaW5lcyA9IFtdO1xuICAgIHZhciBmc0NodW5rQXBwbGllcyA9IFtdO1xuXG4gICAgdmFyIHZlcnRleEhlYWRlciA9IFtoZWFkZXJdO1xuICAgIHZhciBmcmFnbWVudEhlYWRlciA9IFtoZWFkZXJdO1xuXG4gICAgdmFyIGZyYWdtZW50U291cmNlO1xuICAgIHZhciB2ZXJ0ZXhTb3VyY2U7XG4gICAgdmFyIG1hdGVyaWFsO1xuICAgIHZhciBwcm9ncmFtO1xuICAgIHZhciBjaHVuaztcbiAgICB2YXIgbmFtZTtcbiAgICB2YXIgdmFsdWU7XG4gICAgdmFyIGk7XG5cbiAgICB0aGlzLnVuaWZvcm1Mb2NhdGlvbnMgICA9IFtdO1xuICAgIHRoaXMuYXR0cmlidXRlTG9jYXRpb25zID0ge307XG5cbiAgICB0aGlzLmF0dHJpYnV0ZU5hbWVzID0gVXRpbGl0eS5jbG9uZShhdHRyaWJ1dGVzLmtleXMpO1xuICAgIHRoaXMuYXR0cmlidXRlVmFsdWVzID0gVXRpbGl0eS5jbG9uZShhdHRyaWJ1dGVzLnZhbHVlcyk7XG5cbiAgICB0aGlzLnZhcnlpbmdOYW1lcyA9IFV0aWxpdHkuY2xvbmUodmFyeWluZ3Mua2V5cyk7XG4gICAgdGhpcy52YXJ5aW5nVmFsdWVzID0gVXRpbGl0eS5jbG9uZSh2YXJ5aW5ncy52YWx1ZXMpO1xuXG4gICAgdGhpcy51bmlmb3JtTmFtZXMgPSBVdGlsaXR5LmNsb25lKHVuaWZvcm1zLmtleXMpO1xuICAgIHRoaXMudW5pZm9ybVZhbHVlcyA9IFV0aWxpdHkuY2xvbmUodW5pZm9ybXMudmFsdWVzKTtcblxuICAgIHRoaXMuZmxhZ2dlZFVuaWZvcm1zID0gW107XG4gICAgdGhpcy5jYWNoZWRVbmlmb3JtcyA9IHt9O1xuXG4gICAgZnJhZ21lbnRIZWFkZXIucHVzaCgndW5pZm9ybSBzYW1wbGVyMkQgaW1hZ2U7XFxuJyk7XG5cbiAgICBpZiAodGhpcy5hcHBsaWNhdGlvblZlcnQubGVuZ3RoID4gMSkge1xuICAgICAgICB2ZXJ0ZXhIZWFkZXIucHVzaCgndW5pZm9ybSBzYW1wbGVyMkQgaW1hZ2U7XFxuJyk7XG4gICAgfVxuXG4gICAgZm9yKGkgPSAwOyBpIDwgdGhpcy51bmlmb3JtTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmFtZSA9IHRoaXMudW5pZm9ybU5hbWVzW2ldLCB2YWx1ZSA9IHRoaXMudW5pZm9ybVZhbHVlc1tpXTtcbiAgICAgICAgdmVydGV4SGVhZGVyLnB1c2goJ3VuaWZvcm0gJyArIFRZUEVTW3ZhbHVlLmxlbmd0aF0gKyBuYW1lICsgJztcXG4nKTtcbiAgICAgICAgZnJhZ21lbnRIZWFkZXIucHVzaCgndW5pZm9ybSAnICsgVFlQRVNbdmFsdWUubGVuZ3RoXSArIG5hbWUgKyAnO1xcbicpO1xuICAgIH1cblxuICAgIGZvcihpID0gMDsgaSA8IHRoaXMuYXR0cmlidXRlTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmFtZSA9IHRoaXMuYXR0cmlidXRlTmFtZXNbaV0sIHZhbHVlID0gdGhpcy5hdHRyaWJ1dGVWYWx1ZXNbaV07XG4gICAgICAgIHZlcnRleEhlYWRlci5wdXNoKCdhdHRyaWJ1dGUgJyArIFRZUEVTW3ZhbHVlLmxlbmd0aF0gKyBuYW1lICsgJztcXG4nKTtcbiAgICB9XG5cbiAgICBmb3IoaSA9IDA7IGkgPCB0aGlzLnZhcnlpbmdOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBuYW1lID0gdGhpcy52YXJ5aW5nTmFtZXNbaV0sIHZhbHVlID0gdGhpcy52YXJ5aW5nVmFsdWVzW2ldO1xuICAgICAgICB2ZXJ0ZXhIZWFkZXIucHVzaCgndmFyeWluZyAnICsgVFlQRVNbdmFsdWUubGVuZ3RoXSAgKyBuYW1lICsgJztcXG4nKTtcbiAgICAgICAgZnJhZ21lbnRIZWFkZXIucHVzaCgndmFyeWluZyAnICsgVFlQRVNbdmFsdWUubGVuZ3RoXSArIG5hbWUgKyAnO1xcbicpO1xuICAgIH1cblxuICAgIHZlcnRleFNvdXJjZSA9IHZlcnRleEhlYWRlci5qb2luKCcnKSArIHZlcnRleFdyYXBwZXJcbiAgICAgICAgLnJlcGxhY2UoJyN2ZXJ0X2RlZmluaXRpb25zJywgdGhpcy5kZWZpbml0aW9uVmVydC5qb2luKCdcXG4nKSlcbiAgICAgICAgLnJlcGxhY2UoJyN2ZXJ0X2FwcGxpY2F0aW9ucycsIHRoaXMuYXBwbGljYXRpb25WZXJ0LmpvaW4oJ1xcbicpKTtcblxuICAgIGZyYWdtZW50U291cmNlID0gZnJhZ21lbnRIZWFkZXIuam9pbignJykgKyBmcmFnbWVudFdyYXBwZXJcbiAgICAgICAgLnJlcGxhY2UoJyN2ZWNfZGVmaW5pdGlvbnMnLCB0aGlzLmRlZmluaXRpb25WZWMuam9pbignXFxuJykpXG4gICAgICAgIC5yZXBsYWNlKCcjdmVjX2FwcGxpY2F0aW9ucycsIHRoaXMuYXBwbGljYXRpb25WZWMuam9pbignXFxuJykpXG4gICAgICAgIC5yZXBsYWNlKCcjZmxvYXRfZGVmaW5pdGlvbnMnLCB0aGlzLmRlZmluaXRpb25GbG9hdC5qb2luKCdcXG4nKSlcbiAgICAgICAgLnJlcGxhY2UoJyNmbG9hdF9hcHBsaWNhdGlvbnMnLCB0aGlzLmFwcGxpY2F0aW9uRmxvYXQuam9pbignXFxuJykpO1xuXG4gICAgcHJvZ3JhbSA9IHRoaXMuZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuXG4gICAgdGhpcy5nbC5hdHRhY2hTaGFkZXIoXG4gICAgICAgIHByb2dyYW0sXG4gICAgICAgIHRoaXMuY29tcGlsZVNoYWRlcih0aGlzLmdsLmNyZWF0ZVNoYWRlcihWRVJURVhfU0hBREVSKSwgdmVydGV4U291cmNlKVxuICAgICk7XG5cbiAgICB0aGlzLmdsLmF0dGFjaFNoYWRlcihcbiAgICAgICAgcHJvZ3JhbSxcbiAgICAgICAgdGhpcy5jb21waWxlU2hhZGVyKHRoaXMuZ2wuY3JlYXRlU2hhZGVyKEZSQUdNRU5UX1NIQURFUiksIGZyYWdtZW50U291cmNlKVxuICAgICk7XG5cbiAgICB0aGlzLmdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuXG4gICAgaWYgKCEgdGhpcy5nbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIHRoaXMuZ2wuTElOS19TVEFUVVMpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2xpbmsgZXJyb3I6ICcgKyB0aGlzLmdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pKTtcbiAgICAgICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XG4gICAgICAgIHRoaXMuZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xuICAgIH1cblxuICAgIHRoaXMuc2V0VW5pZm9ybXModGhpcy51bmlmb3JtTmFtZXMsIHRoaXMudW5pZm9ybVZhbHVlcyk7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29tcGFyZXMgdGhlIHZhbHVlIG9mIHRoZSBpbnB1dCB1bmlmb3JtIHZhbHVlIGFnYWluc3RcbiAqIHRoZSBjYWNoZWQgdmFsdWUgc3RvcmVkIG9uIHRoZSBQcm9ncmFtIGNsYXNzLiAgVXBkYXRlcyBhbmRcbiAqIGNyZWF0ZXMgbmV3IGVudHJpZXMgaW4gdGhlIGNhY2hlIHdoZW4gbmVjZXNzYXJ5LlxuICpcbiAqIEBtZXRob2QgdW5pZm9ybUlzQ2FjaGVkXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRhcmdldE5hbWUgS2V5IG9mIHVuaWZvcm0gc3BlYyBiZWluZyBldmFsdWF0ZWQuXG4gKiBAcGFyYW0ge051bWJlcnxBcnJheX0gdmFsdWUgVmFsdWUgb2YgdW5pZm9ybSBzcGVjIGJlaW5nIGV2YWx1YXRlZC5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IFZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgdW5pZm9ybSBiZWluZyBzZXRcbiAqIGlzIGNhY2hlZC5cbiAqL1xuUHJvZ3JhbS5wcm90b3R5cGUudW5pZm9ybUlzQ2FjaGVkID0gZnVuY3Rpb24odGFyZ2V0TmFtZSwgdmFsdWUpIHtcbiAgICBpZih0aGlzLmNhY2hlZFVuaWZvcm1zW3RhcmdldE5hbWVdID09IG51bGwpIHtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5jYWNoZWRVbmlmb3Jtc1t0YXJnZXROYW1lXSA9IG5ldyBGbG9hdDMyQXJyYXkodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jYWNoZWRVbmlmb3Jtc1t0YXJnZXROYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIHZhciBpID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBpZih2YWx1ZVtpXSAhPT0gdGhpcy5jYWNoZWRVbmlmb3Jtc1t0YXJnZXROYW1lXVtpXSkge1xuICAgICAgICAgICAgICAgIGkgPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd2hpbGUoaS0tKSB0aGlzLmNhY2hlZFVuaWZvcm1zW3RhcmdldE5hbWVdW2ldID0gdmFsdWVbaV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZWxzZSBpZiAodGhpcy5jYWNoZWRVbmlmb3Jtc1t0YXJnZXROYW1lXSAhPT0gdmFsdWUpIHtcbiAgICAgICAgdGhpcy5jYWNoZWRVbmlmb3Jtc1t0YXJnZXROYW1lXSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEhhbmRsZXMgYWxsIHBhc3Npbmcgb2YgdW5pZm9ybXMgdG8gV2ViR0wgZHJhd2luZyBjb250ZXh0LiAgVGhpc1xuICogZnVuY3Rpb24gd2lsbCBmaW5kIHRoZSB1bmlmb3JtIGxvY2F0aW9uIGFuZCB0aGVuLCBiYXNlZCBvblxuICogYSB0eXBlIGluZmVycmVkIGZyb20gdGhlIGphdmFzY3JpcHQgdmFsdWUgb2YgdGhlIHVuaWZvcm0sIGl0IHdpbGwgY2FsbFxuICogdGhlIGFwcHJvcHJpYXRlIGZ1bmN0aW9uIHRvIHBhc3MgdGhlIHVuaWZvcm0gdG8gV2ViR0wuICBGaW5hbGx5LFxuICogc2V0VW5pZm9ybXMgd2lsbCBpdGVyYXRlIHRocm91Z2ggdGhlIHBhc3NlZCBpbiBzaGFkZXJDaHVua3MgKGlmIGFueSlcbiAqIGFuZCBzZXQgdGhlIGFwcHJvcHJpYXRlIHVuaWZvcm1zIHRvIHNwZWNpZnkgd2hpY2ggY2h1bmtzIHRvIHVzZS5cbiAqXG4gKiBAbWV0aG9kIHNldFVuaWZvcm1zXG4gKlxuICogQHBhcmFtIHtBcnJheX0gdW5pZm9ybU5hbWVzIEFycmF5IGNvbnRhaW5pbmcgdGhlIGtleXMgb2YgYWxsIHVuaWZvcm1zIHRvIGJlIHNldC5cbiAqIEBwYXJhbSB7QXJyYXl9IHVuaWZvcm1WYWx1ZSBBcnJheSBjb250YWluaW5nIHRoZSB2YWx1ZXMgb2YgYWxsIHVuaWZvcm1zIHRvIGJlIHNldC5cbiAqXG4gKiBAcmV0dXJuIHtQcm9ncmFtfSBDdXJyZW50IHByb2dyYW0uXG4gKi9cblByb2dyYW0ucHJvdG90eXBlLnNldFVuaWZvcm1zID0gZnVuY3Rpb24gKHVuaWZvcm1OYW1lcywgdW5pZm9ybVZhbHVlKSB7XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICB2YXIgbG9jYXRpb247XG4gICAgdmFyIHZhbHVlO1xuICAgIHZhciBuYW1lO1xuICAgIHZhciBmbGFnO1xuICAgIHZhciBsZW47XG4gICAgdmFyIGk7XG5cbiAgICBpZiAoIXRoaXMucHJvZ3JhbSkgcmV0dXJuO1xuXG4gICAgbGVuID0gdW5pZm9ybU5hbWVzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbmFtZSA9IHVuaWZvcm1OYW1lc1tpXTtcbiAgICAgICAgdmFsdWUgPSB1bmlmb3JtVmFsdWVbaV07XG5cbiAgICAgICAgLy8gUmV0cmVpdmUgdGhlIGNhY2hlZCBsb2NhdGlvbiBvZiB0aGUgdW5pZm9ybSxcbiAgICAgICAgLy8gcmVxdWVzdGluZyBhIG5ldyBsb2NhdGlvbiBmcm9tIHRoZSBXZWJHTCBjb250ZXh0XG4gICAgICAgIC8vIGlmIGl0IGRvZXMgbm90IHlldCBleGlzdC5cblxuICAgICAgICBsb2NhdGlvbiA9IHRoaXMudW5pZm9ybUxvY2F0aW9uc1tuYW1lXSB8fCBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBuYW1lKTtcbiAgICAgICAgaWYgKCFsb2NhdGlvbikgY29udGludWU7XG5cbiAgICAgICAgdGhpcy51bmlmb3JtTG9jYXRpb25zW25hbWVdID0gbG9jYXRpb247XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHZhbHVlIGlzIGFscmVhZHkgc2V0IGZvciB0aGVcbiAgICAgICAgLy8gZ2l2ZW4gdW5pZm9ybS5cblxuICAgICAgICBpZiAodGhpcy51bmlmb3JtSXNDYWNoZWQobmFtZSwgdmFsdWUpKSBjb250aW51ZTtcblxuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIGNvcnJlY3QgZnVuY3Rpb24gYW5kIHBhc3MgdGhlIHVuaWZvcm1cbiAgICAgICAgLy8gdmFsdWUgdG8gV2ViR0wuXG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHZhbHVlIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNhc2UgNDogIGdsLnVuaWZvcm00ZnYobG9jYXRpb24sIHZhbHVlKTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOiAgZ2wudW5pZm9ybTNmdihsb2NhdGlvbiwgdmFsdWUpOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6ICBnbC51bmlmb3JtMmZ2KGxvY2F0aW9uLCB2YWx1ZSk7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTY6IGdsLnVuaWZvcm1NYXRyaXg0ZnYobG9jYXRpb24sIGZhbHNlLCB2YWx1ZSk7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTogIGdsLnVuaWZvcm0xZnYobG9jYXRpb24sIHZhbHVlKTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA5OiAgZ2wudW5pZm9ybU1hdHJpeDNmdihsb2NhdGlvbiwgZmFsc2UsIHZhbHVlKTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgJ2NhbnQgbG9hZCB1bmlmb3JtIFwiJyArIG5hbWUgKyAnXCIgd2l0aCB2YWx1ZTonICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCEgaXNOYU4ocGFyc2VGbG9hdCh2YWx1ZSkpICYmIGlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgZ2wudW5pZm9ybTFmKGxvY2F0aW9uLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyAnc2V0IHVuaWZvcm0gXCInICsgbmFtZSArICdcIiB0byBpbnZhbGlkIHR5cGUgOicgKyB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkcyBzaGFkZXIgc291cmNlIHRvIHNoYWRlciBhbmQgY29tcGlsZXMgdGhlIGlucHV0IHNoYWRlci4gIENoZWNrc1xuICogY29tcGlsZSBzdGF0dXMgYW5kIGxvZ3MgZXJyb3IgaWYgbmVjZXNzYXJ5LlxuICpcbiAqIEBtZXRob2QgY29tcGlsZVNoYWRlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzaGFkZXIgUHJvZ3JhbSB0byBiZSBjb21waWxlZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzb3VyY2UgU291cmNlIHRvIGJlIHVzZWQgaW4gdGhlIHNoYWRlci5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IENvbXBpbGVkIHNoYWRlci5cbiAqL1xuUHJvZ3JhbS5wcm90b3R5cGUuY29tcGlsZVNoYWRlciA9IGZ1bmN0aW9uIGNvbXBpbGVTaGFkZXIoc2hhZGVyLCBzb3VyY2UpIHtcbiAgICB2YXIgaSA9IDE7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmRlYnVnKSB7XG4gICAgICAgIHRoaXMuZ2wuY29tcGlsZVNoYWRlciA9IERlYnVnLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgdGhpcy5nbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzb3VyY2UpO1xuICAgIHRoaXMuZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuICAgIGlmICghdGhpcy5nbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCB0aGlzLmdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdjb21waWxlIGVycm9yOiAnICsgdGhpcy5nbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcikpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCcxOiAnICsgc291cmNlLnJlcGxhY2UoL1xcbi9nLCBmdW5jdGlvbiAoKSB7IHJldHVybiAnXFxuJyArIChpKz0xKSArICc6ICc7IH0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2hhZGVyO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9ncmFtO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFRleHR1cmUgaXMgYSBwcml2YXRlIGNsYXNzIHRoYXQgc3RvcmVzIGltYWdlIGRhdGFcbiAqIHRvIGJlIGFjY2Vzc2VkIGZyb20gYSBzaGFkZXIgb3IgdXNlZCBhcyBhIHJlbmRlciB0YXJnZXQuXG4gKlxuICogQGNsYXNzIFRleHR1cmVcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBUZXh0dXJlKGdsLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5pZCA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICB0aGlzLndpZHRoID0gb3B0aW9ucy53aWR0aCB8fCAwO1xuICAgIHRoaXMuaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQgfHwgMDtcbiAgICB0aGlzLmZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0IHx8IGdsLlJHQkE7XG4gICAgdGhpcy50eXBlID0gb3B0aW9ucy50eXBlIHx8IGdsLlVOU0lHTkVEX0JZVEU7XG4gICAgdGhpcy5nbCA9IGdsO1xuXG4gICAgdGhpcy5iaW5kKCk7XG5cbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBmYWxzZSk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCBmYWxzZSk7XG4gICAgXG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsW29wdGlvbnMubWFnRmlsdGVyXSB8fCBnbC5ORUFSRVNUKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2xbb3B0aW9ucy5taW5GaWx0ZXJdIHx8IGdsLk5FQVJFU1QpO1xuXG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2xbb3B0aW9ucy53cmFwU10gfHwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2xbb3B0aW9ucy53cmFwU10gfHwgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIHRoaXMuZm9ybWF0LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgMCwgdGhpcy5mb3JtYXQsIHRoaXMudHlwZSwgbnVsbCk7XG5cbiAgICBpZiAob3B0aW9ucy5taXBtYXAgIT09IGZhbHNlICYmIGlzUG93ZXJPZlR3byh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCkpIHtcbiAgICAgICAgZ2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV8yRCk7XG4gICAgfVxuXG4gICAgdGhpcy51bmJpbmQoKTtcbn1cblxuLyoqXG4gKiBCaW5kcyB0aGlzIHRleHR1cmUgYXMgdGhlIHNlbGVjdGVkIHRhcmdldC5cbiAqXG4gKiBAbWV0aG9kIGJpbmRcbiAqIEBjaGFpbmFibGVcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gdW5pdCBUaGUgdGV4dHVyZSBzbG90IGluIHdoaWNoIHRvIHVwbG9hZCB0aGUgZGF0YS5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgdGV4dHVyZSBpbnN0YW5jZS5cbiAqL1xuVGV4dHVyZS5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIGJpbmQodW5pdCkge1xuICAgIHRoaXMuZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkUwICsgKHVuaXQgfHwgMCkpO1xuICAgIHRoaXMuZ2wuYmluZFRleHR1cmUodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLmlkKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRXJhc2VzIHRoZSB0ZXh0dXJlIGRhdGEgaW4gdGhlIGdpdmVuIHRleHR1cmUgc2xvdC5cbiAqXG4gKiBAbWV0aG9kIHVuYmluZFxuICogQGNoYWluYWJsZVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB1bml0IFRoZSB0ZXh0dXJlIHNsb3QgaW4gd2hpY2ggdG8gY2xlYW4gdGhlIGRhdGEuXG4gKiBcbiAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCB0ZXh0dXJlIGluc3RhbmNlLlxuICovXG5UZXh0dXJlLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbiB1bmJpbmQodW5pdCkge1xuICAgIHRoaXMuZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkUwICsgKHVuaXQgfHwgMCkpO1xuICAgIHRoaXMuZ2wuYmluZFRleHR1cmUodGhpcy5nbC5URVhUVVJFXzJELCBudWxsKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVwbGFjZXMgdGhlIGltYWdlIGRhdGEgaW4gdGhlIHRleHR1cmUgd2l0aCB0aGUgZ2l2ZW4gaW1hZ2UuXG4gKlxuICogQG1ldGhvZCBzZXRJbWFnZVxuICogQGNoYWluYWJsZVxuICpcbiAqIEBwYXJhbSB7SW1hZ2V9IGltZyBUaGUgaW1hZ2Ugb2JqZWN0IHRvIHVwbG9hZCBwaXhlbCBkYXRhIGZyb20uXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IHRleHR1cmUgaW5zdGFuY2UuXG4gKi9cblRleHR1cmUucHJvdG90eXBlLnNldEltYWdlID0gZnVuY3Rpb24gc2V0SW1hZ2UoaW1nKSB7XG4gICAgdGhpcy5nbC5iaW5kVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMuaWQpO1xuICAgIHRoaXMuZ2wudGV4SW1hZ2UyRCh0aGlzLmdsLlRFWFRVUkVfMkQsIDAsIHRoaXMuZm9ybWF0LCB0aGlzLmZvcm1hdCwgdGhpcy50eXBlLCBpbWcpO1xuICAgIHRoaXMuZ2wuYmluZFRleHR1cmUodGhpcy5nbC5URVhUVVJFXzJELCBudWxsKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVwbGFjZXMgdGhlIGltYWdlIGRhdGEgaW4gdGhlIHRleHR1cmUgd2l0aCBhbiBhcnJheSBvZiBhcmJpdHJhcnkgZGF0YS5cbiAqXG4gKiBAbWV0aG9kIHNldEFycmF5XG4gKiBAY2hhaW5hYmxlXG4gKlxuICogQHBhcmFtIHtBcnJheX0gaW5wdXQgQXJyYXkgdG8gYmUgc2V0IGFzIGRhdGEgdG8gdGV4dHVyZS4gXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IHRleHR1cmUgaW5zdGFuY2UuXG4gKi9cblRleHR1cmUucHJvdG90eXBlLnNldEFycmF5ID0gZnVuY3Rpb24gc2V0QXJyYXkoaW5wdXQpIHtcbiAgICB0aGlzLmdsLmJpbmRUZXh0dXJlKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGhpcy5pZCk7XG4gICAgdGhpcy5nbC50ZXhJbWFnZTJEKHRoaXMuZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5mb3JtYXQsIDEsIDEsIDAsIHRoaXMuZm9ybWF0LCB0aGlzLnR5cGUsIG5ldyBVaW50OEFycmF5KGlucHV0KSk7XG4gICAgdGhpcy5nbC5iaW5kVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkVfMkQsIG51bGwpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEdW1wcyB0aGUgcmdiLXBpeGVsIGNvbnRlbnRzIG9mIGEgdGV4dHVyZSBpbnRvIGFuIGFycmF5IGZvciBkZWJ1Z2dpbmcgcHVycG9zZXNcbiAqXG4gKiBAbWV0aG9kIHJlYWRCYWNrXG4gKiBAY2hhaW5hYmxlXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHgtb2Zmc2V0IGJldHdlZW4gdGV4dHVyZSBjb29yZGluYXRlcyBhbmQgc25hcHNob3RcbiAqIEBwYXJhbSB7TnVtYmVyfSB5LW9mZnNldCBiZXR3ZWVuIHRleHR1cmUgY29vcmRpbmF0ZXMgYW5kIHNuYXBzaG90XG4gKiBAcGFyYW0ge051bWJlcn0geC1kZXB0aCBvZiB0aGUgc25hcHNob3RcbiAqIEBwYXJhbSB7TnVtYmVyfSB5LWRlcHRoIG9mIHRoZSBzbmFwc2hvdFxuICogXG4gKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2YgdGhlIHBpeGVscyBjb250YWluZWQgaW4gdGhlIHNuYXBzaG90LlxuICovXG5UZXh0dXJlLnByb3RvdHlwZS5yZWFkQmFjayA9IGZ1bmN0aW9uIHJlYWRCYWNrKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIHZhciBwaXhlbHM7XG4gICAgeCA9IHggfHwgMDtcbiAgICB5ID0geSB8fCAwO1xuICAgIHdpZHRoID0gd2lkdGggfHwgdGhpcy53aWR0aDtcbiAgICBoZWlnaHQgPSBoZWlnaHQgfHwgdGhpcy5oZWlnaHQ7XG4gICAgdmFyIGZiID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZiKTtcbiAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRoaXMuaWQsIDApO1xuICAgIGlmIChnbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKGdsLkZSQU1FQlVGRkVSKSA9PSBnbC5GUkFNRUJVRkZFUl9DT01QTEVURSkge1xuICAgICAgICBwaXhlbHMgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgICAgICBnbC5yZWFkUGl4ZWxzKHgsIHksIHdpZHRoLCBoZWlnaHQsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHBpeGVscyk7XG4gICAgfVxuICAgIHJldHVybiBwaXhlbHM7XG59O1xuXG4vKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGJvdGggaW5wdXQgdmFsdWVzIGFyZSBwb3dlci1vZi10d28gbnVtYmVycy5cbiAqXG4gKiBAbWV0aG9kIGlzUG93ZXJPZlR3b1xuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gd2lkdGggTnVtYmVyIHJlcHJlc2VudGluZyB0ZXh0dXJlIHdpZHRoLlxuICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCBOdW1iZXIgcmVwcmVzZW50aW5nIHRleHR1cmUgaGVpZ2h0LlxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59IEJvb2xlYW4gZGVub3Rpbmcgd2hldGhlciB0aGUgaW5wdXQgZGltZW5zaW9uc1xuICogYXJlIGJvdGggcG93ZXItb2YtdHdvIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gaXNQb3dlck9mVHdvKHdpZHRoLCBoZWlnaHQpIHtcbiAgICByZXR1cm4gKHdpZHRoICYgd2lkdGggLSAxKSA9PT0gMCBcbiAgICAgICAgJiYgKGhlaWdodCAmIGhlaWdodCAtIDEpID09PSAwO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUZXh0dXJlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVGV4dHVyZSA9IHJlcXVpcmUoJy4vVGV4dHVyZScpO1xudmFyIFByb2dyYW0gPSByZXF1aXJlKCcuL1Byb2dyYW0nKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCcuL0J1ZmZlcicpO1xudmFyIEJ1ZmZlclJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9CdWZmZXJSZWdpc3RyeScpO1xudmFyIGNoZWNrZXJzID0gcmVxdWlyZSgnLi9DaGVja2VyYm9hcmQnKTtcbnZhciBQbGFuZSA9IHJlcXVpcmUoJ2ZhbW91cy13ZWJnbC1nZW9tZXRyaWVzJykuUGxhbmU7XG52YXIgc29ydGVyID0gcmVxdWlyZSgnLi9yYWRpeFNvcnQnKTtcbnZhciBVdGlsaXR5ID0gcmVxdWlyZSgnZmFtb3VzLXV0aWxpdGllcycpO1xuXG52YXIgaWRlbnRpdHkgPSBbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMV07XG5cbi8qKlxuICogV2ViR0xSZW5kZXJlciBpcyBhIHByaXZhdGUgY2xhc3MgdGhhdCBtYW5hZ2VzIGFsbCBpbnRlcmFjdGlvbnMgd2l0aCB0aGUgV2ViR0xcbiAqIEFQSS4gIEVhY2ggZnJhbWUgaXQgcmVjZWl2ZXMgY29tbWFuZHMgZnJvbSB0aGUgY29tcG9zaXRvciBhbmQgdXBkYXRlcyBpdHMgcmVnaXN0cmllc1xuICogYWNjb3JkaW5nbHkuICBTdWJzZXF1ZW50bHksIHRoZSBkcmF3IGZ1bmN0aW9uIGlzIGNhbGxlZCBhbmQgdGhlIFdlYkdMUmVuZGVyZXJcbiAqIGlzc3VlcyBkcmF3IGNhbGxzIGZvciBhbGwgbWVzaGVzIGluIGl0cyByZWdpc3RyeS5cbiAqXG4gKiBAY2xhc3MgV2ViR0xSZW5kZXJlclxuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBjYW52YXMgVGhlIGRvbSBlbGVtZW50IHRoYXQgR0wgd2lsbCBwYWludCBpdHNlbGYgb250by5cbiAqXG4gKi9cbmZ1bmN0aW9uIFdlYkdMUmVuZGVyZXIoY2FudmFzKSB7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG5cbiAgICB2YXIgZ2wgPSB0aGlzLmdsID0gdGhpcy5nZXRXZWJHTENvbnRleHQodGhpcy5jYW52YXMpO1xuXG4gICAgZ2wucG9seWdvbk9mZnNldCgwLjEsIDAuMSk7XG4gICAgZ2wuZW5hYmxlKGdsLlBPTFlHT05fT0ZGU0VUX0ZJTEwpO1xuICAgIGdsLmVuYWJsZShnbC5ERVBUSF9URVNUKTtcbiAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuICAgIGdsLmRlcHRoRnVuYyhnbC5MRVFVQUwpO1xuICAgIGdsLmJsZW5kRnVuYyhnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xuICAgIGdsLmVuYWJsZShnbC5DVUxMX0ZBQ0UpO1xuXG4gICAgdGhpcy5tZXNoUmVnaXN0cnkgPSB7fTtcbiAgICB0aGlzLm1lc2hSZWdpc3RyeUtleXMgPSBbXTtcblxuICAgIHRoaXMuY3V0b3V0UmVnaXN0cnkgPSB7fTtcbiAgICB0aGlzLmN1dG91dFJlZ2lzdHJ5S2V5cyA9IFtdO1xuICAgIHRoaXMuY3V0b3V0R2VvbWV0cnk7XG5cbiAgICAvKipcbiAgICAgKiBMaWdodHNcbiAgICAgKi9cblxuICAgIHRoaXMubnVtTGlnaHRzID0gMDtcbiAgICB0aGlzLmFtYmllbnRMaWdodENvbG9yID0gWzAsIDAsIDBdO1xuICAgIHRoaXMubGlnaHRSZWdpc3RyeSA9IHt9O1xuICAgIHRoaXMubGlnaHRSZWdpc3RyeUtleXMgPSBbXTtcbiAgICB0aGlzLmxpZ2h0UG9zaXRpb25zID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdO1xuICAgIHRoaXMubGlnaHRDb2xvcnMgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF07XG5cbiAgICB0aGlzLnRleHR1cmVSZWdpc3RyeSA9IFtdO1xuICAgIHRoaXMudGV4Q2FjaGUgPSB7fTtcbiAgICB0aGlzLmJ1ZmZlclJlZ2lzdHJ5ID0gbmV3IEJ1ZmZlclJlZ2lzdHJ5KGdsKTtcbiAgICB0aGlzLnByb2dyYW0gPSBuZXcgUHJvZ3JhbShnbCwgeyBkZWJ1ZzogZmFsc2UgfSk7XG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICBib3VuZEFycmF5QnVmZmVyOiBudWxsLFxuICAgICAgICBib3VuZEVsZW1lbnRCdWZmZXI6IG51bGwsXG4gICAgICAgIGxhc3REcmF3bjogbnVsbCxcbiAgICAgICAgZW5hYmxlZEF0dHJpYnV0ZXM6IHt9LFxuICAgICAgICBlbmFibGVkQXR0cmlidXRlc0tleXM6IFtdXG4gICAgfTtcblxuICAgIHRoaXMucmVzb2x1dGlvbk5hbWUgPSBbJ3Jlc29sdXRpb24nXTtcbiAgICB0aGlzLnJlc29sdXRpb25WYWx1ZXMgPSBbXTtcblxuICAgIHRoaXMuY2FjaGVkU2l6ZSA9IFtdO1xuXG4gICAgdGhpcy5wcm9qZWN0aW9uVHJhbnNmb3JtID0gWzEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDFdO1xufVxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIHJldHJlaXZlIHRoZSBXZWJHTFJlbmRlcmVyIGNvbnRleHQgdXNpbmcgc2V2ZXJhbFxuICogYWNjZXNzb3JzLiAgRm9yIGJyb3dzZXIgY29tcGF0YWJpbGl0eS4gIFRocm93cyBvbiBlcnJvci5cbiAqXG4gKiBAbWV0aG9kIGdldFdlYkdMQ29udGV4dFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYW52YXMgQ2FudmFzIGVsZW1lbnQgZnJvbSB3aGljaCB0aGUgY29udGV4dCBpcyByZXRyZWl2ZWQuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBXZWJHTENvbnRleHQgb2YgY2FudmFzIGVsZW1lbnQuXG4gKi9cbldlYkdMUmVuZGVyZXIucHJvdG90eXBlLmdldFdlYkdMQ29udGV4dCA9IGZ1bmN0aW9uIGdldFdlYkdMQ29udGV4dChjYW52YXMpIHtcbiAgICB2YXIgbmFtZXMgPSBbJ3dlYmdsJywgJ2V4cGVyaW1lbnRhbC13ZWJnbCcsICd3ZWJraXQtM2QnLCAnbW96LXdlYmdsJ107XG4gICAgdmFyIGNvbnRleHQgPSBudWxsO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChuYW1lc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB2YXIgbXNnID0gJ0Vycm9yIGNyZWF0aW5nIFdlYkdMIGNvbnRleHQ6ICcgKyBlcnJvci50b1N0cmluZygpO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29udGV4dCA/IGNvbnRleHQgOiBmYWxzZTtcbn07XG5cbi8qKlxuICogQWRkcyBhIG5ldyBiYXNlIHNwZWMgdG8gdGhlIGxpZ2h0IHJlZ2lzdHJ5IGF0IGEgZ2l2ZW4gcGF0aC5cbiAqXG4gKiBAbWV0aG9kIGNyZWF0ZUxpZ2h0XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFBhdGggdXNlZCBhcyBpZCBvZiBuZXcgbGlnaHQgaW4gbGlnaHRSZWdpc3RyeS5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IE5ld2x5IGNyZWF0ZWQgbGlnaHQgc3BlYy5cbiAqL1xuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlTGlnaHQgPSBmdW5jdGlvbiBjcmVhdGVMaWdodChwYXRoKSB7XG4gICAgdGhpcy5udW1MaWdodHMrKztcbiAgICB0aGlzLmxpZ2h0UmVnaXN0cnlLZXlzLnB1c2gocGF0aCk7XG4gICAgcmV0dXJuIHRoaXMubGlnaHRSZWdpc3RyeVtwYXRoXSA9IHtcbiAgICAgICAgY29sb3I6IFswLCAwLCAwXSxcbiAgICAgICAgcG9zaXRpb246IFswLCAwLCAwXVxuICAgIH07XG59O1xuXG4vKipcbiAqIEFkZHMgYSBuZXcgYmFzZSBzcGVjIHRvIHRoZSBtZXNoIHJlZ2lzdHJ5IGF0IGEgZ2l2ZW4gcGF0aC5cbiAqXG4gKiBAbWV0aG9kIGNyZWF0ZU1lc2hcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gUGF0aCB1c2VkIGFzIGlkIG9mIG5ldyBtZXNoIGluIG1lc2hSZWdpc3RyeS5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IE5ld2x5IGNyZWF0ZWQgbWVzaCBzcGVjLlxuICovXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVNZXNoID0gZnVuY3Rpb24gY3JlYXRlTWVzaChwYXRoKSB7XG4gICAgdGhpcy5tZXNoUmVnaXN0cnlLZXlzLnB1c2gocGF0aCk7XG4gICAgdmFyIHVuaWZvcm1zID0gVXRpbGl0eS5rZXlWYWx1ZVRvQXJyYXlzKHtcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgdHJhbnNmb3JtOiBpZGVudGl0eSxcbiAgICAgICAgc2l6ZTogWzAsIDAsIDBdLFxuICAgICAgICBiYXNlQ29sb3I6IFswLjUsIDAuNSwgMC41XSxcbiAgICAgICAgcG9zaXRpb25PZmZzZXQ6IFswLCAwLCAwXSxcbiAgICAgICAgdV9GbGF0U2hhZGluZzogMCxcbiAgICAgICAgZ2xvc3NpbmVzczogMFxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLm1lc2hSZWdpc3RyeVtwYXRoXSA9IHtcbiAgICAgICAgZGVwdGg6IG51bGwsXG4gICAgICAgIHVuaWZvcm1LZXlzOiB1bmlmb3Jtcy5rZXlzLFxuICAgICAgICB1bmlmb3JtVmFsdWVzOiB1bmlmb3Jtcy52YWx1ZXMsXG4gICAgICAgIGJ1ZmZlcnM6IHt9LFxuICAgICAgICBnZW9tZXRyeTogbnVsbCxcbiAgICAgICAgZHJhd1R5cGU6IG51bGwsXG4gICAgICAgIHRleHR1cmU6IG51bGwsXG4gICAgICAgIHZpc2libGU6IHRydWVcbiAgICB9O1xufTtcblxuXG4vKipcbiAqIENyZWF0ZXMgb3IgcmV0cmVpdmVzIGN1dG91dFxuICpcbiAqIEBtZXRob2QgZ2V0T3JTZXRDdXRvdXRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gUGF0aCB1c2VkIGFzIGlkIG9mIG5ldyBtZXNoIGluIG1lc2hSZWdpc3RyeS5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IE5ld2x5IGNyZWF0ZWQgY3V0b3V0IHNwZWMuXG4gKi9cblxuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuZ2V0T3JTZXRDdXRvdXQgPSBmdW5jdGlvbiBnZXRPclNldEN1dG91dChwYXRoKSB7XG4gICAgdmFyIGdlb21ldHJ5O1xuXG4gICAgaWYgKHRoaXMuY3V0b3V0UmVnaXN0cnlbcGF0aF0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3V0b3V0UmVnaXN0cnlbcGF0aF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoIXRoaXMuY3V0b3V0R2VvbWV0cnkpIHtcbiAgICAgICAgICAgIGdlb21ldHJ5ID0gdGhpcy5jdXRvdXRHZW9tZXRyeSA9IFBsYW5lKCk7XG5cbiAgICAgICAgICAgIHRoaXMuYnVmZmVyUmVnaXN0cnkuYWxsb2NhdGUoZ2VvbWV0cnkuaWQsICdwb3MnLCBnZW9tZXRyeS5zcGVjLmJ1ZmZlclZhbHVlc1swXSwgMyk7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlclJlZ2lzdHJ5LmFsbG9jYXRlKGdlb21ldHJ5LmlkLCAndGV4Q29vcmQnLCBnZW9tZXRyeS5zcGVjLmJ1ZmZlclZhbHVlc1sxXSwgMik7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlclJlZ2lzdHJ5LmFsbG9jYXRlKGdlb21ldHJ5LmlkLCAnbm9ybWFscycsIGdlb21ldHJ5LnNwZWMuYnVmZmVyVmFsdWVzWzJdLCAzKTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyUmVnaXN0cnkuYWxsb2NhdGUoZ2VvbWV0cnkuaWQsICdpbmRpY2VzJywgZ2VvbWV0cnkuc3BlYy5idWZmZXJWYWx1ZXNbM10sIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jdXRvdXRSZWdpc3RyeUtleXMucHVzaChwYXRoKTtcblxuICAgICAgICB2YXIgdW5pZm9ybXMgPSBVdGlsaXR5LmtleVZhbHVlVG9BcnJheXMoe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBpZGVudGl0eSxcbiAgICAgICAgICAgIHNpemU6IFswLCAwLCAwXSxcbiAgICAgICAgICAgIG9yaWdpbjogWzAsIDAsIDBdLFxuICAgICAgICAgICAgYmFzZUNvbG9yOiBbMCwgMCwgMF0sXG4gICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5jdXRvdXRSZWdpc3RyeVtwYXRoXSA9IHtcbiAgICAgICAgICAgIHVuaWZvcm1LZXlzOiB1bmlmb3Jtcy5rZXlzLFxuICAgICAgICAgICAgdW5pZm9ybVZhbHVlczogdW5pZm9ybXMudmFsdWVzLFxuICAgICAgICAgICAgZ2VvbWV0cnk6IHRoaXMuY3V0b3V0R2VvbWV0cnkuaWQsXG4gICAgICAgICAgICBkcmF3VHlwZTogNFxuICAgICAgICB9O1xuICAgIH1cblxufTtcblxuLyoqXG4gKiBQcmV2ZW50cyBhIG1lc2ggZnJvbSBiZWluZyBkcmF3biB0byB0aGUgY2FudmFzLlxuICpcbiAqIEBtZXRob2QgaGlkZU1lc2hcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBQYXRoIHVzZWQgYXMgaWQgb2YgbWVzaCBpbiBtZXNoIHJlZ2lzdHJ5LlxuICpcbiAqL1xuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuaGlkZU1lc2ggPSBmdW5jdGlvbiBoaWRlTWVzaChwYXRoKSB7XG4gICAgdmFyIG1lc2ggPSB0aGlzLm1lc2hSZWdpc3RyeVtwYXRoXSB8fCB0aGlzLmNyZWF0ZU1lc2gocGF0aCk7XG4gICAgbWVzaC52aXNpYmxlID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIEFsbG93cyBhIG1lc2ggdG8gYmUgZHJhd24gdG8gdGhlIGNhbnZhcy5cbiAqXG4gKiBAbWV0aG9kIHNob3dNZXNoXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggUGF0aCB1c2VkIGFzIGlkIG9mIG1lc2ggaW4gbWVzaCByZWdpc3RyeS5cbiAqXG4gKi9cbldlYkdMUmVuZGVyZXIucHJvdG90eXBlLnNob3dNZXNoID0gZnVuY3Rpb24gc2hvd01lc2gocGF0aCkge1xuICAgIHZhciBtZXNoID0gdGhpcy5tZXNoUmVnaXN0cnlbcGF0aF0gfHwgdGhpcy5jcmVhdGVNZXNoKHBhdGgpO1xuICAgIG1lc2gudmlzaWJsZSA9IHRydWU7XG59O1xuXG5cbi8qKlxuICogQ3JlYXRlcyBvciByZXRyZWl2ZXMgY3V0b3V0XG4gKlxuICogQG1ldGhvZCBzZXRDdXRvdXRVbmlmb3JtXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFBhdGggdXNlZCBhcyBpZCBvZiBjdXRvdXQgaW4gY3V0b3V0IHJlZ2lzdHJ5LlxuICogQHBhcmFtIHtTdHJpbmd9IHVuaWZvcm1Mb2NhdGlvbiBpZGVudGlmaWVyIHVzZWQgdG8gdXBsb2FkIHZhbHVlXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZSBvZiB1bmlmb3JtIGRhdGEgXG4gKlxuICovXG5cbldlYkdMUmVuZGVyZXIucHJvdG90eXBlLnNldEN1dG91dFVuaWZvcm0gPSBmdW5jdGlvbiBzZXRDdXRvdXRVbmlmb3JtKHBhdGgsIHVuaWZvcm1OYW1lLCB1bmlmb3JtVmFsdWUpIHtcbiAgICB2YXIgY3V0b3V0ID0gdGhpcy5nZXRPclNldEN1dG91dChwYXRoKTtcblxuICAgIHZhciBpbmRleCA9IGN1dG91dC51bmlmb3JtS2V5cy5pbmRleE9mKHVuaWZvcm1OYW1lKTtcblxuICAgIGN1dG91dC51bmlmb3JtVmFsdWVzW2luZGV4XSA9IHVuaWZvcm1WYWx1ZTtcbn07XG5cblxuLyoqXG4gKiBFZGl0cyB0aGUgb3B0aW9ucyBmaWVsZCBvbiBhIG1lc2hcbiAqXG4gKiBAbWV0aG9kIHNldE1lc2hPcHRpb25zXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFBhdGggdXNlZCBhcyBpZCBvZiBjdXRvdXQgaW4gY3V0b3V0IHJlZ2lzdHJ5LlxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBvZiBkcmF3IG9wdGlvbnMgZm9yIG1lc2hcbiAqXG4qKi9cbldlYkdMUmVuZGVyZXIucHJvdG90eXBlLnNldE1lc2hPcHRpb25zID0gZnVuY3Rpb24ocGF0aCwgb3B0aW9ucykge1xuICAgIHZhciBtZXNoID0gdGhpcy5tZXNoUmVnaXN0cnlbcGF0aF0gfHwgdGhpcy5jcmVhdGVNZXNoKHBhdGgpO1xuXG4gICAgbWVzaC5vcHRpb25zID0gb3B0aW9ucztcbiAgICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqXG4gKiBDaGFuZ2VzIHRoZSBjb2xvciBvZiB0aGUgZml4ZWQgaW50ZW5zaXR5IGxpZ2h0aW5nIGluIHRoZSBzY2VuZVxuICpcbiAqIEBtZXRob2Qgc2V0QW1iaWVudExpZ2h0Q29sb3JcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCB1c2VkIGFzIGlkIG9mIGxpZ2h0XG4gKiBAcGFyYW0ge051bWJlcn0gcmVkIGNoYW5uZWxcbiAqIEBwYXJhbSB7TnVtYmVyfSBncmVlbiBjaGFubmVsXG4gKiBAcGFyYW0ge051bWJlcn0gYmx1ZSBjaGFubmVsXG4gKlxuKiovXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5zZXRBbWJpZW50TGlnaHRDb2xvciA9IGZ1bmN0aW9uIHNldEFtYmllbnRMaWdodENvbG9yKHBhdGgsIHIsIGcsIGIpIHtcbiAgICB0aGlzLmFtYmllbnRMaWdodENvbG9yWzBdID0gcjtcbiAgICB0aGlzLmFtYmllbnRMaWdodENvbG9yWzFdID0gZztcbiAgICB0aGlzLmFtYmllbnRMaWdodENvbG9yWzJdID0gYjtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqXG4gKiBDaGFuZ2VzIHRoZSBsb2NhdGlvbiBvZiB0aGUgbGlnaHQgaW4gdGhlIHNjZW5lXG4gKlxuICogQG1ldGhvZCBzZXRMaWdodFBvc2l0aW9uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggdXNlZCBhcyBpZCBvZiBsaWdodFxuICogQHBhcmFtIHtOdW1iZXJ9IHggcG9zaXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSB5IHBvc2l0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0geiBwb3NpdGlvblxuICpcbioqL1xuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuc2V0TGlnaHRQb3NpdGlvbiA9IGZ1bmN0aW9uIHNldExpZ2h0UG9zaXRpb24ocGF0aCwgeCwgeSwgeikge1xuICAgIHZhciBsaWdodCA9IHRoaXMubGlnaHRSZWdpc3RyeVtwYXRoXSB8fCB0aGlzLmNyZWF0ZUxpZ2h0KHBhdGgpO1xuXG4gICAgbGlnaHQucG9zaXRpb25bMF0gPSB4O1xuICAgIGxpZ2h0LnBvc2l0aW9uWzFdID0geTtcbiAgICBsaWdodC5wb3NpdGlvblsyXSA9IHo7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogQ2hhbmdlcyB0aGUgY29sb3Igb2YgYSBkeW5hbWljIGludGVuc2l0eSBsaWdodGluZyBpbiB0aGUgc2NlbmVcbiAqXG4gKiBAbWV0aG9kIHNldExpZ2h0Q29sb3JcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCB1c2VkIGFzIGlkIG9mIGxpZ2h0IGluIGxpZ2h0IFJlZ2lzdHJ5LlxuICogQHBhcmFtIHtOdW1iZXJ9IHJlZCBjaGFubmVsXG4gKiBAcGFyYW0ge051bWJlcn0gZ3JlZW4gY2hhbm5lbFxuICogQHBhcmFtIHtOdW1iZXJ9IGJsdWUgY2hhbm5lbFxuICpcbioqL1xuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuc2V0TGlnaHRDb2xvciA9IGZ1bmN0aW9uIHNldExpZ2h0Q29sb3IocGF0aCwgciwgZywgYikge1xuICAgIHZhciBsaWdodCA9IHRoaXMubGlnaHRSZWdpc3RyeVtwYXRoXSB8fCB0aGlzLmNyZWF0ZUxpZ2h0KHBhdGgpO1xuXG4gICAgbGlnaHQuY29sb3JbMF0gPSByO1xuICAgIGxpZ2h0LmNvbG9yWzFdID0gZztcbiAgICBsaWdodC5jb2xvclsyXSA9IGI7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuLyoqXG4gKiBDb21waWxlcyBtYXRlcmlhbCBzcGVjIGludG8gcHJvZ3JhbSBzaGFkZXJcbiAqXG4gKiBAbWV0aG9kIGhhbmRsZU1hdGVyaWFJbnB1dFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBQYXRoIHVzZWQgYXMgaWQgb2YgY3V0b3V0IGluIGN1dG91dCByZWdpc3RyeS5cbiAqIEBwYXJhbSB7U3RyaW5nfSB3aGljaCByZW5kZXJpbmcgaW5wdXQgdGhlIG1hdGVyaWFsIGlzIGJvdW5kIHRvXG4gKiBAcGFyYW0ge09iamVjdH0gbWF0ZXJpYWwgc3BlY1xuICpcbioqL1xuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuaGFuZGxlTWF0ZXJpYWxJbnB1dCA9IGZ1bmN0aW9uIGhhbmRsZU1hdGVyaWFsSW5wdXQocGF0aCwgbmFtZSwgbWF0ZXJpYWwpIHtcbiAgICB2YXIgbWVzaCA9IHRoaXMubWVzaFJlZ2lzdHJ5W3BhdGhdIHx8IHRoaXMuY3JlYXRlTWVzaChwYXRoKTtcblxuICAgIG1lc2gudW5pZm9ybVZhbHVlc1tuYW1lID09PSAnYmFzZUNvbG9yJyA/IDMgOiA0XVswXSA9IC0gbWF0ZXJpYWwuX2lkO1xuICAgIGlmIChtYXRlcmlhbC50ZXh0dXJlKSBtZXNoLnRleHR1cmUgPSBoYW5kbGVUZXh0dXJlLmNhbGwodGhpcywgbWF0ZXJpYWwudGV4dHVyZSk7XG4gICAgdGhpcy5wcm9ncmFtLnJlZ2lzdGVyTWF0ZXJpYWwobmFtZSwgbWF0ZXJpYWwpO1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVNpemUoKTtcbn07XG5cbi8qKlxuICogQ2hhbmdlcyB0aGUgZ2VvbWV0cnkgZGF0YSBvZiBhIG1lc2hcbiAqXG4gKiBAbWV0aG9kIHNldEdlb21ldHJ5XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFBhdGggdXNlZCBhcyBpZCBvZiBjdXRvdXQgaW4gY3V0b3V0IHJlZ2lzdHJ5LlxuICogQHBhcmFtIHtPYmplY3R9IEdlb21ldHJ5IG9iamVjdCBjb250YWluaW5nIHZlcnRleCBkYXRhIHRvIGJlIGRyYXduXG4gKiBAcGFyYW0ge051bWJlcn0gcHJpbWl0aXZlIGlkZW50aWZpZXJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gd2lsbCB0aGUgZ2VvbWV0cnkgZGF0YSBjaGFuZ2U/XG4gKlxuKiovXG5cbldlYkdMUmVuZGVyZXIucHJvdG90eXBlLnNldEdlb21ldHJ5ID0gZnVuY3Rpb24gc2V0R2VvbWV0cnkocGF0aCwgZ2VvbWV0cnksIGRyYXdUeXBlLCBkeW5hbWljKSB7XG4gICAgdmFyIG1lc2ggPSB0aGlzLm1lc2hSZWdpc3RyeVtwYXRoXSB8fCB0aGlzLmNyZWF0ZU1lc2gocGF0aCk7XG5cbiAgICBtZXNoLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG4gICAgbWVzaC5kcmF3VHlwZSA9IGRyYXdUeXBlO1xuICAgIG1lc2guZHluYW1pYyA9IGR5bmFtaWM7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVXBsb2FkcyBhIG5ldyB2YWx1ZSBmb3IgdGhlIHVuaWZvcm0gZGF0YSB3aGVuIHRoZSBtZXNoIGlzIGJlaW5nIGRyYXduXG4gKlxuICogQG1ldGhvZCBzZXRNZXNoVW5pZm9ybVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBQYXRoIHVzZWQgYXMgaWQgb2YgbWVzaCBpbiBtZXNoIHJlZ2lzdHJ5XG4gKiBAcGFyYW0ge1N0cmluZ30gdW5pZm9ybUxvY2F0aW9uIGlkZW50aWZpZXIgdXNlZCB0byB1cGxvYWQgdmFsdWVcbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlIG9mIHVuaWZvcm0gZGF0YSBcbiAqXG4qKi9cbldlYkdMUmVuZGVyZXIucHJvdG90eXBlLnNldE1lc2hVbmlmb3JtID0gZnVuY3Rpb24gc2V0TWVzaFVuaWZvcm0ocGF0aCwgdW5pZm9ybU5hbWUsIHVuaWZvcm1WYWx1ZSkge1xuICAgIHZhciBtZXNoID0gdGhpcy5tZXNoUmVnaXN0cnlbcGF0aF0gfHwgdGhpcy5jcmVhdGVNZXNoKHBhdGgpO1xuXG4gICAgdmFyIGluZGV4ID0gbWVzaC51bmlmb3JtS2V5cy5pbmRleE9mKHVuaWZvcm1OYW1lKTtcblxuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgbWVzaC51bmlmb3JtS2V5cy5wdXNoKHVuaWZvcm1OYW1lKTtcbiAgICAgICAgbWVzaC51bmlmb3JtVmFsdWVzLnB1c2godW5pZm9ybVZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1lc2gudW5pZm9ybVZhbHVlc1tpbmRleF0gPSB1bmlmb3JtVmFsdWU7XG4gICAgfVxufVxuXG4vKipcbiAqIFRyaWdnZXJzIHRoZSAnZHJhdycgcGhhc2Ugb2YgdGhlIFdlYkdMUmVuZGVyZXIuICBJdGVyYXRlcyB0aHJvdWdoIHJlZ2lzdHJpZXNcbiAqIHRvIHNldCB1bmlmb3Jtcywgc2V0IGF0dHJpYnV0ZXMgYW5kIGlzc3VlIGRyYXcgY29tbWFuZHMgZm9yIHJlbmRlcmFibGVzLlxuICpcbiAqIEBtZXRob2QgYnVmZmVyRGF0YVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBQYXRoIHVzZWQgYXMgaWQgb2YgbWVzaCBpbiBtZXNoIHJlZ2lzdHJ5XG4gKiBAcGFyYW0ge051bWJlcn0gSWQgb2YgZ2VvbWV0cnkgaW4gZ2VvbWV0cnkgcmVnaXN0cnlcbiAqIEBwYXJhbSB7U3RyaW5nfSBBdHRyaWJ1dGUgbG9jYXRpb24gbmFtZVxuICogQHBhcmFtIHtBcnJheX0gVmVydGV4IGRhdGEgXG4gKiBAcGFyYW0ge051bWJlcn0gVGhlIGRpbWVuc2lvbnMgb2YgdGhlIHZlcnRleFxuICovXG5cblxuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuYnVmZmVyRGF0YSA9IGZ1bmN0aW9uIGJ1ZmZlckRhdGEocGF0aCwgZ2VvbWV0cnlJZCwgYnVmZmVyTmFtZSwgYnVmZmVyVmFsdWUsIGJ1ZmZlclNwYWNpbmcpIHtcbiAgICB0aGlzLmJ1ZmZlclJlZ2lzdHJ5LmFsbG9jYXRlKGdlb21ldHJ5SWQsIGJ1ZmZlck5hbWUsIGJ1ZmZlclZhbHVlLCBidWZmZXJTcGFjaW5nKTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBUcmlnZ2VycyB0aGUgJ2RyYXcnIHBoYXNlIG9mIHRoZSBXZWJHTFJlbmRlcmVyLiAgSXRlcmF0ZXMgdGhyb3VnaCByZWdpc3RyaWVzXG4gKiB0byBzZXQgdW5pZm9ybXMsIHNldCBhdHRyaWJ1dGVzIGFuZCBpc3N1ZSBkcmF3IGNvbW1hbmRzIGZvciByZW5kZXJhYmxlcy5cbiAqXG4gKiBAbWV0aG9kIGRyYXdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcmVuZGVyU3RhdGUgUGFyYW1ldGVycyBwcm92aWRlZCBieSB0aGUgY29tcG9zaXRvciwgdGhhdFxuICogYWZmZWN0IHRoZSByZW5kZXJpbmcgb2YgYWxsIHJlbmRlcmFibGVzLlxuICovXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gZHJhdyhyZW5kZXJTdGF0ZSkge1xuICAgIHRoaXMuc2V0R2xvYmFsVW5pZm9ybXMocmVuZGVyU3RhdGUpO1xuICAgIHRoaXMubWVzaFJlZ2lzdHJ5S2V5cyA9IHNvcnRlcih0aGlzLm1lc2hSZWdpc3RyeUtleXMsIHRoaXMubWVzaFJlZ2lzdHJ5KTtcbiAgICB0aGlzLmRyYXdDdXRvdXRzKCk7XG4gICAgdGhpcy5kcmF3TWVzaGVzKCk7XG59O1xuXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5kcmF3TWVzaGVzID0gZnVuY3Rpb24gZHJhd01lc2hlcygpIHtcbiAgICB2YXIgbWVzaDtcbiAgICB2YXIgYnVmZmVycztcblxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLm1lc2hSZWdpc3RyeUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWVzaCA9IHRoaXMubWVzaFJlZ2lzdHJ5W3RoaXMubWVzaFJlZ2lzdHJ5S2V5c1tpXV07XG4gICAgICAgIGJ1ZmZlcnMgPSB0aGlzLmJ1ZmZlclJlZ2lzdHJ5LnJlZ2lzdHJ5W21lc2guZ2VvbWV0cnldO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFtZXNoLnZpc2libGUpIGNvbnRpbnVlO1xuXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIGlmIChtZXNoLnVuaWZvcm1WYWx1ZXNbMF0gPCAxKSB7XG4gICAgICAgICAgICBnbC5kZXB0aE1hc2soZmFsc2UpO1xuICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsLmRlcHRoTWFzayh0cnVlKTtcbiAgICAgICAgICAgIGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFidWZmZXJzKSBjb250aW51ZTtcblxuICAgICAgICBpZiAobWVzaC5vcHRpb25zKSB0aGlzLmhhbmRsZU9wdGlvbnMobWVzaC5vcHRpb25zKTtcbiAgICAgICAgaWYgKG1lc2gudGV4dHVyZSkgbWVzaC50ZXh0dXJlLmJpbmQoKTtcbiAgICAgICAgdGhpcy5wcm9ncmFtLnNldFVuaWZvcm1zKG1lc2gudW5pZm9ybUtleXMsIG1lc2gudW5pZm9ybVZhbHVlcyk7XG4gICAgICAgIHRoaXMuZHJhd0J1ZmZlcnMoYnVmZmVycywgbWVzaC5kcmF3VHlwZSwgbWVzaC5nZW9tZXRyeSk7XG5cbiAgICAgICAgaWYgKG1lc2gudGV4dHVyZSkgbWVzaC50ZXh0dXJlLnVuYmluZCgpO1xuICAgICAgICBpZiAobWVzaC5vcHRpb25zKSB0aGlzLnJlc2V0T3B0aW9ucyhtZXNoLm9wdGlvbnMpO1xuICAgIH1cbn1cblxuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuZHJhd0N1dG91dHMgPSBmdW5jdGlvbiBkcmF3Q3V0b3V0cygpIHtcbiAgICB2YXIgY3V0b3V0O1xuICAgIHZhciBidWZmZXJzO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY3V0b3V0UmVnaXN0cnlLZXlzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGN1dG91dCA9IHRoaXMuY3V0b3V0UmVnaXN0cnlbdGhpcy5jdXRvdXRSZWdpc3RyeUtleXNbaV1dO1xuICAgICAgICBidWZmZXJzID0gdGhpcy5idWZmZXJSZWdpc3RyeS5yZWdpc3RyeVtjdXRvdXQuZ2VvbWV0cnldO1xuXG4gICAgICAgIHRoaXMuZ2wuZW5hYmxlKHRoaXMuZ2wuQkxFTkQpO1xuICAgICAgICB0aGlzLnByb2dyYW0uc2V0VW5pZm9ybXMoY3V0b3V0LnVuaWZvcm1LZXlzLCBjdXRvdXQudW5pZm9ybVZhbHVlcyk7XG4gICAgICAgIHRoaXMuZHJhd0J1ZmZlcnMoYnVmZmVycywgY3V0b3V0LmRyYXdUeXBlLCBjdXRvdXQuZ2VvbWV0cnkpO1xuICAgICAgICB0aGlzLmdsLmRpc2FibGUodGhpcy5nbC5CTEVORCk7XG4gICAgfVxufTtcblxuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuc2V0R2xvYmFsVW5pZm9ybXMgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHVuaWZvcm1OYW1lcyA9IFtcbiAgICAgICAgJ3VfTnVtTGlnaHRzJyxcbiAgICAgICAgJ3VfQW1iaWVudExpZ2h0JyxcbiAgICAgICAgJ3VfTGlnaHRQb3NpdGlvbicsXG4gICAgICAgICd1X0xpZ2h0Q29sb3InLFxuICAgICAgICAncGVyc3BlY3RpdmUnLFxuICAgICAgICAndGltZScsXG4gICAgICAgICd2aWV3J1xuICAgIF07XG4gICAgdmFyIHVuaWZvcm1WYWx1ZXMgPSBbXTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBzZXRHbG9iYWxVbmlmb3JtcyhyZW5kZXJTdGF0ZSkge1xuICAgICAgICB2YXIgbGlnaHQ7XG4gICAgICAgIHZhciBzdHJpZGU7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogU2V0IGxpZ2h0IHVuaWZvcm1zXG4gICAgICAgICAqL1xuXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxpZ2h0UmVnaXN0cnlLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsaWdodCA9IHRoaXMubGlnaHRSZWdpc3RyeVt0aGlzLmxpZ2h0UmVnaXN0cnlLZXlzW2ldXTtcbiAgICAgICAgICAgIHN0cmlkZSA9IGkgKiA0O1xuXG4gICAgICAgICAgICAvLyBCdWlsZCB0aGUgbGlnaHQgcG9zaXRpb25zJyA0eDQgbWF0cml4XG4gICAgICAgICAgICB0aGlzLmxpZ2h0UG9zaXRpb25zWzAgKyBzdHJpZGVdID0gbGlnaHQucG9zaXRpb25bMF07XG4gICAgICAgICAgICB0aGlzLmxpZ2h0UG9zaXRpb25zWzEgKyBzdHJpZGVdID0gbGlnaHQucG9zaXRpb25bMV07XG4gICAgICAgICAgICB0aGlzLmxpZ2h0UG9zaXRpb25zWzIgKyBzdHJpZGVdID0gbGlnaHQucG9zaXRpb25bMl07XG5cbiAgICAgICAgICAgIC8vIEJ1aWxkIHRoZSBsaWdodCBjb2xvcnMnIDR4NCBtYXRyaXhcbiAgICAgICAgICAgIHRoaXMubGlnaHRDb2xvcnNbMCArIHN0cmlkZV0gPSBsaWdodC5jb2xvclswXTtcbiAgICAgICAgICAgIHRoaXMubGlnaHRDb2xvcnNbMSArIHN0cmlkZV0gPSBsaWdodC5jb2xvclsxXTtcbiAgICAgICAgICAgIHRoaXMubGlnaHRDb2xvcnNbMiArIHN0cmlkZV0gPSBsaWdodC5jb2xvclsyXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdW5pZm9ybVZhbHVlc1swXSA9IHRoaXMubnVtTGlnaHRzO1xuICAgICAgICB1bmlmb3JtVmFsdWVzWzFdID0gdGhpcy5hbWJpZW50TGlnaHRDb2xvcjtcbiAgICAgICAgdW5pZm9ybVZhbHVlc1syXSA9IHRoaXMubGlnaHRQb3NpdGlvbnM7XG4gICAgICAgIHVuaWZvcm1WYWx1ZXNbM10gPSB0aGlzLmxpZ2h0Q29sb3JzO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFNldCB0aW1lIGFuZCBwcm9qZWN0aW9uIHVuaWZvcm1zXG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMucHJvamVjdGlvblRyYW5zZm9ybVsxMV0gPSByZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZVRyYW5zZm9ybVsxMV07XG5cbiAgICAgICAgdW5pZm9ybVZhbHVlc1s0XSA9IHRoaXMucHJvamVjdGlvblRyYW5zZm9ybTtcbiAgICAgICAgdW5pZm9ybVZhbHVlc1s1XSA9IERhdGUubm93KCkgICUgMTAwMDAwIC8gMTAwMDtcbiAgICAgICAgdW5pZm9ybVZhbHVlc1s2XSA9IHJlbmRlclN0YXRlLnZpZXdUcmFuc2Zvcm07XG5cbiAgICAgICAgdGhpcy5wcm9ncmFtLnNldFVuaWZvcm1zKHVuaWZvcm1OYW1lcywgdW5pZm9ybVZhbHVlcyk7XG4gICAgfVxufSgpKTtcblxuLyoqXG4gKiBMb2FkcyB0aGUgYnVmZmVycyBhbmQgaXNzdWVzIHRoZSBkcmF3IGNvbW1hbmQgZm9yIGEgZ2VvbWV0cnkuXG4gKlxuICogQG1ldGhvZCBkcmF3QnVmZmVyc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2ZXJ0ZXhCdWZmZXJzIEFsbCBidWZmZXJzIHVzZWQgdG8gZHJhdyB0aGUgZ2VvbWV0cnkuXG4gKiBAcGFyYW0ge051bWJlcn0gbW9kZSBFbnVtZXJhdG9yIGRlZmluaW5nIHdoYXQgcHJpbWl0aXZlIHRvIGRyYXdcbiAqIEBwYXJhbSB7TnVtYmVyfSBpZCBJRCBvZiBnZW9tZXRyeSBiZWluZyBkcmF3bi5cbiAqL1xuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuZHJhd0J1ZmZlcnMgPSBmdW5jdGlvbiBkcmF3QnVmZmVycyh2ZXJ0ZXhCdWZmZXJzLCBtb2RlLCBpZCkge1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgdmFyIGF0dHJpYnV0ZTtcbiAgICB2YXIgbG9jYXRpb247XG4gICAgdmFyIHNwYWNpbmc7XG4gICAgdmFyIG9mZnNldDtcbiAgICB2YXIgYnVmZmVyO1xuICAgIHZhciBpdGVyO1xuICAgIHZhciBqO1xuXG4gICAgaXRlciA9IHZlcnRleEJ1ZmZlcnMua2V5cy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVyOyBpKyspIHtcbiAgICAgICAgYXR0cmlidXRlID0gdmVydGV4QnVmZmVycy5rZXlzW2ldO1xuXG4gICAgICAgIC8vIERvIG5vdCBzZXQgdmVydGV4QXR0cmliUG9pbnRlciBpZiBpbmRleCBidWZmZXIuXG5cbiAgICAgICAgaWYgKGF0dHJpYnV0ZSA9PT0gJ2luZGljZXMnKSB7XG4gICAgICAgICAgICBqID0gaTsgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXRyZWl2ZSB0aGUgYXR0cmlidXRlIGxvY2F0aW9uIGFuZCBtYWtlIHN1cmUgaXQgaXMgZW5hYmxlZC5cblxuICAgICAgICBsb2NhdGlvbiA9IHRoaXMucHJvZ3JhbS5hdHRyaWJ1dGVMb2NhdGlvbnNbYXR0cmlidXRlXTtcblxuICAgICAgICBpZiAobG9jYXRpb24gPT09IC0xKSBjb250aW51ZTtcbiAgICAgICAgaWYgKGxvY2F0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5wcm9ncmFtLnByb2dyYW0sIGF0dHJpYnV0ZSk7XG4gICAgICAgICAgICB0aGlzLnByb2dyYW0uYXR0cmlidXRlTG9jYXRpb25zW2F0dHJpYnV0ZV0gPSBsb2NhdGlvbjtcbiAgICAgICAgICAgIGlmIChsb2NhdGlvbiA9PT0gLTEpIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmVuYWJsZWRBdHRyaWJ1dGVzW2F0dHJpYnV0ZV0pIHtcbiAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGxvY2F0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuZW5hYmxlZEF0dHJpYnV0ZXNbYXR0cmlidXRlXSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmVuYWJsZWRBdHRyaWJ1dGVzS2V5cy5wdXNoKGF0dHJpYnV0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXRyZWl2ZSBidWZmZXIgaW5mb3JtYXRpb24gdXNlZCB0byBzZXQgYXR0cmlidXRlIHBvaW50ZXIuXG5cbiAgICAgICAgYnVmZmVyID0gdmVydGV4QnVmZmVycy52YWx1ZXNbaV07XG4gICAgICAgIHNwYWNpbmcgPSB2ZXJ0ZXhCdWZmZXJzLnNwYWNpbmdbaV07XG4gICAgICAgIG9mZnNldCA9IHZlcnRleEJ1ZmZlcnMub2Zmc2V0W2ldO1xuICAgICAgICBsZW5ndGggPSB2ZXJ0ZXhCdWZmZXJzLmxlbmd0aFtpXTtcblxuICAgICAgICAvLyBTa2lwIGJpbmRCdWZmZXIgaWYgYnVmZmVyIGlzIGN1cnJlbnRseSBib3VuZC5cblxuICAgICAgICBpZiAodGhpcy5zdGF0ZS5ib3VuZEFycmF5QnVmZmVyICE9PSBidWZmZXIpIHtcbiAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoYnVmZmVyLnRhcmdldCwgYnVmZmVyLmJ1ZmZlcik7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmJvdW5kQXJyYXlCdWZmZXIgPSBidWZmZXI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zdGF0ZS5sYXN0RHJhd24gIT09IGlkKSB7XG4gICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGxvY2F0aW9uLCBzcGFjaW5nLCBnbC5GTE9BVCwgZ2wuRkFMU0UsIDAsIDQgKiBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGlzYWJsZSBhbnkgYXR0cmlidXRlcyB0aGF0IG5vdCBjdXJyZW50bHkgYmVpbmcgdXNlZC5cblxuICAgIGZvcih2YXIgaSA9IDAsIGxlbiA9IHRoaXMuc3RhdGUuZW5hYmxlZEF0dHJpYnV0ZXNLZXlzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSB0aGlzLnN0YXRlLmVuYWJsZWRBdHRyaWJ1dGVzW3RoaXMuc3RhdGUuZW5hYmxlZEF0dHJpYnV0ZXNLZXlzW2ldXTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuZW5hYmxlZEF0dHJpYnV0ZXNba2V5XSAmJiB2ZXJ0ZXhCdWZmZXJzLmtleXMuaW5kZXhPZihrZXkpID09PSAtMSkge1xuICAgICAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMucHJvZ3JhbS5hdHRyaWJ1dGVMb2NhdGlvbnNba2V5XSk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmVuYWJsZWRBdHRyaWJ1dGVzW2tleV0gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsZW5ndGgpIHtcblxuICAgICAgICAvLyBJZiBpbmRleCBidWZmZXIsIHVzZSBkcmF3RWxlbWVudHMuXG5cbiAgICAgICAgaWYgKGogIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYnVmZmVyID0gdmVydGV4QnVmZmVycy52YWx1ZXNbal07XG4gICAgICAgICAgICBvZmZzZXQgPSB2ZXJ0ZXhCdWZmZXJzLm9mZnNldFtqXTtcbiAgICAgICAgICAgIHNwYWNpbmcgPSB2ZXJ0ZXhCdWZmZXJzLnNwYWNpbmdbal07XG4gICAgICAgICAgICBsZW5ndGggPSB2ZXJ0ZXhCdWZmZXJzLmxlbmd0aFtqXTtcblxuICAgICAgICAgICAgLy8gU2tpcCBiaW5kQnVmZmVyIGlmIGJ1ZmZlciBpcyBjdXJyZW50bHkgYm91bmQuXG5cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmJvdW5kRWxlbWVudEJ1ZmZlciAhPT0gYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihidWZmZXIudGFyZ2V0LCBidWZmZXIuYnVmZmVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmJvdW5kRWxlbWVudEJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKG1vZGUsIGxlbmd0aCwgZ2wuVU5TSUdORURfU0hPUlQsIDIgKiBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2wuZHJhd0FycmF5cyhtb2RlLCAwLCBsZW5ndGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZS5sYXN0RHJhd24gPSBpZDtcbn07XG5cbi8qKlxuICogV3JhcHMgZHJhdyBtZXRob2RzIGluIGJvdW5kIGZyYW1lIGJ1ZmZlclxuICpcbiAqIEBtZXRob2QgcmVuZGVyT2Zmc2NyZWVuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIHJlbmRlciBmdW5jdGlvbiB0byBiZSBjYWxsZWQgYWZ0ZXIgc2V0dXAgYW5kIGJlZm9yZSBjbGVhbnVwLlxuICogQHBhcmFtIHtBcnJheX0gc2l6ZSBTaXplIG9mIGZyYW1lYnVmZmVyIGJlaW5nIGRyYXduIHRvLlxuICogQHBhcmFtIHtPYmplY3R9IHRleHR1cmUgTG9jYXRpb24gd2hlcmUgdGhlIHJlbmRlciBkYXRhIGlzIHN0b3JlZC5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyT2Zmc2NyZWVuKGNhbGxiYWNrLCBzaXplLCB0ZXh0dXJlKSB7XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcblxuICAgIHZhciBmcmFtZWJ1ZmZlciAgPSB0aGlzLmZyYW1lYnVmZmVyID8gdGhpcy5mcmFtZWJ1ZmZlciA6IHRoaXMuZnJhbWVidWZmZXIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgIHZhciByZW5kZXJidWZmZXIgPSB0aGlzLnJlbmRlcmJ1ZmZlciA/IHRoaXMucmVuZGVyYnVmZmVyIDogdGhpcy5yZW5kZXJidWZmZXIgPSBnbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcblxuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIpO1xuICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJidWZmZXIpO1xuXG4gICAgaWYgKHNpemVbMF0gIT0gcmVuZGVyYnVmZmVyLndpZHRoIHx8IHNpemVbMV0gIT0gcmVuZGVyYnVmZmVyLmhlaWdodCkge1xuICAgICAgICByZW5kZXJidWZmZXIud2lkdGggPSBzaXplWzBdO1xuICAgICAgICByZW5kZXJidWZmZXIuaGVpZ2h0ID0gc2l6ZVsxXTtcbiAgICAgICAgZ2wucmVuZGVyYnVmZmVyU3RvcmFnZShnbC5SRU5ERVJCVUZGRVIsIGdsLkRFUFRIX0NPTVBPTkVOVDE2LCBzaXplWzBdLCBzaXplWzFdKTtcbiAgICB9XG5cbiAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUuaWQsIDApO1xuICAgIGdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBnbC5ERVBUSF9BVFRBQ0hNRU5ULCBnbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlcik7XG5cbiAgICBpZiAodGhpcy5kZWJ1ZykgY2hlY2tGcmFtZUJ1ZmZlclN0YXR1cyhnbCk7XG5cbiAgICBjYWxsYmFjay5jYWxsKHRoaXMpO1xuXG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcbiAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgbnVsbCk7XG59O1xuXG4vKipcbiAqIERpYWdub3NlcyB0aGUgZmFpbGVkIGludGlhbGl6YXRpb24gb2YgYW4gRkJPLlxuICpcbiAqIEBtZXRob2QgY2hlY2tGcmFtZUJ1ZmZlclN0YXR1c1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGUgV2ViR0xDb250ZXh0IHRoYXQgb3ducyB0aGlzIEZCTy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tGcmFtZUJ1ZmZlclN0YXR1cyhnbCkge1xuICAgIHZhciBzdGF0dXMgPSBnbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKGdsLkZSQU1FQlVGRkVSKTtcblxuICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgZ2wuRlJBTUVCVUZGRVJfQ09NUExFVEU6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBnbC5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlQ6XG4gICAgICAgICAgICB0aHJvdyhcIkluY29tcGxldGUgZnJhbWVidWZmZXI6IEZSQU1FQlVGRkVSX0lOQ09NUExFVEVfQVRUQUNITUVOVFwiKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgZ2wuRlJBTUVCVUZGRVJfSU5DT01QTEVURV9NSVNTSU5HX0FUVEFDSE1FTlQ6XG4gICAgICAgICAgICB0aHJvdyhcIkluY29tcGxldGUgZnJhbWVidWZmZXI6IEZSQU1FQlVGRkVSX0lOQ09NUExFVEVfTUlTU0lOR19BVFRBQ0hNRU5UXCIpOyBicmVhaztcbiAgICAgICAgY2FzZSBnbC5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0RJTUVOU0lPTlM6XG4gICAgICAgICAgICB0aHJvdyhcIkluY29tcGxldGUgZnJhbWVidWZmZXI6IEZSQU1FQlVGRkVSX0lOQ09NUExFVEVfRElNRU5TSU9OU1wiKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgZ2wuRlJBTUVCVUZGRVJfVU5TVVBQT1JURUQ6XG4gICAgICAgICAgICB0aHJvdyhcIkluY29tcGxldGUgZnJhbWVidWZmZXI6IEZSQU1FQlVGRkVSX1VOU1VQUE9SVEVEXCIpOyBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93KFwiSW5jb21wbGV0ZSBmcmFtZWJ1ZmZlcjogXCIgKyBzdGF0dXMpO1xuICAgIH1cbn07XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiBwYXJlbnQgY2FudmFzLCBzZXRzIHRoZSB2aWV3cG9ydCBzaXplIG9uXG4gKiB0aGUgV2ViR0wgY29udGV4dCBhbmQgdXBkYXRlcyB0aGUgcmVzb2x1dGlvbiB1bmlmb3JtIGZvciB0aGUgc2hhZGVyIHByb2dyYW0uXG4gKiBTaXplIGlzIHJldHJlaXZlZCBmcm9tIHRoZSBjb250YWluZXIgb2JqZWN0IG9mIHRoZSByZW5kZXJlci5cbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZVNpemVcbiAqIFxuICogQHBhcmFtIHtBcnJheX0gd2lkdGgsIGhlaWdodCBhbmQgZGVwdGggb2YgY2FudmFzXG4gKiBcbiAqL1xuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUudXBkYXRlU2l6ZSA9IGZ1bmN0aW9uIHVwZGF0ZVNpemUoc2l6ZSkge1xuICAgIGlmIChzaXplKSB7XG4gICAgICAgIHRoaXMuY2FjaGVkU2l6ZVswXSA9IHNpemVbMF07XG4gICAgICAgIHRoaXMuY2FjaGVkU2l6ZVsxXSA9IHNpemVbMV07XG4gICAgICAgIHRoaXMuY2FjaGVkU2l6ZVsyXSA9IChzaXplWzBdID4gc2l6ZVsxXSkgPyBzaXplWzBdIDogc2l6ZVsxXTtcbiAgICB9XG5cbiAgICB0aGlzLmdsLnZpZXdwb3J0KDAsIDAsIHRoaXMuY2FjaGVkU2l6ZVswXSwgdGhpcy5jYWNoZWRTaXplWzFdKTtcblxuICAgIHRoaXMucmVzb2x1dGlvblZhbHVlc1swXSA9IHRoaXMuY2FjaGVkU2l6ZTtcbiAgICB0aGlzLnByb2dyYW0uc2V0VW5pZm9ybXModGhpcy5yZXNvbHV0aW9uTmFtZSwgdGhpcy5yZXNvbHV0aW9uVmFsdWVzKTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBzdGF0ZSBvZiB0aGUgV2ViR0wgZHJhd2luZyBjb250ZXh0IGJhc2VkIG9uIGN1c3RvbSBwYXJhbWV0ZXJzXG4gKiBkZWZpbmVkIG9uIGEgbWVzaC5cbiAqXG4gKiBAbWV0aG9kIGhhbmRsZU9wdGlvbnNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBEcmF3IHN0YXRlIG9wdGlvbnMgdG8gYmUgc2V0IHRvIHRoZSBjb250ZXh0LlxuICovXG5XZWJHTFJlbmRlcmVyLnByb3RvdHlwZS5oYW5kbGVPcHRpb25zID0gZnVuY3Rpb24gaGFuZGxlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICBpZiAoIW9wdGlvbnMpIHJldHVybjtcbiAgICBpZiAob3B0aW9ucy5ibGVuZGluZykgZ2wuYmxlbmRGdW5jKGdsLlNSQ19BTFBIQSwgZ2wuT05FKTtcbn07XG5cbi8qKlxuICogUmVzZXRzIHRoZSBzdGF0ZSBvZiB0aGUgV2ViR0wgZHJhd2luZyBjb250ZXh0IHRvIGRlZmF1bHQgdmFsdWVzLlxuICpcbiAqIEBtZXRob2QgcmVzZXRPcHRpb25zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgRHJhdyBzdGF0ZSBvcHRpb25zIHRvIGJlIHNldCB0byB0aGUgY29udGV4dC5cbiAqL1xuV2ViR0xSZW5kZXJlci5wcm90b3R5cGUucmVzZXRPcHRpb25zID0gZnVuY3Rpb24gcmVzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIGlmICghb3B0aW9ucykgcmV0dXJuO1xuICAgIGlmIChvcHRpb25zLmJsZW5kaW5nKSBnbC5ibGVuZEZ1bmMoZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcbn07XG5cbi8qKlxuICogTG9hZHMgYW4gaW1hZ2UgZnJvbSBhIHN0cmluZyBvciBJbWFnZSBvYmplY3QgYW5kIGV4ZWN1dGVzIGEgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKlxuICogQG1ldGhvZCBsb2FkSW1hZ2VcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtPYmplY3QgfCBTdHJpbmd9IGltZyBUaGUgaW5wdXQgaW1hZ2UgZGF0YSB0byBsb2FkIGFzIGFuIGFzc2V0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGZpcmVkIHdoZW5cbiAqIHRoZSBpbWFnZSBoYXMgZmluaXNoZWQgbG9hZGluZy5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IEltYWdlIG9iamVjdCBiZWluZyBsb2FkZWQuXG4gKi9cbmZ1bmN0aW9uIGxvYWRJbWFnZSAoaW1nLCBjYWxsYmFjaykge1xuICAgIHZhciBvYmogPSAodHlwZW9mIGltZyA9PT0gJ3N0cmluZycgPyBuZXcgSW1hZ2UoKSA6IGltZykgfHwge307XG4gICAgb2JqLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cyc7XG4gICAgaWYgKCEgb2JqLnNyYykgb2JqLnNyYyA9IGltZztcbiAgICBpZiAoISBvYmouY29tcGxldGUpIG9iai5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7IGNhbGxiYWNrKG9iaik7IH07XG4gICAgZWxzZSBjYWxsYmFjayhvYmopO1xuICAgIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogSGFuZGxlcyBsb2FkaW5nIG9mIHRleHR1cmUgb2JqZWN0cy5cbiAqXG4gKiBAbWV0aG9kIGhhbmRsZVRleHR1cmVcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0IFRoZSBpbnB1dCB0ZXh0dXJlIG9iamVjdCBjb2xsZWN0ZWQgZnJvbSBtZXNoLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gVGV4dHVyZSBpbnN0YW5jZSBsaW5rZWQgdG8gaW5wdXQgZGF0YS5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlVGV4dHVyZShpbnB1dCkge1xuICAgIHZhciBzb3VyY2UgPSBpbnB1dC5kYXRhO1xuICAgIHZhciB0ZXh0dXJlSWQgPSBpbnB1dC5pZDtcbiAgICB2YXIgb3B0aW9ucyA9IGlucHV0Lm9wdGlvbnM7XG4gICAgdmFyIHRleHR1cmUgPSB0aGlzLnRleHR1cmVSZWdpc3RyeVt0ZXh0dXJlSWRdO1xuXG4gICAgaWYgKCF0ZXh0dXJlKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgICAgICAgIHRleHR1cmUgPSBuZXcgVGV4dHVyZSh0aGlzLmdsLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRleHR1cmUuc2V0QXJyYXkoc291cmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsc2UgaWYgKHdpbmRvdyAmJiBzb3VyY2UgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTFZpZGVvRWxlbWVudCkge1xuICAgICAgICAgICAgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKHRoaXMuZ2wsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGV4dHVyZS5zcmMgPSB0ZXh0dXJlO1xuICAgICAgICAgICAgdGV4dHVyZS5zZXRJbWFnZShjaGVja2Vycyk7XG4gICAgICAgICAgICBzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVkZGF0YScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRleHR1cmUuc2V0SW1hZ2Uoc291cmNlKTtcbiAgICAgICAgICAgICAgICBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7IHRleHR1cmUuc2V0SW1hZ2Uoc291cmNlKTsgfSwgMTYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBlbHNlIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHNvdXJjZSkge1xuICAgICAgICAgICAgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKHRoaXMuZ2wsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGV4dHVyZS5zZXRJbWFnZShjaGVja2Vycyk7XG4gICAgICAgICAgICBsb2FkSW1hZ2Uoc291cmNlLCBmdW5jdGlvbiAoaW1nKSB7XG4gICAgICAgICAgICAgICAgdGV4dHVyZS5zZXRJbWFnZShpbWcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRleHR1cmVSZWdpc3RyeVt0ZXh0dXJlSWRdID0gdGV4dHVyZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGV4dHVyZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBXZWJHTFJlbmRlcmVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBCdWZmZXI6IHJlcXVpcmUoJy4vQnVmZmVyJyksXG4gICAgQnVmZmVyUmVnaXN0cnk6IHJlcXVpcmUoJy4vQnVmZmVyUmVnaXN0cnknKSxcbiAgICBDaGVja2VyYm9hcmQ6IHJlcXVpcmUoJy4vQ2hlY2tlcmJvYXJkJyksXG4gICAgUHJvZ3JhbTogcmVxdWlyZSgnLi9Qcm9ncmFtJyksXG4gICAgV2ViR0xSZW5kZXJlcjogcmVxdWlyZSgnLi9XZWJHTFJlbmRlcmVyJyksXG4gICAgVGV4dHVyZTogcmVxdWlyZSgnLi9UZXh0dXJlJylcbn07XG4iLCJ2YXIgcmFkaXhCaXRzID0gMTEsXG4gICAgbWF4UmFkaXggPSAxIDw8IChyYWRpeEJpdHMpLFxuICAgIHJhZGl4TWFzayA9IG1heFJhZGl4IC0gMSxcbiAgICBidWNrZXRzID0gbmV3IEFycmF5KG1heFJhZGl4ICogTWF0aC5jZWlsKDY0IC8gcmFkaXhCaXRzKSksXG4gICAgbXNiTWFzayA9IDEgPDwgKCgzMiAtIDEpICUgcmFkaXhCaXRzKSxcbiAgICBsYXN0TWFzayA9IChtc2JNYXNrIDw8IDEpIC0gMSxcbiAgICBwYXNzQ291bnQgPSAoKDMyIC8gcmFkaXhCaXRzKSArIDAuOTk5OTk5OTk5OTk5OTk5KSB8IDAsXG4gICAgbWF4T2Zmc2V0ID0gbWF4UmFkaXggKiAocGFzc0NvdW50IC0gMSksXG4gICAgbm9ybWFsaXplciA9IE1hdGgucG93KDIwLCA2KTtcblxudmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcig0KTtcbnZhciBmbG9hdFZpZXcgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciwgMCwgMSk7XG52YXIgaW50VmlldyA9IG5ldyBJbnQzMkFycmF5KGJ1ZmZlciwgMCwgMSk7XG5cbmZ1bmN0aW9uIGNvbXAobGlzdCwgcmVnaXN0cnksIGkpIHtcbiAgICB2YXIga2V5ID0gbGlzdFtpXTtcbiAgICB2YXIgaXRlbSA9IHJlZ2lzdHJ5W2tleV07XG4gICAgcmV0dXJuIChpdGVtLmRlcHRoID8gaXRlbS5kZXB0aCA6IHJlZ2lzdHJ5W2tleV0udW5pZm9ybVZhbHVlc1sxXVsxNF0pICsgbm9ybWFsaXplcjtcbn1cblxuZnVuY3Rpb24gbXV0YXRvcihsaXN0LCByZWdpc3RyeSwgaSwgdmFsdWUpIHtcbiAgICB2YXIga2V5ID0gbGlzdFtpXTtcbiAgICByZWdpc3RyeVtrZXldLmRlcHRoID0gaW50VG9GbG9hdCh2YWx1ZSkgLSBub3JtYWxpemVyO1xuICAgIHJldHVybiBrZXk7XG59XG5mdW5jdGlvbiBjbGVhbihsaXN0LCByZWdpc3RyeSwgaSkge1xuICAgIHJlZ2lzdHJ5W2xpc3RbaV1dLmRlcHRoID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gZmxvYXRUb0ludChrKSB7XG4gICAgZmxvYXRWaWV3WzBdID0gaztcbiAgICByZXR1cm4gaW50Vmlld1swXTtcbn1cblxuZnVuY3Rpb24gaW50VG9GbG9hdChrKSB7XG4gICAgaW50Vmlld1swXSA9IGs7XG4gICAgcmV0dXJuIGZsb2F0Vmlld1swXTtcbn1cblxuZnVuY3Rpb24gc29ydChsaXN0LCByZWdpc3RyeSkge1xuICAgIHZhciBwYXNzID0gMDtcbiAgICB2YXIgb3V0ID0gW107XG5cbiAgICB2YXIgaSwgaiwgaywgbiwgZGl2LCBvZmZzZXQsIHN3YXAsIGlkLCBzdW0sIHRzdW0sIHNpemU7XG5cbiAgICBwYXNzQ291bnQgPSAoKDMyIC8gcmFkaXhCaXRzKSArIDAuOTk5OTk5OTk5OTk5OTk5KSB8IDA7XG5cbiAgICBmb3IgKGkgPSAwLCBuID0gbWF4UmFkaXggKiBwYXNzQ291bnQ7IGkgPCBuOyBpKyspIGJ1Y2tldHNbaV0gPSAwO1xuXG4gICAgZm9yIChpID0gMCwgbiA9IGxpc3QubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGRpdiA9IGZsb2F0VG9JbnQoY29tcChsaXN0LCByZWdpc3RyeSwgaSkpO1xuICAgICAgICBkaXYgXj0gZGl2ID4+IDMxIHwgMHg4MDAwMDAwMDtcbiAgICAgICAgZm9yIChqID0gMCwgayA9IDA7IGogPCBtYXhPZmZzZXQ7IGogKz0gbWF4UmFkaXgsIGsgKz0gcmFkaXhCaXRzKSB7XG4gICAgICAgICAgICBidWNrZXRzW2ogKyAoZGl2ID4+PiBrICYgcmFkaXhNYXNrKV0rKztcbiAgICAgICAgfVxuICAgICAgICBidWNrZXRzW2ogKyAoZGl2ID4+PiBrICYgbGFzdE1hc2spXSsrO1xuICAgIH1cblxuICAgIGZvciAoaiA9IDA7IGogPD0gbWF4T2Zmc2V0OyBqICs9IG1heFJhZGl4KSB7XG4gICAgICAgIGZvciAoaWQgPSBqLCBzdW0gPSAwOyBpZCA8IGogKyBtYXhSYWRpeDsgaWQrKykge1xuICAgICAgICAgICAgdHN1bSA9IGJ1Y2tldHNbaWRdICsgc3VtO1xuICAgICAgICAgICAgYnVja2V0c1tpZF0gPSBzdW0gLSAxO1xuICAgICAgICAgICAgc3VtID0gdHN1bTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoLS1wYXNzQ291bnQpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbiA9IGxpc3QubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBkaXYgPSBmbG9hdFRvSW50KGNvbXAobGlzdCwgcmVnaXN0cnksIGkpKTtcbiAgICAgICAgICAgIG91dFsrK2J1Y2tldHNbZGl2ICYgcmFkaXhNYXNrXV0gPSBtdXRhdG9yKGxpc3QsIHJlZ2lzdHJ5LCBpLCBkaXYgXj0gZGl2ID4+IDMxIHwgMHg4MDAwMDAwMCk7XG4gICAgICAgIH1cbiAgICAgICAgc3dhcCA9IG91dCwgb3V0ID0gbGlzdCwgbGlzdCA9IHN3YXA7XG4gICAgICAgIHdoaWxlICgrK3Bhc3MgPCBwYXNzQ291bnQpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIG4gPSBsaXN0Lmxlbmd0aCwgb2Zmc2V0ID0gcGFzcyAqIG1heFJhZGl4LCBzaXplID0gcGFzcyAqIHJhZGl4Qml0czsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIGRpdiA9IGZsb2F0VG9JbnQoY29tcChsaXN0LCByZWdpc3RyeSwgaSkpO1xuICAgICAgICAgICAgICAgIG91dFsrK2J1Y2tldHNbb2Zmc2V0ICsgKGRpdiA+Pj4gc2l6ZSAmIHJhZGl4TWFzayldXSA9IGxpc3RbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2FwID0gb3V0LCBvdXQgPSBsaXN0LCBsaXN0ID0gc3dhcDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIG4gPSBsaXN0Lmxlbmd0aCwgb2Zmc2V0ID0gcGFzcyAqIG1heFJhZGl4LCBzaXplID0gcGFzcyAqIHJhZGl4Qml0czsgaSA8IG47IGkrKykge1xuICAgICAgICBkaXYgPSBmbG9hdFRvSW50KGNvbXAobGlzdCwgcmVnaXN0cnksIGkpKTtcbiAgICAgICAgb3V0WysrYnVja2V0c1tvZmZzZXQgKyAoZGl2ID4+PiBzaXplICYgbGFzdE1hc2spXV0gPSBtdXRhdG9yKGxpc3QsIHJlZ2lzdHJ5LCBpLCBkaXYgXiAofmRpdiA+PiAzMSB8IDB4ODAwMDAwMDApKTtcbiAgICAgICAgY2xlYW4obGlzdCwgcmVnaXN0cnksIGkpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzb3J0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVmlydHVhbEVsZW1lbnQgPSByZXF1aXJlKCdmYW1vdXMtZG9tLXJlbmRlcmVycycpLlZpcnR1YWxFbGVtZW50O1xudmFyIHN0cmlwID0gcmVxdWlyZSgnZmFtb3VzLXV0aWxpdGllcycpLnN0cmlwO1xudmFyIGZsYXRDbG9uZSA9IHJlcXVpcmUoJ2ZhbW91cy11dGlsaXRpZXMnKS5mbGF0Q2xvbmU7XG5cbnZhciBDb250ZXh0ID0gcmVxdWlyZSgnLi9Db250ZXh0Jyk7XG5cbi8qKlxuICogSW5zdGFudGlhdGVzIGEgbmV3IENvbXBvc2l0b3IsIHVzZWQgZm9yIHJvdXRpbmcgY29tbWFuZHMgcmVjZWl2ZWQgZnJvbSB0aGVcbiAqIFdlYldvcmtlciB0byB0aGUgV2ViR0wgYW5kIERPTSByZW5kZXJlci5cbiAqXG4gKiBAY2xhc3MgQ29tcG9zaXRvclxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIENvbXBvc2l0b3IoKSB7XG4gICAgdGhpcy5fY29udGV4dHMgPSB7fTtcbiAgICB0aGlzLl9vdXRDb21tYW5kcyA9IFtdO1xuICAgIHRoaXMuX2luQ29tbWFuZHMgPSBbXTtcblxuICAgIHRoaXMuY2xlYXJDb21tYW5kcygpO1xufVxuXG4vKipcbiAqIFNjaGVkdWxlcyBhbiBldmVudCB0byBiZSBzZW50IHRvIHRoZSBXZWJXb3JrZXIgdGhlIG5leHQgdGltZSB0aGUgb3V0IGNvbW1hbmRcbiAqIHF1ZXVlIGlzIGJlaW5nIGZsdXNoZWQuXG4gKlxuICogQG1ldGhvZCBzZW5kRXZlbnRcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBwYXRoICAgIHJlbmRlciBwYXRoIHRvIHRoZSBub2RlIHRoZSBldmVudCBzaG91bGQgYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyZWQgb24gKCp0YXJnZXRlZCBldmVudCopXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGV2ICAgICAgZXZlbnQgdHlwZVxuICogQHBhcmFtICB7T2JqZWN0fSBwYXlsb2FkIGV2ZW50IG9iamVjdCAoc2VyaWFsaXphYmxlIHVzaW5nIHN0cnVjdHVyZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uaW5nIGFsZ29yaXRobSlcbiAqL1xuQ29tcG9zaXRvci5wcm90b3R5cGUuc2VuZEV2ZW50ID0gZnVuY3Rpb24gc2VuZEV2ZW50KHBhdGgsIGV2LCBwYXlsb2FkKSB7XG4gICAgdGhpcy5fb3V0Q29tbWFuZHMucHVzaCgnV0lUSCcsIHBhdGgsICdUUklHR0VSJywgZXYsIHBheWxvYWQpO1xufTtcblxuLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXIgbWV0aG9kIHVzZWQgYnkgYGRyYXdDb21tYW5kc2AuXG4gKlxuICogQG1ldGhvZCBoYW5kbGVXaXRoXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSAge0FycmF5fSBjb21tYW5kcyAgICAgcmVtYWluaW5nIG1lc3NhZ2UgcXVldWUgcmVjZWl2ZWQgZnJvbSB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgV2ViV29ya2VyLCB1c2VkIHRvIHNoaWZ0IHNpbmdsZSBtZXNzYWdlcyBmcm9tXG4gKi9cbkNvbXBvc2l0b3IucHJvdG90eXBlLmhhbmRsZVdpdGggPSBmdW5jdGlvbiBoYW5kbGVXaXRoIChpdGVyYXRvciwgY29tbWFuZHMpIHtcbiAgICB2YXIgcGF0aCA9IGNvbW1hbmRzW2l0ZXJhdG9yXTtcbiAgICB2YXIgcGF0aEFyciA9IHBhdGguc3BsaXQoJy8nKTtcbiAgICB2YXIgY29udGV4dCA9IHRoaXMuZ2V0T3JTZXRDb250ZXh0KHBhdGhBcnIuc2hpZnQoKSk7XG4gICAgcmV0dXJuIGNvbnRleHQucmVjZWl2ZShwYXRoQXJyLCBwYXRoLCBjb21tYW5kcywgaXRlcmF0b3IpO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIHRvcC1sZXZlbCBWaXJ0dWFsRWxlbWVudCBhdHRhY2hlZCB0byB0aGUgcGFzc2VkIGluIGRvY3VtZW50XG4gKiBzZWxlY3Rvci5cbiAqIElmIG5vIHN1Y2ggZWxlbWVudCBleGlzdHMsIG9uZSB3aWxsIGJlIGluc3RhbnRpYXRlZCwgdGhlcmVmb3JlIHJlcHJlc2VudGluZ1xuICogdGhlIGVxdWl2YWxlbnQgb2YgYSBDb250ZXh0IGluIHRoZSBNYWluIFRocmVhZC5cbiAqXG4gKiBAbWV0aG9kIGdldE9yU2V0Q29udGV4dFxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHNlbGVjdG9yICAgICAgICAgICAgZG9jdW1lbnQgcXVlcnkgc2VsZWN0b3IgdXNlZCBmb3JcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXRyaWV2aW5nIHRoZSBET00gbm9kZSB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWaXJ0dWFsRWxlbWVudCBzaG91bGQgYmUgYXR0YWNoZWQgdG9cbiAqIEByZXR1cm4ge09iamVjdH0gcmVzdWx0XG4gKiBAcmV0dXJuIHtWaXJ0dWFsRWxlbWVudH0gcmVzdWx0LkRPTSAgZmluYWwgVmlydHVhbEVsZW1lbnRcbiAqL1xuQ29tcG9zaXRvci5wcm90b3R5cGUuZ2V0T3JTZXRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0T3JTZXRDb250ZXh0KHNlbGVjdG9yKSB7XG4gICAgaWYgKHRoaXMuX2NvbnRleHRzW3NlbGVjdG9yXSkgcmV0dXJuIHRoaXMuX2NvbnRleHRzW3NlbGVjdG9yXTtcbiAgICBlbHNlIHJldHVybiAodGhpcy5fY29udGV4dHNbc2VsZWN0b3JdID0gbmV3IENvbnRleHQoc2VsZWN0b3IsIHRoaXMpKTtcbn07XG5cbi8qKlxuICogSW50ZXJuYWwgaGVscGVyIG1ldGhvZCB1c2VkIGJ5IGBkcmF3Q29tbWFuZHNgLlxuICpcbiAqIEBtZXRob2QgZ2l2ZVNpemVGb3JcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtICB7QXJyYXl9IGNvbW1hbmRzICAgICByZW1haW5pbmcgbWVzc2FnZSBxdWV1ZSByZWNlaXZlZCBmcm9tIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBXZWJXb3JrZXIsIHVzZWQgdG8gc2hpZnQgc2luZ2xlIG1lc3NhZ2VzIGZyb21cbiAqL1xuQ29tcG9zaXRvci5wcm90b3R5cGUuZ2l2ZVNpemVGb3IgPSBmdW5jdGlvbiBnaXZlU2l6ZUZvcihpdGVyYXRvciwgY29tbWFuZHMpIHtcbiAgICB2YXIgc2VsZWN0b3IgPSBjb21tYW5kc1tpdGVyYXRvcl07XG4gICAgdmFyIHNpemUgPSB0aGlzLmdldE9yU2V0Q29udGV4dChzZWxlY3RvcikuZ2V0Um9vdFNpemUoKTtcbiAgICB0aGlzLnNlbmRSZXNpemUoc2VsZWN0b3IsIHNpemUpO1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKHNlbGVjdG9yID09PSAnYm9keScpXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMuX3NlbnRSZXNpemUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZW5kUmVzaXplKHNlbGVjdG9yLCBfdGhpcy5nZXRPclNldENvbnRleHQoc2VsZWN0b3IpLmdldFJvb3RTaXplKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbn07XG5cbi8qKlxuICogSW50ZXJuYWwgaGVscGVyIG1ldGhvZCB1c2VkIGZvciBub3RpZnlpbmcgdGhlIFdlYldvcmtlciBhYm91dCBleHRlcm5hbGx5XG4gKiByZXNpemVkIGNvbnRleHRzIChlLmcuIGJ5IHJlc2l6aW5nIHRoZSBicm93c2VyIHdpbmRvdykuXG4gKlxuICogQG1ldGhvZCBzZW5kUmVzaXplXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gc2VsZWN0b3IgICAgcmVuZGVyIHBhdGggdG8gdGhlIG5vZGUgKGNvbnRleHQpIHRoYXQgc2hvdWxkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlIHJlc2l6ZWRcbiAqIEBwYXJhbSAge0FycmF5fSBzaXplICAgICAgICAgbmV3IGNvbnRleHQgc2l6ZVxuICovXG5Db21wb3NpdG9yLnByb3RvdHlwZS5zZW5kUmVzaXplID0gZnVuY3Rpb24gc2VuZFJlc2l6ZSAoc2VsZWN0b3IsIHNpemUpIHtcbiAgICB0aGlzLl9vdXRDb21tYW5kcy5wdXNoKCdXSVRIJywgc2VsZWN0b3IsICdUUklHR0VSJywgJ0NPTlRFWFRfUkVTSVpFJywgc2l6ZSk7XG4gICAgdGhpcy5fc2VudFJlc2l6ZSA9IHRydWU7XG59O1xuXG5Db21wb3NpdG9yLnByb3RvdHlwZS5fd3JhcFByb3h5RnVuY3Rpb24gPSBmdW5jdGlvbiBfd3JhcFByb3h5RnVuY3Rpb24oaWQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbaV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgYXJndW1lbnRzW2ldID0gc3RyaXAoZmxhdENsb25lKGFyZ3VtZW50c1tpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF90aGlzLl9vdXRDb21tYW5kcy5wdXNoKCdJTlZPS0UnLCBpZCwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfTtcbn07XG5cbkNvbXBvc2l0b3IucHJvdG90eXBlLmludm9rZSA9IGZ1bmN0aW9uIGludm9rZSAodGFyZ2V0LCBtZXRob2ROYW1lLCBhcmdzLCBmdW5jdGlvbkFyZ3MpIHtcbiAgICB2YXIgdGFyZ2V0T2JqZWN0ID0gd2luZG93W3RhcmdldF07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGZ1bmN0aW9uQXJnc1tpXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBhcmdzW2ldID0gdGhpcy5fd3JhcFByb3h5RnVuY3Rpb24oZnVuY3Rpb25BcmdzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRhcmdldE9iamVjdFttZXRob2ROYW1lXS5hcHBseSh0YXJnZXRPYmplY3QsIGFyZ3MpO1xufTtcblxuLyoqXG4gKiBQcm9jZXNzZXMgdGhlIHByZXZpb3VzbHkgdmlhIGByZWNlaXZlQ29tbWFuZHNgIHVwZGF0ZWQgaW5jb21pbmcgXCJpblwiXG4gKiBjb21tYW5kIHF1ZXVlLlxuICogQ2FsbGVkIGJ5IFRocmVhZE1hbmFnZXIuXG4gKlxuICogQG1ldGhvZCBkcmF3Q29tbWFuZHNcbiAqXG4gKiBAcmV0dXJuIHtBcnJheX0gb3V0Q29tbWFuZHMgIHNldCBvZiBjb21tYW5kcyB0byBiZSBzZW50IGJhY2sgdG8gdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdlYldvcmtlclxuICovXG5Db21wb3NpdG9yLnByb3RvdHlwZS5kcmF3Q29tbWFuZHMgPSBmdW5jdGlvbiBkcmF3Q29tbWFuZHMoKSB7XG4gICAgdmFyIGNvbW1hbmRzID0gdGhpcy5faW5Db21tYW5kcztcbiAgICB2YXIgbG9jYWxJdGVyYXRvciA9IDA7XG4gICAgdmFyIGNvbW1hbmQgPSBjb21tYW5kc1tsb2NhbEl0ZXJhdG9yXTtcbiAgICB3aGlsZSAoY29tbWFuZCkge1xuICAgICAgICBzd2l0Y2ggKGNvbW1hbmQpIHtcbiAgICAgICAgICAgIGNhc2UgJ1dJVEgnOlxuICAgICAgICAgICAgICAgIGxvY2FsSXRlcmF0b3IgPSB0aGlzLmhhbmRsZVdpdGgoKytsb2NhbEl0ZXJhdG9yLCBjb21tYW5kcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ0lOVk9LRSc6XG4gICAgICAgICAgICAgICAgdGhpcy5pbnZva2UoXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl0sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl0sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl0sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdORUVEX1NJWkVfRk9SJzpcbiAgICAgICAgICAgICAgICB0aGlzLmdpdmVTaXplRm9yKCsrbG9jYWxJdGVyYXRvciwgY29tbWFuZHMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbW1hbmQgPSBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdO1xuICAgIH1cblxuICAgIC8vIFRPRE86IFN3aXRjaCB0byBhc3NvY2lhdGl2ZSBhcnJheXMgaGVyZS4uLlxuXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuX2NvbnRleHRzKSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHRzW2tleV0uZHJhdygpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9vdXRDb21tYW5kcztcbn07XG5cbi8qKlxuICogVXNlZCBieSBUaHJlYWRNYW5hZ2VyIHRvIHVwZGF0ZSB0aGUgaW50ZXJhbCBxdWV1ZSBvZiBpbmNvbWluZyBjb21tYW5kcy5cbiAqIFJlY2VpdmluZyBjb21tYW5kcyBkb2VzIG5vdCBpbW1lZGlhdGVseSBzdGFydCB0aGUgcmVkZXJuaW5nIHByb2Nlc3MuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9IGNvbW1hbmRzICAgICBjb21tYW5kIHF1ZXVlIHRvIGJlIHByb2Nlc3NlZCBieSB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9zaXRvcidzIGBkcmF3Q29tbWFuZHNgIG1ldGhvZFxuICovXG5Db21wb3NpdG9yLnByb3RvdHlwZS5yZWNlaXZlQ29tbWFuZHMgPSBmdW5jdGlvbiByZWNlaXZlQ29tbWFuZHMoY29tbWFuZHMpIHtcbiAgICB2YXIgbGVuID0gY29tbWFuZHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdGhpcy5faW5Db21tYW5kcy5wdXNoKGNvbW1hbmRzW2ldKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEZsdXNoZXMgdGhlIHF1ZXVlIG9mIG91dGdvaW5nIFwib3V0XCIgY29tbWFuZHMuXG4gKiBDYWxsZWQgYnkgVGhyZWFkTWFuYWdlci5cbiAqXG4gKiBAbWV0aG9kIGNsZWFyQ29tbWFuZHNcbiAqL1xuQ29tcG9zaXRvci5wcm90b3R5cGUuY2xlYXJDb21tYW5kcyA9IGZ1bmN0aW9uIGNsZWFyQ29tbWFuZHMoKSB7XG4gICAgdGhpcy5faW5Db21tYW5kcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuX291dENvbW1hbmRzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fc2VudFJlc2l6ZSA9IGZhbHNlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb3NpdG9yO1xuIiwidmFyIFdlYkdMUmVuZGVyZXIgPSByZXF1aXJlKCdmYW1vdXMtd2ViZ2wtcmVuZGVyZXJzJykuV2ViR0xSZW5kZXJlcjtcbnZhciBDYW1lcmEgPSByZXF1aXJlKCdmYW1vdXMtY29tcG9uZW50cycpLkNhbWVyYTtcbnZhciBET01SZW5kZXJlciA9IHJlcXVpcmUoJ2ZhbW91cy1kb20tcmVuZGVyZXJzJykuRE9NUmVuZGVyZXI7XG5cbmZ1bmN0aW9uIENvbnRleHQoc2VsZWN0b3IsIGNvbXBvc2l0b3IpIHtcbiAgICB0aGlzLl9jb21wb3NpdG9yID0gY29tcG9zaXRvcjtcbiAgICB0aGlzLl9yb290RWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcblxuICAgIGlmICh0aGlzLl9yb290RWwgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMudXBkYXRlU2l6ZS5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICB2YXIgRE9NTGF5ZXJFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIERPTUxheWVyRWwuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgRE9NTGF5ZXJFbC5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgRE9NTGF5ZXJFbC5zdHlsZS50cmFuc2Zvcm1TdHlsZSA9ICdwcmVzZXJ2ZS0zZCc7XG4gICAgRE9NTGF5ZXJFbC5zdHlsZS53ZWJraXRUcmFuc2Zvcm1TdHlsZSA9ICdwcmVzZXJ2ZS0zZCc7XG4gICAgdGhpcy5fcm9vdEVsLmFwcGVuZENoaWxkKERPTUxheWVyRWwpO1xuICAgIHRoaXMuRE9NUmVuZGVyZXIgPSBuZXcgRE9NUmVuZGVyZXIoRE9NTGF5ZXJFbCwgc2VsZWN0b3IsIGNvbXBvc2l0b3IpOyBcbiBcbiAgICB0aGlzLldlYkdMUmVuZGVyZXIgPSBudWxsO1xuICAgIHRoaXMuY2FudmFzID0gbnVsbDtcblxuICAgIHRoaXMuX3JlbmRlclN0YXRlID0ge1xuICAgICAgICBwcm9qZWN0aW9uVHlwZTogQ2FtZXJhLk9SVEhPR1JBUEhJQ19QUk9KRUNUSU9OLFxuICAgICAgICBwZXJzcGVjdGl2ZVRyYW5zZm9ybTogbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMV0pLFxuICAgICAgICB2aWV3VHJhbnNmb3JtOiBuZXcgRmxvYXQzMkFycmF5KFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxXSksXG4gICAgICAgIHZpZXdEaXJ0eTogZmFsc2UsXG4gICAgICAgIHBlcnNwZWN0aXZlRGlydHk6IGZhbHNlXG4gICAgfTtcblxuICAgIHRoaXMuX3NpemUgPSBbXTtcbiAgICB0aGlzLl9jaGlsZHJlbiA9IHt9O1xuICAgIHRoaXMuX2VsZW1lbnRIYXNoID0ge307XG5cbiAgICB0aGlzLl9tZXNoVHJhbnNmb3JtID0gW107XG4gICAgdGhpcy5fbWVzaFNpemUgPSBbMCwgMCwgMF07XG5cbiAgICB0aGlzLnVwZGF0ZVNpemUoKTtcbn1cblxuQ29udGV4dC5wcm90b3R5cGUudXBkYXRlU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbmV3U2l6ZSA9IHRoaXMuRE9NUmVuZGVyZXIuX2dldFNpemUoKTtcblxuICAgIHZhciB3aWR0aCA9IG5ld1NpemVbMF07XG4gICAgdmFyIGhlaWdodCA9IG5ld1NpemVbMV07XG5cbiAgICB0aGlzLl9zaXplWzBdID0gd2lkdGg7XG4gICAgdGhpcy5fc2l6ZVsxXSA9IGhlaWdodDtcbiAgICB0aGlzLl9zaXplWzJdID0gKHdpZHRoID4gaGVpZ2h0KSA/IHdpZHRoIDogaGVpZ2h0O1xuXG4gICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLndpZHRoICA9IHdpZHRoO1xuICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuV2ViR0xSZW5kZXJlcikgdGhpcy5XZWJHTFJlbmRlcmVyLnVwZGF0ZVNpemUodGhpcy5fc2l6ZSk7XG5cbiAgICByZXR1cm4gdGhpcztcbn1cblxuQ29udGV4dC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIGRyYXcoKSB7XG4gICAgdGhpcy5ET01SZW5kZXJlci5kcmF3KHRoaXMuX3JlbmRlclN0YXRlKTtcbiAgICBpZiAodGhpcy5XZWJHTFJlbmRlcmVyKSB0aGlzLldlYkdMUmVuZGVyZXIuZHJhdyh0aGlzLl9yZW5kZXJTdGF0ZSk7XG5cbiAgICBpZiAodGhpcy5fcmVuZGVyU3RhdGUucGVyc3BlY3RpdmVEaXJ0eSkgdGhpcy5fcmVuZGVyU3RhdGUucGVyc3BlY3RpdmVEaXJ0eSA9IGZhbHNlO1xuICAgIGlmICh0aGlzLl9yZW5kZXJTdGF0ZS52aWV3RGlydHkpIHRoaXMuX3JlbmRlclN0YXRlLnZpZXdEaXJ0eSA9IGZhbHNlO1xufTtcblxuQ29udGV4dC5wcm90b3R5cGUuZ2V0Um9vdFNpemUgPSBmdW5jdGlvbiBnZXRSb290U2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ET01SZW5kZXJlci5nZXRTaXplKCk7XG59O1xuXG5Db250ZXh0LnByb3RvdHlwZS5pbml0V2ViR0wgPSBmdW5jdGlvbiBpbml0V2ViR0woKSB7XG4gICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB0aGlzLmNhbnZhcy5jbGFzc05hbWUgPSAnZmFtb3VzLXdlYmdsJztcbiAgICB0aGlzLl9yb290RWwuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXMpO1xuICAgIHRoaXMuV2ViR0xSZW5kZXJlciA9IG5ldyBXZWJHTFJlbmRlcmVyKHRoaXMuY2FudmFzKTtcbiAgICB0aGlzLnVwZGF0ZVNpemUoKTtcbn07XG5cbkNvbnRleHQucHJvdG90eXBlLnJlY2VpdmUgPSBmdW5jdGlvbiByZWNlaXZlKHBhdGhBcnIsIHBhdGgsIGNvbW1hbmRzLCBpdGVyYXRvcikge1xuICAgIHZhciBwb2ludGVyO1xuICAgIHZhciBwYXJlbnRFbDtcbiAgICB2YXIgZWxlbWVudDtcbiAgICB2YXIgaWQ7XG4gICAgdmFyIGxvY2FsSXRlcmF0b3IgPSBpdGVyYXRvcjtcblxuICAgIHZhciBjb21tYW5kID0gY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXTtcbiAgICB0aGlzLkRPTVJlbmRlcmVyLmxvYWRQYXRoKHBhdGgpO1xuICAgIHRoaXMuRE9NUmVuZGVyZXIuZmluZFRhcmdldCgpO1xuICAgIHdoaWxlIChjb21tYW5kKSB7XG5cbiAgICAgICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICAgICAgICBjYXNlICdJTklUX0RPTSc6XG4gICAgICAgICAgICAgICAgdGhpcy5ET01SZW5kZXJlci5pbnNlcnRFbChjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnQ0hBTkdFX1RSQU5TRk9STSc6XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgMTYgOyBpKyspIHRoaXMuX21lc2hUcmFuc2Zvcm1baV0gPSBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5ET01SZW5kZXJlci5zZXRNYXRyaXgodGhpcy5fbWVzaFRyYW5zZm9ybSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5XZWJHTFJlbmRlcmVyKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLldlYkdMUmVuZGVyZXIuc2V0Q3V0b3V0VW5pZm9ybShwYXRoLCAndHJhbnNmb3JtJywgdGhpcy5fbWVzaFRyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ0NIQU5HRV9TSVpFJzpcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdO1xuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5ET01SZW5kZXJlci5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLldlYkdMUmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVzaFNpemVbMF0gPSB3aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVzaFNpemVbMV0gPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuV2ViR0xSZW5kZXJlci5zZXRDdXRvdXRVbmlmb3JtKHBhdGgsICdzaXplJywgdGhpcy5fbWVzaFNpemUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnQ0hBTkdFX1BST1BFUlRZJzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5XZWJHTFJlbmRlcmVyKSB0aGlzLldlYkdMUmVuZGVyZXIuZ2V0T3JTZXRDdXRvdXQocGF0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ET01SZW5kZXJlci5zZXRQcm9wZXJ0eShjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdLCBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnQ0hBTkdFX0NPTlRFTlQnOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLldlYkdMUmVuZGVyZXIpIHRoaXMuV2ViR0xSZW5kZXJlci5nZXRPclNldEN1dG91dChwYXRoKTtcbiAgICAgICAgICAgICAgICB0aGlzLkRPTVJlbmRlcmVyLnNldENvbnRlbnQoY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ0NIQU5HRV9BVFRSSUJVVEUnOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLldlYkdMUmVuZGVyZXIpIHRoaXMuV2ViR0xSZW5kZXJlci5nZXRPclNldEN1dG91dChwYXRoKTtcbiAgICAgICAgICAgICAgICB0aGlzLkRPTVJlbmRlcmVyLnNldEF0dHJpYnV0ZShjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdLCBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnQUREX0NMQVNTJzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5XZWJHTFJlbmRlcmVyKSB0aGlzLldlYkdMUmVuZGVyZXIuZ2V0T3JTZXRDdXRvdXQocGF0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ET01SZW5kZXJlci5hZGRDbGFzcyhjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdKTsgXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ1JFTU9WRV9DTEFTUyc6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuV2ViR0xSZW5kZXJlcikgdGhpcy5XZWJHTFJlbmRlcmVyLmdldE9yU2V0Q3V0b3V0KHBhdGgpO1xuICAgICAgICAgICAgICAgIHRoaXMuRE9NUmVuZGVyZXIucmVtb3ZlQ2xhc3MoY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ0FERF9FVkVOVF9MSVNURU5FUic6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuV2ViR0xSZW5kZXJlcikgdGhpcy5XZWJHTFJlbmRlcmVyLmdldE9yU2V0Q3V0b3V0KHBhdGgpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdO1xuICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXTtcbiAgICAgICAgICAgICAgICB2YXIgcHJldmVudERlZmF1bHQgPSBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5ET01SZW5kZXJlci5hZGRFdmVudExpc3RlbmVyKHBhdGgsIHR5cGUsIHByb3BlcnRpZXMsIHByZXZlbnREZWZhdWx0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnR0xfU0VUX0RSQVdfT1BUSU9OUyc6IFxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5XZWJHTFJlbmRlcmVyKSB0aGlzLmluaXRXZWJHTCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuV2ViR0xSZW5kZXJlci5zZXRNZXNoT3B0aW9ucyhwYXRoLCBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnR0xfQU1CSUVOVF9MSUdIVCc6XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLldlYkdMUmVuZGVyZXIpIHRoaXMuaW5pdFdlYkdMKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5XZWJHTFJlbmRlcmVyLnNldEFtYmllbnRMaWdodENvbG9yKFxuICAgICAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnR0xfTElHSFRfUE9TSVRJT04nOlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5XZWJHTFJlbmRlcmVyKSB0aGlzLmluaXRXZWJHTCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuV2ViR0xSZW5kZXJlci5zZXRMaWdodFBvc2l0aW9uKFxuICAgICAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnR0xfTElHSFRfQ09MT1InOlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5XZWJHTFJlbmRlcmVyKSB0aGlzLmluaXRXZWJHTCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuV2ViR0xSZW5kZXJlci5zZXRMaWdodENvbG9yKFxuICAgICAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnTUFURVJJQUxfSU5QVVQnOlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5XZWJHTFJlbmRlcmVyKSB0aGlzLmluaXRXZWJHTCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuV2ViR0xSZW5kZXJlci5oYW5kbGVNYXRlcmlhbElucHV0KFxuICAgICAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnR0xfU0VUX0dFT01FVFJZJzpcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuV2ViR0xSZW5kZXJlcikgdGhpcy5pbml0V2ViR0woKTtcbiAgICAgICAgICAgICAgICB0aGlzLldlYkdMUmVuZGVyZXIuc2V0R2VvbWV0cnkoXG4gICAgICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl0sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl0sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdHTF9VTklGT1JNUyc6XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLldlYkdMUmVuZGVyZXIpIHRoaXMuaW5pdFdlYkdMKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5XZWJHTFJlbmRlcmVyLnNldE1lc2hVbmlmb3JtKFxuICAgICAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnR0xfQlVGRkVSX0RBVEEnOlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5XZWJHTFJlbmRlcmVyKSB0aGlzLmluaXRXZWJHTCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuV2ViR0xSZW5kZXJlci5idWZmZXJEYXRhKFxuICAgICAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnR0xfSElERV9NRVNIJzpcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuV2ViR0xSZW5kZXJlcikgdGhpcy5pbml0V2ViR0woKTtcbiAgICAgICAgICAgICAgICB0aGlzLldlYkdMUmVuZGVyZXIuaGlkZU1lc2gocGF0aCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ0dMX1NIT1dfTUVTSCc6XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLldlYkdMUmVuZGVyZXIpIHRoaXMuaW5pdFdlYkdMKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5XZWJHTFJlbmRlcmVyLnNob3dNZXNoKHBhdGgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdQSU5IT0xFX1BST0pFQ1RJT04nOlxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlclN0YXRlLnByb2plY3Rpb25UeXBlID0gQ2FtZXJhLlBJTkhPTEVfUFJPSkVDVElPTjtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZVRyYW5zZm9ybVsxMV0gPSAtMSAvIGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl07XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZURpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnT1JUSE9HUkFQSElDX1BST0pFQ1RJT04nOlxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlclN0YXRlLnByb2plY3Rpb25UeXBlID0gQ2FtZXJhLk9SVEhPR1JBUEhJQ19QUk9KRUNUSU9OO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlclN0YXRlLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzExXSA9IDA7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZURpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnQ0hBTkdFX1ZJRVdfVFJBTlNGT1JNJzpcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJTdGF0ZS52aWV3VHJhbnNmb3JtWzBdID0gY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJTdGF0ZS52aWV3VHJhbnNmb3JtWzFdID0gY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJTdGF0ZS52aWV3VHJhbnNmb3JtWzJdID0gY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJTdGF0ZS52aWV3VHJhbnNmb3JtWzNdID0gY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlclN0YXRlLnZpZXdUcmFuc2Zvcm1bNF0gPSBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlclN0YXRlLnZpZXdUcmFuc2Zvcm1bNV0gPSBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlclN0YXRlLnZpZXdUcmFuc2Zvcm1bNl0gPSBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlclN0YXRlLnZpZXdUcmFuc2Zvcm1bN10gPSBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyU3RhdGUudmlld1RyYW5zZm9ybVs4XSA9IGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl07XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyU3RhdGUudmlld1RyYW5zZm9ybVs5XSA9IGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl07XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyU3RhdGUudmlld1RyYW5zZm9ybVsxMF0gPSBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlclN0YXRlLnZpZXdUcmFuc2Zvcm1bMTFdID0gY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlclN0YXRlLnZpZXdUcmFuc2Zvcm1bMTJdID0gY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJTdGF0ZS52aWV3VHJhbnNmb3JtWzEzXSA9IGNvbW1hbmRzWysrbG9jYWxJdGVyYXRvcl07XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyU3RhdGUudmlld1RyYW5zZm9ybVsxNF0gPSBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlclN0YXRlLnZpZXdUcmFuc2Zvcm1bMTVdID0gY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlclN0YXRlLnZpZXdEaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ1dJVEgnOiByZXR1cm4gbG9jYWxJdGVyYXRvciAtIDE7XG4gICAgICAgIH1cblxuICAgICAgICBjb21tYW5kID0gY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbG9jYWxJdGVyYXRvcjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udGV4dDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBUaGUgVGhyZWFkTWFuYWdlciBpcyBiZWluZyB1cGRhdGVkIGJ5IGFuIEVuZ2luZSBieSBjb25zZWN1dGl2ZWx5IGNhbGxpbmcgaXRzXG4gKiBgdXBkYXRlYCBtZXRob2QuIEl0IGNhbiBlaXRoZXIgbWFuYWdlIGEgcmVhbCBXZWItV29ya2VyIG9yIHRoZSBnbG9iYWxcbiAqIEZhbW91cyBjb3JlIHNpbmdsZXRvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIGNvbXBvc2l0b3IgPSBuZXcgQ29tcG9zaXRvcigpO1xuICogXG4gKiAvLyBVc2luZyBhIFdlYiBXb3JrZXJcbiAqIHZhciB3b3JrZXIgPSBuZXcgV29ya2VyKCd3b3JrZXIuYnVuZGxlLmpzJyk7XG4gKiB2YXIgdGhyZWFkbWFuZ2VyID0gbmV3IFRocmVhZE1hbmFnZXIod29ya2VyLCBjb21wb3NpdG9yKTtcbiAqIFxuICogLy8gV2l0aG91dCB1c2luZyBhIFdlYiBXb3JrZXJcbiAqIHZhciB0aHJlYWRtYW5nZXIgPSBuZXcgVGhyZWFkTWFuYWdlcihGYW1vdXMsIGNvbXBvc2l0b3IpO1xuICogXG4gKiBAY2xhc3MgIFRocmVhZE1hbmFnZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogXG4gKiBAcGFyYW0ge0ZhbW91c3xXb3JrZXJ9IHRocmVhZCAgICAgICAgVGhlIHRocmVhZCBiZWluZyB1c2VkIHRvIHJlY2VpdmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlcyBmcm9tIGFuZCBwb3N0IG1lc3NhZ2VzIHRvLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEV4cGVjdGVkIHRvIGV4cG9zZSBhIFdlYldvcmtlci1saWtlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQVBJLCB3aGljaCBtZWFucyBwcm92aWRpbmcgYSB3YXkgdG9cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW4gZm9yIHVwZGF0ZXMgYnkgc2V0dGluZyBpdHNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgb25tZXNzYWdlYCBwcm9wZXJ0eSBhbmQgc2VuZGluZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZXMgdXNpbmcgYHBvc3RNZXNzYWdlYC5cbiAqIEBwYXJhbSB7Q29tcG9zaXRvcn0gY29tcG9zaXRvciAgICAgICBhbiBpbnN0YW5jZSBvZiBDb21wb3NpdG9yIHVzZWQgdG9cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYWN0IGVucXVldWVkIGRyYXcgY29tbWFuZHMgZnJvbSB0b1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlIHNlbnQgdG8gdGhlIHRocmVhZFxuICovXG5mdW5jdGlvbiBUaHJlYWRNYW5hZ2VyICh0aHJlYWQsIGNvbXBvc2l0b3IpIHtcbiAgICB0aGlzLl90aHJlYWQgPSB0aHJlYWQ7XG4gICAgdGhpcy5fY29tcG9zaXRvciA9IGNvbXBvc2l0b3I7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMuX3RocmVhZC5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgX3RoaXMuX2NvbXBvc2l0b3IucmVjZWl2ZUNvbW1hbmRzKGV2LmRhdGEgPyBldi5kYXRhIDogZXYpO1xuICAgIH07XG4gICAgdGhpcy5fdGhyZWFkLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB0aHJlYWQgYmVpbmcgdXNlZCBieSB0aGUgVGhyZWFkTWFuYWdlci5cbiAqIFRoaXMgY291bGQgZWl0aGVyIGJlIGFuIGFuIGFjdHVhbCB3ZWIgd29ya2VyIG9yIGEgYEZhbW91c2Agc2luZ2xldG9uLlxuICpcbiAqIEBtZXRob2QgZ2V0VGhyZWFkXG4gKiBcbiAqIEByZXR1cm4ge1dvcmtlcnxGYW1vdXN9ICBFaXRoZXIgYSB3ZWIgd29ya2VyIG9yIGEgYEZhbW91c2Agc2luZ2xldG9uLlxuICovXG5UaHJlYWRNYW5hZ2VyLnByb3RvdHlwZS5nZXRUaHJlYWQgPSBmdW5jdGlvbiBnZXRUaHJlYWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RocmVhZDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY29tcG9zaXRvciBiZWluZyB1c2VkIGJ5IHRoaXMgVGhyZWFkTWFuYWdlci5cbiAqXG4gKiBAbWV0aG9kIGdldENvbXBvc2l0b3JcbiAqIFxuICogQHJldHVybiB7Q29tcG9zaXRvcn0gICAgIFRoZSBjb21wb3NpdG9yIHVzZWQgYnkgdGhlIFRocmVhZE1hbmFnZXIuXG4gKi9cblRocmVhZE1hbmFnZXIucHJvdG90eXBlLmdldENvbXBvc2l0b3IgPSBmdW5jdGlvbiBnZXRDb21wb3NpdG9yKCkge1xuICAgIHJldHVybiB0aGlzLl9jb21wb3NpdG9yO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgbWV0aG9kIGJlaW5nIGludm9rZWQgYnkgdGhlIEVuZ2luZSBvbiBldmVyeSBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYC5cbiAqIFVzZWQgZm9yIHVwZGF0aW5nIHRoZSBub3Rpb24gb2YgdGltZSB3aXRoaW4gdGhlIG1hbmFnZWQgdGhyZWFkIGJ5IHNlbmRpbmdcbiAqIGEgRlJBTUUgY29tbWFuZCBhbmQgc2VuZGluZyBtZXNzYWdlcyB0byBcbiAqIFxuICogQG1ldGhvZCB1cGRhdGVcbiAqIFxuICogQHBhcmFtICB7TnVtYmVyfSB0aW1lIHVuaXggdGltZXN0YW1wIHRvIGJlIHBhc3NlZCBkb3duIHRvIHRoZSB3b3JrZXIgYXMgYVxuICogICAgICAgICAgICAgICAgICAgICAgIEZSQU1FIGNvbW1hbmRcbiAqL1xuVGhyZWFkTWFuYWdlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlICh0aW1lKSB7XG4gICAgdGhpcy5fdGhyZWFkLnBvc3RNZXNzYWdlKFsnRlJBTUUnLCB0aW1lXSk7XG4gICAgdmFyIHRocmVhZE1lc3NhZ2VzID0gdGhpcy5fY29tcG9zaXRvci5kcmF3Q29tbWFuZHMoKTtcbiAgICB0aGlzLl90aHJlYWQucG9zdE1lc3NhZ2UodGhyZWFkTWVzc2FnZXMpO1xuICAgIHRoaXMuX2NvbXBvc2l0b3IuY2xlYXJDb21tYW5kcygpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUaHJlYWRNYW5hZ2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBDb21wb3NpdG9yOiByZXF1aXJlKCcuL0NvbXBvc2l0b3InKSxcbiAgICBUaHJlYWRNYW5hZ2VyOiByZXF1aXJlKCcuL1RocmVhZE1hbmFnZXInKVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHNlc3Npb25IaXN0b3J5U3VwcG9ydCA9IHdpbmRvdy5oaXN0b3J5ICYmIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSAmJiB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGU7XG5cbi8qKlxuICogQSBzdGF0ZWxlc3Mgc2hpbSBmb3IgaGFzaCByb3V0aW5nLiBVc2VkIGJ5IHJvdXRlci5cbiAqICAgU3VwcG9ydHMgaGFzaCBiYW5nIHJvdXRpbmcgYW5kIEhUTUw1IHB1c2hTdGF0ZS5cbiAqICAgRmFsbHMgYmFjayB0byBoYXNoIGJhbmcgdXJscyB3aGVuIHB1c2hTdGF0ZSBpcyBub3Qgc3VwcG9ydGVkLlxuICogICBJbXBsZW1lbnRzIHN1YnNldCBvZiBXM0Mgc3BlYyBpbiByZXNwZWN0IHRvXG4gKiAgIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvV0QtaHRtbDUtMjAxMTAxMTMvaGlzdG9yeS5odG1sI2hpc3RvcnktMFxuICpcbiAqIEBIaXN0b3J5XG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIGhpc3RvcnkgPSBIaXN0b3J5KCk7XG4gKiBjb25zb2xlLmxvZyhoaXN0b3J5Lmhhc2hCYW5nVXJscyk7XG4gKiBoaXN0b3J5LnB1c2hTdGF0ZSh7fSwgZG9jdW1lbnQudGl0bGUsICcvcm91dGUnKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmhhc2hCYW5nVXJscyBmb3JjZSBoaXN0b3J5IHRvIHVzZSBVUkxzXG4gKiAgIGluIHRoZSBmb3JtIG9mIC8jIS9yb3V0ZVxuICogQHBhcmFtIHtTdHJpbmd9IHJvb3RcbiAqL1xuZnVuY3Rpb24gSGlzdG9yeShvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEhpc3RvcnkpKSByZXR1cm4gbmV3IEhpc3Rvcnkob3B0aW9ucyk7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLl9yb290ID0gb3B0aW9ucy5yb290IHx8ICcnO1xuICAgIHRoaXMuX3Nlc3Npb25IaXN0b3J5U3VwcG9ydCA9IHNlc3Npb25IaXN0b3J5U3VwcG9ydDtcbiAgICB0aGlzLmhhc2hCYW5nVXJscyA9IG9wdGlvbnMuaGFzaEJhbmdVcmxzIHx8ICF0aGlzLl9zZXNzaW9uSGlzdG9yeVN1cHBvcnQ7XG4gICAgdGhpcy5fbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb247XG59XG5cbi8qKlxuICogQHByb3BlcnR5IHtCb29sZWFufSBoYXNoQmFuZ1VybHNcbiAqIEByZWFkb25seVxuICovXG5IaXN0b3J5LnByb3RvdHlwZS5oYXNoQmFuZ1VybHMgPSBmYWxzZTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgb24gZXZlcnkgc3RhdGUgY2hhbmdlLlxuICpcbiAqIEBtZXRob2Qgb25TdGF0ZUNoYW5nZVxuICogQGNoYWluYWJsZVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgY2FsbGJhY2sgdG8gaW52b2tlIG9uIHN0YXRlIGNoYW5nZVxuICpcbiAqIEByZXR1cm4ge0hpc3Rvcnl9IHRoaXNcbiAqL1xuSGlzdG9yeS5wcm90b3R5cGUub25TdGF0ZUNoYW5nZSA9IGZ1bmN0aW9uIG9uU3RhdGVDaGFuZ2UoaGFuZGxlcikge1xuICAgIC8vIHByZWZlciBIVE1MNSBoaXN0b3J5IEFQSSBvdmVyIGhhc2hjaGFuZ2Ugd2hlbiBwb3NzaWJsZVxuICAgIGlmICh0aGlzLl9zZXNzaW9uSGlzdG9yeVN1cHBvcnQpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgaGFuZGxlcik7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwdXNoc3RhdGUnLCBoYW5kbGVyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5oYXNoQmFuZ1VybHMgJiYgJ29uaGFzaGNoYW5nZScgaW4gd2luZG93KSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgaGFuZGxlcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBvbmx5IHBvc3NpYmxlIHNvbHV0aW9uIGF0IHRoaXMgcG9pbnQgaXMgdG8gdXNlIGFuIHVnbHkgY29tYmluYXRpb25cbiAgICAgICAgLy8gb2Ygc2V0SW50ZXJ2YWwgYW5kIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRGVyZWdpc3RlciBhIHN0YXRlIGNoYW5nZSBoYW5kbGVyIHRoYXQgaGFzIGJlZW4gcHJldmlvdXNseSByZWdpc3RlcmVkXG4gKiAgIHRocm91Z2ggb25TdGF0ZUNoYW5nZS5cbiAqXG4gKiBAbWV0aG9kIG9mZlN0YXRlQ2hhbmdlXG4gKiBAY2hhaW5hYmxlXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBoYW5kbGVyIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCB0aHJvdWdoIG9uU3RhdGVDaGFuZ2VcbiAqXG4gKiBAcmV0dXJuIHtIaXN0b3J5fSB0aGlzXG4gKi9cbkhpc3RvcnkucHJvdG90eXBlLm9mZlN0YXRlQ2hhbmdlID0gZnVuY3Rpb24gb2ZmU3RhdGVDaGFuZ2UoaGFuZGxlcikge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIGhhbmRsZXIpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwdXNoc3RhdGUnLCBoYW5kbGVyKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignaGFzaGNoYW5nZScsIGhhbmRsZXIpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTaGltIGZvciB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGVcbiAqIFxuICogQG1ldGhvZCBwdXNoU3RhdGVcbiAqIEBjaGFpbmFibGVcbiAqXG4gKiBAcGFyYW1zIHtPYmplY3R9IGRhdGEgc3RhdGUgb2JqZWN0IHBhc3NlZCB0aHJvdWdoIHNlc3Npb24gQVBJIGlmIHBvc3NpYmxlLFxuICogICBub3QgYWNjZXNzYWJsZSBsYXRlciBvbiwgdXNlZCB0byBtYWtlIGFyZ3VtZW50cyBsaXN0IGNvbXBsYWludCB3aXRoIFczQ1xuICogICBzcGVjXG4gKiBAcGFyYW1zIHtTdHJpbmc9ZG9jdW1lbnQudGl0bGV9IHRpdGxlIG5ldyBkb2N1bWVudCB0aXRsZSwgbm90IGFzc29jaWF0ZWQgd2l0aFxuICogICBuZXcgc3RhdGVcbiAqIEBwYXJhbXMge1N0cmluZ30gdXJsXG4gKlxuICogQHJldHVybiB7SGlzdG9yeX0gdGhpc1xuICovXG5IaXN0b3J5LnByb3RvdHlwZS5wdXNoU3RhdGUgPSBmdW5jdGlvbiBwdXNoU3RhdGUoZGF0YSwgdGl0bGUsIHVybCkge1xuICAgIGRvY3VtZW50LnRpdGxlID0gdGl0bGUgfHwgZG9jdW1lbnQudGl0bGU7XG4gICAgaWYgKHRoaXMuaGFzaEJhbmdVcmxzKSB7XG4gICAgICAgIGlmICh0aGlzLl9zZXNzaW9uSGlzdG9yeVN1cHBvcnQpIHtcbiAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShkYXRhLCB0aXRsZSwgJyMhJyArIHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaGFzaCA9IHVybDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKGRhdGEsIHRpdGxlLCB1cmwpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2hpbSBmb3Igd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlXG4gKiBcbiAqIEBtZXRob2QgcmVwbGFjZVN0YXRlXG4gKiBAY2hhaW5hYmxlXG4gKlxuICogQHBhcmFtcyB7T2JqZWN0fSBkYXRhIHN0YXRlIG9iamVjdCBwYXNzZWQgdGhyb3VnaCBzZXNzaW9uIEFQSSBpZiBwb3NzaWJsZSxcbiAqICAgbm90IGFjY2Vzc2FibGUgbGF0ZXIgb24sIHVzZWQgdG8gbWFrZSBhcmd1bWVudHMgbGlzdCBjb21wbGFpbnQgd2l0aCBXM0NcbiAqICAgc3BlY1xuICogQHBhcmFtcyB7U3RyaW5nPWRvY3VtZW50LnRpdGxlfSB0aXRsZSBuZXcgZG9jdW1lbnQgdGl0bGUsIG5vdCBhc3NvY2lhdGVkIHdpdGhcbiAqICAgbmV3IHN0YXRlXG4gKiBAcGFyYW1zIHtTdHJpbmd9IHVybFxuICpcbiAqIEByZXR1cm4ge0hpc3Rvcnl9IHRoaXNcbiAqL1xuSGlzdG9yeS5wcm90b3R5cGUucmVwbGFjZVN0YXRlID0gZnVuY3Rpb24gcmVwbGFjZVN0YXRlKGRhdGEsIHRpdGxlLCB1cmwpIHtcbiAgICBkb2N1bWVudC50aXRsZSA9IHRpdGxlIHx8IGRvY3VtZW50LnRpdGxlO1xuICAgIGlmICh0aGlzLmhhc2hCYW5nVXJscykge1xuICAgICAgICBpZiAodGhpcy5fc2Vzc2lvbkhpc3RvcnlTdXBwb3J0KSB7XG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoZGF0YSwgdGl0bGUsICcjIScgKyB1cmwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXJsID0gKCcnICsgd2luZG93LmxvY2F0aW9uKS5zcGxpdCgnIycpWzBdICsgJyMhJyArIHVybDtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKHVybCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShkYXRhLCB0aXRsZSwgdXJsKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybiBjdXJyZW50IG5vcm1hbGl6ZWQgc3RhdGUgKHJvdXRlZCBwYXRobmFtZSkuXG4gKiBOb3QgY29tcGxpYW50IHdpdGggW1czQyBzcGVjIDUuNCBTZXNzaW9uIGhpc3RvcnkgYW5kXG4gKiBuYXZpZ2F0aW9uXShodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1dELWh0bWw1LTIwMTEwMTEzL2hpc3RvcnkuaHRtbClcbiAqXG4gKiBAbWV0aG9kIGdldFN0YXRlXG4gKlxuICogQHJldHVybiB7U3RyaW5nfG51bGx9IHN0YXRlIGFzIG5vcm1hbGl6ZWQgcGF0aG5hbWVcbiAqL1xuSGlzdG9yeS5wcm90b3R5cGUuZ2V0U3RhdGUgPSBmdW5jdGlvbiBnZXRTdGF0ZSgpIHtcbiAgICBpZiAoIXRoaXMuX2xvY2F0aW9uLnBhdGhuYW1lLm1hdGNoKCdeJyArIHRoaXMuX3Jvb3QpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5oYXNoQmFuZ1VybHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2F0aW9uLmhhc2guc3Vic3RyaW5nKDIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlY29kZVVSSSh0aGlzLl9sb2NhdGlvbi5wYXRobmFtZSkuc3Vic3RyaW5nKHRoaXMuX3Jvb3QubGVuZ3RoKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhpc3Rvcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBfSGlzdG9yeSA9IHJlcXVpcmUoJy4vSGlzdG9yeScpO1xuXG4vKipcbiAqIEEgc2ltcGxlIHJvdXRlciBzdXBwb3J0aW5nIEhUTUw1IHB1c2hTdGF0ZSBhbmQgaGFzaGJhbmcgIHJvdXRpbmcgKFwiIyEvXCIpLlxuICogXG4gKiBAZXhhbXBsZVxuICogdmFyIHJvdXRlciA9IFJvdXRlcih7XG4gKiAgICAgJy9leGFtcGxlLXJvdXRlLTAnOiBmdW5jdGlvbigpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coJy9leGFtcGxlLXJvdXRlLTAnKTtcbiAqICAgICB9LFxuICogICAgICcvZXhhbXBsZS1yb3V0ZS0xJzogZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKCcvZXhhbXBsZS1yb3V0ZS0xJyk7XG4gKiAgICAgfSxcbiAqICAgICAnL2V4YW1wbGUtcm91dGUtMic6IGZ1bmN0aW9uKCkge1xuICogICAgICAgICBjb25zb2xlLmxvZygnL2V4YW1wbGUtcm91dGUtMicpO1xuICogICAgIH0sXG4gKiAgICAgJy9leGFtcGxlLXJvdXRlLTMnOiBmdW5jdGlvbigpIHtcbiAqICAgICAgICAgY29uc29sZS5sb2coJy9leGFtcGxlLXJvdXRlLTMnKTtcbiAqICAgICB9XG4gKiB9KTtcbiAqXG4gKiB2YXIgY3VycmVudFN0YXRlID0gMDtcbiAqIHZhciBpbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuICogICAgIGlmIChjdXJyZW50U3RhdGUgPT09IDQpIHJldHVybiBjbGVhclRpbWVvdXQoaW50ZXJ2YWwpO1xuICogICAgIHJvdXRlci5uYXZpZ2F0ZSgnL2V4YW1wbGUtcm91dGUtJyArIGN1cnJlbnRTdGF0ZSwgeyBpbnZva2U6IHRydWUgfSk7XG4gKiAgICAgY3VycmVudFN0YXRlKys7XG4gKiB9LCAxMDAwKTtcbiAqIFxuICogQGNsYXNzIFJvdXRlclxuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHJvdXRlc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5zaWxlbnRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5oYXNoQmFuZ1VybHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnByb3h5XG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5yb290XG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMudmFsaWRhdGUgY2hlY2sgZm9yIHVua25vd24gcm91dGVzXG4gKi9cbmZ1bmN0aW9uIFJvdXRlcihyb3V0ZXMsIG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUm91dGVyKSkgcmV0dXJuIG5ldyBSb3V0ZXIocm91dGVzLCBvcHRpb25zKTtcbiAgICBcbiAgICByb3V0ZXMgPSByb3V0ZXMgfHwge307XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB0aGlzLl9yb290ID0gb3B0aW9ucy5yb290IHx8ICcnO1xuXG4gICAgdGhpcy5fcm91dGVzID0gW107XG4gICAgdGhpcy5wcm94eSA9IG9wdGlvbnMucHJveHkgfHwge307XG4gICAgaWYgKG9wdGlvbnMudmFsaWRhdGUpIHRoaXMudmFsaWRhdGUgPSB0cnVlO1xuXG4gICAgLy8gQXZvaWRzIGN5bGljIHJvdXRpbmcgYnkgc3RvcmluZyB0aGUgbGFzdCByb3V0ZWQgc3RhdGVcbiAgICAvLyBTZWVtcyBsaWtlIFczQyBzcGVjIGRvZXNuJ3QgbWVudGlvbiBpZiBwdXNoU3RhdGUgZXZlbnQgc2hvdWxkIGJlXG4gICAgLy8gZGlzcGF0Y2hlZCBvbiBwYWdlIGxvYWQuXG4gICAgdGhpcy5fbGFzdFN0YXRlID0gbnVsbDtcblxuICAgIF9hZGRJbml0aWFsUm91dGVzLmNhbGwodGhpcywgcm91dGVzKTtcblxuICAgIHRoaXMuX2hpc3RvcnkgPSBfSGlzdG9yeSh7XG4gICAgICAgIGhhc2hCYW5nVXJsczogb3B0aW9ucy5oYXNoQmFuZ1VybHMsXG4gICAgICAgIHJvb3Q6IHRoaXMuX3Jvb3RcbiAgICB9KS5vblN0YXRlQ2hhbmdlKF9vblN0YXRlQ2hhbmdlLmJpbmQodGhpcykpO1xuXG4gICAgaWYgKCFvcHRpb25zLnNpbGVudCkgdGhpcy5zdGFydCgpO1xufVxuXG4vKipcbiAqIFN0YXJ0cyB0aGUgcm91dGVyIGJ5IGludm9raW5nIHRoZSByb3V0ZSBoYW5kbGVyIGJvdW5kIHRvIHRoZSBjdXJyZW50XG4gKiAgIHBhdGhuYW1lLiBXaWxsIGJlIGNhbGxlZCBieSBjb25zdHJ1Y3RvciwgdW5sZXNzIHNpbGVudCBvcHRpb24gaXNcbiAqICAgaW4gdXNlLlxuICpcbiAqIEBtZXRob2Qgc3RhcnRcbiAqIEBjaGFpbmFibGVcbiAqXG4gKiBAcmV0dXJuIHtSb3V0ZXJ9IHRoaXNcbiAqL1xuUm91dGVyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgIHRoaXMuaW52b2tlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE5hdmlnYXRlcyB0byB0aGUgZ2l2ZW4gcm91dGUuIElmIG5vIHJvdXRlIGlzIGdpdmUsIG5hdmlnYXRlIHRvIHRoZSBjdXJyZW50XG4gKiAgIHBhdGhuYW1lICh1c2VkIGR1cmluZyBpbml0aWFsaXphdGlvbikuXG4gKlxuICogQG1ldGhvZCBuYXZpZ2F0ZVxuICogQGNoYWluYWJsZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbc3RhdGU9Y3VycmVudCBwYXRobmFtZV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMucmVwbGFjZVxuICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmludm9rZVxuICpcbiAqIEByZXR1cm4ge1JvdXRlcn0gdGhpc1xuICovXG5Sb3V0ZXIucHJvdG90eXBlLm5hdmlnYXRlID0gZnVuY3Rpb24gbmF2aWdhdGUoc3RhdGUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBzdGF0ZSA9IHN0YXRlIHx8IHRoaXMuX2hpc3RvcnkuZ2V0U3RhdGUoKTtcbiAgICBpZiAodGhpcy5fbGFzdFN0YXRlID09PSBzdGF0ZSkgcmV0dXJuIHRoaXM7XG5cbiAgICB2YXIgbWV0aG9kID0gb3B0aW9ucy5yZXBsYWNlID8gJ3JlcGxhY2VTdGF0ZScgOiAncHVzaFN0YXRlJztcbiAgICB0aGlzLl9oaXN0b3J5W21ldGhvZF0obnVsbCwgbnVsbCwgc3RhdGUpO1xuXG4gICAgaWYgKG9wdGlvbnMuaW52b2tlKSB0aGlzLmludm9rZSgpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEeW5hbWljYWxseSBhZGRzIGEgcm91dGUgdG8gdGhlIHJlZ2lzdGVyLlxuICpcbiAqIEBtZXRob2QgYWRkUm91dGVcbiAqIEBjaGFpbmFibGVcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IHJvdXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gKlxuICogQHJldHVybiB7Um91dGVyfSB0aGlzXG4gKi9cblJvdXRlci5wcm90b3R5cGUuYWRkUm91dGUgPSBmdW5jdGlvbiBhZGRSb3V0ZShyb3V0ZSwgaGFuZGxlcikge1xuICAgIGlmICh0eXBlb2Ygcm91dGUgPT09ICdzdHJpbmcnKSByb3V0ZSA9IF9jcmVhdGVSZWdFeHBSb3V0ZShyb3V0ZSk7XG4gICAgdGhpcy5fcm91dGVzLnB1c2goeyByZWdFeHA6IHJvdXRlLCBoYW5kbGVyOiBoYW5kbGVyIH0pO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBJbnZva2VzIHRoZSBoYW5kbGVyIGJvdW5kIHRvIHRoZSBnaXZlbiBzdGF0ZS5cbiAqXG4gKiBAbWV0aG9kIGludm9rZVxuICogQGNoYWluYWJsZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbc3RhdGU9Y3VycmVudCBwYXRobmFtZV0gcm91dGVcbiAqXG4gKiBAcmV0dXJuIHtSb3V0ZXJ9IHRoaXNcbiAqL1xuUm91dGVyLnByb3RvdHlwZS5pbnZva2UgPSBmdW5jdGlvbiBpbnZva2Uoc3RhdGUpIHtcbiAgICBpZiAodGhpcy5fbGFzdFN0YXRlID09PSBzdGF0ZSkgcmV0dXJuIHRoaXM7XG4gICAgc3RhdGUgPSBzdGF0ZSB8fCB0aGlzLl9oaXN0b3J5LmdldFN0YXRlKCk7XG4gICAgaWYgKHN0YXRlID09PSBudWxsKSByZXR1cm47XG4gICAgdmFyIHVua25vd24gPSB0aGlzLl9yb3V0ZXMuZXZlcnkoZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBfY2hlY2tSb3V0ZS5jYWxsKHRoaXMsIHJvdXRlLCBzdGF0ZSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygcm91dGUuaGFuZGxlciA9PT0gJ3N0cmluZycgJiYgdGhpcy5wcm94eVtyb3V0ZS5oYW5kbGVyXSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJveHlbcm91dGUuaGFuZGxlcl0uYXBwbHkobnVsbCwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJvdXRlLmhhbmRsZXIuYXBwbHkobnVsbCwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIXJlc3VsdDtcbiAgICB9LmJpbmQodGhpcykpO1xuICAgIGlmICh1bmtub3duICYmIHRoaXMudmFsaWRhdGUpIHRocm93IG5ldyBFcnJvcignVW5rbm93biByb3V0ZScpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gX2NoZWNrUm91dGUocm91dGUsIHN0YXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IHN0YXRlLm1hdGNoKHJvdXRlLnJlZ0V4cCk7XG4gICAgaWYgKCFyZXN1bHQpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIG5vIHN1cHBvcnQgZm9yIG5lc3RlZCBjYXB0dXJpbmcgZ3JvdXBzXG4gICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDEpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVSZWdFeHBSb3V0ZShyb3V0ZSkge1xuICAgIC8vIFRPRE8gY291bGQgYmUgZXh0ZW5kZWQgdG8gc3BsYXRzIGV0Yy5cbiAgICByb3V0ZSA9IHJvdXRlLnJlcGxhY2UoL1xcOlxcdysvLCBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgcGFyYW0gPSBwYXJhbS5zdWJzdHJpbmcoMSk7XG4gICAgICAgIHJldHVybiAnKCcgKyBwYXJhbSArICcpJztcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cCgnXicgKyByb3V0ZSArICckJyk7XG59XG5cbmZ1bmN0aW9uIF9vblN0YXRlQ2hhbmdlKCkge1xuICAgIC8qIGpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cbiAgICB0aGlzLmludm9rZSgpO1xufVxuXG5mdW5jdGlvbiBfYWRkSW5pdGlhbFJvdXRlcyhyb3V0ZXMsIHNjb3BlKSB7XG4gICAgLyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xuICAgIHNjb3BlID0gc2NvcGUgfHwgJyc7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocm91dGVzKSkge1xuICAgICAgICAvLyBjb21wb3NpbmcgbmVzdGVkIHNldHMgb2YgcmVndWxhciBleHByZXNzaW9ucyBvZiByZWd1bGFyIGV4cHJlc3Npb25zXG4gICAgICAgIC8vIGluY2x1ZGluZyBsb29rYXJvdW5kcyBtaWdodCBsZWFkIHRvIHVuZXhwZWN0ZWQgYmVoYXZpb3IuIEZvciBub3csXG4gICAgICAgIC8vIHRob3NlIGNhbid0IGJlIHRyYXZlcnNlZC5cbiAgICAgICAgcm91dGVzLmZvckVhY2goZnVuY3Rpb24ocm91dGVTcGVjKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFJvdXRlKHJvdXRlU3BlYy5yb3V0ZSwgcm91dGVTcGVjLmhhbmRsZXIpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIHJvdXRlIGluIHJvdXRlcykge1xuICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSByb3V0ZXNbcm91dGVdO1xuICAgICAgICAgICAgaWYgKGhhbmRsZXIgaW5zdGFuY2VvZiBGdW5jdGlvbiB8fCB0eXBlb2YgaGFuZGxlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFJvdXRlKHNjb3BlICsgcm91dGUsIHJvdXRlc1tyb3V0ZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX2FkZEluaXRpYWxSb3V0ZXMuY2FsbCh0aGlzLCByb3V0ZXNbcm91dGVdLCBzY29wZSArIHJvdXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSb3V0ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIEhpc3Rvcnk6IHJlcXVpcmUoJy4vSGlzdG9yeScpLFxuICAgIFJvdXRlcjogcmVxdWlyZSgnLi9Sb3V0ZXInKVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzcywgY3VzdG9tRG9jdW1lbnQpIHtcbiAgdmFyIGRvYyA9IGN1c3RvbURvY3VtZW50IHx8IGRvY3VtZW50O1xuICBpZiAoZG9jLmNyZWF0ZVN0eWxlU2hlZXQpIHtcbiAgICB2YXIgc2hlZXQgPSBkb2MuY3JlYXRlU3R5bGVTaGVldCgpXG4gICAgc2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgICByZXR1cm4gc2hlZXQub3duZXJOb2RlO1xuICB9IGVsc2Uge1xuICAgIHZhciBoZWFkID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0sXG4gICAgICAgIHN0eWxlID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG5cbiAgICBzdHlsZS50eXBlID0gJ3RleHQvY3NzJztcblxuICAgIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvYy5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgICB9XG5cbiAgICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICByZXR1cm4gc3R5bGU7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmJ5VXJsID0gZnVuY3Rpb24odXJsKSB7XG4gIGlmIChkb2N1bWVudC5jcmVhdGVTdHlsZVNoZWV0KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVN0eWxlU2hlZXQodXJsKS5vd25lck5vZGU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLFxuICAgICAgICBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpO1xuXG4gICAgbGluay5yZWwgPSAnc3R5bGVzaGVldCc7XG4gICAgbGluay5ocmVmID0gdXJsO1xuXG4gICAgaGVhZC5hcHBlbmRDaGlsZChsaW5rKTtcbiAgICByZXR1cm4gbGluaztcbiAgfVxufTtcbiIsInZhciBjc3MgPSBcImh0bWwge1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICBtYXJnaW46IDBweDtcXG4gICAgcGFkZGluZzogMHB4O1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybS1zdHlsZTogcHJlc2VydmUtM2Q7XFxuICAgIHRyYW5zZm9ybS1zdHlsZTogcHJlc2VydmUtM2Q7XFxufVxcblxcbmJvZHkge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIG1hcmdpbjogMHB4O1xcbiAgICBwYWRkaW5nOiAwcHg7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtLXN0eWxlOiBwcmVzZXJ2ZS0zZDtcXG4gICAgdHJhbnNmb3JtLXN0eWxlOiBwcmVzZXJ2ZS0zZDtcXG4gICAgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7XFxuICAgIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgIC13ZWJraXQtcGVyc3BlY3RpdmU6IDA7XFxuICAgIHBlcnNwZWN0aXZlOiBub25lO1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbn1cXG5cXG4uZmFtb3VzLWNvbnRhaW5lciwgLmZhbW91cy1ncm91cCB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgdG9wOiAwcHg7XFxuICAgIGxlZnQ6IDBweDtcXG4gICAgYm90dG9tOiAwcHg7XFxuICAgIHJpZ2h0OiAwcHg7XFxuICAgIG92ZXJmbG93OiB2aXNpYmxlO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybS1zdHlsZTogcHJlc2VydmUtM2Q7XFxuICAgIHRyYW5zZm9ybS1zdHlsZTogcHJlc2VydmUtM2Q7XFxuICAgIC13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTogdmlzaWJsZTtcXG4gICAgYmFja2ZhY2UtdmlzaWJpbGl0eTogdmlzaWJsZTtcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxufVxcblxcbi5mYW1vdXMtZ3JvdXAge1xcbiAgICB3aWR0aDogMHB4O1xcbiAgICBoZWlnaHQ6IDBweDtcXG4gICAgbWFyZ2luOiAwcHg7XFxuICAgIHBhZGRpbmc6IDBweDtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm0tc3R5bGU6IHByZXNlcnZlLTNkO1xcbiAgICB0cmFuc2Zvcm0tc3R5bGU6IHByZXNlcnZlLTNkO1xcbn1cXG5cXG4uZmEtc3VyZmFjZSB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiAwJSAwJTtcXG4gICAgdHJhbnNmb3JtLW9yaWdpbjogMCUgMCU7XFxuICAgIC13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTogdmlzaWJsZTtcXG4gICAgYmFja2ZhY2UtdmlzaWJpbGl0eTogdmlzaWJsZTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm0tc3R5bGU6IHByZXNlcnZlLTNkO1xcbiAgICB0cmFuc2Zvcm0tc3R5bGU6IHByZXNlcnZlLTNkOyAvKiBwZXJmb3JtYW5jZSAqL1xcbiAgICAtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICBwb2ludGVyLWV2ZW50czogYXV0bztcXG4gICAgei1pbmRleDogMTsgLyogSEFDSyB0byBhY2NvdW50IGZvciBicm93c2VyIGlzc3VlcyB3aXRoIGV2ZW50aW5nIG9uIHRoZSBzYW1lIHotcGxhbmUqL1xcbn1cXG5cXG4uZmEtY29udGVudCB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuXFxuLmZhbW91cy1jb250YWluZXItZ3JvdXAge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxufVxcblxcbi5mYS1jb250YWluZXIge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogY2VudGVyIGNlbnRlcjtcXG4gICAgdHJhbnNmb3JtLW9yaWdpbjogY2VudGVyIGNlbnRlcjtcXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG59XFxuXFxuY2FudmFzLmZhbW91cy13ZWJnbCB7XFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHotaW5kZXg6IDE7XFxuICAgIHRvcDogMHB4O1xcbiAgICBsZWZ0OiAwcHg7XFxufVwiOyAocmVxdWlyZShcIi9Vc2Vycy9tb3JnYW50aGVwbGFudC9Db2RlL3JlZmFjdG9yL3ZlY3RyL25vZGVfbW9kdWxlcy9mYW1vdXMvbm9kZV9tb2R1bGVzL2ZhbW91cy1zdHlsZXNoZWV0cy9ub2RlX21vZHVsZXMvY3NzaWZ5XCIpKShjc3MpOyBtb2R1bGUuZXhwb3J0cyA9IGNzczsiLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4vZmFtb3VzLmNzcycpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVGV4dHVyZVJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9UZXh0dXJlUmVnaXN0cnknKTtcblxuLyoqIFxuICogQSBsaXN0IG9mIGdsc2wgZXhwcmVzc2lvbnMgd2hpY2ggY2FuIGludGVyZmFjZSB3aXRoIGphdmFzY3JpcHQgZGF0YSBhbmRcbiAqIGNvbm5lY3RlZCB0byBlYWNoIG90aGVyIHRvIGJ1aWxkIGN1c3RvbSBzaGFkZXJzLiBcbiAqXG4gKi9cbnZhciBleHByZXNzaW9ucyA9IHt9O1xuXG52YXIgc25pcHBldHMgPSB7XG5cbiAgICAvKiBBYnMgLSBUaGUgYWJzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHgsIGkuZS4geCB3aGVuIHggaXMgcG9zaXRpdmUgb3IgemVybyBhbmQgLXggZm9yIG5lZ2F0aXZlIHguIFRoZSBpbnB1dCBwYXJhbWV0ZXIgY2FuIGJlIGEgZmxvYXRpbmcgc2NhbGFyIG9yIGEgZmxvYXQgdmVjdG9yLiBJbiBjYXNlIG9mIGEgZmxvYXQgdmVjdG9yIHRoZSBvcGVyYXRpb24gaXMgZG9uZSBjb21wb25lbnQtd2lzZS5cbiAgICAgKi8gXG5cbiAgICBhYnM6IHtnbHNsOiAnYWJzKCUxKTsnfSxcbiAgICAvKiBTaWduIC0gVGhlIHNpZ24gZnVuY3Rpb24gcmV0dXJucyAxLjAgd2hlbiB4IGlzIHBvc2l0aXZlLCAwLjAgd2hlbiB4IGlzIHplcm8gYW5kIC0xLjAgd2hlbiB4IGlzIG5lZ2F0aXZlLiBUaGUgaW5wdXQgcGFyYW1ldGVyIGNhbiBiZSBhIGZsb2F0aW5nIHNjYWxhciBvciBhIGZsb2F0IHZlY3Rvci4gSW4gY2FzZSBvZiBhIGZsb2F0IHZlY3RvciB0aGUgb3BlcmF0aW9uIGlzIGRvbmUgY29tcG9uZW50LXdpc2UuICovXG5cblxuICAgIHNpZ246IHtnbHNsOiAnc2lnbiglMSk7J30sXG5cbiAgICAvKiBGbG9vciAtIFRoZSBmbG9vciBmdW5jdGlvbiByZXR1cm5zIHRoZSBsYXJnZXN0IGludGVnZXIgbnVtYmVyIHRoYXQgaXMgc21hbGxlciBvciBlcXVhbCB0byB4LiBUaGUgaW5wdXQgcGFyYW1ldGVyIGNhbiBiZSBhIGZsb2F0aW5nIHNjYWxhciBvciBhIGZsb2F0IHZlY3Rvci4gSW4gY2FzZSBvZiBhIGZsb2F0IHZlY3RvciB0aGUgb3BlcmF0aW9uIGlzIGRvbmUgY29tcG9uZW50LXdpc2UuICovXG5cbiAgICBmbG9vcjoge2dsc2w6ICdmbG9vciglMSk7J30sXG5cbiAgICAvKiBDZWlsaW5nIC0gVGhlIGNlaWxpbmcgZnVuY3Rpb24gcmV0dXJucyB0aGUgc21hbGxlc3QgbnVtYmVyIHRoYXQgaXMgbGFyZ2VyIG9yIGVxdWFsIHRvIHguIFRoZSBpbnB1dCBwYXJhbWV0ZXIgY2FuIGJlIGEgZmxvYXRpbmcgc2NhbGFyIG9yIGEgZmxvYXQgdmVjdG9yLiBJbiBjYXNlIG9mIGEgZmxvYXQgdmVjdG9yIHRoZSBvcGVyYXRpb24gaXMgZG9uZSBjb21wb25lbnQtd2lzZS4gKi9cblxuICAgIGNlaWxpbmc6IHtnbHNsOiAnY2VpbCglMSk7J30sXG5cbiAgICAvKiBUaGUgbW9kIGV4cHJlc3Npb24gcmV0dXJucyB0aGUgcmVtYWluZWQgb2YgdGhlIGRpdmlzaW9uIG9wZXJhdGlvbiBvZiB0aGUgdHdvIGlucHV0cy4gKi9cbiAgICBtb2Q6IHtnbHNsOiAnbW9kKCUxLCAlMik7J30sXG5cbiAgICAvKiBNaW4gLSBUaGUgbWluIGZ1bmN0aW9uIHJldHVybnMgdGhlIHNtYWxsZXIgb2YgdGhlIHR3byBhcmd1bWVudHMuIFRoZSBpbnB1dCBwYXJhbWV0ZXJzIGNhbiBiZSBmbG9hdGluZyBzY2FsYXJzIG9yIGZsb2F0IHZlY3RvcnMuIEluIGNhc2Ugb2YgZmxvYXQgdmVjdG9ycyB0aGUgb3BlcmF0aW9uIGlzIGRvbmUgY29tcG9uZW50LXdpc2UuICovXG5cbiAgICBtaW46IHtnbHNsOiAnbWluKCUxLCAlMik7J30sXG5cbiAgICAvKiBNYXggLSBUaGUgbWF4IGZ1bmN0aW9uIHJldHVybnMgdGhlIGxhcmdlciBvZiB0aGUgdHdvIGFyZ3VtZW50cy4gVGhlIGlucHV0IHBhcmFtZXRlcnMgY2FuIGJlIGZsb2F0aW5nIHNjYWxhcnMgb3IgZmxvYXQgdmVjdG9ycy4gSW4gY2FzZSBvZiBmbG9hdCB2ZWN0b3JzIHRoZSBvcGVyYXRpb24gaXMgZG9uZSBjb21wb25lbnQtd2lzZS4gKi8gXG5cbiAgICBtYXg6IHtnbHNsOiAnbWF4KCUxLCAlMik7J30sXG4gICAgLyogQ2xhbXAgLSBUaGUgY2xhbXAgZnVuY3Rpb24gcmV0dXJucyB4IGlmIGl0IGlzIGxhcmdlciB0aGFuIG1pblZhbCBhbmQgc21hbGxlciB0aGFuIG1heFZhbC4gSW4gY2FzZSB4IGlzIHNtYWxsZXIgdGhhbiBtaW5WYWwsIG1pblZhbCBpcyByZXR1cm5lZC4gSWYgeCBpcyBsYXJnZXIgdGhhbiBtYXhWYWwsIG1heFZhbCBpcyByZXR1cm5lZC4gVGhlIGlucHV0IHBhcmFtZXRlcnMgY2FuIGJlIGZsb2F0aW5nIHNjYWxhcnMgb3IgZmxvYXQgdmVjdG9ycy4gSW4gY2FzZSBvZiBmbG9hdCB2ZWN0b3JzIHRoZSBvcGVyYXRpb24gaXMgZG9uZSBjb21wb25lbnQtd2lzZS4gKi9cblxuICAgIGNsYW1wOiB7Z2xzbDogJ2NsYW1wKCUxLCAlMiwgJTMpOyd9LFxuXG4gICAgLyogTWl4IC0gVGhlIG1peCBmdW5jdGlvbiByZXR1cm5zIHRoZSBsaW5lYXIgYmxlbmQgb2YgeCBhbmQgeSwgaS5lLiB0aGUgcHJvZHVjdCBvZiB4IGFuZCAoMSAtIGEpIHBsdXMgdGhlIHByb2R1Y3Qgb2YgeSBhbmQgYS4gVGhlIGlucHV0IHBhcmFtZXRlcnMgY2FuIGJlIGZsb2F0aW5nIHNjYWxhcnMgb3IgZmxvYXQgdmVjdG9ycy4gSW4gY2FzZSBvZiBmbG9hdCB2ZWN0b3JzIHRoZSBvcGVyYXRpb24gaXMgZG9uZSBjb21wb25lbnQtd2lzZS4gKi9cblxuICAgIG1peDoge2dsc2w6ICdtaXgoJTEsICUyLCAlMyk7J30sXG5cbiAgICAvKiBTdGVwIC0gVGhlIHN0ZXAgZnVuY3Rpb24gcmV0dXJucyAwLjAgaWYgeCBpcyBzbWFsbGVyIHRoZW4gZWRnZSBhbmQgb3RoZXJ3aXNlIDEuMC4gVGhlIGlucHV0IHBhcmFtZXRlcnMgY2FuIGJlIGZsb2F0aW5nIHNjYWxhcnMgb3IgZmxvYXQgdmVjdG9ycy4gSW4gY2FzZSBvZiBmbG9hdCB2ZWN0b3JzIHRoZSBvcGVyYXRpb24gaXMgZG9uZSBjb21wb25lbnQtd2lzZS4gKi9cblxuICAgIHN0ZXA6IHtnbHNsOiAnc3RlcCglMSwgJTIsICUzKTsnfSxcbiAgICBcbiAgICAvKiBTbW9vdGhzdGVwIC0gVGhlIHNtb290aHN0ZXAgZnVuY3Rpb24gcmV0dXJucyAwLjAgaWYgeCBpcyBzbWFsbGVyIHRoZW4gZWRnZTAgYW5kIDEuMCBpZiB4IGlzIGxhcmdlciB0aGFuIGVkZ2UxLiBPdGhlcndpc2UgdGhlIHJldHVybiB2YWx1ZSBpcyBpbnRlcnBvbGF0ZWQgYmV0d2VlbiAwLjAgYW5kIDEuMCB1c2luZyBIZXJtaXRlIHBvbHlub21pcmFscy4gVGhlIGlucHV0IHBhcmFtZXRlcnMgY2FuIGJlIGZsb2F0aW5nIHNjYWxhcnMgb3IgZmxvYXQgdmVjdG9ycy4gSW4gY2FzZSBvZiBmbG9hdCB2ZWN0b3JzIHRoZSBvcGVyYXRpb24gaXMgZG9uZSBjb21wb25lbnQtd2lzZS4gKi8gXG5cbiAgICBzbW9vdGhzdGVwOiB7Z2xzbDogJ3Ntb290aHN0ZXAoJTEpOyd9LFxuXG5cbiAgICAvKiBmcmFnQ29vcmQgLSBUaGUgZnJhZ0Nvb3JkIGZ1bmN0aW9uIHJldHVybnMgdGhlIGZyYWdtZW50J3MgcG9zaXRpb24gaW4gc2NyZWVuc3BhY2UuICovXG5cbiAgICBmcmFnQ29vcmQ6IHtnbHNsOiAnZ2xfRnJhZ0NvbG9yLnh5Oyd9LFxuXG4gICAgLyogU2luIC0gVGhlIHNpbiBmdW5jdGlvbiByZXR1cm5zIHRoZSBzaW5lIG9mIGFuIGFuZ2xlIGluIHJhZGlhbnMuIFRoZSBpbnB1dCBwYXJhbWV0ZXIgY2FuIGJlIGEgZmxvYXRpbmcgc2NhbGFyIG9yIGEgZmxvYXQgdmVjdG9yLiBJbiBjYXNlIG9mIGEgZmxvYXQgdmVjdG9yIHRoZSBzaW5lIGlzIGNhbGN1bGF0ZWQgc2VwYXJhdGVseSBmb3IgZXZlcnkgY29tcG9uZW50LiAqL1xuXG5cbiAgICBzaW46IHtnbHNsOiAnc2luKCUxKTsnfSxcblxuICAgIC8qIENvcyAtIFRoZSBjb3MgZnVuY3Rpb24gcmV0dXJucyB0aGUgY29zaW5lIG9mIGFuIGFuZ2xlIGluIHJhZGlhbnMuIFRoZSBpbnB1dCBwYXJhbWV0ZXIgY2FuIGJlIGEgZmxvYXRpbmcgc2NhbGFyIG9yIGEgZmxvYXQgdmVjdG9yLiAqL1xuXG4gICAgY29zOiB7Z2xzbDogJ2NvcyglMSk7J30sXG5cbiAgICAvKiBQb3cgLSBUaGUgcG93ZXIgZnVuY3Rpb24gcmV0dXJucyB4IHJhaXNlZCB0byB0aGUgcG93ZXIgb2YgeS4gVGhlIGlucHV0IHBhcmFtZXRlcnMgY2FuIGJlIGZsb2F0aW5nIHNjYWxhcnMgb3IgZmxvYXQgdmVjdG9ycy4gSW4gY2FzZSBvZiBmbG9hdCB2ZWN0b3JzIHRoZSBvcGVyYXRpb24gaXMgZG9uZSBjb21wb25lbnQtd2lzZS4gKi8gXG5cbiAgICBwb3c6IHtnbHNsOiAncG93KCUxLCAlMik7J30sXG5cbiAgICAvKiBTcXJ0IC0gVGhlIHNxcnQgZnVuY3Rpb24gcmV0dXJucyB0aGUgc3F1YXJlIHJvb3Qgb2YgeC4gVGhlIGlucHV0IHBhcmFtZXRlciBjYW4gYmUgYSBmbG9hdGluZyBzY2FsYXIgb3IgYSBmbG9hdCB2ZWN0b3IuIEluIGNhc2Ugb2YgYSBmbG9hdCB2ZWN0b3IgdGhlIG9wZXJhdGlvbiBpcyBkb25lIGNvbXBvbmVudC13aXNlLiAqLyBcblxuICAgIC8qIGZyYWdDb29yZCAtIFRoZSB0aW1lIGZ1bmN0aW9uIHJldHVybnMgdGhlIGVsYXBzZWQgdGltZSBpbiB0aGUgdW5peCBlcG9jaCBpbiBtaWxsaXNlY29uZHMuKi9cblxuICAgIHRpbWU6IHtnbHNsOiAndGltZTsnfSxcblxuICAgIC8qIFRoZSBBZGQgZnVuY3Rpb24gdGFrZXMgdHdvIGlucHV0cywgYWRkcyB0aGVtIHRvZ2V0aGVyIGFuZCBvdXRwdXRzIHRoZSByZXN1bHQuIFRoaXMgYWRkaXRpb24gb3BlcmF0aW9uIGlzIHBlcmZvcm1lZCBvbiBhIHBlciBjaGFubmVsIGJhc2lzLCBtZWFuaW5nIHRoYXQgdGhlIGlucHV0cycgUiBjaGFubmVscyBnZXQgYWRkZWQsIEcgY2hhbm5lbHMgZ2V0IGFkZGVkLCBCIGNoYW5uZWxzIGdldCBhZGRlZCwgZXRjLiBCb3RoIGlucHV0cyBtdXN0IGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGNoYW5uZWxzIHVubGVzcyBvbmUgb2YgdGhlbSBpcyBhIHNpbmdsZSBDb25zdGFudCB2YWx1ZS4gQ29uc3RhbnRzIGNhbiBiZSBhZGRlZCB0byBhIHZlY3RvciB3aXRoIGFueSBudW1iZXIgb2YgaW5wdXRzLiAqL1xuICAgIGFkZDoge2dsc2w6ICclMSArICUyOyd9LFxuXG4gICAgLyogVGhlIEFkZCBmdW5jdGlvbiB0YWtlcyB0d28gaW5wdXRzLCBhZGRzIHRoZW0gdG9nZXRoZXIgYW5kIG91dHB1dHMgdGhlIHJlc3VsdC4gVGhpcyBhZGRpdGlvbiBvcGVyYXRpb24gaXMgcGVyZm9ybWVkIG9uIGEgcGVyIGNoYW5uZWwgYmFzaXMsIG1lYW5pbmcgdGhhdCB0aGUgaW5wdXRzJyBSIGNoYW5uZWxzIGdldCBhZGRlZCwgRyBjaGFubmVscyBnZXQgYWRkZWQsIEIgY2hhbm5lbHMgZ2V0IGFkZGVkLCBldGMuIEJvdGggaW5wdXRzIG11c3QgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgY2hhbm5lbHMgdW5sZXNzIG9uZSBvZiB0aGVtIGlzIGEgc2luZ2xlIENvbnN0YW50IHZhbHVlLiBDb25zdGFudHMgY2FuIGJlIGFkZGVkIHRvIGEgdmVjdG9yIHdpdGggYW55IG51bWJlciBvZiBpbnB1dHMuICovXG4gICAgbXVsdGlwbHk6IHtnbHNsOiAnJTEgKiAlMjsnfSxcblxuXG4gICAgLyogVGhlIG5vcm1hbCBmdW5jdGlvbiByZXR1cm5zIHRoZSAzLWRpbWVuc2lvbmFsIHN1cmZhY2Ugbm9ybWFsLCB3aGljaCBpcyBhIHZlY3RvciB0aGF0IGlzIHBlcnBlbmRpY3VsYXIgdG8gdGhlIHRhbmdlbnQgcGxhbmUgYXQgdGhhdCBwb2ludC4qL1xuICAgIG5vcm1hbDoge2dsc2w6Jyh2X05vcm1hbCArIDEuMCkgKiAwLjU7J30sXG5cbiAgICAvKiBUaGUgdXYgZnVuY3Rpb24gcmV0dXJucyB0aGUgMi1kaW1lbnNpb25hbCB2ZWN0b3IgdGhhdCBtYXBzIHRoZSBvYmplY3QncyAzLWRpbWVuc2lvbmFsIHZlcnRpY2VzIHRvIGEgMkQgcGxhbmUuICovXG4gICAgdXY6IHtnbHNsOid2ZWMzKHZfVGV4dHVyZUNvb3JkaW5hdGUsIDEpOyd9LFxuXG4gICAgLyogVGhlIG1lc2ggcG9zaXRpb24gZnVuY3Rpb24gcmV0dXJucyB0aGUgdHJhbnNmb3JtZWQgZnJhZ21lbnQncyBwb3NpdGlvbiBpbiB3b3JsZC1zcGFjZS4gICovXG4gICAgbWVzaFBvc2l0aW9uOiB7Z2xzbDonKHZfUG9zaXRpb24gKyAxLjApICogMC41Oyd9LFxuXG5cbiAgICAvKiBUaGUgaW1hZ2UgZnVuY3Rpb24gZmV0Y2hlcyB0aGUgbW9kZWwncyAqL1xuICAgIGltYWdlOiB7Z2xzbDondGV4dHVyZTJEKGltYWdlLCB2X1RleHR1cmVDb29yZGluYXRlKS5yZ2I7J30sXG5cblxuICAgIC8qIFRoZSBjb25zdGFudCBmdW5jdGlvbiByZXR1cm5zIGEgc3RhdGljIHZhbHVlIHdoaWNoIGlzIGRlZmluZWQgYXQgY29tcGlsZS10aW1lIHRoYXQgY2Fubm90IGJlIGNoYW5nZWQgZHluYW1pY2FsbHkuKi9cbiAgICBjb25zdGFudDoge2dsc2w6ICclMTsnfSxcbiAgICBcbiAgICAvKiBUaGUgUGFyYW1ldGVyIGV4cHJlc3Npb24gaGFzIHZhbHVlcyB0aGF0IGNhbiBiZSBtb2RpZmllZCAoZHluYW1pY2FsbHkgZHVyaW5nIHJ1bnRpbWUgaW4gc29tZSBjYXNlcykgaW4gYSBNYXRlcmlhbEluc3RhbmNlIG9mIHRoZSBiYXNlIG1hdGVyaWFsIGNvbnRhaW5pbmcgdGhlIHBhcmFtZXRlci4gVGhlc2UgZXhwcmVzc2lvbnMgc2hvdWxkIGJlIGdpdmVuIHVuaXF1ZSBuYW1lcywgdmlhIHRoZSBQYXJhbWV0ZXIgTmFtZSBwcm9wZXJ0eSwgdG8gYmUgdXNlZCB3aGVuIGlkZW50aWZ5aW5nIHRoZSBzcGVjaWZpYyBwYXJhbWV0ZXIgaW4gdGhlIE1hdGVyaWFsSW5zdGFuY2UuIElmIHR3byBwYXJhbWV0ZXJzIG9mIHRoZSBzYW1lIHR5cGUgaGF2ZSB0aGUgc2FtZSBuYW1lIGluIHRoZSBzYW1lIG1hdGVyaWFsLCB0aGV5IHdpbGwgYmUgYXNzdW1lZCB0byBiZSB0aGUgc2FtZSBwYXJhbWV0ZXIuIENoYW5naW5nIHRoZSB2YWx1ZSBvZiB0aGUgcGFyYW1ldGVyIGluIHRoZSBNYXRlcmlhbEluc3RhbmNlIHdvdWxkIGNoYW5nZSB0aGUgdmFsdWUgb2YgYm90aCB0aGUgcGFyYW1ldGVyIGV4cHJlc3Npb25zIGluIHRoZSBtYXRlcmlhbC4gQSBkZWZhdWx0IHZhbHVlIGZvciB0aGUgcGFyYW1ldGVyIHdpbGwgYWxzbyBiZSBzZXQgaW4gdGhlIGJhc2UgbWF0ZXJpYWwuIFRoaXMgd2lsbCBiZSB0aGUgdmFsdWUgb2YgdGhlIHBhcmFtZXRlciBpbiB0aGUgTWF0ZXJpYWxJbnN0YW5jZSB1bmxlc3MgaXQgaXMgb3ZlcnJpZGRlbiBhbmQgbW9kaWZpZWQgdGhlcmUuICovXG5cbiAgICBwYXJhbWV0ZXI6IHt1bmlmb3Jtczoge3BhcmFtZXRlcjogMX0sIGdsc2w6ICdwYXJhbWV0ZXI7J31cbn07XG5cbmV4cHJlc3Npb25zLnJlZ2lzdGVyRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIHJlZ2lzdGVyRXhwcmVzc2lvbihuYW1lLCBzY2hlbWEpIHtcbiAgICB0aGlzW25hbWVdID0gZnVuY3Rpb24gKGlucHV0cywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IE1hdGVyaWFsKG5hbWUsIHNjaGVtYSwgaW5wdXRzLCBvcHRpb25zKTtcbiAgICB9O1xufTtcblxuZm9yICh2YXIgbmFtZSBpbiBzbmlwcGV0cykge1xuICAgIGV4cHJlc3Npb25zLnJlZ2lzdGVyRXhwcmVzc2lvbihuYW1lLCBzbmlwcGV0c1tuYW1lXSk7XG59XG5cbi8qKlxuICogTWF0ZXJpYWwgaXMgYSBwdWJsaWMgY2xhc3MgdGhhdCBjb21wb3NlcyBhIG1hdGVyaWFsLWdyYXBoIG91dCBvZiBleHByZXNzaW9uc1xuICpcbiAqXG4gKiBAY2xhc3MgTWF0ZXJpYWxcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZpbml0b24gb2YgbmFzY2VudCBleHByZXNzaW9uIHdpdGggc2hhZGVyIGNvZGUsIGlucHV0cyBhbmQgdW5pZm9ybXNcbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3Qgb2YgTWF0ZXJpYWwgZXhwcmVzc2lvbnMsIGltYWdlcywgb3IgY29uc3RhbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgb2YgdW5pZm9ybSBkYXRhIG9mIGZsb2F0LCB2ZWMyLCB2ZWMzLCB2ZWM0XG4gKi9cblxuZnVuY3Rpb24gTWF0ZXJpYWwobmFtZSwgY2h1bmssIGlucHV0cywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmNodW5rID0gY2h1bms7XG4gICAgdGhpcy5pbnB1dHMgPSBpbnB1dHMgPyAoQXJyYXkuaXNBcnJheShpbnB1dHMpID8gaW5wdXRzIDogW2lucHV0c10pOiBbXTtcbiAgICB0aGlzLnVuaWZvcm1zID0gb3B0aW9ucy51bmlmb3JtcyB8fCB7fTtcbiAgICB0aGlzLnZhcnlpbmdzID0gb3B0aW9ucy52YXJ5aW5ncztcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBvcHRpb25zLmF0dHJpYnV0ZXM7XG4gICAgaWYgKG9wdGlvbnMudGV4dHVyZSkge1xuICAgICAgICB0aGlzLnRleHR1cmUgPSBvcHRpb25zLnRleHR1cmUuX19pc0FUZXh0dXJlX18gPyBvcHRpb25zLnRleHR1cmUgOiBUZXh0dXJlUmVnaXN0cnkucmVnaXN0ZXIobnVsbCwgb3B0aW9ucy50ZXh0dXJlKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pZCA9IE1hdGVyaWFsLmlkKys7XG5cbiAgICB0aGlzLmludmFsaWRhdGlvbnMgPSBbXTtcbn1cblxuTWF0ZXJpYWwuaWQgPSAxO1xuXG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgbWF0ZXJpYWwgZ3JhcGhcbiAqXG4gKiBAbWV0aG9kIHRyYXZlcnNlXG4gKiBAY2hhaW5hYmxlXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaW52b2tlZCB1cG9uIGV2ZXJ5IGV4cHJlc3Npb24gaW4gdGhlIGdyYXBoXG4gKi9cblxuTWF0ZXJpYWwucHJvdG90eXBlLnRyYXZlcnNlID0gZnVuY3Rpb24gdHJhdmVyc2UoY2FsbGJhY2spIHtcbiAgICB2YXIgbGVuID0gdGhpcy5pbnB1dHMgJiYgdGhpcy5pbnB1dHMubGVuZ3RoLCBpZHggPSAtMTtcblxuICAgIHdoaWxlICgrK2lkeCA8IGxlbikgdHJhdmVyc2UuY2FsbCh0aGlzLmlucHV0c1tpZHhdLCBjYWxsYmFjaywgaWR4KTtcblxuICAgIGNhbGxiYWNrKHRoaXMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5NYXRlcmlhbC5wcm90b3R5cGUuc2V0VW5pZm9ybSA9IGZ1bmN0aW9uIHNldFVuaWZvcm0obmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLnVuaWZvcm1zW25hbWVdID0gdmFsdWU7XG5cbiAgICB0aGlzLmludmFsaWRhdGlvbnMucHVzaChuYW1lKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgbWF0ZXJpYWwgZ3JhcGggaW50byBjaHVua1xuICpcbiAqIEBtZXRob2QgX2NvbXBpbGVcbiAqIEBwcm90ZWN0ZWRcbiAqXG4gKi9cblxuTWF0ZXJpYWwucHJvdG90eXBlLl9jb21waWxlID0gZnVuY3Rpb24gX2NvbXBpbGUoKSB7XG4gICAgdmFyIGdsc2wgPSAnJztcbiAgICB2YXIgdW5pZm9ybXMgPSB7fTtcbiAgICB2YXIgdmFyeWluZ3MgPSB7fTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IHt9O1xuICAgIHZhciBkZWZpbmVzID0gW107XG4gICAgdmFyIHRleHR1cmU7XG5cbiAgICB0aGlzLnRyYXZlcnNlKGZ1bmN0aW9uIChub2RlLCBkZXB0aCkge1xuICAgICAgICBpZiAoISBub2RlLmNodW5rKSByZXR1cm47XG4gICAgICAgIGdsc2wgKz0gJ3ZlYzMgJyArIG1ha2VMYWJlbChub2RlKSArICc9JyArIHByb2Nlc3NHTFNMKG5vZGUuY2h1bmsuZ2xzbCwgbm9kZS5pbnB1dHMpICsgJ1xcbiAnO1xuICAgICAgICBpZiAobm9kZS51bmlmb3JtcykgZXh0ZW5kKHVuaWZvcm1zLCBub2RlLnVuaWZvcm1zKTtcbiAgICAgICAgaWYgKG5vZGUudmFyeWluZ3MpIGV4dGVuZCh2YXJ5aW5ncywgbm9kZS52YXJ5aW5ncyk7XG4gICAgICAgIGlmIChub2RlLmF0dHJpYnV0ZXMpIGV4dGVuZChhdHRyaWJ1dGVzLCBub2RlLmF0dHJpYnV0ZXMpO1xuICAgICAgICBpZiAobm9kZS5jaHVuay5kZWZpbmVzKSBkZWZpbmVzLnB1c2gobm9kZS5jaHVuay5kZWZpbmVzKTtcbiAgICAgICAgaWYgKG5vZGUudGV4dHVyZSkgdGV4dHVyZSA9IG5vZGUudGV4dHVyZTtcbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIF9pZDogdGhpcy5faWQsXG4gICAgICAgIGdsc2w6IGdsc2wgKyAncmV0dXJuICcgKyBtYWtlTGFiZWwodGhpcykgKyAnOycsXG4gICAgICAgIGRlZmluZXM6IGRlZmluZXMuam9pbignXFxuJyksXG4gICAgICAgIHVuaWZvcm1zOiB1bmlmb3JtcyxcbiAgICAgICAgdmFyeWluZ3M6IHZhcnlpbmdzLFxuICAgICAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzLFxuICAgICAgICB0ZXh0dXJlOiB0ZXh0dXJlXG4gICAgfTtcbn07XG5cbmZ1bmN0aW9uIGV4dGVuZCAoYSwgYikgeyBmb3IgKHZhciBrIGluIGIpIGFba10gPSBiW2tdOyB9XG5cbmZ1bmN0aW9uIHByb2Nlc3NHTFNMKHN0ciwgaW5wdXRzKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8lXFxkL2csIGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHJldHVybiBtYWtlTGFiZWwoaW5wdXRzW3NbMV0tMV0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gbWFrZUxhYmVsIChuKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobikpIHJldHVybiBhcnJheVRvVmVjKG4pO1xuICAgIGlmICh0eXBlb2YgbiA9PSAnb2JqZWN0JykgcmV0dXJuICdmYV8nICsgKG4uX2lkKTtcbiAgICBlbHNlIHJldHVybiBKU09OLnN0cmluZ2lmeShuKTtcbn1cblxuZnVuY3Rpb24gYXJyYXlUb1ZlYyhhcnJheSkge1xuICAgIHZhciBsZW4gPSBhcnJheS5sZW5ndGg7XG4gICAgcmV0dXJuICd2ZWMnICsgbGVuICsgJygnICsgYXJyYXkuam9pbignLCcpICArICcpJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHByZXNzaW9ucztcbmV4cHJlc3Npb25zLk1hdGVyaWFsID0gTWF0ZXJpYWw7XG5leHByZXNzaW9ucy5UZXh0dXJlID0gZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIGNvbnNvbGUuZXJyb3IoJ1RleHR1cmUgY29uc3RydWN0b3IgY2Fubm90IGJlIHJ1biBpbnNpZGUgb2YgYSB3b3JrZXInKTtcbiAgICByZXR1cm4gZXhwcmVzc2lvbnMuaW1hZ2UoW10sIHsgdGV4dHVyZTogc291cmNlIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLypcbiAqIEEgc2luZ2xldG9uIG9iamVjdCB0aGF0IGhvbGRzIHRleHR1cmUgaW5zdGFuY2VzIGluIGEgcmVnaXN0cnkgd2hpY2hcbiAqIGNhbiBiZSBhY2Nlc3NlZCBieSBrZXkuICBBbGxvd3MgZm9yIHRleHR1cmUgc2hhcmluZyBhbmQgZWFzeSByZWZlcmVuY2luZy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAY2xhc3MgVGV4dHVyZVJlZ2lzdHJ5XG4gKi9cbnZhciBUZXh0dXJlUmVnaXN0cnkgPSB7XG5cdHJlZ2lzdHJ5OiB7fSxcblx0dGV4dHVyZUlkczogMVxufTtcblxuLypcbiAqIFJlZ2lzdGVycyBhIG5ldyBUZXh0dXJlIG9iamVjdCB3aXRoIGEgdW5pcXVlIGlkIGFuZCBpbnB1dCBwYXJhbWV0ZXJzIHRvIGJlXG4gKiBoYW5kbGVkIGJ5IHRoZSBXZWJHTFJlbmRlcmVyLiAgSWYgbm8gYWNjZXNzb3IgaXMgaW5wdXQgdGhlIHRleHR1cmUgd2lsbCBiZSBcbiAqIGNyZWF0ZWQgYnV0IG5vdCBzdG9yZSBpbiB0aGUgcmVnaXN0cnkuXG4gKlxuICogQG1ldGhvZCByZWdpc3RlclxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhY2Nlc3NvciBLZXkgdXNlZCB0byBsYXRlciBhY2Nlc3MgdGhlIHRleHR1cmUgb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3QgfCBBcnJheSB8IFN0cmluZ30gZGF0YSBEYXRhIHRvIGJlIHVzZWQgaW4gdGhlIFdlYkdMUmVuZGVyZXIgdG9cbiAqIGdlbmVyYXRlIHRleHR1cmUgZGF0YS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbmFsIHBhcmFtZXRlcnMgdG8gYWZmZWN0IHRoZSByZW5kZXJpbmcgb2YgdGhlXG4gKiBXZWJHTCB0ZXh0dXJlLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gTmV3bHkgZ2VuZXJhdGVkIHRleHR1cmUgb2JqZWN0LlxuICovXG5UZXh0dXJlUmVnaXN0cnkucmVnaXN0ZXIgPSBmdW5jdGlvbiByZWdpc3RlcihhY2Nlc3NvciwgZGF0YSwgb3B0aW9ucykge1xuXHRpZiAoYWNjZXNzb3IpIHJldHVybiAodGhpcy5yZWdpc3RyeVthY2Nlc3Nvcl0gPSB7IGlkOiB0aGlzLnRleHR1cmVJZHMrKywgX19pc0FUZXh0dXJlX186IHRydWUsIGRhdGE6IGRhdGEsIG9wdGlvbnM6IG9wdGlvbnMgfSk7XG5cdGVsc2UgcmV0dXJuIHsgaWQ6IHRoaXMudGV4dHVyZUlkcysrLCBkYXRhOiBkYXRhLCBfX2lzQVRleHR1cmVfXzogdHJ1ZSwgb3B0aW9uczogb3B0aW9ucyB9O1xufTtcblxuLypcbiAqIFJldHJlaXZlcyB0aGUgdGV4dHVyZSBvYmplY3QgZnJvbSByZWdpc3RyeS4gIFRocm93cyBpZiBubyB0ZXh0dXJlIGlzXG4gKiBmb3VuZCBhdCBnaXZlbiBrZXkuXG4gKlxuICogQG1ldGhvZCBnZXRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWNjZXNzb3IgS2V5IG9mIGEgZGVzaXJlZCB0ZXh0dXJlIGluIHRoZSByZWdpc3RyeS5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IERlc2lyZWQgdGV4dHVyZSBvYmplY3QuXG4gKi9cblRleHR1cmVSZWdpc3RyeS5nZXQgPSBmdW5jdGlvbiBnZXQoYWNjZXNzb3IpIHtcblx0aWYgKCF0aGlzLnJlZ2lzdHJ5W2FjY2Vzc29yXSkge1xuXHRcdHRocm93ICdUZXh0dXJlIFwiJyArIGFjY2Vzc29yICsgJ1wiIG5vdCBmb3VuZCEnO1xuXHR9XG5cdGVsc2Uge1xuXHRcdHJldHVybiB0aGlzLnJlZ2lzdHJ5W2FjY2Vzc29yXTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRleHR1cmVSZWdpc3RyeTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgTWF0ZXJpYWw6IHJlcXVpcmUoJy4vTWF0ZXJpYWwnKSxcbiAgICBUZXh0dXJlUmVnaXN0cnk6IHJlcXVpcmUoJy4vVGV4dHVyZVJlZ2lzdHJ5Jylcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIEdlb21ldHJ5ID0gcmVxdWlyZSgnZmFtb3VzLXdlYmdsLWdlb21ldHJpZXMnKTtcblxuLyoqXG4gKiBUaGUgTWVzaCBjbGFzcyBpcyByZXNwb25zaWJsZSBmb3IgcHJvdmlkaW5nIHRoZSBBUEkgZm9yIGhvd1xuICogYSBSZW5kZXJOb2RlIHdpbGwgaW50ZXJhY3Qgd2l0aCB0aGUgV2ViR0wgQVBJIGJ5IGFkZGluZ1xuICogYSBzZXQgb2YgY29tbWFuZHMgdG8gdGhlIHJlbmRlcmVyLlxuICpcbiAqIEBjbGFzcyBNZXNoXG4gKiBAY29uc3RydWN0b3JcbiAqIEByZW5kZXJhYmxlXG4gKiBAcGFyYW0ge0xvY2FsRGlzcGF0Y2h9IGRpc3BhdGNoIExvY2FsRGlzcGF0Y2ggdG8gYmUgcmV0cmlldmVkXG4gKiBAcGFyYW0ge29iamVjdH0gT3B0aW9ucyBPcHRpb25hbCBwYXJhbXMgZm9yIGNvbmZpZ3VyaW5nIE1lc2hcbiAqL1xuZnVuY3Rpb24gTWVzaCAobm9kZSwgb3B0aW9ucykge1xuICAgIHRoaXMuX25vZGUgPSBub2RlO1xuICAgIHRoaXMuX2NoYW5nZVF1ZXVlID0gW107XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy5faW5EcmF3ID0gZmFsc2U7XG4gICAgdGhpcy52YWx1ZSA9IHtcbiAgICAgICAgZHJhd09wdGlvbnM6IG51bGwsXG4gICAgICAgIGNvbG9yOiBudWxsLFxuICAgICAgICBleHByZXNzaW9uczoge30sXG4gICAgICAgIGdlb21ldHJ5OiBudWxsLFxuICAgICAgICBmbGF0U2hhZGluZzogbnVsbCxcbiAgICAgICAgZ2xvc3NpbmVzczogbnVsbCxcbiAgICAgICAgcG9zaXRpb25PZmZzZXQ6IG51bGwsXG4gICAgICAgIG5vcm1hbHM6IG51bGxcbiAgICB9O1xuXG4gICAgaWYgKG9wdGlvbnMpIHRoaXMuc2V0RHJhd09wdGlvbnMob3B0aW9ucyk7XG4gICAgdGhpcy5faWQgPSBub2RlLmFkZENvbXBvbmVudCh0aGlzKTtcbn1cblxuLyoqXG4gKiBQYXNzIGN1c3RvbSBvcHRpb25zIHRvIE1lc2gsIHN1Y2ggYXMgYSAzIGVsZW1lbnQgbWFwXG4gKiB3aGljaCBkaXNwbGFjZXMgdGhlIHBvc2l0aW9uIG9mIGVhY2ggdmVydGV4IGluIHdvcmxkIHNwYWNlLlxuICpcbiAqIEBtZXRob2Qgc2V0RHJhd09wdGlvbnNcbiAqIEBjaGFpbmFibGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gT3B0aW9uc1xuICogQGNoYWluYWJsZVxuICovXG5NZXNoLnByb3RvdHlwZS5zZXREcmF3T3B0aW9ucyA9IGZ1bmN0aW9uIHNldE9wdGlvbnMgKG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy52YWx1ZS5kcmF3T3B0aW9ucy5ibGVuZE1vZGUpIHtcbiAgICAgICAgdGhpcy52YWx1ZS5kcmF3T3B0aW9ucy5ibGVuZE1vZGUgPSBvcHRpb25zLmJsZW5kTW9kZTtcbiAgICAgICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaCgnR0xfU0VUX0RSQVdfT1BUSU9OUycpO1xuICAgICAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudmFsZS5kcmF3T3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGJsZW5kTW9kZTogb3B0aW9ucy5ibGVuZE1vZGVcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaCgnR0xfU0VUX0RSQVdfT1BUSU9OUycpO1xuICAgICAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBtZXNoJ3MgY3VzdG9tIG9wdGlvbnMuXG4gKlxuICogQG1ldGhvZCBnZXREcmF3T3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gT3B0aW9uc1xuICovXG5NZXNoLnByb3RvdHlwZS5nZXREcmF3T3B0aW9ucyA9IGZ1bmN0aW9uIGdldERyYXdPcHRpb25zICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZS5kcmF3T3B0aW9ucztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBnZW9tZXRyeSBvZiBhIG1lc2guXG4gKlxuICogQG1ldGhvZCBzZXRHZW9tZXRyeVxuICogQGNoYWluYWJsZVxuICpcbiAqIEBwYXJhbSB7R2VvbWV0cnl9IGdlb21ldHJ5IGluc3RhbmNlIHRvIGJlIGFzc29jaWF0ZWQgd2l0aCB0aGUgbWVzaFxuICogQHBhcmFtIHtPYmplY3R9IE9wdGlvbnMgVmFyaW91cyBjb25maWd1cmF0aW9ucyBmb3IgZ2VvbWV0cmllcy5cbiAqIEBjaGFpbmFibGVcbiAqL1xuTWVzaC5wcm90b3R5cGUuc2V0R2VvbWV0cnkgPSBmdW5jdGlvbiBzZXRHZW9tZXRyeSAoZ2VvbWV0cnksIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIGdlb21ldHJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoIUdlb21ldHJ5W2dlb21ldHJ5XSkgdGhyb3cgJ0ludmFsaWQgZ2VvbWV0cnk6IFwiJyArIGdlb21ldHJ5ICsgJ1wiLic7XG4gICAgICAgIGVsc2UgZ2VvbWV0cnkgPSBuZXcgR2VvbWV0cnlbZ2VvbWV0cnldKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnZhbHVlLmdlb21ldHJ5ICE9PSBnZW9tZXRyeSB8fCB0aGlzLl9pbkRyYXcpIHtcbiAgICAgICAgaWYgKHRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKCdHTF9TRVRfR0VPTUVUUlknKTtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2goZ2VvbWV0cnkuaWQpO1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaChnZW9tZXRyeS5zcGVjLnR5cGUpO1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaChnZW9tZXRyeS5zcGVjLmR5bmFtaWMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlcXVlc3RVcGRhdGUoKTtcbiAgICAgICAgdGhpcy52YWx1ZS5nZW9tZXRyeSA9IGdlb21ldHJ5O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGdlb21ldHJ5IG9mIGEgbWVzaC5cbiAqXG4gKiBAbWV0aG9kIGdldEdlb21ldHJ5XG4gKiBAcmV0dXJucyB7R2VvbWV0cnl9IGdlb21ldHJ5IEdlb21ldHJ5IG9mIG1lc2hcbiAqL1xuTWVzaC5wcm90b3R5cGUuZ2V0R2VvbWV0cnkgPSBmdW5jdGlvbiBnZXRHZW9tZXRyeSAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUuZ2VvbWV0cnk7XG59O1xuXG4vKipcbiogQ2hhbmdlcyB0aGUgY29sb3Igb2YgTWVzaCwgcGFzc2luZyBlaXRoZXIgYSBtYXRlcmlhbCBleHByZXNzaW9uIG9yXG4qIGNvbG9yIHVzaW5nIHRoZSAnQ29sb3InIHV0aWxpdHkgY29tcG9uZW50LlxuKlxuKiBAbWV0aG9kIHNldEJhc2VDb2xvclxuKiBAcGFyYW0ge09iamVjdHxDb2xvcn0gTWF0ZXJpYWwsIGltYWdlLCB2ZWMzLCBvciBDb2xvciBpbnN0YW5jZVxuKiBAY2hhaW5hYmxlXG4qL1xuTWVzaC5wcm90b3R5cGUuc2V0QmFzZUNvbG9yID0gZnVuY3Rpb24gc2V0QmFzZUNvbG9yIChjb2xvcikge1xuICAgIHZhciB1bmlmb3JtVmFsdWU7XG4gICAgaWYgKGNvbG9yLl9jb21waWxlKSB7XG4gICAgICAgIHRoaXMudmFsdWUuZXhwcmVzc2lvbnMuYmFzZUNvbG9yID0gY29sb3I7XG4gICAgICAgIHVuaWZvcm1WYWx1ZSA9IGNvbG9yLl9jb21waWxlKCk7IFxuICAgIH0gZWxzZSBpZiAoY29sb3IuZ2V0Tm9ybWFsaXplZFJHQikge1xuICAgICAgICB0aGlzLnZhbHVlLmV4cHJlc3Npb25zLmJhc2VDb2xvciA9IG51bGw7XG4gICAgICAgIHRoaXMudmFsdWUuY29sb3IgPSBjb2xvcjtcbiAgICAgICAgdW5pZm9ybVZhbHVlID0gY29sb3IuZ2V0Tm9ybWFsaXplZFJHQigpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgICAvLyBJZiBhIG1hdGVyaWFsIGV4cHJlc3Npb25cbiAgICAgICAgaWYgKGNvbG9yLl9jb21waWxlKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKCdNQVRFUklBTF9JTlBVVCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgYSBjb2xvciBjb21wb25lbnRcbiAgICAgICAgZWxzZSBpZiAoY29sb3IuZ2V0Tm9ybWFsaXplZFJHQikge1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaCgnR0xfVU5JRk9STVMnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKCdiYXNlQ29sb3InKTtcbiAgICAgICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaCh1bmlmb3JtVmFsdWUpO1xuICAgIH1cblxuICAgIHRoaXMuX3JlcXVlc3RVcGRhdGUoKTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGVpdGhlciB0aGUgbWF0ZXJpYWwgZXhwcmVzc2lvbiBvciB0aGUgY29sb3IgaW5zdGFuY2Ugb2YgTWVzaC5cbiAqXG4gKiBAbWV0aG9kIGdldEJhc2VDb2xvclxuICogQHJldHVybnMge01hdGVyaWFsRXhwcmVzc3xDb2xvcn1cbiAqL1xuTWVzaC5wcm90b3R5cGUuZ2V0QmFzZUNvbG9yID0gZnVuY3Rpb24gZ2V0QmFzZUNvbG9yICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZS5leHByZXNzaW9ucy5iYXNlQ29sb3IgfHwgdGhpcy52YWx1ZS5jb2xvcjtcbn07XG5cbi8qKlxuICogQ2hhbmdlIHdoZXRoZXIgdGhlIE1lc2ggaXMgYWZmZWN0ZWQgYnkgbGlnaHQuIERlZmF1bHQgaXMgdHJ1ZS5cbiAqXG4gKiBAbWV0aG9kIHNldEZsYXRTaGFkaW5nXG4gKiBAcGFyYW0ge2Jvb2xlYW59IEJvb2xlYW5cbiAqIEBjaGFpbmFibGVcbiAqL1xuTWVzaC5wcm90b3R5cGUuc2V0RmxhdFNoYWRpbmcgPSBmdW5jdGlvbiBzZXRGbGF0U2hhZGluZyAoYm9vbCkge1xuICAgIGlmICh0aGlzLl9pbkRyYXcgfHwgdGhpcy52YWx1ZS5mbGF0U2hhZGluZyAhPT0gYm9vbCkge1xuICAgICAgICB0aGlzLnZhbHVlLmZsYXRTaGFkaW5nID0gYm9vbDtcbiAgICAgICAgaWYgKHRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKCdHTF9VTklGT1JNUycpO1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaCgndV9GbGF0U2hhZGluZycpO1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaChib29sID8gMSA6IDApOyAgICAgICAgXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVxdWVzdFVwZGF0ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgYm9vbGVhbiBmb3Igd2hldGhlciBNZXNoIGlzIGFmZmVjdGVkIGJ5IGxpZ2h0LlxuICpcbiAqIEBtZXRob2QgZ2V0RmxhdFNoYWRpbmdcbiAqIEByZXR1cm5zIHtCb29sZWFufSBCb29sZWFuXG4gKi9cbk1lc2gucHJvdG90eXBlLmdldEZsYXRTaGFkaW5nID0gZnVuY3Rpb24gZ2V0RmxhdFNoYWRpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlLmZsYXRTaGFkaW5nO1xufTtcblxuXG4vKipcbiAqIERlZmluZXMgYSAzLWVsZW1lbnQgbWFwIHdoaWNoIGlzIHVzZWQgdG8gcHJvdmlkZSBzaWduaWZpY2FudCBwaHlzaWNhbFxuICogZGV0YWlsIHRvIHRoZSBzdXJmYWNlIGJ5IHBlcnR1cmJpbmcgdGhlIGZhY2luZyBkaXJlY3Rpb24gb2YgZWFjaCBpbmRpdmlkdWFsXG4gKiBwaXhlbC5cbiAqXG4gKiBAbWV0aG9kIG5vcm1hbFxuICogQGNoYWluYWJsZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBNYXRlcmlhbCwgSW1hZ2Ugb3IgdmVjM1xuICogQHJldHVybiB7RWxlbWVudH0gY3VycmVudCBNZXNoXG4gKi9cbk1lc2gucHJvdG90eXBlLnNldE5vcm1hbHMgPSBmdW5jdGlvbiBzZXROb3JtYWxzIChtYXRlcmlhbEV4cHJlc3Npb24pIHtcbiAgICBpZiAobWF0ZXJpYWxFeHByZXNzaW9uLl9jb21waWxlKSB7XG4gICAgICAgIHRoaXMudmFsdWUuZXhwcmVzc2lvbnMubm9ybWFscyA9IG1hdGVyaWFsRXhwcmVzc2lvbjtcbiAgICAgICAgbWF0ZXJpYWxFeHByZXNzaW9uID0gbWF0ZXJpYWxFeHByZXNzaW9uLl9jb21waWxlKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICAgIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2gobWF0ZXJpYWxFeHByZXNzaW9uLl9jb21waWxlID8gJ01BVEVSSUFMX0lOUFVUJyA6ICdVTklGT1JNX0lOUFVUJyk7XG4gICAgICAgIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2goJ25vcm1hbCcpO1xuICAgICAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKG1hdGVyaWFsRXhwcmVzc2lvbik7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVxdWVzdFVwZGF0ZSgpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIE5vcm1hbHMgZXhwcmVzc2lvbiBvZiBNZXNoXG4gKlxuICogQG1ldGhvZCBnZXROb3JtYWxzXG4gKiBAcmV0dXJucyBUaGUgbm9ybWFscyBleHByZXNzaW9uIGZvciBNZXNoXG4gKi9cbk1lc2gucHJvdG90eXBlLmdldE5vcm1hbHMgPSBmdW5jdGlvbiBnZXROb3JtYWxzIChtYXRlcmlhbEV4cHJlc3Npb24pIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZS5leHByZXNzaW9ucy5ub3JtYWxzO1xufTtcblxuLyoqXG4gKiBEZWZpbmVzIHRoZSBnbG9zc2luZXNzIG9mIHRoZSBtZXNoIGZyb20gZWl0aGVyIGEgbWF0ZXJpYWwgZXhwcmVzc2lvbiBvciBhXG4gKiBzY2FsYXIgdmFsdWVcbiAqXG4gKiBAbWV0aG9kIHNldEdsb3NzaW5lc3NcbiAqIEBwYXJhbSB7TWF0ZXJpYWxFeHByZXNzaW9ufE51bWJlcn1cbiAqIEBwYXJhbSB7T2JqZWN0fSBPcHRpb25hbCB0d2VlbmluZyBwYXJhbWV0ZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IENhbGxiYWNrXG4gKiBAY2hhaW5hYmxlXG4gKi9cbk1lc2gucHJvdG90eXBlLnNldEdsb3NzaW5lc3MgPSBmdW5jdGlvbiBzZXRHbG9zc2luZXNzIChtYXRlcmlhbEV4cHJlc3Npb24pIHtcbiAgICB2YXIgZ2xvc3NpbmVzcztcblxuICAgIGlmIChtYXRlcmlhbEV4cHJlc3Npb24uX2NvbXBpbGUpIHtcbiAgICAgICAgdGhpcy52YWx1ZS5leHByZXNzaW9ucy5nbG9zc2luZXNzID0gbWF0ZXJpYWxFeHByZXNzaW9uO1xuICAgICAgICBnbG9zc2luZXNzID0gbWF0ZXJpYWxFeHByZXNzaW9uLl9jb21waWxlKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnZhbHVlLmV4cHJlc3Npb25zLmdsb3NzaW5lc3MgPSBudWxsO1xuICAgICAgICB0aGlzLnZhbHVlLmdsb3NzaW5lc3MgPSBtYXRlcmlhbEV4cHJlc3Npb247XG4gICAgICAgIGdsb3NzaW5lc3MgPSB0aGlzLnZhbHVlLmdsb3NzaW5lc3M7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICAgIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2gobWF0ZXJpYWxFeHByZXNzaW9uLl9jb21waWxlID8gJ01BVEVSSUFMX0lOUFVUJyA6ICdHTF9VTklGT1JNUycpO1xuICAgICAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKCdnbG9zc2luZXNzJyk7XG4gICAgICAgIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2goZ2xvc3NpbmVzcyk7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVxdWVzdFVwZGF0ZSgpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgbWF0ZXJpYWwgZXhwcmVzc2lvbiBvciBzY2FsYXIgdmFsdWUgZm9yIGdsb3NzaW5lc3MuXG4gKlxuICogQG1ldGhvZCBnZXRHbG9zc2luZXNzXG4gKiBAcmV0dXJucyB7TWF0ZXJpYWxFeHByZXNzfE51bWJlcn1cbiAqL1xuTWVzaC5wcm90b3R5cGUuZ2V0R2xvc3NpbmVzcyA9IGZ1bmN0aW9uIGdldEdsb3NzaW5lc3MgKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlLmV4cHJlc3Npb25zLmdsb3NzaW5lc3MgfHwgdGhpcy52YWx1ZS5nbG9zc2luZXNzO1xufTtcblxuLyoqXG4gKiBEZWZpbmVzIDMgZWxlbWVudCBtYXAgd2hpY2ggZGlzcGxhY2VzIHRoZSBwb3NpdGlvbiBvZiBlYWNoIHZlcnRleCBpbiB3b3JsZFxuICogc3BhY2UuXG4gKlxuICogQG1ldGhvZCBzZXRQb3NpdGlvbk9mZnNldFxuICogQGNoYWluYWJsZVxuICpcbiAqIEBwYXJhbSB7TWF0ZXJpYWxFeHByZXNzaW9ufEFycmF5fVxuICogQHBhcmFtIHtPYmplY3R9IE9wdGlvbmFsIHR3ZWVuaW5nIHBhcmFtZXRlclxuICogQHBhcmFtIHtGdW5jdGlvbn0gQ2FsbGJhY2tcbiAqIEBjaGFpbmFibGVcbiAqL1xuTWVzaC5wcm90b3R5cGUuc2V0UG9zaXRpb25PZmZzZXQgPSBmdW5jdGlvbiBwb3NpdGlvbk9mZnNldCAobWF0ZXJpYWxFeHByZXNzaW9uKSB7XG4gICAgdmFyIHVuaWZvcm1WYWx1ZTtcblxuICAgIGlmIChtYXRlcmlhbEV4cHJlc3Npb24uX2NvbXBpbGUpIHtcbiAgICAgICAgdGhpcy52YWx1ZS5leHByZXNzaW9ucy5wb3NpdGlvbk9mZnNldCA9IG1hdGVyaWFsRXhwcmVzc2lvbjtcbiAgICAgICAgdW5pZm9ybVZhbHVlID0gbWF0ZXJpYWxFeHByZXNzaW9uLl9jb21waWxlKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnZhbHVlLmV4cHJlc3Npb25zLnBvc2l0aW9uT2Zmc2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy52YWx1ZS5wb3NpdGlvbk9mZnNldCA9IG1hdGVyaWFsRXhwcmVzc2lvbjtcbiAgICAgICAgdW5pZm9ybVZhbHVlID0gdGhpcy52YWx1ZS5wb3NpdGlvbk9mZnNldDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaChtYXRlcmlhbEV4cHJlc3Npb24uX2NvbXBpbGUgPyAnTUFURVJJQUxfSU5QVVQnIDogJ0dMX1VOSUZPUk1TJyk7XG4gICAgICAgIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2goJ3Bvc2l0aW9uT2Zmc2V0Jyk7XG4gICAgICAgIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2godW5pZm9ybVZhbHVlKTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJucyBwb3NpdGlvbiBvZmZzZXQuXG4gKlxuICogQG1ldGhvZCBnZXRQb3NpdGlvbk9mZnNldFxuICogQHJldHVybnMge01hdGVyaWFsRXhwcmVzc3xOdW1iZXJ9XG4gKi9cbk1lc2gucHJvdG90eXBlLmdldFBvc2l0aW9uT2Zmc2V0ID0gZnVuY3Rpb24gZ2V0UG9zaXRpb25PZmZzZXQgKG1hdGVyaWFsRXhwcmVzc2lvbikge1xuICAgIHJldHVybiB0aGlzLnZhbHVlLmV4cHJlc3Npb25zLnBvc2l0aW9uT2Zmc2V0IHx8IHRoaXMudmFsdWUucG9zaXRpb25PZmZzZXQ7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbWVzaCdzIGN1c3RvbSBvcHRpb25zLlxuICpcbiAqIEBtZXRob2QgZ2V0RHJhd09wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IE9wdGlvbnNcbiAqL1xuTWVzaC5wcm90b3R5cGUuZ2V0TWF0ZXJpYWxFeHByZXNzaW9ucyA9IGZ1bmN0aW9uIGdldE1hdGVyaWFsRXhwcmVzc2lvbnMgKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlLmV4cHJlc3Npb25zO1xufTtcblxuTWVzaC5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiBnZXRWYWx1ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG59O1xuXG5NZXNoLnByb3RvdHlwZS5fcHVzaEludmFsaWRhdGlvbnMgPSBmdW5jdGlvbiBwdXNoSW52YWxpZGF0aW9ucyAoZXhwcmVzc2lvbk5hbWUpIHtcbiAgICB2YXIgdW5pZm9ybUtleTtcbiAgICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMudmFsdWUuZXhwcmVzc2lvbnNbZXhwcmVzc2lvbk5hbWVdO1xuICAgIGlmIChleHByZXNzaW9uKSB7XG4gICAgICAgIHZhciBpID0gZXhwcmVzc2lvbi5pbnZhbGlkYXRpb25zLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgdW5pZm9ybUtleSA9IGV4cHJlc3Npb24uaW52YWxpZGF0aW9ucy5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKCdHTF9VTklGT1JNUycpO1xuICAgICAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQodW5pZm9ybUtleSk7XG4gICAgICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZChleHByZXNzaW9uLnVuaWZvcm1zW3VuaWZvcm1LZXldKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuKiBTZW5kcyBkcmF3IGNvbW1hbmRzIHRvIHRoZSByZW5kZXJlclxuKlxuKiBAcHJpdmF0ZVxuKiBAbWV0aG9kIG9uVXBkYXRlXG4qL1xuTWVzaC5wcm90b3R5cGUub25VcGRhdGUgPSBmdW5jdGlvbiBvblVwZGF0ZSAoKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLl9ub2RlO1xuICAgIHZhciBxdWV1ZSA9IHRoaXMuX2NoYW5nZVF1ZXVlO1xuXG4gICAgaWYgKG5vZGUpIHtcbiAgICAgICAgbm9kZS5zZW5kRHJhd0NvbW1hbmQoJ1dJVEgnKTtcbiAgICAgICAgbm9kZS5zZW5kRHJhd0NvbW1hbmQobm9kZS5nZXRMb2NhdGlvbigpKTtcblxuICAgICAgICBpZiAodGhpcy52YWx1ZS5nZW9tZXRyeSkge1xuICAgICAgICBpID0gdGhpcy52YWx1ZS5nZW9tZXRyeS5zcGVjLmludmFsaWRhdGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgIHZhciBidWZmZXJJbmRleCA9IHRoaXMudmFsdWUuZ2VvbWV0cnkuc3BlYy5pbnZhbGlkYXRpb25zLnBvcCgpO1xuICAgICAgICAgICAgICAgIG5vZGUuc2VuZERyYXdDb21tYW5kKCdHTF9CVUZGRVJfREFUQScpO1xuICAgICAgICAgICAgICAgIG5vZGUuc2VuZERyYXdDb21tYW5kKHRoaXMudmFsdWUuZ2VvbWV0cnkuaWQpO1xuICAgICAgICAgICAgICAgIG5vZGUuc2VuZERyYXdDb21tYW5kKHRoaXMudmFsdWUuZ2VvbWV0cnkuc3BlYy5idWZmZXJOYW1lc1tpXSk7XG4gICAgICAgICAgICAgICAgbm9kZS5zZW5kRHJhd0NvbW1hbmQodGhpcy52YWx1ZS5nZW9tZXRyeS5zcGVjLmJ1ZmZlclZhbHVlc1tpXSk7XG4gICAgICAgICAgICAgICAgbm9kZS5zZW5kRHJhd0NvbW1hbmQodGhpcy52YWx1ZS5nZW9tZXRyeS5zcGVjLmJ1ZmZlclNwYWNpbmdzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGFueSBpbnZhbGlkYXRpb25zIGV4aXN0LCBwdXNoIHRoZW0gaW50byB0aGUgcXVldWVcbiAgICAgICAgaWYgKHRoaXMudmFsdWUuY29sb3IgJiYgdGhpcy52YWx1ZS5jb2xvci5pc0FjdGl2ZSgpKSB7XG4gICAgICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZCgnR0xfVU5JRk9STVMnKTtcbiAgICAgICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKCdiYXNlQ29sb3InKTtcbiAgICAgICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKHRoaXMudmFsdWUuY29sb3IuZ2V0Tm9ybWFsaXplZFJHQigpKTtcbiAgICAgICAgICAgIHRoaXMuX25vZGUucmVxdWVzdFVwZGF0ZU9uTmV4dFRpY2sodGhpcy5faWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgYW55IGludmFsaWRhdGlvbnMgZXhpc3QsIHB1c2ggdGhlbSBpbnRvIHRoZSBxdWV1ZVxuICAgICAgICB0aGlzLl9wdXNoSW52YWxpZGF0aW9ucygnYmFzZUNvbG9yJyk7XG4gICAgICAgIHRoaXMuX3B1c2hJbnZhbGlkYXRpb25zKCdwb3NpdGlvbk9mZnNldCcpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG5vZGUuc2VuZERyYXdDb21tYW5kKHF1ZXVlW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgfVxuXG59O1xuXG5NZXNoLnByb3RvdHlwZS5vbk1vdW50ID0gZnVuY3Rpb24gb25Nb3VudCAobm9kZSwgaWQpIHtcbiAgICB0aGlzLl9ub2RlID0gbm9kZTtcbiAgICB0aGlzLl9pZCA9IGlkO1xuXG4gICAgdGhpcy5kcmF3KCk7XG59O1xuXG5NZXNoLnByb3RvdHlwZS5vbkRpc21vdW50ID0gZnVuY3Rpb24gb25EaXNtb3VudCAoKSB7XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLm9uSGlkZSgpO1xufTtcblxuTWVzaC5wcm90b3R5cGUub25TaG93ID0gZnVuY3Rpb24gb25TaG93ICgpIHtcbiAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKCdHTF9ISURFX01FU0gnKTtcbn07XG5cbk1lc2gucHJvdG90eXBlLm9uSGlkZSA9IGZ1bmN0aW9uIG9uSGlkZSAoKSB7XG4gICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaCgnR0xfSElERV9NRVNIJyk7XG59O1xuXG4vKipcbiAqIFJlY2VpdmVzIHRyYW5zZm9ybSBjaGFuZ2UgdXBkYXRlcyBmcm9tIHRoZSBzY2VuZSBncmFwaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5NZXNoLnByb3RvdHlwZS5vblRyYW5zZm9ybUNoYW5nZSA9IGZ1bmN0aW9uIG9uVHJhbnNmb3JtQ2hhbmdlICh0cmFuc2Zvcm0pIHtcbiAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaCgnR0xfVU5JRk9STVMnKTtcbiAgICAgICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaCgndHJhbnNmb3JtJyk7XG4gICAgICAgIHRoaXMuX2NoYW5nZVF1ZXVlLnB1c2godHJhbnNmb3JtKTsgICAgICAgIFxuICAgIH1cblxuICAgIHRoaXMuX3JlcXVlc3RVcGRhdGUoKTtcbn07XG5cbi8qKlxuICogUmVjZWl2ZXMgc2l6ZSBjaGFuZ2UgdXBkYXRlcyBmcm9tIHRoZSBzY2VuZSBncmFwaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5NZXNoLnByb3RvdHlwZS5vblNpemVDaGFuZ2UgPSBmdW5jdGlvbiBvblNpemVDaGFuZ2UgKHNpemUpIHtcbiAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaCgnR0xfVU5JRk9STVMnKTtcbiAgICAgICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaCgnc2l6ZScpO1xuICAgICAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKHNpemUpO1xuICAgIH1cblxuICAgIHRoaXMuX3JlcXVlc3RVcGRhdGUoKTtcbn07XG5cbi8qKlxuICogUmVjZWl2ZXMgb3BhY2l0eSBjaGFuZ2UgdXBkYXRlcyBmcm9tIHRoZSBzY2VuZSBncmFwaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5NZXNoLnByb3RvdHlwZS5vbk9wYWNpdHlDaGFuZ2UgPSBmdW5jdGlvbiBvbk9wYWNpdHlDaGFuZ2UgKG9wYWNpdHkpIHtcbiAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaCgnR0xfVU5JRk9STVMnKTtcbiAgICAgICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaCgnb3BhY2l0eScpO1xuICAgICAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKG9wYWNpdHkpO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG59O1xuXG5NZXNoLnByb3RvdHlwZS5vbkFkZFVJRXZlbnQgPSBmdW5jdGlvbiBvbkFkZFVJRXZlbnQgKFVJRXZlbnQsIG1ldGhvZHMsIHByb3BlcnRpZXMpIHtcbiAgICAvL1RPRE9cbn07XG5cbk1lc2gucHJvdG90eXBlLl9yZXF1ZXN0VXBkYXRlID0gZnVuY3Rpb24gX3JlcXVlc3RVcGRhdGUgKCkge1xuICAgIGlmICghdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSkge1xuICAgICAgICB0aGlzLl9ub2RlLnJlcXVlc3RVcGRhdGUodGhpcy5faWQpO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG59O1xuXG5NZXNoLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdCAoKSB7XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIHRoaXMub25UcmFuc2Zvcm1DaGFuZ2UodGhpcy5fbm9kZS5nZXRUcmFuc2Zvcm0oKSk7XG4gICAgdGhpcy5vblNpemVDaGFuZ2UodGhpcy5fbm9kZS5nZXRTaXplKCkpO1xuICAgIHRoaXMub25PcGFjaXR5Q2hhbmdlKHRoaXMuX25vZGUuZ2V0T3BhY2l0eSgpKTtcbiAgICB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG59O1xuXG5NZXNoLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gZHJhdyAoKSB7XG4gICAgdmFyIGtleTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuO1xuXG4gICAgdGhpcy5faW5EcmF3ID0gdHJ1ZTtcblxuICAgIHRoaXMuaW5pdCgpO1xuXG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuICAgIGlmICh2YWx1ZS5nZW9tZXRyeSAhPSBudWxsKSB0aGlzLnNldEdlb21ldHJ5KHZhbHVlLmdlb21ldHJ5KTtcbiAgICBpZiAodmFsdWUuY29sb3IgIT0gbnVsbCkgdGhpcy5zZXRCYXNlQ29sb3IodmFsdWUuY29sb3IpO1xuICAgIGlmICh2YWx1ZS5kcmF3T3B0aW9ucyAhPSBudWxsKSB0aGlzLnNldERyYXdPcHRpb25zKHZhbHVlLmRyYXdPcHRpb25zKTtcbiAgICBpZiAodmFsdWUuZmxhdFNoYWRpbmcgIT0gbnVsbCkgdGhpcy5zZXRGbGF0U2hhZGluZyh2YWx1ZS5mbGF0U2hhZGluZyk7XG4gICAgaWYgKHZhbHVlLmV4cHJlc3Npb25zLm5vcm1hbHMgIT0gbnVsbCkgdGhpcy5zZXROb3JtYWxzKHZhbHVlLmV4cHJlc3Npb25zLm5vcm1hbHMpO1xuICAgIGlmICh2YWx1ZS5leHByZXNzaW9ucy5iYXNlQ29sb3IgIT0gbnVsbCkgdGhpcy5zZXRCYXNlQ29sb3IodmFsdWUuZXhwcmVzc2lvbnMuYmFzZUNvbG9yKTtcbiAgICBpZiAodmFsdWUuZXhwcmVzc2lvbnMuZ2xvc3NpbmVzcyAhPSBudWxsKSB0aGlzLnNldEdsb3NzaW5lc3ModmFsdWUuZXhwcmVzc2lvbnMuZ2xvc3NpbmVzcyk7XG4gICAgaWYgKHZhbHVlLmV4cHJlc3Npb25zLnBvc2l0aW9uT2Zmc2V0ICE9IG51bGwpIHRoaXMuc2V0UG9zaXRpb25PZmZzZXQodmFsdWUuZXhwcmVzc2lvbnMucG9zaXRpb25PZmZzZXQpO1xuXG4gICAgdGhpcy5faW5EcmF3ID0gZmFsc2U7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1lc2g7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIE1lc2g6IHJlcXVpcmUoJy4vTWVzaCcpLFxuICAgIFBvaW50TGlnaHQ6IHJlcXVpcmUoJy4vbGlnaHRzL1BvaW50TGlnaHQnKSxcbiAgICBBbWJpZW50TGlnaHQ6IHJlcXVpcmUoJy4vbGlnaHRzL0FtYmllbnRMaWdodCcpLFxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIExpZ2h0ID0gcmVxdWlyZSgnLi9MaWdodCcpO1xuXG5cbi8qKlxuICogQW1iaWVudExpZ2h0IGV4dGVuZHMgdGhlIGZ1bmN0aW9uYWxpdHkgb2YgTGlnaHQuIEl0IHNldHMgdGhlIGFtYmllbmNlIGluXG4gKiB0aGUgc2NlbmUuIEFtYmllbmNlIGlzIGEgbGlnaHQgc291cmNlIHRoYXQgZW1pdHMgbGlnaHQgaW4gdGhlIGVudGlyZVxuICogc2NlbmUsIGV2ZW5seS5cbiAqXG4gKiBAY2xhc3MgQW1iaWVudExpZ2h0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBjb21wb25lbnRcbiAqIEBwYXJhbSB7TG9jYWxEaXNwYXRjaH0gZGlzcGF0Y2ggTG9jYWxEaXNwYXRjaCB0byBiZSByZXRyaWV2ZWRcbiAqIGZyb20gdGhlIGNvcnJlc3BvbmRpbmcgUmVuZGVyIE5vZGVcbiAqL1xuZnVuY3Rpb24gQW1iaWVudExpZ2h0KG5vZGUpIHtcbiAgICBMaWdodC5jYWxsKHRoaXMsIG5vZGUpO1xuICAgIHRoaXMuY29tbWFuZHMuY29sb3IgPSAnR0xfQU1CSUVOVF9MSUdIVCc7XG59O1xuXG4vKipcbiogUmV0dXJucyB0aGUgZGVmaW5pdGlvbiBvZiB0aGUgQ2xhc3M6ICdBbWJpZW50TGlnaHQnXG4qXG4qIEBtZXRob2QgdG9TdHJpbmdcbiogQHJldHVybiB7c3RyaW5nfSBkZWZpbml0aW9uXG4qL1xuQW1iaWVudExpZ2h0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdBbWJpZW50TGlnaHQnO1xufTtcblxuLyoqXG4gKiBFeHRlbmRzIExpZ2h0IGNvbnN0cnVjdG9yXG4gKi9cbkFtYmllbnRMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKExpZ2h0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogU2V0cyBBbWJpZW50TGlnaHQgYXMgdGhlIGNvbnN0cnVjdG9yXG4gKi9cbkFtYmllbnRMaWdodC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBbWJpZW50TGlnaHQ7XG5cbm1vZHVsZS5leHBvcnRzID0gQW1iaWVudExpZ2h0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFRoZSBibHVlcHJpbnQgZm9yIGFsbCBsaWdodCBjb21wb25lbnRzIGZvciBpbmhlcml0aW5nIGNvbW1vbiBmdW5jdGlvbmFsaXR5LlxuICpcbiAqIEBjbGFzcyBMaWdodFxuICogQGNvbnN0cnVjdG9yXG4gKiBAY29tcG9uZW50XG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIGNvbnRyb2xsaW5nIG5vZGVcbiAqIGZyb20gdGhlIGNvcnJlc3BvbmRpbmcgUmVuZGVyIE5vZGVcbiAqL1xuZnVuY3Rpb24gTGlnaHQobm9kZSkge1xuICAgIHRoaXMuX25vZGUgPSBub2RlO1xuICAgIHRoaXMuX2lkID0gbm9kZS5hZGRDb21wb25lbnQodGhpcyk7XG4gICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICB0aGlzLl9jb2xvcjtcbiAgICB0aGlzLmNvbW1hbmRzID0geyBjb2xvcjogJ0dMX0xJR0hUX0NPTE9SJyB9O1xufTtcblxuLyoqXG4qIFJldHVybnMgdGhlIGRlZmluaXRpb24gb2YgdGhlIENsYXNzOiAnTGlnaHQnXG4qXG4qIEBtZXRob2QgdG9TdHJpbmdcbiogQHJldHVybiB7U3RyaW5nfSBkZWZpbml0aW9uXG4qL1xuTGlnaHQudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ0xpZ2h0Jztcbn07XG5cbi8qKlxuKiBDaGFuZ2VzIHRoZSBjb2xvciBvZiB0aGUgbGlnaHQsIHVzaW5nIHRoZSAnQ29sb3InIHV0aWxpdHkgY29tcG9uZW50LlxuKlxuKiBAbWV0aG9kIHNldENvbG9yXG4qIEBwYXJhbSB7Q29sb3J9IENvbG9yIGluc3RhbmNlXG4qIEBjaGFpbmFibGVcbiovXG5MaWdodC5wcm90b3R5cGUuc2V0Q29sb3IgPSBmdW5jdGlvbiBzZXRDb2xvcihjb2xvcikge1xuICAgIGlmICghY29sb3IuZ2V0Tm9ybWFsaXplZFJHQikgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSkge1xuICAgICAgICB0aGlzLl9ub2RlLnJlcXVlc3RVcGRhdGUodGhpcy5faWQpO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fY29sb3IgPSBjb2xvcjtcbiAgICB0aGlzLnF1ZXVlLnB1c2godGhpcy5jb21tYW5kcy5jb2xvcik7XG4gICAgdmFyIHJnYiA9IHRoaXMuX2NvbG9yLmdldE5vcm1hbGl6ZWRSR0IoKTtcbiAgICB0aGlzLnF1ZXVlLnB1c2gocmdiWzBdKTtcbiAgICB0aGlzLnF1ZXVlLnB1c2gocmdiWzFdKTtcbiAgICB0aGlzLnF1ZXVlLnB1c2gocmdiWzJdKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuKiBSZXR1cm5zIHRoZSBjdXJyZW50IGNvbG9yLlxuXG4qIEBtZXRob2QgZ2V0Q29sb3JcbiogQHJldHVybnMge0NvbG9yfSBDb2xvci5cbiovXG5MaWdodC5wcm90b3R5cGUuZ2V0Q29sb3IgPSBmdW5jdGlvbiBnZXRDb2xvcihvcHRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5fY29sb3I7XG59O1xuXG4vKipcbiogU2VuZHMgZHJhdyBjb21tYW5kcyB0byB0aGUgcmVuZGVyZXJcbipcbiogQHByaXZhdGVcbiogQG1ldGhvZCBvblVwZGF0ZVxuKi9cbkxpZ2h0LnByb3RvdHlwZS5vblVwZGF0ZSA9IGZ1bmN0aW9uIGNsZWFuKCkge1xuICAgIHZhciBwYXRoID0gdGhpcy5fbm9kZS5nZXRMb2NhdGlvbigpO1xuXG4gICAgdGhpcy5fbm9kZVxuICAgICAgICAuc2VuZERyYXdDb21tYW5kKCdXSVRIJylcbiAgICAgICAgLnNlbmREcmF3Q29tbWFuZChwYXRoKTtcblxuICAgIHZhciBpID0gdGhpcy5xdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZCh0aGlzLnF1ZXVlLnNoaWZ0KCkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9jb2xvciAmJiB0aGlzLl9jb2xvci5pc0FjdGl2ZSgpKSB7XG4gICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKHRoaXMuY29tbWFuZHMuY29sb3IpO1xuICAgICAgICB2YXIgcmdiID0gdGhpcy5fY29sb3IuZ2V0Tm9ybWFsaXplZFJHQigpO1xuICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZChyZ2JbMF0pO1xuICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZChyZ2JbMV0pO1xuICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZChyZ2JbMl0pO1xuICAgICAgICB0aGlzLl9ub2RlLnJlcXVlc3RVcGRhdGVPbk5leHRUaWNrKHRoaXMuX2lkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlID0gZmFsc2U7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMaWdodDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIExpZ2h0ID0gcmVxdWlyZSgnLi9MaWdodCcpO1xuXG4vKipcbiAqIFBvaW50TGlnaHQgZXh0ZW5kcyB0aGUgZnVuY3Rpb25hbGl0eSBvZiBMaWdodC4gUG9pbnRMaWdodCBpcyBhIGxpZ2h0IHNvdXJjZVxuICogdGhhdCBlbWl0cyBsaWdodCBpbiBhbGwgZGlyZWN0aW9ucyBmcm9tIGEgcG9pbnQgaW4gc3BhY2UuXG4gKlxuICogQGNsYXNzIFBvaW50TGlnaHRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGNvbXBvbmVudFxuICogQHBhcmFtIHtMb2NhbERpc3BhdGNofSBkaXNwYXRjaCBMb2NhbERpc3BhdGNoIHRvIGJlIHJldHJpZXZlZFxuICogZnJvbSB0aGUgY29ycmVzcG9uZGluZyBSZW5kZXIgTm9kZVxuICovXG5mdW5jdGlvbiBQb2ludExpZ2h0KG5vZGUpIHtcbiAgICBMaWdodC5jYWxsKHRoaXMsIG5vZGUpO1xuICAgIHRoaXMuY29tbWFuZHMucG9zaXRpb24gPSAnR0xfTElHSFRfUE9TSVRJT04nO1xuICAgIHRoaXMub25UcmFuc2Zvcm1DaGFuZ2Uobm9kZS5nZXRUcmFuc2Zvcm0oKSk7XG59O1xuXG4vKipcbiogUmV0dXJucyB0aGUgZGVmaW5pdGlvbiBvZiB0aGUgQ2xhc3M6ICdQb2ludExpZ2h0J1xuKlxuKiBAbWV0aG9kIHRvU3RyaW5nXG4qIEByZXR1cm4ge3N0cmluZ30gZGVmaW5pdGlvblxuKi9cblBvaW50TGlnaHQudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ1BvaW50TGlnaHQnO1xufTtcblxuLyoqXG4gKiBFeHRlbmRzIExpZ2h0IGNvbnN0cnVjdG9yXG4gKi9cblBvaW50TGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMaWdodC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFNldHMgUG9pbnRMaWdodCBhcyB0aGUgY29uc3RydWN0b3JcbiAqL1xuUG9pbnRMaWdodC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQb2ludExpZ2h0O1xuXG4vKipcbiAqIFJlY2VpdmVzIHRyYW5zZm9ybSBjaGFuZ2UgdXBkYXRlcyBmcm9tIHRoZSBzY2VuZSBncmFwaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5Qb2ludExpZ2h0LnByb3RvdHlwZS5vblRyYW5zZm9ybUNoYW5nZSA9IGZ1bmN0aW9uIG9uVHJhbnNmb3JtQ2hhbmdlICh0cmFuc2Zvcm0pIHtcbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5fbm9kZS5yZXF1ZXN0VXBkYXRlKHRoaXMuX2lkKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMucXVldWUucHVzaCh0aGlzLmNvbW1hbmRzLnBvc2l0aW9uKTtcbiAgICB0aGlzLnF1ZXVlLnB1c2godHJhbnNmb3JtWzEyXSk7XG4gICAgdGhpcy5xdWV1ZS5wdXNoKHRyYW5zZm9ybVsxM10pO1xuICAgIHRoaXMucXVldWUucHVzaCh0cmFuc2Zvcm1bMTRdKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9pbnRMaWdodDtcbiIsInZhciBGYW1vdXNQbGF0Zm9ybSA9IHJlcXVpcmUoJ2ZhbW91cycpO1xudmFyIFNpemUgPSBGYW1vdXNQbGF0Zm9ybS5jb21wb25lbnRzLlNpemU7XG52YXIgUG9zaXRpb24gPSBGYW1vdXNQbGF0Zm9ybS5jb21wb25lbnRzLlBvc2l0aW9uO1xudmFyIFJvdGF0aW9uID0gRmFtb3VzUGxhdGZvcm0uY29tcG9uZW50cy5Sb3RhdGlvbjtcbnZhciBBbGlnbiA9IEZhbW91c1BsYXRmb3JtLmNvbXBvbmVudHMuQWxpZ247XG52YXIgT3JpZ2luID0gRmFtb3VzUGxhdGZvcm0uY29tcG9uZW50cy5PcmlnaW47XG52YXIgTW91bnRQb2ludCA9IEZhbW91c1BsYXRmb3JtLmNvbXBvbmVudHMuTW91bnRQb2ludDtcbnZhciBET01FbGVtZW50ID0gRmFtb3VzUGxhdGZvcm0uZG9tUmVuZGVyYWJsZXMuRE9NRWxlbWVudDtcbnZhciBQaHlzaWNzRW5naW5lID0gRmFtb3VzUGxhdGZvcm0ucGh5c2ljcy5QaHlzaWNzRW5naW5lO1xudmFyIEZhbW91cyA9IEZhbW91c1BsYXRmb3JtLmNvcmUuRmFtb3VzO1xudmFyIENsb2NrID0gRmFtb3VzLmdldENsb2NrKCk7XG52YXIgcGh5c2ljcyA9IEZhbW91c1BsYXRmb3JtLnBoeXNpY3M7XG52YXIgbWF0aCA9IEZhbW91c1BsYXRmb3JtLm1hdGg7XG52YXIgVUlFdmVudEhhbmRsZXIgPSBGYW1vdXNQbGF0Zm9ybS5jb21wb25lbnRzLlVJRXZlbnRIYW5kbGVyO1xudmFyIENvbGxpc2lvbiA9IHBoeXNpY3MuQ29sbGlzaW9uO1xudmFyIEJveCA9IHBoeXNpY3MuQm94O1xudmFyIFZlYzMgPSBtYXRoLlZlYzM7XG52YXIgV2FsbCA9IHBoeXNpY3MuV2FsbDtcbnZhciBHcmF2aXR5ID0gcGh5c2ljcy5HcmF2aXR5MURcbnZhciBUcmFuc2l0aW9uYWJsZSA9IEZhbW91c1BsYXRmb3JtLnRyYW5zaXRpb25zLlRyYW5zaXRpb25hYmxlO1xudmFyIGF1ZGlvID0gbmV3IEF1ZGlvKCcuL3NvdW5kcy9wbGFzbWEubXAzJyk7XG5cblxuZnVuY3Rpb24gR2FtZShub2RlKXtcbiAgdGhpcy5zaW11bGF0aW9uID0gbmV3IFBoeXNpY3NFbmdpbmUoKTtcbiAgdGhpcy5ub2RlID0gbm9kZTtcbiAgdGhpcy5tYWluQmdQb3MgPSAwO1xuXG4gIHRoaXMubWFpbkVsID0gbmV3IERPTUVsZW1lbnQodGhpcy5ub2RlLCB7XG4gICAgcHJvcGVydGllczoge1xuICAgICAgJ2JhY2tncm91bmQtaW1hZ2UnOiAndXJsKC4vaW1hZ2VzL2NpdHkyLnBuZyknLFxuICAgICAgLy8gJ2JhY2tncm91bmQtY29sb3InOiAndGVhbCcsXG4gICAgICAnYmFja2dyb3VuZC1yZXBlYXQnOiAncmVwZWF0LXgnLFxuICAgICAgJ2JhY2tncm91bmQtcG9zaXRpb24nOiAnY2VudGVyJyxcbiAgICAgICdiYWNrZ3JvdW5kLXBvc2l0aW9uJzogJzEwcHgnXG4gICAgfVxuICB9KVxuXG4gIHRoaXMuY3VycmVudEV2ZW50ID0gbnVsbDtcbiAgdGhpcy5zdGVwc0Ftb3VudCA9IG51bGw7XG4gIHRoaXMuZXZlbnREdXJhdGlvbiA9IG51bGw7XG4gIHRoaXMudGltZXIgPSAwO1xuICB0aGlzLnNjb3JlID0gMDtcblxuICB0aGlzLmJ1bGxldHMgPSBbXTtcbiAgdGhpcy5lbmVtaWVzID0gW107XG4gIFxuICAvL3VwZGF0ZSB0aGUgcGh5c2ljcyBlbmdpbmVcbiAgdmFyIHVwZGF0ZXIgPSB7XG4gICAgb25VcGRhdGU6IGZ1bmN0aW9uKHQpIHtcbiAgICAgIHRoaXMuc2ltdWxhdGlvbi51cGRhdGUodClcbiAgICAgIHRoaXMudXBkYXRlKClcbiAgICAgIEZhbW91cy5yZXF1ZXN0VXBkYXRlT25OZXh0VGljayh1cGRhdGVyKTtcbiAgICB9LmJpbmQodGhpcylcbiAgfVxuXG4gIEZhbW91cy5yZXF1ZXN0VXBkYXRlT25OZXh0VGljayh1cGRhdGVyKTtcblxuICBfY3JlYXRlS2V5RXZlbnRzLmNhbGwodGhpcylcbiAgX2NyZWF0ZVBsYXllci5jYWxsKHRoaXMpXG4gIF9jcmVhdGVUaXRsZXMuY2FsbCh0aGlzKVxuICBfY3JlYXRlQm9kaWVzLmNhbGwodGhpcylcblxuICBcbiBjcmVhdGVFbmVteS5jYWxsKHRoaXMpXG4gIGNyZWF0ZUVuZW15LmNhbGwodGhpcylcbiAgY3JlYXRlRW5lbXkuY2FsbCh0aGlzKVxuICBjcmVhdGVFbmVteS5jYWxsKHRoaXMpXG5cbiAgdmFyIHNpemVyID0gbmV3IFNpemUobm9kZSlcbiAgc2l6ZXIub25TaXplQ2hhbmdlID0gZnVuY3Rpb24oc2l6ZSl7XG4gICAgdGhpcy5tYWluSGVpZ2h0ID0gc2l6ZVswXVxuICAgIHRoaXMubWFpbldpZHRoID0gc2l6ZVsxXVxuICAgIC8vIHRoaXMud2FsbDMuc2V0UG9zaXRpb24odGhpcy5tYWluV2lkdGgsMCwwKTtcbiAgICAvLyB0aGlzLndhbGw0LnNldFBvc2l0aW9uKDAsdGhpcy5tYWluSGVpZ2h0LDApXG5cbiAgfS5iaW5kKHRoaXMpXG5cbiBcblxufVxuXG5HYW1lLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpe1xuICBcbiAgLy9sb29wIHRocm91Z2ggYnVsbGV0IHZpZXdzIGFuZCB1cGRhdGUgdG8gY29ycmVzcG9uZGluZyBib3ggaW4gUEUgXG4gIGlmKHRoaXMuYnVsbGV0cy5sZW5ndGggPiAwKXtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5idWxsZXRzLmxlbmd0aDsgaSsrKXtcbiAgICAgIHZhciBidWxsZXRQb3NpdGlvbiA9IHRoaXMuc2ltdWxhdGlvbi5nZXRUcmFuc2Zvcm0odGhpcy5idWxsZXRzW2ldWzBdKS5wb3NpdGlvblxuICAgICAgdGhpcy5idWxsZXRzW2ldWzFdLnNldChidWxsZXRQb3NpdGlvblswXSwgYnVsbGV0UG9zaXRpb25bMV0sIDIpXG4gICAgfVxuICB9XG4gIFxuICAvL2xvb3AgdGhyb3VnaCBlbmVtaWVzIGFuZCB1cGRhdGUgdG8gY29ycmVzcG9uZGluZyBib3ggaW4gUEVcbiAgaWYodGhpcy5lbmVtaWVzLmxlbmd0aCA+IDApe1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmVuZW1pZXMubGVuZ3RoOyBpKyspe1xuICAgICAgdmFyIGVuZW15UG9zaXRpb24gPSB0aGlzLnNpbXVsYXRpb24uZ2V0VHJhbnNmb3JtKHRoaXMuZW5lbWllc1tpXVswXSkucG9zaXRpb25cbiAgICAgIHRoaXMuZW5lbWllc1tpXVsxXS5zZXQoZW5lbXlQb3NpdGlvblswXSwgZW5lbXlQb3NpdGlvblsxXSwgMClcbiAgICB9XG4gIH1cblxuICAvL2JveCB0aGF0IHVwZGF0ZXMgcGxheWVyXG4gIHZhciBib3hUcmFuc2Zvcm0gPSB0aGlzLnNpbXVsYXRpb24uZ2V0VHJhbnNmb3JtKHRoaXMuYm94KS5wb3NpdGlvbjtcbiAgdmFyIHggPSBib3hUcmFuc2Zvcm1bMF1cbiAgdmFyIHkgPSBib3hUcmFuc2Zvcm1bMV1cbiAgdmFyIHogPSBib3hUcmFuc2Zvcm1bMl1cblxuICB0aGlzLnBsYXllci5wb3NpdGlvbi5zZXQoeCx5LHopXG5cbiBcbiAgLy9zdGFydHMgdGhlIHNwcml0ZSBhbmltYXRpb25zIHdoZW4gYSBuZXcgZXZlbnQgaXMgY2FsbGVkXG4gIGlmKHRoaXMuY3VycmVudEV2ZW50IT09bnVsbCl7XG5cbiAgICB0aGlzLnRpbWVyKys7XG4gICAgXG4gICAgLy9jYWxscyBzcHJpdGUgZnJhbWUgb24gJ3RoaXMuZXZlbnREdXJhdGlvbicgaW50ZXJ2YWxzXG4gICAgaWYodGhpcy50aW1lciV0aGlzLmV2ZW50RHVyYXRpb24gPT09IDApe1xuICAgICAgdGhpcy5jdXJyZW50RXZlbnQuY2FsbCh0aGlzKVxuICAgICAgdGhpcy5wbGF5ZXIuY3VycmVudFN0ZXArK1xuICAgIH1cbiAgICBcbiAgICAvL3Jlc2V0IHRvIGRlZmF1bHRzIHdoZW4gc3ByaXRlIGFuaW1hdGlvbiBpcyBmaW5pc2hlZFxuICAgIGlmKHRoaXMucGxheWVyLmN1cnJlbnRTdGVwID4gdGhpcy5zdGVwc0Ftb3VudCl7XG4gICAgICB0aGlzLmN1cnJlbnRFdmVudCA9IG51bGw7XG4gICAgICB0aGlzLnRpbWVyID0gMDtcbiAgICAgIHRoaXMucGxheWVyLmN1cnJlbnRTdGVwID0gMDtcbiAgICAgIHRoaXMucGxheWVyLmJhY2tncm91bmRQb3NpdGlvbiA9IDA7XG4gICAgICB0aGlzLnBsYXllci5qdW1waW5nID0gZmFsc2U7XG4gICAgfVxuXG4gIH1cblxuXG59XG5cblxuXG5cbmZ1bmN0aW9uIF9jcmVhdGVLZXlFdmVudHMoKXtcbiAgLy9oYWNrIHVudGlsIGZpZ3VyZSBvdXQga2V5ZG93biBldmVudCBcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBmdW5jdGlvbihlKXtcbiAgICBcbiAgICAvL3VwXG4gICAgaWYoZS53aGljaCA9PT0gMzgpe1xuICAgICAgIGluaXRFdmVudC5jYWxsKHRoaXMsIDEzLCA2LCBKdW1wKVxuICAgIH1cbiAgICBcbiAgICAvL2xlZnRcbiAgICBpZihlLndoaWNoID09PSAzNyl7XG4gICAgICAgaW5pdEV2ZW50LmNhbGwodGhpcywgMTMsIDQsIG1vdmVMZWZ0KVxuICAgIH1cbiAgICAvL3JpZ2h0XG4gICAgaWYoZS53aGljaCA9PT0gMzkpe1xuICAgICAgaW5pdEV2ZW50LmNhbGwodGhpcywgMTMsIDQsIG1vdmVSaWdodCkgXG4gICAgfVxuICAgIFxuICAgIC8vc3BhY2ViYXJcbiAgICBpZihlLndoaWNoID09PSAzMil7XG4gICAgIGNvbnNvbGUubG9nKCdwZXcnKVxuICAgIFxuICAgICAgIGluaXRFdmVudC5jYWxsKHRoaXMsIDcsIDUsIHNob290KVxuICAgICAgIG5ldyBBdWRpbygnLi9zb3VuZHMvcGxhc21hLm1wMycpLnBsYXkoKVxuICAgICAgIGNyZWF0ZUJ1bGxldC5jYWxsKHRoaXMpXG4gICAgIFxuICAgIH1cbiAgXG4gIH0uYmluZCh0aGlzKSlcblxufVxuXG5cbmZ1bmN0aW9uIF9jcmVhdGVQbGF5ZXIoKXtcbiAgIC8vcGxheWVyIFxuICB2YXIgcGxheWVyTm9kZSA9IHRoaXMubm9kZS5hZGRDaGlsZCgpXG4gIFxuICB0aGlzLnBsYXllciA9IHtcbiAgICBub2RlOiBwbGF5ZXJOb2RlLFxuICAgIGVsOiBuZXcgRE9NRWxlbWVudChwbGF5ZXJOb2RlKSxcbiAgICBoZWFsdGg6IDUwLFxuICAgIGN1cnJlbnRTdGVwOiAwLFxuICAgIGJhY2tncm91bmRQb3NpdGlvbjogMCxcbiAgICBkaXJlY3Rpb246ICdyaWdodCcsXG4gICAgbW92ZW1lbnQ6IFtdLFxuICAgIGp1bXBpbmc6IGZhbHNlLFxuICAgIHNpemU6IG5ldyBTaXplKHBsYXllck5vZGUpLFxuICAgIHBvc2l0aW9uOiBuZXcgUG9zaXRpb24ocGxheWVyTm9kZSksXG4gICAgbW91bnRwb2ludDogbmV3IE1vdW50UG9pbnQocGxheWVyTm9kZSlcbiAgfVxuICAgXG4gIHRoaXMucGxheWVyLmVsLnNldFByb3BlcnR5KCdiYWNrZ3JvdW5kLWltYWdlJywgJ3VybCguL2ltYWdlcy92Y3RybWFuaWRsZS5wbmcpJylcbiAgIC8vc2l6ZSBhbmQgY2VudGVyIHBsYXllclxuICB0aGlzLnBsYXllci5zaXplLnNldE1vZGUoMSwxKVxuICB0aGlzLnBsYXllci5zaXplLnNldEFic29sdXRlKDk2LDk2KVxuICB0aGlzLnBsYXllci5tb3VudHBvaW50LnNldCgwLjUsMC41KVxuICBcbn1cblxuXG5cbmZ1bmN0aW9uIF9jcmVhdGVUaXRsZXMoKXtcbiAvL3RpdGxlc1xuICB2YXIgdGl0bGVzID0gdGhpcy5ub2RlLmFkZENoaWxkKClcbiAgdGhpcy50aXRsZXMgPSB7XG4gICAgYWxpZ246IG5ldyBBbGlnbih0aXRsZXMpLFxuICAgIHNpemU6IG5ldyBTaXplKHRpdGxlcyksXG4gICAgZWw6IG5ldyBET01FbGVtZW50KHRpdGxlcylcbiAgfVxuICAvL3NpemUgYW5kIHNldCB0aXRsZSBcbiAgdGhpcy50aXRsZXMuYWxpZ24uc2V0KDAuMDEsMC4wMSlcbiAgdGhpcy50aXRsZXMuc2l6ZS5zZXRNb2RlKDEsMSlcbiAgdGhpcy50aXRsZXMuc2l6ZS5zZXRBYnNvbHV0ZSgxNTAsNTApXG4gIHRoaXMudGl0bGVzLmVsLnNldENvbnRlbnQoJ3Njb3JlOiAnK3RoaXMuc2NvcmUrICcgaGVhbHRoOiAnKyB0aGlzLnBsYXllci5oZWFsdGgpXG4gIHRoaXMudGl0bGVzLmVsLnNldFByb3BlcnR5KCdjb2xvcicsICd3aGl0ZScpXG5cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUJvZGllcygpe1xuICBcbiAgLy9jcmVhdGUgYm94IGZvciBwbGF5ZXJcbiAgdGhpcy5ib3ggPSBuZXcgQm94KHtcbiAgICBzaXplOiBbOTAsOTAsNTBdLFxuICAgIG1hc3M6IDEwLFxuICAgIHJlc3RyaWN0aW9uczogWyd6J10sXG4gICAgcG9zaXRpb246IG5ldyBWZWMzKDUwMCw1MCwwKVxuICB9KTtcblxuICAvL2lkIHBsYXllciBmb3IgY29sbGlzaW9uIGV2ZW50c1xuICB0aGlzLmJveC5wbGF5ZXIgPSB0cnVlO1xuICBcbiAgLy9zZXQgdXAgYm91bmRhcmllc1xuICB0aGlzLndhbGwxID0gbmV3IFdhbGwoe2RpcmVjdGlvbjogcGh5c2ljcy5XYWxsLlJJR0hULCByZXN0aXR1dGlvbjogNSwgZnJpY3Rpb246IDJ9KTtcbiAgdGhpcy53YWxsMiA9IG5ldyBXYWxsKHtkaXJlY3Rpb246IHBoeXNpY3MuV2FsbC5ET1dOLCByZXN0aXR1dGlvbjogNSwgZnJpY3Rpb246IDJ9KTtcbiAgdGhpcy53YWxsMyA9IG5ldyBXYWxsKHtkaXJlY3Rpb246IHBoeXNpY3MuV2FsbC5MRUZULCByZXN0aXR1dGlvbjogNSwgZnJpY3Rpb246IDJ9KTtcbiAgdGhpcy53YWxsNCA9IG5ldyBXYWxsKHtkaXJlY3Rpb246IHBoeXNpY3MuV2FsbC5VUCwgcmVzdGl0dXRpb246IDUsIGZyaWN0aW9uOiAyfSk7XG4gIFxuICAvL2Jlc3QgcHJhY3RpY2UgaGVyZSBmb3Igd2lkdGgvaGVpZ2h0P1xuICB0aGlzLndhbGwzLnNldFBvc2l0aW9uKHdpbmRvdy5pbm5lcldpZHRoLDAsMCk7XG4gIHRoaXMud2FsbDQuc2V0UG9zaXRpb24oMCx3aW5kb3cuaW5uZXJIZWlnaHQsMClcblxuICB0aGlzLmdyYXZpdHkgPSBuZXcgR3Jhdml0eShbdGhpcy5ib3hdKVxuICB0aGlzLmVuZW15Q29sbGlzaW9uID0gbmV3IENvbGxpc2lvbihbdGhpcy53YWxsMSwgdGhpcy53YWxsMiwgdGhpcy53YWxsMywgdGhpcy53YWxsNF0pXG5cbiAgdGhpcy5jb2xsaXNpb24gPSBuZXcgQ29sbGlzaW9uKFt0aGlzLmJveCwgdGhpcy53YWxsMSwgdGhpcy53YWxsMiwgdGhpcy53YWxsMywgdGhpcy53YWxsNF0pXG4gIHRoaXMuc2ltdWxhdGlvbi5hZGQodGhpcy5ncmF2aXR5LHRoaXMuYm94LCB0aGlzLmNvbGxpc2lvbiwgdGhpcy5lbmVteUNvbGxpc2lvbilcbiAgLy90aGlzLmVuZW15Q29sbGlzaW9uID0gbmV3IENvbGxpc2lvbigpXG4gIFxuXG59XG5cblxuZnVuY3Rpb24gY3JlYXRlRW5lbXkoKXtcbiAgXG4gIHZhciBlbmVteSA9IG5ldyBCb3goe1xuICAgIHNpemU6IFs5MCw5MCw1MF0sXG4gICAgbWFzczogNTAsXG4gICAgcmVzdHJpY3Rpb25zOiBbJ3onXSxcbiAgICBwb3NpdGlvbjogbmV3IFZlYzMoKE1hdGgucmFuZG9tKCkqd2luZG93LmlubmVyV2lkdGgpLC0yMDAsMClcbiAgfSk7XG5cbiAgLy9pZCBhcyBlbmVteSBmb3IgY29sbGlzaW9uIGV2ZW50c1xuICBlbmVteS5lbmVteSA9IHRydWU7XG5cbiAgdmFyIGVuZW15Tm9kZSA9IHRoaXMubm9kZS5hZGRDaGlsZCgpXG4gIC8vdGhpcy5ncmF2aXR5LmFkZFRhcmdldChlbmVteSlcbiAgdGhpcy5zaW11bGF0aW9uLmFkZEJvZHkoZW5lbXksIHRoaXMuZ3Jhdml0eSlcbiAgLy9iZXR0ZXIgaW1wbGVtZW50YXRpb24/XG4gIC8vYWRkIGVsIHRvIGVuZW15IHNvIHdlIGNhbiBtb2RpZnkgaXQgaW4gYnVsbGV0IGNvbGxpc2lvblxuICBlbmVteS5lbmVteUVsID0gbmV3IERPTUVsZW1lbnQoZW5lbXlOb2RlKVxuICB2YXIgZW5lbXlQb3NpdGlvbiA9IG5ldyBQb3NpdGlvbihlbmVteU5vZGUpXG4gIHZhciBlbmVteVNpemUgPSBuZXcgU2l6ZShlbmVteU5vZGUpXG4gIHZhciBlbmVteU1vdW50UG9pbnQgPSBuZXcgTW91bnRQb2ludChlbmVteU5vZGUpXG4gIC8vZW5lbXkuZW5lbXlFbC5zZXRQcm9wZXJ0eSgnYmFja2dyb3VuZC1jb2xvcicsICdyZWQnKVxuICBlbmVteVNpemUuc2V0TW9kZSgxLDEsMClcbiAgZW5lbXlTaXplLnNldEFic29sdXRlKDkwLDkwLDApXG4gIGVuZW15TW91bnRQb2ludC5zZXQoMC41LDAuNSlcbiAgZW5lbXlQb3NpdGlvbi5zZXQoMTAsMTApXG4gIHRoaXMuY29sbGlzaW9uLmFkZFRhcmdldChlbmVteSlcbiAgdGhpcy5lbmVteUNvbGxpc2lvbi5hZGRUYXJnZXQoZW5lbXkpXG4gIHRoaXMuZW5lbWllcy5wdXNoKFtlbmVteSwgZW5lbXlQb3NpdGlvbl0pXG4gIGVuZW15LmVuZW15RWwuc2V0Q29udGVudCgnPGltZyBzcmM9XCIuL2ltYWdlcy9saXZlLmdpZlwiIC8+JylcbiAgXG4gIC8vZW5lbXkgY29sbGlzaW9uIGV2ZW50XG4gIGVuZW15LmV2ZW50cy5vbignY29sbGlzaW9uOnN0YXJ0JywgZnVuY3Rpb24oZSl7XG4gICAgLy9pZiBjb2xsaWRlZCB3aXRoIGEgcGxheWVyXG4gICAgaWYoZS5ib2R5QS5wbGF5ZXIgfHwgZS5ib2R5Qi5wbGF5ZXIpe1xuICAgICAgLy9kZWNyZWFzZSBoZWFsdGggXG4gICAgICB0aGlzLnBsYXllci5oZWFsdGgtLTtcbiAgICAgXG4gICAgICAvL2NvbnNvbGUubG9nKCdvdWNoJywgdGhpcy5wbGF5ZXIuaGVhbHRoKVxuICAgICAgLy91cGRhdGUgc2NvcmVib2FyZFxuICAgICAgLy90aGlzLnRpdGxlcy5lbC5zZXRDb250ZW50KCdzY29yZTogJyt0aGlzLnNjb3JlKyAnIGhlYWx0aDogJysgdGhpcy5wbGF5ZXIuaGVhbHRoKVxuICAgICAgXG4gICAgICAvL2FsZXJ0IGlmIG5vIG1vcmUgaGVhbHRoXG4gIFxuICAgIH1cblxuIH0uYmluZCh0aGlzKSlcblxuXG59XG5cblxuXG5mdW5jdGlvbiBjcmVhdGVCdWxsZXQoKXtcbiAgXG4gIC8vaW5pdCBwb3NpdGlvbiBvZiBidWxsZXRcbiAgdmFyIGJveFRyYW5zZm9ybSA9IHRoaXMuc2ltdWxhdGlvbi5nZXRUcmFuc2Zvcm0odGhpcy5ib3gpLnBvc2l0aW9uO1xuICB2YXIgeCA9IGJveFRyYW5zZm9ybVswXSArIDEwO1xuICB2YXIgeSA9IGJveFRyYW5zZm9ybVsxXTtcbiAgXG4gIHZhciBidWxsZXQgPSBuZXcgQm94KHtcbiAgICBzaXplOiBbMTAsMTAsNTBdLFxuICAgIG1hc3M6IDExMCxcbiAgICByZXN0cmljdGlvbnM6IFsneiddLFxuICAgIHBvc2l0aW9uOiBuZXcgVmVjMyh4LHksMClcbiAgfSk7XG4gIFxuICAvL2lkIGFzIGJ1bGxldCBmb3IgY2hlY2tpbmcgY29sbGlzaW9uIGV2ZW50c1xuICBidWxsZXQuYnVsbGV0ID0gdHJ1ZTtcbiAgXG4gIHRoaXMuZW5lbXlDb2xsaXNpb24uYWRkVGFyZ2V0KGJ1bGxldClcbiAgdGhpcy5zaW11bGF0aW9uLmFkZEJvZHkoYnVsbGV0KVxuXG4gIHZhciBidWxsZXRTaGVsbCA9IHRoaXMubm9kZS5hZGRDaGlsZCgpXG4gIHZhciBidWxsZXRFbCA9IG5ldyBET01FbGVtZW50KGJ1bGxldFNoZWxsKVxuICB2YXIgYnVsbGV0UG9zaXRpb24gPSBuZXcgUG9zaXRpb24oYnVsbGV0U2hlbGwpXG4gIHZhciBidWxsZXRTaXplID0gbmV3IFNpemUoYnVsbGV0U2hlbGwpXG4gIGJ1bGxldEVsLnNldFByb3BlcnR5KCdiYWNrZ3JvdW5kLWNvbG9yJywgJ3JnYmEoMjI4LCAyNDAsIDI1MywgMC43NiknKVxuICBidWxsZXRFbC5zZXRQcm9wZXJ0eSgnYm9yZGVyLXJhZGl1cycsICc1MCUnKVxuICBidWxsZXRFbC5zZXRQcm9wZXJ0eSgnYm94LXNoYWRvdycsICcwcHggMHB4IDEwcHggcmdiKDIyOCwgMjQwLCAyNTMpJylcbiAgYnVsbGV0U2l6ZS5zZXRNb2RlKDEsMSwxKVxuICBidWxsZXRTaXplLnNldEFic29sdXRlKDEwLDEwLDEwKVxuICAgXG4gIHRoaXMuYnVsbGV0cy5wdXNoKFtidWxsZXQsIGJ1bGxldFBvc2l0aW9uXSlcbiAgIFxuICAvL3NldCB2ZWxvY2l0eSBiYXNlZCBvbiBwbGF5ZXIgZGlyZWN0aW9uXG5cbiAgaWYodGhpcy5wbGF5ZXIuZGlyZWN0aW9uID09PSAnbGVmdCcpe1xuICAgICBidWxsZXQuc2V0VmVsb2NpdHkoLTEwMDAsIDAsMClcbiAgfVxuXG4gIGlmKHRoaXMucGxheWVyLmRpcmVjdGlvbiA9PT0gJ3JpZ2h0Jyl7XG4gICAgYnVsbGV0LnNldFZlbG9jaXR5KDEwMDAsMCwwKVxuICB9XG4gXG4gIFxuXG4gIHRoaXMuY29sbGlkZWQgPSBmYWxzZTtcbiAgLy9idWxsZXQgY29sbGlzaW9uIGV2ZW50c1xuICBidWxsZXQuZXZlbnRzLm9uKCdjb2xsaXNpb246c3RhcnQnLCBmdW5jdGlvbihlKXtcbiAgICAvL2NoZWNrIGlmIGNvbGxpZGVkIGJvZHkgaXMgYW4gZW5lbXlcbiAgICBpZihlLmJvZHlBLmVuZW15KXtcbiAgICAgIHRoaXMuc2NvcmUrKztcbiAgICBcbiAgICAgIC8vb24gaGl0IHVwZGF0ZSBzY29yZSBhbmQgY2hhbmdlIGVuZW15IGltYWdlIHRvIGRlYWRcbiAgICAgIC8vdmFyIHVwZGF0ZWRTY29yZSA9ICdzY29yZTogJyt0aGlzLnNjb3JlKyAnIGhlYWx0aDogJysgdGhpcy5wbGF5ZXIuaGVhbHRoXG4gICAgICAvL2NvbnNvbGUubG9nKHVwZGF0ZWRTY29yZSwgdGhpcy50aXRsZXMuZWwuc2V0Q29udGVudCh1cGRhdGVkU2NvcmUpKVxuICAgICAgLy90aGlzLnRpdGxlcy5lbC5zZXRDb250ZW50KClcbiAgICAgIGUuYm9keUEuZW5lbXlFbC5zZXRDb250ZW50KCc8aW1nIHNyYz1cIi4vaW1hZ2VzL2RlYWQucG5nXCIgLz4nKVxuICAgIC8vb25seSBwbGF5IHNvdW5kIG9uIGJ1bGxldCdzIGZpcnN0IGhpdFxuICAgIGlmKCF0aGlzLmNvbGxpZGVkKXtcbiAgICAgIG5ldyBBdWRpbygnLi9zb3VuZHMvaGl0Lm1wMycpLnBsYXkoKVxuICAgICAgdGhpcy5jb2xsaWRlZCA9IHRydWU7XG4gICAgfVxuICAgXG4gICAgfVxuICB9LmJpbmQodGhpcykpXG5cblxuXG59XG5cbi8vbWFrZXMgc3VyZSBldmVudHMgYXJlbid0IGNhbGxlZCB0d2ljZSBcbmZ1bmN0aW9uIGluaXRFdmVudChzdGVwcywgZHVyYXRpb24sIGNhbGxiYWNrKXtcbiAgXG4gIGlmKHRoaXMuY3VycmVudEV2ZW50ICE9PSBjYWxsYmFjayl7XG4gICAgdGhpcy5wbGF5ZXIuY3VycmVudFN0ZXAgPSAwO1xuICAgIHRoaXMuY3VycmVudEV2ZW50ID0gY2FsbGJhY2s7XG4gICAgdGhpcy5zdGVwc0Ftb3VudCA9IHN0ZXBzO1xuICAgIHRoaXMuZXZlbnREdXJhdGlvbiA9IGR1cmF0aW9uO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gc2hvb3QoKXtcblxuICAvL3Nob290IHJpZ2h0IGFuZCBub3QganVtcGluZyBzcHJpdGVcbiAgaWYodGhpcy5wbGF5ZXIuZGlyZWN0aW9uID09PSAncmlnaHQnICYmICF0aGlzLnBsYXllci5qdW1waW5nKXtcbiAgICAvL21vdmUgc3ByaXRlIGZyYW1lXG4gICAgaWYodGhpcy5wbGF5ZXIuY3VycmVudFN0ZXAgPiAwICYmIHRoaXMucGxheWVyLmN1cnJlbnRTdGVwIDw9IDcpe1xuICAgICAgdGhpcy5wbGF5ZXIuYmFja2dyb3VuZFBvc2l0aW9uLT0xNjhcbiAgICAgIHZhciBudW0gPSB0aGlzLnBsYXllci5iYWNrZ3JvdW5kUG9zaXRpb25cbiAgICAgIHRoaXMucGxheWVyLmVsLnNldFByb3BlcnR5KCdiYWNrZ3JvdW5kLXBvc2l0aW9uJywgbnVtICsgJ3B4JylcbiAgICB9XG4gICAgLy9pbml0IHNwcml0ZVxuICAgIGlmKHRoaXMucGxheWVyLmN1cnJlbnRTdGVwID09PSAwICYmICF0aGlzLnBsYXllci5qdW1waW5nKXtcbiAgICAgIHRoaXMucGxheWVyLnNpemUuc2V0TW9kZSgxLDEpXG4gICAgICB0aGlzLnBsYXllci5zaXplLnNldEFic29sdXRlKDE2OCw5NilcbiAgICAgIHRoaXMucGxheWVyLmVsLnNldFByb3BlcnR5KCdiYWNrZ3JvdW5kLXBvc2l0aW9uJywgMCArICdweCcpXG4gICAgICB0aGlzLnBsYXllci5lbC5zZXRQcm9wZXJ0eSgnYmFja2dyb3VuZC1pbWFnZScsICd1cmwoLi9pbWFnZXMvc2hvb3RSaWdodC5wbmcpJylcbiAgICAgIHRoaXMucGxheWVyLmJhY2tncm91bmRQb3NpdGlvbiA9IDBcbiAgICB9XG4gIH1cbiAgXG4gIC8vc2hvb3QgbGVmdCBhbmQgbm90IGp1bXBpbmcgc3ByaXRlXG4gIGlmKHRoaXMucGxheWVyLmRpcmVjdGlvbiA9PT0gJ2xlZnQnICYmICF0aGlzLnBsYXllci5qdW1waW5nKXtcbiAgICAvL21vdmUgc3ByaXRlIGZyYW1lXG4gICAgaWYodGhpcy5wbGF5ZXIuY3VycmVudFN0ZXAgPiAwICYmIHRoaXMucGxheWVyLmN1cnJlbnRTdGVwIDw9IDcpe1xuICAgICAgdGhpcy5wbGF5ZXIuYmFja2dyb3VuZFBvc2l0aW9uKz0xNjhcbiAgICAgIHZhciBudW0gPSB0aGlzLnBsYXllci5iYWNrZ3JvdW5kUG9zaXRpb25cbiAgICAgIHRoaXMucGxheWVyLmVsLnNldFByb3BlcnR5KCdiYWNrZ3JvdW5kLXBvc2l0aW9uJywgbnVtICsgJ3B4JylcbiAgICB9XG4gICAgLy9pbml0IHNwcml0ZVxuICAgIGlmKHRoaXMucGxheWVyLmN1cnJlbnRTdGVwID09PSAwICYmICF0aGlzLnBsYXllci5qdW1waW5nKXtcbiAgICAgIHRoaXMucGxheWVyLnNpemUuc2V0TW9kZSgxLDEpXG4gICAgICB0aGlzLnBsYXllci5zaXplLnNldEFic29sdXRlKDE2OCw5NilcbiAgICAgIHRoaXMucGxheWVyLmJhY2tncm91bmRQb3NpdGlvbiA9IDE2OFxuICAgICAgdGhpcy5wbGF5ZXIuZWwuc2V0UHJvcGVydHkoJ2JhY2tncm91bmQtaW1hZ2UnLCAndXJsKC4vaW1hZ2VzL3Nob290TGVmdC5wbmcpJylcbiAgICAgIHRoaXMucGxheWVyLmVsLnNldFByb3BlcnR5KCdiYWNrZ3JvdW5kLXBvc2l0aW9uJywgMTY4ICsgJ3B4JylcbiAgICAgXG4gICAgfVxuICB9XG4gIFxuICAvL3Nob290IHJpZ2h0IGFuZCBqdW1waW5nIHNwcml0ZVxuICBpZih0aGlzLnBsYXllci5kaXJlY3Rpb24gPT09ICdyaWdodCcgJiYgdGhpcy5wbGF5ZXIuanVtcGluZyl7XG4gICAgLy9tb3ZlIHNwcml0ZSBmcmFtZVxuICAgIGlmKHRoaXMucGxheWVyLmN1cnJlbnRTdGVwID4gMSAmJiB0aGlzLnBsYXllci5jdXJyZW50U3RlcCA8PSA3KXtcbiAgICAgIHRoaXMucGxheWVyLmJhY2tncm91bmRQb3NpdGlvbi09MTg1XG4gICAgICB2YXIgbnVtID0gdGhpcy5wbGF5ZXIuYmFja2dyb3VuZFBvc2l0aW9uXG4gICAgICB0aGlzLnBsYXllci5lbC5zZXRQcm9wZXJ0eSgnYmFja2dyb3VuZC1wb3NpdGlvbicsIG51bSArICdweCcpXG4gICAgfVxuICAgIC8vaW5pdCBzcHJpdGVcbiAgICBpZih0aGlzLnBsYXllci5jdXJyZW50U3RlcCA9PT0gMCAmJiB0aGlzLnBsYXllci5qdW1waW5nKXtcbiAgICAgIHRoaXMucGxheWVyLmJhY2tncm91bmRQb3NpdGlvbiA9IDBcbiAgICAgIHRoaXMucGxheWVyLnNpemUuc2V0TW9kZSgxLDEpXG4gICAgICB0aGlzLnBsYXllci5zaXplLnNldEFic29sdXRlKDE4NSwxMDApXG4gICAgICB0aGlzLnBsYXllci5lbC5zZXRQcm9wZXJ0eSgnYmFja2dyb3VuZC1wb3NpdGlvbicsIDQgKyAncHgnKVxuICAgICAgdGhpcy5wbGF5ZXIuZWwuc2V0UHJvcGVydHkoJ2JhY2tncm91bmQtaW1hZ2UnLCAndXJsKC4vaW1hZ2VzL2p1bXBTaG9vdFJpZ2h0LnBuZyknKVxuICAgICAgdGhpcy5wbGF5ZXIuanVtcGluZyA9IHRydWU7XG4gICAgfVxuICB9XG4gIFxuICAvL3Nob290IGxlZnQgYW5kIGp1bXBpbmcgc3ByaXRlXG4gIGlmKHRoaXMucGxheWVyLmRpcmVjdGlvbiA9PT0gJ2xlZnQnICYmIHRoaXMucGxheWVyLmp1bXBpbmcpe1xuICAgIC8vbW92ZSBzcHJpdGUgZnJhbWVcbiAgICBpZih0aGlzLnBsYXllci5jdXJyZW50U3RlcCA+IDEgJiYgdGhpcy5wbGF5ZXIuY3VycmVudFN0ZXAgPD0gNyl7XG4gICAgICB0aGlzLnBsYXllci5iYWNrZ3JvdW5kUG9zaXRpb24rPTE4NVxuICAgICAgdmFyIG51bSA9IHRoaXMucGxheWVyLmJhY2tncm91bmRQb3NpdGlvblxuICAgICAgdGhpcy5wbGF5ZXIuZWwuc2V0UHJvcGVydHkoJ2JhY2tncm91bmQtcG9zaXRpb24nLCBudW0gKyAncHgnKVxuICAgIH1cbiAgICAvL2luaXQgc3ByaXRlXG4gICAgaWYodGhpcy5wbGF5ZXIuY3VycmVudFN0ZXAgPT09IDAgJiYgdGhpcy5wbGF5ZXIuanVtcGluZyl7XG4gICAgICB0aGlzLnBsYXllci5iYWNrZ3JvdW5kUG9zaXRpb24gPSAxODVcbiAgICAgIHRoaXMucGxheWVyLnNpemUuc2V0TW9kZSgxLDEpXG4gICAgICB0aGlzLnBsYXllci5zaXplLnNldEFic29sdXRlKDE4NSwxMDApXG4gICAgICB0aGlzLnBsYXllci5lbC5zZXRQcm9wZXJ0eSgnYmFja2dyb3VuZC1wb3NpdGlvbicsIDE4NSArICdweCcpXG4gICAgICB0aGlzLnBsYXllci5lbC5zZXRQcm9wZXJ0eSgnYmFja2dyb3VuZC1pbWFnZScsICd1cmwoLi9pbWFnZXMvanVtcFNob290TGVmdC5wbmcpJylcbiAgICAgIHRoaXMucGxheWVyLmp1bXBpbmcgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBcblxufVxuXG5cblxuZnVuY3Rpb24gbW92ZVJpZ2h0KCl7XG52YXIgYmdwb3MgPSB0aGlzLm1haW5CZ1Bvcy09MVxuIHRoaXMubWFpbkVsLnNldFByb3BlcnR5KCdiYWNrZ3JvdW5kLXBvc2l0aW9uJywgYmdwb3MgKyAncHgnKVxuXG4gIHRoaXMucGxheWVyLmRpcmVjdGlvbiA9ICdyaWdodCdcbiAgLy9kbyBub3Qgc3RhcnQgbW92ZXJSaWdodCBzcHJpdGUgaWYganVtcGluZ1xuICBpZighdGhpcy5wbGF5ZXIuanVtcGluZyl7IFxuICAgIC8vbW92ZSBzcHJpdGUgZnJhbWVcbiAgICBpZih0aGlzLnBsYXllci5jdXJyZW50U3RlcCA+IDAgJiYgdGhpcy5wbGF5ZXIuY3VycmVudFN0ZXAgPD0gMTQpe1xuICAgICAgdGhpcy5wbGF5ZXIuYmFja2dyb3VuZFBvc2l0aW9uLT05NlxuICAgICAgdmFyIG51bSA9IHRoaXMucGxheWVyLmJhY2tncm91bmRQb3NpdGlvblxuICAgICAgdGhpcy5wbGF5ZXIuZWwuc2V0UHJvcGVydHkoJ2JhY2tncm91bmQtcG9zaXRpb24nLCBudW0gKyAncHgnKVxuICAgIH1cbiAgICAvL2luaXQgbW92ZSByaWdodCBzcHJpdGVcbiAgICBpZih0aGlzLnBsYXllci5jdXJyZW50U3RlcCA9PT0gMCl7XG4gICAgICB0aGlzLnBsYXllci5lbC5zZXRQcm9wZXJ0eSgnYmFja2dyb3VuZC1pbWFnZScsICd1cmwoLi9pbWFnZXMvbW92ZVJpZ2h0LnBuZyknKVxuICAgICAgdGhpcy5wbGF5ZXIuYmFja2dyb3VuZFBvc2l0aW9uID0gMFxuICAgICAgdGhpcy5wbGF5ZXIuc2l6ZS5zZXRNb2RlKDEsMSlcbiAgICAgIHRoaXMucGxheWVyLnNpemUuc2V0QWJzb2x1dGUoOTYsOTYpXG4gICAgICB0aGlzLnBsYXllci5lbC5zZXRQcm9wZXJ0eSgnYmFja2dyb3VuZC1wb3NpdGlvbicsIDAgKyAncHgnKVxuICAgIH0gIFxuICB9XG4gIHRoaXMuYm94LnNldFZlbG9jaXR5KDUwLHRoaXMuYm94LmdldFZlbG9jaXR5KClbMV0sdGhpcy5ib3guZ2V0VmVsb2NpdHkoKVsyXSlcbiAgXG59XG5cbmZ1bmN0aW9uIG1vdmVMZWZ0KCl7XG4gIHZhciBiZ3BvcyA9IHRoaXMubWFpbkJnUG9zKz0xXG4gIHRoaXMubWFpbkVsLnNldFByb3BlcnR5KCdiYWNrZ3JvdW5kLXBvc2l0aW9uJywgYmdwb3MgKyAncHgnKVxuICB0aGlzLnBsYXllci5kaXJlY3Rpb24gPSAnbGVmdCdcbiAgLy9kbyBub3Qgc3RhcnQgbW92ZUxlZnQgc3ByaXRlIGlmIGp1bXBpbmdcbiAgaWYoIXRoaXMucGxheWVyLmp1bXBpbmcpe1xuICAgIC8vbW92ZSBzcHJpdGUgZnJhbWVcbiAgICBpZih0aGlzLnBsYXllci5jdXJyZW50U3RlcCA+IDAgJiYgdGhpcy5wbGF5ZXIuY3VycmVudFN0ZXAgPD0gMTQpe1xuICAgICAgdGhpcy5wbGF5ZXIuYmFja2dyb3VuZFBvc2l0aW9uKz05NlxuICAgICAgdmFyIG51bSA9IHRoaXMucGxheWVyLmJhY2tncm91bmRQb3NpdGlvblxuICAgICAgdGhpcy5wbGF5ZXIuZWwuc2V0UHJvcGVydHkoJ2JhY2tncm91bmQtcG9zaXRpb24nLCBudW0gKyAncHgnKVxuICAgIH1cbiAgICAvL2luaXQgbW92ZSBsZWZ0IHNwcml0ZVxuICAgIGlmKHRoaXMucGxheWVyLmN1cnJlbnRTdGVwID09PSAwKXtcbiAgICAgIHRoaXMucGxheWVyLmVsLnNldFByb3BlcnR5KCdiYWNrZ3JvdW5kLWltYWdlJywgJ3VybCguL2ltYWdlcy9tb3ZlTGVmdC5wbmcpJylcbiAgICAgIHRoaXMucGxheWVyLmJhY2tncm91bmRQb3NpdGlvbiA9IDBcbiAgICAgIHRoaXMucGxheWVyLnNpemUuc2V0TW9kZSgxLDEpXG4gICAgICB0aGlzLnBsYXllci5zaXplLnNldEFic29sdXRlKDk2LDk2KVxuICAgICAgdGhpcy5wbGF5ZXIuZWwuc2V0UHJvcGVydHkoJ2JhY2tncm91bmQtcG9zaXRpb24nLCAwICsgJ3B4JylcbiAgICB9XG4gIH0gICBcbiAgdGhpcy5ib3guc2V0VmVsb2NpdHkoLTEwMCx0aGlzLmJveC5nZXRWZWxvY2l0eSgpWzFdLHRoaXMuYm94LmdldFZlbG9jaXR5KClbMl0pXG4gIFxufVxuXG5mdW5jdGlvbiBKdW1wKCl7XG4gIHRoaXMucGxheWVyLmp1bXBpbmcgPSB0cnVlO1xuICAvL3JpZ2h0IGp1bXBcbiAgaWYodGhpcy5wbGF5ZXIuZGlyZWN0aW9uID09PSAncmlnaHQnKXtcbiAgICAvL21vdmUgc3ByaXRlIGZyYW1lXG4gICAgaWYodGhpcy5wbGF5ZXIuY3VycmVudFN0ZXAgPiAwICYmIHRoaXMucGxheWVyLmN1cnJlbnRTdGVwIDw9IDEzKXtcbiAgICAgICAgdGhpcy5wbGF5ZXIuYmFja2dyb3VuZFBvc2l0aW9uLT05NlxuICAgICAgICB2YXIgbnVtID0gdGhpcy5wbGF5ZXIuYmFja2dyb3VuZFBvc2l0aW9uXG4gICAgICAgIHRoaXMucGxheWVyLmVsLnNldFByb3BlcnR5KCdiYWNrZ3JvdW5kLXBvc2l0aW9uJywgbnVtICsgJ3B4JylcbiAgICAgIFxuICAgIH1cbiAgICAvL2luaXQganVtcCByaWdodCBzcHJpdGUgICAgIFxuICAgIGlmKHRoaXMucGxheWVyLmN1cnJlbnRTdGVwID09PSAwKXtcbiAgICAgIHRoaXMucGxheWVyLmVsLnNldFByb3BlcnR5KCdiYWNrZ3JvdW5kLWltYWdlJywgJ3VybCguL2ltYWdlcy9qdW1wUmlnaHQucG5nKScpXG4gICAgICB0aGlzLnBsYXllci5zaXplLnNldE1vZGUoMSwxKVxuICAgICAgdGhpcy5wbGF5ZXIuc2l6ZS5zZXRBYnNvbHV0ZSg5Niw5NilcbiAgICAgIHRoaXMucGxheWVyLmJhY2tncm91bmRQb3NpdGlvbiA9IDBcbiAgICAgIHRoaXMucGxheWVyLmVsLnNldFByb3BlcnR5KCdiYWNrZ3JvdW5kLXBvc2l0aW9uJywgMCArICdweCcpXG4gICAgfSAgXG4gIH0gXG4gIC8vbGVmdCBqdW1wXG4gIGlmKHRoaXMucGxheWVyLmRpcmVjdGlvbiA9PT0gJ2xlZnQnKXtcbiAgICAvL21vdmUgc3ByaXRlIGZyYW1lXG4gICAgaWYodGhpcy5wbGF5ZXIuY3VycmVudFN0ZXAgPiAwICYmIHRoaXMucGxheWVyLmN1cnJlbnRTdGVwIDw9IDEzKXtcbiAgICAgICAgdGhpcy5wbGF5ZXIuYmFja2dyb3VuZFBvc2l0aW9uKz05NlxuICAgICAgICB2YXIgbnVtID0gdGhpcy5wbGF5ZXIuYmFja2dyb3VuZFBvc2l0aW9uXG4gICAgICAgIHRoaXMucGxheWVyLmVsLnNldFByb3BlcnR5KCdiYWNrZ3JvdW5kLXBvc2l0aW9uJywgbnVtICsgJ3B4JylcbiAgICAgIFxuICAgIH1cbiAgICAvL2luaXQganVtcCBsZWZ0IHNwcml0ZSAgICBcbiAgICBpZih0aGlzLnBsYXllci5jdXJyZW50U3RlcCA9PT0gMCl7XG4gICAgICB0aGlzLnBsYXllci5lbC5zZXRQcm9wZXJ0eSgnYmFja2dyb3VuZC1pbWFnZScsICd1cmwoLi9pbWFnZXMvanVtcExlZnQucG5nKScpXG4gICAgICB0aGlzLnBsYXllci5zaXplLnNldE1vZGUoMSwxKVxuICAgICAgdGhpcy5wbGF5ZXIuc2l6ZS5zZXRBYnNvbHV0ZSg5Niw5NilcbiAgICAgIHRoaXMucGxheWVyLmJhY2tncm91bmRQb3NpdGlvbiA9IDBcbiAgICAgIHRoaXMucGxheWVyLmVsLnNldFByb3BlcnR5KCdiYWNrZ3JvdW5kLXBvc2l0aW9uJywgMCArICdweCcpXG4gICAgfSAgXG4gICAgXG4gIH0gXG4gIHRoaXMuYm94LnNldFZlbG9jaXR5KHRoaXMuYm94LmdldFZlbG9jaXR5KClbMF0sLTgwLHRoaXMuYm94LmdldFZlbG9jaXR5KClbMl0pXG4gIFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdhbWUiLCIndXNlIHN0cmljdCc7XG5cbnZhciBGYW1vdXNQbGF0Zm9ybSA9IHJlcXVpcmUoJ2ZhbW91cycpO1xudmFyIENvbXBvc2l0b3IgPSBGYW1vdXNQbGF0Zm9ybS5yZW5kZXJlcnMuQ29tcG9zaXRvcjtcbnZhciBUaHJlYWRNYW5hZ2VyID0gRmFtb3VzUGxhdGZvcm0ucmVuZGVyZXJzLlRocmVhZE1hbmFnZXI7XG52YXIgRW5naW5lID0gRmFtb3VzUGxhdGZvcm0uZW5naW5lO1xudmFyIERPTUVsZW1lbnQgPSBGYW1vdXNQbGF0Zm9ybS5kb21SZW5kZXJhYmxlcy5ET01FbGVtZW50O1xudmFyIEZhbW91cyA9IEZhbW91c1BsYXRmb3JtLmNvcmUuRmFtb3VzO1xuXG4vLyBCb2lsZXJwbGF0ZVxudmFyIGNvbXBvc2l0b3IgPSBuZXcgQ29tcG9zaXRvcigpO1xudmFyIHRocmVhZG1hbmdlciA9IG5ldyBUaHJlYWRNYW5hZ2VyKEZhbW91cywgY29tcG9zaXRvcik7XG52YXIgZW5naW5lID0gbmV3IEVuZ2luZSgpO1xuZW5naW5lLnVwZGF0ZSh0aHJlYWRtYW5nZXIpO1xuXG4vLyBBcHAgQ29kZVxudmFyIGNvbnRleHQgPSBGYW1vdXMuY3JlYXRlQ29udGV4dCgpO1xudmFyIHJvb3QgPSBjb250ZXh0LmFkZENoaWxkKCk7XG5cbnZhciBHYW1lID0gcmVxdWlyZSgnLi9HYW1lJylcbnZhciBnYW1lID0gbmV3IEdhbWUocm9vdCkiXX0=
